import{g as Bg,c as Zi}from"./antd-BtCqKfBL.js";const ff="140",Ub={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},Fb={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},mA=0,Xm=1,gA=2,Hb=3,Gb=0,Lg=1,vA=2,Na=3,An=0,pi=1,yt=2,zg=1,Vb=2,Mn=0,qs=1,Jm=2,Zm=3,Km=4,Du=5,hr=100,yA=101,Ng=102,Ym=103,Qd=104,Dc=200,Js=201,xA=202,wA=203,kg=204,Ug=205,pf=206,AA=207,Fg=208,SA=209,MA=210,bA=0,EA=1,TA=2,Wd=3,CA=4,IA=5,RA=6,PA=7,Ou=0,DA=1,OA=2,Nr=0,BA=1,LA=2,zA=3,Hg=4,NA=5,mf=300,ra=301,sa=302,Oc=303,Bc=304,Sl=306,vs=1e3,bi=1001,Lc=1002,Dt=1003,Xd=1004,jb=1004,Jd=1005,Qb=1005,St=1006,Gg=1007,Wb=1007,uo=1008,Xb=1008,Fr=1009,Vg=1010,jg=1011,qa=1012,Qg=1013,tl=1014,Dn=1015,di=1016,Wg=1017,Xg=1018,_s=1020,Jg=1021,Zg=1022,Hn=1023,Kg=1024,Yg=1025,ps=1026,aa=1027,gf=1028,qg=1029,_g=1030,$g=1031,ev=1033,Ga=33776,Va=33777,ja=33778,Qa=33779,zc=35840,Nc=35841,kc=35842,Uc=35843,tv=36196,Fc=37492,Hc=37496,Gc=37808,Vc=37809,jc=37810,Qc=37811,Wc=37812,Xc=37813,Jc=37814,Zc=37815,Kc=37816,Yc=37817,qc=37818,_c=37819,$c=37820,eu=37821,tu=36492,kA=2200,UA=2201,FA=2202,nu=2300,iu=2301,Od=2302,ka=2400,Ua=2401,ru=2402,vf=2500,nv=2501,HA=0,Jb=1,Zb=2,Fi=3e3,vt=3001,iv=3200,da=3201,ho=0,GA=1,Kb="",Ir="srgb",Zs="srgb-linear",Yb=0,yc=7680,$s=7681,qb=7682,_b=7683,$b=34055,eE=34056,tE=5386,nE=512,iE=513,VA=514,rE=515,sE=516,jA=517,aE=518,Bu=519,al=35044,Xn=35048,oE=35040,lE=35045,cE=35049,uE=35041,hE=35046,dE=35050,fE=35042,pE="100",qm="300 es",su=1035;class Ss{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const r=i.indexOf(t);r!==-1&&i.splice(r,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const n=this._listeners[e.type];if(n!==void 0){e.target=this;const i=n.slice(0);for(let r=0,s=i.length;r<s;r++)i[r].call(this,e);e.target=null}}}const Kn=[];for(let a=0;a<256;a++)Kn[a]=(a<16?"0":"")+a.toString(16);let P0=1234567;const Wa=Math.PI/180,au=180/Math.PI;function Ni(){const a=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(Kn[a&255]+Kn[a>>8&255]+Kn[a>>16&255]+Kn[a>>24&255]+"-"+Kn[e&255]+Kn[e>>8&255]+"-"+Kn[e>>16&15|64]+Kn[e>>24&255]+"-"+Kn[t&63|128]+Kn[t>>8&255]+"-"+Kn[t>>16&255]+Kn[t>>24&255]+Kn[n&255]+Kn[n>>8&255]+Kn[n>>16&255]+Kn[n>>24&255]).toLowerCase()}function In(a,e,t){return Math.max(e,Math.min(t,a))}function rv(a,e){return(a%e+e)%e}function mE(a,e,t,n,i){return n+(a-e)*(i-n)/(t-e)}function gE(a,e,t){return a!==e?(t-a)/(e-a):0}function xc(a,e,t){return(1-t)*a+t*e}function vE(a,e,t,n){return xc(a,e,1-Math.exp(-t*n))}function yE(a,e=1){return e-Math.abs(rv(a,e*2)-e)}function xE(a,e,t){return a<=e?0:a>=t?1:(a=(a-e)/(t-e),a*a*(3-2*a))}function wE(a,e,t){return a<=e?0:a>=t?1:(a=(a-e)/(t-e),a*a*a*(a*(a*6-15)+10))}function AE(a,e){return a+Math.floor(Math.random()*(e-a+1))}function SE(a,e){return a+Math.random()*(e-a)}function ME(a){return a*(.5-Math.random())}function bE(a){a!==void 0&&(P0=a);let e=P0+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function EE(a){return a*Wa}function TE(a){return a*au}function _m(a){return(a&a-1)===0&&a!==0}function QA(a){return Math.pow(2,Math.ceil(Math.log(a)/Math.LN2))}function Zd(a){return Math.pow(2,Math.floor(Math.log(a)/Math.LN2))}function CE(a,e,t,n,i){const r=Math.cos,s=Math.sin,o=r(t/2),l=s(t/2),c=r((e+n)/2),u=s((e+n)/2),h=r((e-n)/2),d=s((e-n)/2),f=r((n-e)/2),p=s((n-e)/2);switch(i){case"XYX":a.set(o*u,l*h,l*d,o*c);break;case"YZY":a.set(l*d,o*u,l*h,o*c);break;case"ZXZ":a.set(l*h,l*d,o*u,o*c);break;case"XZX":a.set(o*u,l*p,l*f,o*c);break;case"YXY":a.set(l*f,o*u,l*p,o*c);break;case"ZYZ":a.set(l*p,l*f,o*u,o*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function IE(a,e){switch(e.constructor){case Float32Array:return a;case Uint16Array:return a/65535;case Uint8Array:return a/255;case Int16Array:return Math.max(a/32767,-1);case Int8Array:return Math.max(a/127,-1);default:throw new Error("Invalid component type.")}}function RE(a,e){switch(e.constructor){case Float32Array:return a;case Uint16Array:return Math.round(a*65535);case Uint8Array:return Math.round(a*255);case Int16Array:return Math.round(a*32767);case Int8Array:return Math.round(a*127);default:throw new Error("Invalid component type.")}}var It=Object.freeze({__proto__:null,DEG2RAD:Wa,RAD2DEG:au,generateUUID:Ni,clamp:In,euclideanModulo:rv,mapLinear:mE,inverseLerp:gE,lerp:xc,damp:vE,pingpong:yE,smoothstep:xE,smootherstep:wE,randInt:AE,randFloat:SE,randFloatSpread:ME,seededRandom:bE,degToRad:EE,radToDeg:TE,isPowerOfTwo:_m,ceilPowerOfTwo:QA,floorPowerOfTwo:Zd,setQuaternionFromProperEuler:CE,normalize:RE,denormalize:IE});class te{constructor(e=0,t=0){this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,i=e.elements;return this.x=i[0]*t+i[3]*n+i[6],this.y=i[1]*t+i[4]*n+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),i=Math.sin(t),r=this.x-e.x,s=this.y-e.y;return this.x=r*n-s*i+e.x,this.y=r*i+s*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}te.prototype.isVector2=!0;class Kt{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,i,r,s,o,l,c){const u=this.elements;return u[0]=e,u[1]=i,u[2]=o,u[3]=t,u[4]=r,u[5]=l,u[6]=n,u[7]=s,u[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,r=this.elements,s=n[0],o=n[3],l=n[6],c=n[1],u=n[4],h=n[7],d=n[2],f=n[5],p=n[8],m=i[0],g=i[3],v=i[6],y=i[1],w=i[4],x=i[7],S=i[2],b=i[5],E=i[8];return r[0]=s*m+o*y+l*S,r[3]=s*g+o*w+l*b,r[6]=s*v+o*x+l*E,r[1]=c*m+u*y+h*S,r[4]=c*g+u*w+h*b,r[7]=c*v+u*x+h*E,r[2]=d*m+f*y+p*S,r[5]=d*g+f*w+p*b,r[8]=d*v+f*x+p*E,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],s=e[4],o=e[5],l=e[6],c=e[7],u=e[8];return t*s*u-t*o*c-n*r*u+n*o*l+i*r*c-i*s*l}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],s=e[4],o=e[5],l=e[6],c=e[7],u=e[8],h=u*s-o*c,d=o*l-u*r,f=c*r-s*l,p=t*h+n*d+i*f;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/p;return e[0]=h*m,e[1]=(i*c-u*n)*m,e[2]=(o*n-i*s)*m,e[3]=d*m,e[4]=(u*t-i*l)*m,e[5]=(i*r-o*t)*m,e[6]=f*m,e[7]=(n*l-c*t)*m,e[8]=(s*t-n*r)*m,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,i,r,s,o){const l=Math.cos(r),c=Math.sin(r);return this.set(n*l,n*c,-n*(l*s+c*o)+s+e,-i*c,i*l,-i*(-c*s+l*o)+o+t,0,0,1),this}scale(e,t){const n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=t,n[4]*=t,n[7]*=t,this}rotate(e){const t=Math.cos(e),n=Math.sin(e),i=this.elements,r=i[0],s=i[3],o=i[6],l=i[1],c=i[4],u=i[7];return i[0]=t*r+n*l,i[3]=t*s+n*c,i[6]=t*o+n*u,i[1]=-n*r+t*l,i[4]=-n*s+t*c,i[7]=-n*o+t*u,this}translate(e,t){const n=this.elements;return n[0]+=e*n[2],n[3]+=e*n[5],n[6]+=e*n[8],n[1]+=t*n[2],n[4]+=t*n[5],n[7]+=t*n[8],this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<9;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return new this.constructor().fromArray(this.elements)}}Kt.prototype.isMatrix3=!0;function WA(a){for(let e=a.length-1;e>=0;--e)if(a[e]>65535)return!0;return!1}const PE={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function Yo(a,e){return new PE[a](e)}function ou(a){return document.createElementNS("http://www.w3.org/1999/xhtml",a)}function Xa(a){return a<.04045?a*.0773993808:Math.pow(a*.9478672986+.0521327014,2.4)}function Bd(a){return a<.0031308?a*12.92:1.055*Math.pow(a,.41666)-.055}const lp={[Ir]:{[Zs]:Xa},[Zs]:{[Ir]:Bd}},Wi={legacyMode:!0,get workingColorSpace(){return Zs},set workingColorSpace(a){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(a,e,t){if(this.legacyMode||e===t||!e||!t)return a;if(lp[e]&&lp[e][t]!==void 0){const n=lp[e][t];return a.r=n(a.r),a.g=n(a.g),a.b=n(a.b),a}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(a,e){return this.convert(a,this.workingColorSpace,e)},toWorkingColorSpace:function(a,e){return this.convert(a,e,this.workingColorSpace)}},XA={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Gn={r:0,g:0,b:0},ir={h:0,s:0,l:0},ah={h:0,s:0,l:0};function cp(a,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?a+(e-a)*6*t:t<1/2?e:t<2/3?a+(e-a)*6*(2/3-t):a}function oh(a,e){return e.r=a.r,e.g=a.g,e.b=a.b,e}class Ie{constructor(e,t,n){return t===void 0&&n===void 0?this.set(e):this.setRGB(e,t,n)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=Ir){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,Wi.toWorkingColorSpace(this,t),this}setRGB(e,t,n,i=Zs){return this.r=e,this.g=t,this.b=n,Wi.toWorkingColorSpace(this,i),this}setHSL(e,t,n,i=Zs){if(e=rv(e,1),t=In(t,0,1),n=In(n,0,1),t===0)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+t):n+t-n*t,s=2*n-r;this.r=cp(s,r,e+1/3),this.g=cp(s,r,e),this.b=cp(s,r,e-1/3)}return Wi.toWorkingColorSpace(this,i),this}setStyle(e,t=Ir){function n(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let r;const s=i[1],o=i[2];switch(s){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(r[1],10))/255,this.g=Math.min(255,parseInt(r[2],10))/255,this.b=Math.min(255,parseInt(r[3],10))/255,Wi.toWorkingColorSpace(this,t),n(r[4]),this;if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(r[1],10))/100,this.g=Math.min(100,parseInt(r[2],10))/100,this.b=Math.min(100,parseInt(r[3],10))/100,Wi.toWorkingColorSpace(this,t),n(r[4]),this;break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const l=parseFloat(r[1])/360,c=parseInt(r[2],10)/100,u=parseInt(r[3],10)/100;return n(r[4]),this.setHSL(l,c,u,t)}break}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const r=i[1],s=r.length;if(s===3)return this.r=parseInt(r.charAt(0)+r.charAt(0),16)/255,this.g=parseInt(r.charAt(1)+r.charAt(1),16)/255,this.b=parseInt(r.charAt(2)+r.charAt(2),16)/255,Wi.toWorkingColorSpace(this,t),this;if(s===6)return this.r=parseInt(r.charAt(0)+r.charAt(1),16)/255,this.g=parseInt(r.charAt(2)+r.charAt(3),16)/255,this.b=parseInt(r.charAt(4)+r.charAt(5),16)/255,Wi.toWorkingColorSpace(this,t),this}return e&&e.length>0?this.setColorName(e,t):this}setColorName(e,t=Ir){const n=XA[e.toLowerCase()];return n!==void 0?this.setHex(n,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=Xa(e.r),this.g=Xa(e.g),this.b=Xa(e.b),this}copyLinearToSRGB(e){return this.r=Bd(e.r),this.g=Bd(e.g),this.b=Bd(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=Ir){return Wi.fromWorkingColorSpace(oh(this,Gn),e),In(Gn.r*255,0,255)<<16^In(Gn.g*255,0,255)<<8^In(Gn.b*255,0,255)<<0}getHexString(e=Ir){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=Zs){Wi.fromWorkingColorSpace(oh(this,Gn),t);const n=Gn.r,i=Gn.g,r=Gn.b,s=Math.max(n,i,r),o=Math.min(n,i,r);let l,c;const u=(o+s)/2;if(o===s)l=0,c=0;else{const h=s-o;switch(c=u<=.5?h/(s+o):h/(2-s-o),s){case n:l=(i-r)/h+(i<r?6:0);break;case i:l=(r-n)/h+2;break;case r:l=(n-i)/h+4;break}l/=6}return e.h=l,e.s=c,e.l=u,e}getRGB(e,t=Zs){return Wi.fromWorkingColorSpace(oh(this,Gn),t),e.r=Gn.r,e.g=Gn.g,e.b=Gn.b,e}getStyle(e=Ir){return Wi.fromWorkingColorSpace(oh(this,Gn),e),e!==Ir?`color(${e} ${Gn.r} ${Gn.g} ${Gn.b})`:`rgb(${Gn.r*255|0},${Gn.g*255|0},${Gn.b*255|0})`}offsetHSL(e,t,n){return this.getHSL(ir),ir.h+=e,ir.s+=t,ir.l+=n,this.setHSL(ir.h,ir.s,ir.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(ir),e.getHSL(ah);const n=xc(ir.h,ah.h,t),i=xc(ir.s,ah.s,t),r=xc(ir.l,ah.l,t);return this.setHSL(n,i,r),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}Ie.NAMES=XA;Ie.prototype.isColor=!0;Ie.prototype.r=1;Ie.prototype.g=1;Ie.prototype.b=1;let So;class fa{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{So===void 0&&(So=ou("canvas")),So.width=e.width,So.height=e.height;const n=So.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=So}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=ou("canvas");t.width=e.width,t.height=e.height;const n=t.getContext("2d");n.drawImage(e,0,0,e.width,e.height);const i=n.getImageData(0,0,e.width,e.height),r=i.data;for(let s=0;s<r.length;s++)r[s]=Xa(r[s]/255)*255;return n.putImageData(i,0,0),t}else if(e.data){const t=e.data.slice(0);for(let n=0;n<t.length;n++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[n]=Math.floor(Xa(t[n]/255)*255):t[n]=Xa(t[n]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}class Ks{constructor(e=null){this.uuid=Ni(),this.data=e,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const n={uuid:this.uuid,url:""},i=this.data;if(i!==null){let r;if(Array.isArray(i)){r=[];for(let s=0,o=i.length;s<o;s++)i[s].isDataTexture?r.push(up(i[s].image)):r.push(up(i[s]))}else r=up(i);n.url=r}return t||(e.images[this.uuid]=n),n}}function up(a){return typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&a instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&a instanceof ImageBitmap?fa.getDataURL(a):a.data?{data:Array.prototype.slice.call(a.data),width:a.width,height:a.height,type:a.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}Ks.prototype.isSource=!0;let DE=0;class bn extends Ss{constructor(e=bn.DEFAULT_IMAGE,t=bn.DEFAULT_MAPPING,n=bi,i=bi,r=St,s=uo,o=Hn,l=Fr,c=1,u=Fi){super(),Object.defineProperty(this,"id",{value:DE++}),this.uuid=Ni(),this.name="",this.source=new Ks(e),this.mipmaps=[],this.mapping=t,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=s,this.anisotropy=c,this.format=o,this.internalFormat=null,this.type=l,this.offset=new te(0,0),this.repeat=new te(1,1),this.center=new te(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Kt,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=u,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData),t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==mf)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case vs:e.x=e.x-Math.floor(e.x);break;case bi:e.x=e.x<0?0:1;break;case Lc:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case vs:e.y=e.y-Math.floor(e.y);break;case bi:e.y=e.y<0?0:1;break;case Lc:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}}bn.DEFAULT_IMAGE=null;bn.DEFAULT_MAPPING=mf;bn.prototype.isTexture=!0;class lt{constructor(e=0,t=0,n=0,i=1){this.x=e,this.y=t,this.z=n,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,i){return this.x=e,this.y=t,this.z=n,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,r=this.w,s=e.elements;return this.x=s[0]*t+s[4]*n+s[8]*i+s[12]*r,this.y=s[1]*t+s[5]*n+s[9]*i+s[13]*r,this.z=s[2]*t+s[6]*n+s[10]*i+s[14]*r,this.w=s[3]*t+s[7]*n+s[11]*i+s[15]*r,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,i,r;const l=e.elements,c=l[0],u=l[4],h=l[8],d=l[1],f=l[5],p=l[9],m=l[2],g=l[6],v=l[10];if(Math.abs(u-d)<.01&&Math.abs(h-m)<.01&&Math.abs(p-g)<.01){if(Math.abs(u+d)<.1&&Math.abs(h+m)<.1&&Math.abs(p+g)<.1&&Math.abs(c+f+v-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const w=(c+1)/2,x=(f+1)/2,S=(v+1)/2,b=(u+d)/4,E=(h+m)/4,M=(p+g)/4;return w>x&&w>S?w<.01?(n=0,i=.707106781,r=.707106781):(n=Math.sqrt(w),i=b/n,r=E/n):x>S?x<.01?(n=.707106781,i=0,r=.707106781):(i=Math.sqrt(x),n=b/i,r=M/i):S<.01?(n=.707106781,i=.707106781,r=0):(r=Math.sqrt(S),n=E/r,i=M/r),this.set(n,i,r,t),this}let y=Math.sqrt((g-p)*(g-p)+(h-m)*(h-m)+(d-u)*(d-u));return Math.abs(y)<.001&&(y=1),this.x=(g-p)/y,this.y=(h-m)/y,this.z=(d-u)/y,this.w=Math.acos((c+f+v-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}lt.prototype.isVector4=!0;class pn extends Ss{constructor(e,t,n={}){super(),this.width=e,this.height=t,this.depth=1,this.scissor=new lt(0,0,e,t),this.scissorTest=!1,this.viewport=new lt(0,0,e,t);const i={width:e,height:t,depth:1};this.texture=new bn(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.internalFormat=n.internalFormat!==void 0?n.internalFormat:null,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:St,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null,this.samples=n.samples!==void 0?n.samples:0}setSize(e,t,n=1){(this.width!==e||this.height!==t||this.depth!==n)&&(this.width=e,this.height=t,this.depth=n,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new Ks(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}pn.prototype.isWebGLRenderTarget=!0;class Ml extends bn{constructor(e=null,t=1,n=1,i=1){super(null),this.image={data:e,width:t,height:n,depth:i},this.magFilter=Dt,this.minFilter=Dt,this.wrapR=bi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}Ml.prototype.isDataArrayTexture=!0;class JA extends pn{constructor(e,t,n){super(e,t),this.depth=n,this.texture=new Ml(null,e,t,n),this.texture.isRenderTargetTexture=!0}}JA.prototype.isWebGLArrayRenderTarget=!0;class Lu extends bn{constructor(e=null,t=1,n=1,i=1){super(null),this.image={data:e,width:t,height:n,depth:i},this.magFilter=Dt,this.minFilter=Dt,this.wrapR=bi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}Lu.prototype.isData3DTexture=!0;class ZA extends pn{constructor(e,t,n){super(e,t),this.depth=n,this.texture=new Lu(null,e,t,n),this.texture.isRenderTargetTexture=!0}}ZA.prototype.isWebGL3DRenderTarget=!0;class yf extends pn{constructor(e,t,n,i={}){super(e,t,i);const r=this.texture;this.texture=[];for(let s=0;s<n;s++)this.texture[s]=r.clone(),this.texture[s].isRenderTargetTexture=!0}setSize(e,t,n=1){if(this.width!==e||this.height!==t||this.depth!==n){this.width=e,this.height=t,this.depth=n;for(let i=0,r=this.texture.length;i<r;i++)this.texture[i].image.width=e,this.texture[i].image.height=t,this.texture[i].image.depth=n;this.dispose()}return this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t),this}copy(e){this.dispose(),this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.texture.length=0;for(let t=0,n=e.texture.length;t<n;t++)this.texture[t]=e.texture[t].clone(),this.texture[t].isRenderTargetTexture=!0;return this}}yf.prototype.isWebGLMultipleRenderTargets=!0;class dt{constructor(e=0,t=0,n=0,i=1){this._x=e,this._y=t,this._z=n,this._w=i}static slerp(e,t,n,i){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(e,t,i)}static slerpFlat(e,t,n,i,r,s,o){let l=n[i+0],c=n[i+1],u=n[i+2],h=n[i+3];const d=r[s+0],f=r[s+1],p=r[s+2],m=r[s+3];if(o===0){e[t+0]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h;return}if(o===1){e[t+0]=d,e[t+1]=f,e[t+2]=p,e[t+3]=m;return}if(h!==m||l!==d||c!==f||u!==p){let g=1-o;const v=l*d+c*f+u*p+h*m,y=v>=0?1:-1,w=1-v*v;if(w>Number.EPSILON){const S=Math.sqrt(w),b=Math.atan2(S,v*y);g=Math.sin(g*b)/S,o=Math.sin(o*b)/S}const x=o*y;if(l=l*g+d*x,c=c*g+f*x,u=u*g+p*x,h=h*g+m*x,g===1-o){const S=1/Math.sqrt(l*l+c*c+u*u+h*h);l*=S,c*=S,u*=S,h*=S}}e[t]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h}static multiplyQuaternionsFlat(e,t,n,i,r,s){const o=n[i],l=n[i+1],c=n[i+2],u=n[i+3],h=r[s],d=r[s+1],f=r[s+2],p=r[s+3];return e[t]=o*p+u*h+l*f-c*d,e[t+1]=l*p+u*d+c*h-o*f,e[t+2]=c*p+u*f+o*d-l*h,e[t+3]=u*p-o*h-l*d-c*f,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,i){return this._x=e,this._y=t,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!(e&&e.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=e._x,i=e._y,r=e._z,s=e._order,o=Math.cos,l=Math.sin,c=o(n/2),u=o(i/2),h=o(r/2),d=l(n/2),f=l(i/2),p=l(r/2);switch(s){case"XYZ":this._x=d*u*h+c*f*p,this._y=c*f*h-d*u*p,this._z=c*u*p+d*f*h,this._w=c*u*h-d*f*p;break;case"YXZ":this._x=d*u*h+c*f*p,this._y=c*f*h-d*u*p,this._z=c*u*p-d*f*h,this._w=c*u*h+d*f*p;break;case"ZXY":this._x=d*u*h-c*f*p,this._y=c*f*h+d*u*p,this._z=c*u*p+d*f*h,this._w=c*u*h-d*f*p;break;case"ZYX":this._x=d*u*h-c*f*p,this._y=c*f*h+d*u*p,this._z=c*u*p-d*f*h,this._w=c*u*h+d*f*p;break;case"YZX":this._x=d*u*h+c*f*p,this._y=c*f*h+d*u*p,this._z=c*u*p-d*f*h,this._w=c*u*h-d*f*p;break;case"XZY":this._x=d*u*h-c*f*p,this._y=c*f*h-d*u*p,this._z=c*u*p+d*f*h,this._w=c*u*h+d*f*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,i=Math.sin(n);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],i=t[4],r=t[8],s=t[1],o=t[5],l=t[9],c=t[2],u=t[6],h=t[10],d=n+o+h;if(d>0){const f=.5/Math.sqrt(d+1);this._w=.25/f,this._x=(u-l)*f,this._y=(r-c)*f,this._z=(s-i)*f}else if(n>o&&n>h){const f=2*Math.sqrt(1+n-o-h);this._w=(u-l)/f,this._x=.25*f,this._y=(i+s)/f,this._z=(r+c)/f}else if(o>h){const f=2*Math.sqrt(1+o-n-h);this._w=(r-c)/f,this._x=(i+s)/f,this._y=.25*f,this._z=(l+u)/f}else{const f=2*Math.sqrt(1+h-n-o);this._w=(s-i)/f,this._x=(r+c)/f,this._y=(l+u)/f,this._z=.25*f}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(In(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(n===0)return this;const i=Math.min(1,t/n);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,i=e._y,r=e._z,s=e._w,o=t._x,l=t._y,c=t._z,u=t._w;return this._x=n*u+s*o+i*c-r*l,this._y=i*u+s*l+r*o-n*c,this._z=r*u+s*c+n*l-i*o,this._w=s*u-n*o-i*l-r*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const n=this._x,i=this._y,r=this._z,s=this._w;let o=s*e._w+n*e._x+i*e._y+r*e._z;if(o<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,o=-o):this.copy(e),o>=1)return this._w=s,this._x=n,this._y=i,this._z=r,this;const l=1-o*o;if(l<=Number.EPSILON){const f=1-t;return this._w=f*s+t*this._w,this._x=f*n+t*this._x,this._y=f*i+t*this._y,this._z=f*r+t*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),u=Math.atan2(c,o),h=Math.sin((1-t)*u)/c,d=Math.sin(t*u)/c;return this._w=s*h+this._w*d,this._x=n*h+this._x*d,this._y=i*h+this._y*d,this._z=r*h+this._z*d,this._onChangeCallback(),this}slerpQuaternions(e,t,n){return this.copy(e).slerp(t,n)}random(){const e=Math.random(),t=Math.sqrt(1-e),n=Math.sqrt(e),i=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(t*Math.cos(i),n*Math.sin(r),n*Math.cos(r),t*Math.sin(i))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}dt.prototype.isQuaternion=!0;class A{constructor(e=0,t=0,n=0){this.x=e,this.y=t,this.z=n}set(e,t,n){return n===void 0&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(D0.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(D0.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[3]*n+r[6]*i,this.y=r[1]*t+r[4]*n+r[7]*i,this.z=r[2]*t+r[5]*n+r[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,r=e.elements,s=1/(r[3]*t+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*t+r[4]*n+r[8]*i+r[12])*s,this.y=(r[1]*t+r[5]*n+r[9]*i+r[13])*s,this.z=(r[2]*t+r[6]*n+r[10]*i+r[14])*s,this}applyQuaternion(e){const t=this.x,n=this.y,i=this.z,r=e.x,s=e.y,o=e.z,l=e.w,c=l*t+s*i-o*n,u=l*n+o*t-r*i,h=l*i+r*n-s*t,d=-r*t-s*n-o*i;return this.x=c*l+d*-r+u*-o-h*-s,this.y=u*l+d*-s+h*-r-c*-o,this.z=h*l+d*-o+c*-s-u*-r,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[4]*n+r[8]*i,this.y=r[1]*t+r[5]*n+r[9]*i,this.z=r[2]*t+r[6]*n+r[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,i=e.y,r=e.z,s=t.x,o=t.y,l=t.z;return this.x=i*l-r*o,this.y=r*s-n*l,this.z=n*o-i*s,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return hp.copy(this).projectOnVector(e),this.sub(hp)}reflect(e){return this.sub(hp.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(In(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,i=this.z-e.z;return t*t+n*n+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const i=Math.sin(t)*e;return this.x=i*Math.sin(n),this.y=Math.cos(t)*e,this.z=i*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,n=Math.sqrt(1-e**2);return this.x=n*Math.cos(t),this.y=n*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}A.prototype.isVector3=!0;const hp=new A,D0=new dt;class He{constructor(e=new A(1/0,1/0,1/0),t=new A(-1/0,-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,n=1/0,i=1/0,r=-1/0,s=-1/0,o=-1/0;for(let l=0,c=e.length;l<c;l+=3){const u=e[l],h=e[l+1],d=e[l+2];u<t&&(t=u),h<n&&(n=h),d<i&&(i=d),u>r&&(r=u),h>s&&(s=h),d>o&&(o=d)}return this.min.set(t,n,i),this.max.set(r,s,o),this}setFromBufferAttribute(e){let t=1/0,n=1/0,i=1/0,r=-1/0,s=-1/0,o=-1/0;for(let l=0,c=e.count;l<c;l++){const u=e.getX(l),h=e.getY(l),d=e.getZ(l);u<t&&(t=u),h<n&&(n=h),d<i&&(i=d),u>r&&(r=u),h>s&&(s=h),d>o&&(o=d)}return this.min.set(t,n,i),this.max.set(r,s,o),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=ma.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const n=e.geometry;if(n!==void 0)if(t&&n.attributes!=null&&n.attributes.position!==void 0){const r=n.attributes.position;for(let s=0,o=r.count;s<o;s++)ma.fromBufferAttribute(r,s).applyMatrix4(e.matrixWorld),this.expandByPoint(ma)}else n.boundingBox===null&&n.computeBoundingBox(),dp.copy(n.boundingBox),dp.applyMatrix4(e.matrixWorld),this.union(dp);const i=e.children;for(let r=0,s=i.length;r<s;r++)this.expandByObject(i[r],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,ma),ma.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Ql),lh.subVectors(this.max,Ql),Mo.subVectors(e.a,Ql),bo.subVectors(e.b,Ql),Eo.subVectors(e.c,Ql),Ps.subVectors(bo,Mo),Ds.subVectors(Eo,bo),ga.subVectors(Mo,Eo);let t=[0,-Ps.z,Ps.y,0,-Ds.z,Ds.y,0,-ga.z,ga.y,Ps.z,0,-Ps.x,Ds.z,0,-Ds.x,ga.z,0,-ga.x,-Ps.y,Ps.x,0,-Ds.y,Ds.x,0,-ga.y,ga.x,0];return!fp(t,Mo,bo,Eo,lh)||(t=[1,0,0,0,1,0,0,0,1],!fp(t,Mo,bo,Eo,lh))?!1:(ch.crossVectors(Ps,Ds),t=[ch.x,ch.y,ch.z],fp(t,Mo,bo,Eo,lh))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return ma.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=this.getSize(ma).length()*.5,e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(Yr[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Yr[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Yr[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Yr[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Yr[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Yr[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Yr[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Yr[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Yr),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}He.prototype.isBox3=!0;const Yr=[new A,new A,new A,new A,new A,new A,new A,new A],ma=new A,dp=new He,Mo=new A,bo=new A,Eo=new A,Ps=new A,Ds=new A,ga=new A,Ql=new A,lh=new A,ch=new A,va=new A;function fp(a,e,t,n,i){for(let r=0,s=a.length-3;r<=s;r+=3){va.fromArray(a,r);const o=i.x*Math.abs(va.x)+i.y*Math.abs(va.y)+i.z*Math.abs(va.z),l=e.dot(va),c=t.dot(va),u=n.dot(va);if(Math.max(-Math.max(l,c,u),Math.min(l,c,u))>o)return!1}return!0}const OE=new He,O0=new A,uh=new A,pp=new A;class rn{constructor(e=new A,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;t!==void 0?n.copy(t):OE.setFromPoints(e).getCenter(n);let i=0;for(let r=0,s=e.length;r<s;r++)i=Math.max(i,n.distanceToSquared(e[r]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){pp.subVectors(e,this.center);const t=pp.lengthSq();if(t>this.radius*this.radius){const n=Math.sqrt(t),i=(n-this.radius)*.5;this.center.add(pp.multiplyScalar(i/n)),this.radius+=i}return this}union(e){return this.center.equals(e.center)===!0?uh.set(0,0,1).multiplyScalar(e.radius):uh.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(O0.copy(e.center).add(uh)),this.expandByPoint(O0.copy(e.center).sub(uh)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const qr=new A,mp=new A,hh=new A,Os=new A,gp=new A,dh=new A,vp=new A;class On{constructor(e=new A,t=new A(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,qr)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=qr.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(qr.copy(this.direction).multiplyScalar(t).add(this.origin),qr.distanceToSquared(e))}distanceSqToSegment(e,t,n,i){mp.copy(e).add(t).multiplyScalar(.5),hh.copy(t).sub(e).normalize(),Os.copy(this.origin).sub(mp);const r=e.distanceTo(t)*.5,s=-this.direction.dot(hh),o=Os.dot(this.direction),l=-Os.dot(hh),c=Os.lengthSq(),u=Math.abs(1-s*s);let h,d,f,p;if(u>0)if(h=s*l-o,d=s*o-l,p=r*u,h>=0)if(d>=-p)if(d<=p){const m=1/u;h*=m,d*=m,f=h*(h+s*d+2*o)+d*(s*h+d+2*l)+c}else d=r,h=Math.max(0,-(s*d+o)),f=-h*h+d*(d+2*l)+c;else d=-r,h=Math.max(0,-(s*d+o)),f=-h*h+d*(d+2*l)+c;else d<=-p?(h=Math.max(0,-(-s*r+o)),d=h>0?-r:Math.min(Math.max(-r,-l),r),f=-h*h+d*(d+2*l)+c):d<=p?(h=0,d=Math.min(Math.max(-r,-l),r),f=d*(d+2*l)+c):(h=Math.max(0,-(s*r+o)),d=h>0?r:Math.min(Math.max(-r,-l),r),f=-h*h+d*(d+2*l)+c);else d=s>0?-r:r,h=Math.max(0,-(s*d+o)),f=-h*h+d*(d+2*l)+c;return n&&n.copy(this.direction).multiplyScalar(h).add(this.origin),i&&i.copy(hh).multiplyScalar(d).add(mp),f}intersectSphere(e,t){qr.subVectors(e.center,this.origin);const n=qr.dot(this.direction),i=qr.dot(qr)-n*n,r=e.radius*e.radius;if(i>r)return null;const s=Math.sqrt(r-i),o=n-s,l=n+s;return o<0&&l<0?null:o<0?this.at(l,t):this.at(o,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return n===null?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,i,r,s,o,l;const c=1/this.direction.x,u=1/this.direction.y,h=1/this.direction.z,d=this.origin;return c>=0?(n=(e.min.x-d.x)*c,i=(e.max.x-d.x)*c):(n=(e.max.x-d.x)*c,i=(e.min.x-d.x)*c),u>=0?(r=(e.min.y-d.y)*u,s=(e.max.y-d.y)*u):(r=(e.max.y-d.y)*u,s=(e.min.y-d.y)*u),n>s||r>i||((r>n||n!==n)&&(n=r),(s<i||i!==i)&&(i=s),h>=0?(o=(e.min.z-d.z)*h,l=(e.max.z-d.z)*h):(o=(e.max.z-d.z)*h,l=(e.min.z-d.z)*h),n>l||o>i)||((o>n||n!==n)&&(n=o),(l<i||i!==i)&&(i=l),i<0)?null:this.at(n>=0?n:i,t)}intersectsBox(e){return this.intersectBox(e,qr)!==null}intersectTriangle(e,t,n,i,r){gp.subVectors(t,e),dh.subVectors(n,e),vp.crossVectors(gp,dh);let s=this.direction.dot(vp),o;if(s>0){if(i)return null;o=1}else if(s<0)o=-1,s=-s;else return null;Os.subVectors(this.origin,e);const l=o*this.direction.dot(dh.crossVectors(Os,dh));if(l<0)return null;const c=o*this.direction.dot(gp.cross(Os));if(c<0||l+c>s)return null;const u=-o*Os.dot(vp);return u<0?null:this.at(u/s,r)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class ae{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,i,r,s,o,l,c,u,h,d,f,p,m,g){const v=this.elements;return v[0]=e,v[4]=t,v[8]=n,v[12]=i,v[1]=r,v[5]=s,v[9]=o,v[13]=l,v[2]=c,v[6]=u,v[10]=h,v[14]=d,v[3]=f,v[7]=p,v[11]=m,v[15]=g,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new ae().fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,i=1/To.setFromMatrixColumn(e,0).length(),r=1/To.setFromMatrixColumn(e,1).length(),s=1/To.setFromMatrixColumn(e,2).length();return t[0]=n[0]*i,t[1]=n[1]*i,t[2]=n[2]*i,t[3]=0,t[4]=n[4]*r,t[5]=n[5]*r,t[6]=n[6]*r,t[7]=0,t[8]=n[8]*s,t[9]=n[9]*s,t[10]=n[10]*s,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,n=e.x,i=e.y,r=e.z,s=Math.cos(n),o=Math.sin(n),l=Math.cos(i),c=Math.sin(i),u=Math.cos(r),h=Math.sin(r);if(e.order==="XYZ"){const d=s*u,f=s*h,p=o*u,m=o*h;t[0]=l*u,t[4]=-l*h,t[8]=c,t[1]=f+p*c,t[5]=d-m*c,t[9]=-o*l,t[2]=m-d*c,t[6]=p+f*c,t[10]=s*l}else if(e.order==="YXZ"){const d=l*u,f=l*h,p=c*u,m=c*h;t[0]=d+m*o,t[4]=p*o-f,t[8]=s*c,t[1]=s*h,t[5]=s*u,t[9]=-o,t[2]=f*o-p,t[6]=m+d*o,t[10]=s*l}else if(e.order==="ZXY"){const d=l*u,f=l*h,p=c*u,m=c*h;t[0]=d-m*o,t[4]=-s*h,t[8]=p+f*o,t[1]=f+p*o,t[5]=s*u,t[9]=m-d*o,t[2]=-s*c,t[6]=o,t[10]=s*l}else if(e.order==="ZYX"){const d=s*u,f=s*h,p=o*u,m=o*h;t[0]=l*u,t[4]=p*c-f,t[8]=d*c+m,t[1]=l*h,t[5]=m*c+d,t[9]=f*c-p,t[2]=-c,t[6]=o*l,t[10]=s*l}else if(e.order==="YZX"){const d=s*l,f=s*c,p=o*l,m=o*c;t[0]=l*u,t[4]=m-d*h,t[8]=p*h+f,t[1]=h,t[5]=s*u,t[9]=-o*u,t[2]=-c*u,t[6]=f*h+p,t[10]=d-m*h}else if(e.order==="XZY"){const d=s*l,f=s*c,p=o*l,m=o*c;t[0]=l*u,t[4]=-h,t[8]=c*u,t[1]=d*h+m,t[5]=s*u,t[9]=f*h-p,t[2]=p*h-f,t[6]=o*u,t[10]=m*h+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(BE,e,LE)}lookAt(e,t,n){const i=this.elements;return Bi.subVectors(e,t),Bi.lengthSq()===0&&(Bi.z=1),Bi.normalize(),Bs.crossVectors(n,Bi),Bs.lengthSq()===0&&(Math.abs(n.z)===1?Bi.x+=1e-4:Bi.z+=1e-4,Bi.normalize(),Bs.crossVectors(n,Bi)),Bs.normalize(),fh.crossVectors(Bi,Bs),i[0]=Bs.x,i[4]=fh.x,i[8]=Bi.x,i[1]=Bs.y,i[5]=fh.y,i[9]=Bi.y,i[2]=Bs.z,i[6]=fh.z,i[10]=Bi.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,r=this.elements,s=n[0],o=n[4],l=n[8],c=n[12],u=n[1],h=n[5],d=n[9],f=n[13],p=n[2],m=n[6],g=n[10],v=n[14],y=n[3],w=n[7],x=n[11],S=n[15],b=i[0],E=i[4],M=i[8],T=i[12],I=i[1],O=i[5],R=i[9],k=i[13],P=i[2],F=i[6],N=i[10],Y=i[14],_=i[3],G=i[7],j=i[11],L=i[15];return r[0]=s*b+o*I+l*P+c*_,r[4]=s*E+o*O+l*F+c*G,r[8]=s*M+o*R+l*N+c*j,r[12]=s*T+o*k+l*Y+c*L,r[1]=u*b+h*I+d*P+f*_,r[5]=u*E+h*O+d*F+f*G,r[9]=u*M+h*R+d*N+f*j,r[13]=u*T+h*k+d*Y+f*L,r[2]=p*b+m*I+g*P+v*_,r[6]=p*E+m*O+g*F+v*G,r[10]=p*M+m*R+g*N+v*j,r[14]=p*T+m*k+g*Y+v*L,r[3]=y*b+w*I+x*P+S*_,r[7]=y*E+w*O+x*F+S*G,r[11]=y*M+w*R+x*N+S*j,r[15]=y*T+w*k+x*Y+S*L,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],i=e[8],r=e[12],s=e[1],o=e[5],l=e[9],c=e[13],u=e[2],h=e[6],d=e[10],f=e[14],p=e[3],m=e[7],g=e[11],v=e[15];return p*(+r*l*h-i*c*h-r*o*d+n*c*d+i*o*f-n*l*f)+m*(+t*l*f-t*c*d+r*s*d-i*s*f+i*c*u-r*l*u)+g*(+t*c*h-t*o*f-r*s*h+n*s*f+r*o*u-n*c*u)+v*(-i*o*u-t*l*h+t*o*d+i*s*h-n*s*d+n*l*u)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],s=e[4],o=e[5],l=e[6],c=e[7],u=e[8],h=e[9],d=e[10],f=e[11],p=e[12],m=e[13],g=e[14],v=e[15],y=h*g*c-m*d*c+m*l*f-o*g*f-h*l*v+o*d*v,w=p*d*c-u*g*c-p*l*f+s*g*f+u*l*v-s*d*v,x=u*m*c-p*h*c+p*o*f-s*m*f-u*o*v+s*h*v,S=p*h*l-u*m*l-p*o*d+s*m*d+u*o*g-s*h*g,b=t*y+n*w+i*x+r*S;if(b===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const E=1/b;return e[0]=y*E,e[1]=(m*d*r-h*g*r-m*i*f+n*g*f+h*i*v-n*d*v)*E,e[2]=(o*g*r-m*l*r+m*i*c-n*g*c-o*i*v+n*l*v)*E,e[3]=(h*l*r-o*d*r-h*i*c+n*d*c+o*i*f-n*l*f)*E,e[4]=w*E,e[5]=(u*g*r-p*d*r+p*i*f-t*g*f-u*i*v+t*d*v)*E,e[6]=(p*l*r-s*g*r-p*i*c+t*g*c+s*i*v-t*l*v)*E,e[7]=(s*d*r-u*l*r+u*i*c-t*d*c-s*i*f+t*l*f)*E,e[8]=x*E,e[9]=(p*h*r-u*m*r-p*n*f+t*m*f+u*n*v-t*h*v)*E,e[10]=(s*m*r-p*o*r+p*n*c-t*m*c-s*n*v+t*o*v)*E,e[11]=(u*o*r-s*h*r-u*n*c+t*h*c+s*n*f-t*o*f)*E,e[12]=S*E,e[13]=(u*m*i-p*h*i+p*n*d-t*m*d-u*n*g+t*h*g)*E,e[14]=(p*o*i-s*m*i-p*n*l+t*m*l+s*n*g-t*o*g)*E,e[15]=(s*h*i-u*o*i+u*n*l-t*h*l-s*n*d+t*o*d)*E,this}scale(e){const t=this.elements,n=e.x,i=e.y,r=e.z;return t[0]*=n,t[4]*=i,t[8]*=r,t[1]*=n,t[5]*=i,t[9]*=r,t[2]*=n,t[6]*=i,t[10]*=r,t[3]*=n,t[7]*=i,t[11]*=r,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,i))}makeTranslation(e,t,n){return this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),i=Math.sin(t),r=1-n,s=e.x,o=e.y,l=e.z,c=r*s,u=r*o;return this.set(c*s+n,c*o-i*l,c*l+i*o,0,c*o+i*l,u*o+n,u*l-i*s,0,c*l-i*o,u*l+i*s,r*l*l+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n,i,r,s){return this.set(1,n,r,0,e,1,s,0,t,i,1,0,0,0,0,1),this}compose(e,t,n){const i=this.elements,r=t._x,s=t._y,o=t._z,l=t._w,c=r+r,u=s+s,h=o+o,d=r*c,f=r*u,p=r*h,m=s*u,g=s*h,v=o*h,y=l*c,w=l*u,x=l*h,S=n.x,b=n.y,E=n.z;return i[0]=(1-(m+v))*S,i[1]=(f+x)*S,i[2]=(p-w)*S,i[3]=0,i[4]=(f-x)*b,i[5]=(1-(d+v))*b,i[6]=(g+y)*b,i[7]=0,i[8]=(p+w)*E,i[9]=(g-y)*E,i[10]=(1-(d+m))*E,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,n){const i=this.elements;let r=To.set(i[0],i[1],i[2]).length();const s=To.set(i[4],i[5],i[6]).length(),o=To.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),e.x=i[12],e.y=i[13],e.z=i[14],rr.copy(this);const c=1/r,u=1/s,h=1/o;return rr.elements[0]*=c,rr.elements[1]*=c,rr.elements[2]*=c,rr.elements[4]*=u,rr.elements[5]*=u,rr.elements[6]*=u,rr.elements[8]*=h,rr.elements[9]*=h,rr.elements[10]*=h,t.setFromRotationMatrix(rr),n.x=r,n.y=s,n.z=o,this}makePerspective(e,t,n,i,r,s){s===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,l=2*r/(t-e),c=2*r/(n-i),u=(t+e)/(t-e),h=(n+i)/(n-i),d=-(s+r)/(s-r),f=-2*s*r/(s-r);return o[0]=l,o[4]=0,o[8]=u,o[12]=0,o[1]=0,o[5]=c,o[9]=h,o[13]=0,o[2]=0,o[6]=0,o[10]=d,o[14]=f,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(e,t,n,i,r,s){const o=this.elements,l=1/(t-e),c=1/(n-i),u=1/(s-r),h=(t+e)*l,d=(n+i)*c,f=(s+r)*u;return o[0]=2*l,o[4]=0,o[8]=0,o[12]=-h,o[1]=0,o[5]=2*c,o[9]=0,o[13]=-d,o[2]=0,o[6]=0,o[10]=-2*u,o[14]=-f,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<16;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}ae.prototype.isMatrix4=!0;const To=new A,rr=new ae,BE=new A(0,0,0),LE=new A(1,1,1),Bs=new A,fh=new A,Bi=new A,B0=new ae,L0=new dt;class mi{constructor(e=0,t=0,n=0,i=mi.DefaultOrder){this._x=e,this._y=t,this._z=n,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,i=this._order){return this._x=e,this._y=t,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,n=!0){const i=e.elements,r=i[0],s=i[4],o=i[8],l=i[1],c=i[5],u=i[9],h=i[2],d=i[6],f=i[10];switch(t){case"XYZ":this._y=Math.asin(In(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-u,f),this._z=Math.atan2(-s,r)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-In(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(o,f),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-h,r),this._z=0);break;case"ZXY":this._x=Math.asin(In(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-h,f),this._z=Math.atan2(-s,c)):(this._y=0,this._z=Math.atan2(l,r));break;case"ZYX":this._y=Math.asin(-In(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(d,f),this._z=Math.atan2(l,r)):(this._x=0,this._z=Math.atan2(-s,c));break;case"YZX":this._z=Math.asin(In(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,c),this._y=Math.atan2(-h,r)):(this._x=0,this._y=Math.atan2(o,f));break;case"XZY":this._z=Math.asin(-In(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(o,r)):(this._x=Math.atan2(-u,f),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,n===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return B0.makeRotationFromQuaternion(e),this.setFromRotationMatrix(B0,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return L0.setFromEuler(this),this.setFromQuaternion(L0,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}mi.prototype.isEuler=!0;mi.DefaultOrder="XYZ";mi.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class xf{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let zE=0;const z0=new A,Co=new dt,_r=new ae,ph=new A,Wl=new A,NE=new A,kE=new dt,N0=new A(1,0,0),k0=new A(0,1,0),U0=new A(0,0,1),UE={type:"added"},F0={type:"removed"};class gt extends Ss{constructor(){super(),Object.defineProperty(this,"id",{value:zE++}),this.uuid=Ni(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=gt.DefaultUp.clone();const e=new A,t=new mi,n=new dt,i=new A(1,1,1);function r(){n.setFromEuler(t,!1)}function s(){t.setFromQuaternion(n,void 0,!1)}t._onChange(r),n._onChange(s),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new ae},normalMatrix:{value:new Kt}}),this.matrix=new ae,this.matrixWorld=new ae,this.matrixAutoUpdate=gt.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new xf,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return Co.setFromAxisAngle(e,t),this.quaternion.multiply(Co),this}rotateOnWorldAxis(e,t){return Co.setFromAxisAngle(e,t),this.quaternion.premultiply(Co),this}rotateX(e){return this.rotateOnAxis(N0,e)}rotateY(e){return this.rotateOnAxis(k0,e)}rotateZ(e){return this.rotateOnAxis(U0,e)}translateOnAxis(e,t){return z0.copy(e).applyQuaternion(this.quaternion),this.position.add(z0.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(N0,e)}translateY(e){return this.translateOnAxis(k0,e)}translateZ(e){return this.translateOnAxis(U0,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(_r.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?ph.copy(e):ph.set(e,t,n);const i=this.parent;this.updateWorldMatrix(!0,!1),Wl.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?_r.lookAt(Wl,ph,this.up):_r.lookAt(ph,Wl,this.up),this.quaternion.setFromRotationMatrix(_r),i&&(_r.extractRotation(i.matrixWorld),Co.setFromRotationMatrix(_r),this.quaternion.premultiply(Co.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(UE)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(F0)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(F0)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),_r.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),_r.multiply(e.parent.matrixWorld)),e.applyMatrix4(_r),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,i=this.children.length;n<i;n++){const s=this.children[n].getObjectByProperty(e,t);if(s!==void 0)return s}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Wl,e,NE),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Wl,kE,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].updateMatrixWorld(e)}updateWorldMatrix(e,t){const n=this.parent;if(e===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const i=this.children;for(let r=0,s=i.length;r<s;r++)i[r].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON()));function r(o,l){return o[l.uuid]===void 0&&(o[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(e.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const l=o.shapes;if(Array.isArray(l))for(let c=0,u=l.length;c<u;c++){const h=l[c];r(e.shapes,h)}else r(e.shapes,l)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let l=0,c=this.material.length;l<c;l++)o.push(r(e.materials,this.material[l]));i.material=o}else i.material=r(e.materials,this.material);if(this.children.length>0){i.children=[];for(let o=0;o<this.children.length;o++)i.children.push(this.children[o].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let o=0;o<this.animations.length;o++){const l=this.animations[o];i.animations.push(r(e.animations,l))}}if(t){const o=s(e.geometries),l=s(e.materials),c=s(e.textures),u=s(e.images),h=s(e.shapes),d=s(e.skeletons),f=s(e.animations),p=s(e.nodes);o.length>0&&(n.geometries=o),l.length>0&&(n.materials=l),c.length>0&&(n.textures=c),u.length>0&&(n.images=u),h.length>0&&(n.shapes=h),d.length>0&&(n.skeletons=d),f.length>0&&(n.animations=f),p.length>0&&(n.nodes=p)}return n.object=i,n;function s(o){const l=[];for(const c in o){const u=o[c];delete u.metadata,l.push(u)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let n=0;n<e.children.length;n++){const i=e.children[n];this.add(i.clone())}return this}}gt.DefaultUp=new A(0,1,0);gt.DefaultMatrixAutoUpdate=!0;gt.prototype.isObject3D=!0;const sr=new A,$r=new A,yp=new A,es=new A,Io=new A,Ro=new A,H0=new A,xp=new A,wp=new A,Ap=new A;class Ht{constructor(e=new A,t=new A,n=new A){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,i){i.subVectors(n,t),sr.subVectors(e,t),i.cross(sr);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(e,t,n,i,r){sr.subVectors(i,t),$r.subVectors(n,t),yp.subVectors(e,t);const s=sr.dot(sr),o=sr.dot($r),l=sr.dot(yp),c=$r.dot($r),u=$r.dot(yp),h=s*c-o*o;if(h===0)return r.set(-2,-1,-1);const d=1/h,f=(c*l-o*u)*d,p=(s*u-o*l)*d;return r.set(1-f-p,p,f)}static containsPoint(e,t,n,i){return this.getBarycoord(e,t,n,i,es),es.x>=0&&es.y>=0&&es.x+es.y<=1}static getUV(e,t,n,i,r,s,o,l){return this.getBarycoord(e,t,n,i,es),l.set(0,0),l.addScaledVector(r,es.x),l.addScaledVector(s,es.y),l.addScaledVector(o,es.z),l}static isFrontFacing(e,t,n,i){return sr.subVectors(n,t),$r.subVectors(e,t),sr.cross($r).dot(i)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,i){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[i]),this}setFromAttributeAndIndices(e,t,n,i){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,n),this.c.fromBufferAttribute(e,i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return sr.subVectors(this.c,this.b),$r.subVectors(this.a,this.b),sr.cross($r).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Ht.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Ht.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,i,r){return Ht.getUV(e,this.a,this.b,this.c,t,n,i,r)}containsPoint(e){return Ht.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Ht.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const n=this.a,i=this.b,r=this.c;let s,o;Io.subVectors(i,n),Ro.subVectors(r,n),xp.subVectors(e,n);const l=Io.dot(xp),c=Ro.dot(xp);if(l<=0&&c<=0)return t.copy(n);wp.subVectors(e,i);const u=Io.dot(wp),h=Ro.dot(wp);if(u>=0&&h<=u)return t.copy(i);const d=l*h-u*c;if(d<=0&&l>=0&&u<=0)return s=l/(l-u),t.copy(n).addScaledVector(Io,s);Ap.subVectors(e,r);const f=Io.dot(Ap),p=Ro.dot(Ap);if(p>=0&&f<=p)return t.copy(r);const m=f*c-l*p;if(m<=0&&c>=0&&p<=0)return o=c/(c-p),t.copy(n).addScaledVector(Ro,o);const g=u*p-f*h;if(g<=0&&h-u>=0&&f-p>=0)return H0.subVectors(r,i),o=(h-u)/(h-u+(f-p)),t.copy(i).addScaledVector(H0,o);const v=1/(g+m+d);return s=m*v,o=d*v,t.copy(n).addScaledVector(Io,s).addScaledVector(Ro,o)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let FE=0;class cn extends Ss{constructor(){super(),Object.defineProperty(this,"id",{value:FE++}),this.uuid=Ni(),this.name="",this.type="Material",this.blending=qs,this.side=An,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=kg,this.blendDst=Ug,this.blendEquation=hr,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=Wd,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Bu,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=yc,this.stencilZFail=yc,this.stencilZPass=yc,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const n=e[t];if(n===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if(t==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===zg;continue}const i=this[t];if(i===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[t]=n}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==qs&&(n.blending=this.blending),this.side!==An&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),this.fog===!1&&(n.fog=!1),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData);function i(r){const s=[];for(const o in r){const l=r[o];delete l.metadata,s.push(l)}return s}if(t){const r=i(e.textures),s=i(e.images);r.length>0&&(n.textures=r),s.length>0&&(n.images=s)}return n}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(t!==null){const i=t.length;n=new Array(i);for(let r=0;r!==i;++r)n[r]=t[r].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}cn.prototype.isMaterial=!0;cn.fromType=function(){return null};class ti extends cn{constructor(e){super(),this.type="MeshBasicMaterial",this.color=new Ie(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ou,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}ti.prototype.isMeshBasicMaterial=!0;const zn=new A,mh=new te;class wt{constructor(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=n===!0,this.usage=al,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[e+i]=t.array[n+i];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){const t=this.array;let n=0;for(let i=0,r=e.length;i<r;i++){let s=e[i];s===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),s=new Ie),t[n++]=s.r,t[n++]=s.g,t[n++]=s.b}return this}copyVector2sArray(e){const t=this.array;let n=0;for(let i=0,r=e.length;i<r;i++){let s=e[i];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),s=new te),t[n++]=s.x,t[n++]=s.y}return this}copyVector3sArray(e){const t=this.array;let n=0;for(let i=0,r=e.length;i<r;i++){let s=e[i];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),s=new A),t[n++]=s.x,t[n++]=s.y,t[n++]=s.z}return this}copyVector4sArray(e){const t=this.array;let n=0;for(let i=0,r=e.length;i<r;i++){let s=e[i];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),s=new lt),t[n++]=s.x,t[n++]=s.y,t[n++]=s.z,t[n++]=s.w}return this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,n=this.count;t<n;t++)mh.fromBufferAttribute(this,t),mh.applyMatrix3(e),this.setXY(t,mh.x,mh.y);else if(this.itemSize===3)for(let t=0,n=this.count;t<n;t++)zn.fromBufferAttribute(this,t),zn.applyMatrix3(e),this.setXYZ(t,zn.x,zn.y,zn.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)zn.fromBufferAttribute(this,t),zn.applyMatrix4(e),this.setXYZ(t,zn.x,zn.y,zn.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)zn.fromBufferAttribute(this,t),zn.applyNormalMatrix(e),this.setXYZ(t,zn.x,zn.y,zn.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)zn.fromBufferAttribute(this,t),zn.transformDirection(e),this.setXYZ(t,zn.x,zn.y,zn.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,i){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this}setXYZW(e,t,n,i,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this.array[e+3]=r,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==al&&(e.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(e.updateRange=this.updateRange),e}}wt.prototype.isBufferAttribute=!0;class KA extends wt{constructor(e,t,n){super(new Int8Array(e),t,n)}}class YA extends wt{constructor(e,t,n){super(new Uint8Array(e),t,n)}}class qA extends wt{constructor(e,t,n){super(new Uint8ClampedArray(e),t,n)}}class wf extends wt{constructor(e,t,n){super(new Int16Array(e),t,n)}}class _i extends wt{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class _A extends wt{constructor(e,t,n){super(new Int32Array(e),t,n)}}class ys extends wt{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class $A extends wt{constructor(e,t,n){super(new Uint16Array(e),t,n)}}$A.prototype.isFloat16BufferAttribute=!0;class je extends wt{constructor(e,t,n){super(new Float32Array(e),t,n)}}class eS extends wt{constructor(e,t,n){super(new Float64Array(e),t,n)}}let HE=0;const Vi=new ae,Sp=new gt,Po=new A,Li=new He,Xl=new He,Qn=new A;class nt extends Ss{constructor(){super(),Object.defineProperty(this,"id",{value:HE++}),this.uuid=Ni(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(WA(e)?ys:_i)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const r=new Kt().getNormalMatrix(e);n.applyNormalMatrix(r),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return Vi.makeRotationFromQuaternion(e),this.applyMatrix4(Vi),this}rotateX(e){return Vi.makeRotationX(e),this.applyMatrix4(Vi),this}rotateY(e){return Vi.makeRotationY(e),this.applyMatrix4(Vi),this}rotateZ(e){return Vi.makeRotationZ(e),this.applyMatrix4(Vi),this}translate(e,t,n){return Vi.makeTranslation(e,t,n),this.applyMatrix4(Vi),this}scale(e,t,n){return Vi.makeScale(e,t,n),this.applyMatrix4(Vi),this}lookAt(e){return Sp.lookAt(e),Sp.updateMatrix(),this.applyMatrix4(Sp.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Po).negate(),this.translate(Po.x,Po.y,Po.z),this}setFromPoints(e){const t=[];for(let n=0,i=e.length;n<i;n++){const r=e[n];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new je(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new He);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new A(-1/0,-1/0,-1/0),new A(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,i=t.length;n<i;n++){const r=t[n];Li.setFromBufferAttribute(r),this.morphTargetsRelative?(Qn.addVectors(this.boundingBox.min,Li.min),this.boundingBox.expandByPoint(Qn),Qn.addVectors(this.boundingBox.max,Li.max),this.boundingBox.expandByPoint(Qn)):(this.boundingBox.expandByPoint(Li.min),this.boundingBox.expandByPoint(Li.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new rn);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new A,1/0);return}if(e){const n=this.boundingSphere.center;if(Li.setFromBufferAttribute(e),t)for(let r=0,s=t.length;r<s;r++){const o=t[r];Xl.setFromBufferAttribute(o),this.morphTargetsRelative?(Qn.addVectors(Li.min,Xl.min),Li.expandByPoint(Qn),Qn.addVectors(Li.max,Xl.max),Li.expandByPoint(Qn)):(Li.expandByPoint(Xl.min),Li.expandByPoint(Xl.max))}Li.getCenter(n);let i=0;for(let r=0,s=e.count;r<s;r++)Qn.fromBufferAttribute(e,r),i=Math.max(i,n.distanceToSquared(Qn));if(t)for(let r=0,s=t.length;r<s;r++){const o=t[r],l=this.morphTargetsRelative;for(let c=0,u=o.count;c<u;c++)Qn.fromBufferAttribute(o,c),l&&(Po.fromBufferAttribute(e,c),Qn.add(Po)),i=Math.max(i,n.distanceToSquared(Qn))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=e.array,i=t.position.array,r=t.normal.array,s=t.uv.array,o=i.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new wt(new Float32Array(4*o),4));const l=this.getAttribute("tangent").array,c=[],u=[];for(let I=0;I<o;I++)c[I]=new A,u[I]=new A;const h=new A,d=new A,f=new A,p=new te,m=new te,g=new te,v=new A,y=new A;function w(I,O,R){h.fromArray(i,I*3),d.fromArray(i,O*3),f.fromArray(i,R*3),p.fromArray(s,I*2),m.fromArray(s,O*2),g.fromArray(s,R*2),d.sub(h),f.sub(h),m.sub(p),g.sub(p);const k=1/(m.x*g.y-g.x*m.y);isFinite(k)&&(v.copy(d).multiplyScalar(g.y).addScaledVector(f,-m.y).multiplyScalar(k),y.copy(f).multiplyScalar(m.x).addScaledVector(d,-g.x).multiplyScalar(k),c[I].add(v),c[O].add(v),c[R].add(v),u[I].add(y),u[O].add(y),u[R].add(y))}let x=this.groups;x.length===0&&(x=[{start:0,count:n.length}]);for(let I=0,O=x.length;I<O;++I){const R=x[I],k=R.start,P=R.count;for(let F=k,N=k+P;F<N;F+=3)w(n[F+0],n[F+1],n[F+2])}const S=new A,b=new A,E=new A,M=new A;function T(I){E.fromArray(r,I*3),M.copy(E);const O=c[I];S.copy(O),S.sub(E.multiplyScalar(E.dot(O))).normalize(),b.crossVectors(M,O);const k=b.dot(u[I])<0?-1:1;l[I*4]=S.x,l[I*4+1]=S.y,l[I*4+2]=S.z,l[I*4+3]=k}for(let I=0,O=x.length;I<O;++I){const R=x[I],k=R.start,P=R.count;for(let F=k,N=k+P;F<N;F+=3)T(n[F+0]),T(n[F+1]),T(n[F+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new wt(new Float32Array(t.count*3),3),this.setAttribute("normal",n);else for(let d=0,f=n.count;d<f;d++)n.setXYZ(d,0,0,0);const i=new A,r=new A,s=new A,o=new A,l=new A,c=new A,u=new A,h=new A;if(e)for(let d=0,f=e.count;d<f;d+=3){const p=e.getX(d+0),m=e.getX(d+1),g=e.getX(d+2);i.fromBufferAttribute(t,p),r.fromBufferAttribute(t,m),s.fromBufferAttribute(t,g),u.subVectors(s,r),h.subVectors(i,r),u.cross(h),o.fromBufferAttribute(n,p),l.fromBufferAttribute(n,m),c.fromBufferAttribute(n,g),o.add(u),l.add(u),c.add(u),n.setXYZ(p,o.x,o.y,o.z),n.setXYZ(m,l.x,l.y,l.z),n.setXYZ(g,c.x,c.y,c.z)}else for(let d=0,f=t.count;d<f;d+=3)i.fromBufferAttribute(t,d+0),r.fromBufferAttribute(t,d+1),s.fromBufferAttribute(t,d+2),u.subVectors(s,r),h.subVectors(i,r),u.cross(h),n.setXYZ(d+0,u.x,u.y,u.z),n.setXYZ(d+1,u.x,u.y,u.z),n.setXYZ(d+2,u.x,u.y,u.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(e,t){if(!(e&&e.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);return}t===void 0&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const i in n){if(e.attributes[i]===void 0)continue;const s=n[i].array,o=e.attributes[i],l=o.array,c=o.itemSize*t,u=Math.min(l.length,s.length-c);for(let h=0,d=c;h<u;h++,d++)s[d]=l[h]}return this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)Qn.fromBufferAttribute(e,t),Qn.normalize(),e.setXYZ(t,Qn.x,Qn.y,Qn.z)}toNonIndexed(){function e(o,l){const c=o.array,u=o.itemSize,h=o.normalized,d=new c.constructor(l.length*u);let f=0,p=0;for(let m=0,g=l.length;m<g;m++){o.isInterleavedBufferAttribute?f=l[m]*o.data.stride+o.offset:f=l[m]*u;for(let v=0;v<u;v++)d[p++]=c[f++]}return new wt(d,u,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new nt,n=this.index.array,i=this.attributes;for(const o in i){const l=i[o],c=e(l,n);t.setAttribute(o,c)}const r=this.morphAttributes;for(const o in r){const l=[],c=r[o];for(let u=0,h=c.length;u<h;u++){const d=c[u],f=e(d,n);l.push(f)}t.morphAttributes[o]=l}t.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let o=0,l=s.length;o<l;o++){const c=s[o];t.addGroup(c.start,c.count,c.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(e[c]=l[c]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const l in n){const c=n[l];e.data.attributes[l]=c.toJSON(e.data)}const i={};let r=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],u=[];for(let h=0,d=c.length;h<d;h++){const f=c[h];u.push(f.toJSON(e.data))}u.length>0&&(i[l]=u,r=!0)}r&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(e.data.groups=JSON.parse(JSON.stringify(s)));const o=this.boundingSphere;return o!==null&&(e.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;n!==null&&this.setIndex(n.clone(t));const i=e.attributes;for(const c in i){const u=i[c];this.setAttribute(c,u.clone(t))}const r=e.morphAttributes;for(const c in r){const u=[],h=r[c];for(let d=0,f=h.length;d<f;d++)u.push(h[d].clone(t));this.morphAttributes[c]=u}this.morphTargetsRelative=e.morphTargetsRelative;const s=e.groups;for(let c=0,u=s.length;c<u;c++){const h=s[c];this.addGroup(h.start,h.count,h.materialIndex)}const o=e.boundingBox;o!==null&&(this.boundingBox=o.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,e.parameters!==void 0&&(this.parameters=Object.assign({},e.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}nt.prototype.isBufferGeometry=!0;const G0=new ae,Do=new On,Mp=new rn,Ls=new A,zs=new A,Ns=new A,bp=new A,Ep=new A,Tp=new A,gh=new A,vh=new A,yh=new A,xh=new te,wh=new te,Ah=new te,Cp=new A,Sh=new A;class Ve extends gt{constructor(e=new nt,t=new ti){super(),this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=i.length;r<s;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(e,t){const n=this.geometry,i=this.material,r=this.matrixWorld;if(i===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),Mp.copy(n.boundingSphere),Mp.applyMatrix4(r),e.ray.intersectsSphere(Mp)===!1)||(G0.copy(r).invert(),Do.copy(e.ray).applyMatrix4(G0),n.boundingBox!==null&&Do.intersectsBox(n.boundingBox)===!1))return;let s;if(n.isBufferGeometry){const o=n.index,l=n.attributes.position,c=n.morphAttributes.position,u=n.morphTargetsRelative,h=n.attributes.uv,d=n.attributes.uv2,f=n.groups,p=n.drawRange;if(o!==null)if(Array.isArray(i))for(let m=0,g=f.length;m<g;m++){const v=f[m],y=i[v.materialIndex],w=Math.max(v.start,p.start),x=Math.min(o.count,Math.min(v.start+v.count,p.start+p.count));for(let S=w,b=x;S<b;S+=3){const E=o.getX(S),M=o.getX(S+1),T=o.getX(S+2);s=Mh(this,y,e,Do,l,c,u,h,d,E,M,T),s&&(s.faceIndex=Math.floor(S/3),s.face.materialIndex=v.materialIndex,t.push(s))}}else{const m=Math.max(0,p.start),g=Math.min(o.count,p.start+p.count);for(let v=m,y=g;v<y;v+=3){const w=o.getX(v),x=o.getX(v+1),S=o.getX(v+2);s=Mh(this,i,e,Do,l,c,u,h,d,w,x,S),s&&(s.faceIndex=Math.floor(v/3),t.push(s))}}else if(l!==void 0)if(Array.isArray(i))for(let m=0,g=f.length;m<g;m++){const v=f[m],y=i[v.materialIndex],w=Math.max(v.start,p.start),x=Math.min(l.count,Math.min(v.start+v.count,p.start+p.count));for(let S=w,b=x;S<b;S+=3){const E=S,M=S+1,T=S+2;s=Mh(this,y,e,Do,l,c,u,h,d,E,M,T),s&&(s.faceIndex=Math.floor(S/3),s.face.materialIndex=v.materialIndex,t.push(s))}}else{const m=Math.max(0,p.start),g=Math.min(l.count,p.start+p.count);for(let v=m,y=g;v<y;v+=3){const w=v,x=v+1,S=v+2;s=Mh(this,i,e,Do,l,c,u,h,d,w,x,S),s&&(s.faceIndex=Math.floor(v/3),t.push(s))}}}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}Ve.prototype.isMesh=!0;function GE(a,e,t,n,i,r,s,o){let l;if(e.side===pi?l=n.intersectTriangle(s,r,i,!0,o):l=n.intersectTriangle(i,r,s,e.side!==yt,o),l===null)return null;Sh.copy(o),Sh.applyMatrix4(a.matrixWorld);const c=t.ray.origin.distanceTo(Sh);return c<t.near||c>t.far?null:{distance:c,point:Sh.clone(),object:a}}function Mh(a,e,t,n,i,r,s,o,l,c,u,h){Ls.fromBufferAttribute(i,c),zs.fromBufferAttribute(i,u),Ns.fromBufferAttribute(i,h);const d=a.morphTargetInfluences;if(r&&d){gh.set(0,0,0),vh.set(0,0,0),yh.set(0,0,0);for(let p=0,m=r.length;p<m;p++){const g=d[p],v=r[p];g!==0&&(bp.fromBufferAttribute(v,c),Ep.fromBufferAttribute(v,u),Tp.fromBufferAttribute(v,h),s?(gh.addScaledVector(bp,g),vh.addScaledVector(Ep,g),yh.addScaledVector(Tp,g)):(gh.addScaledVector(bp.sub(Ls),g),vh.addScaledVector(Ep.sub(zs),g),yh.addScaledVector(Tp.sub(Ns),g)))}Ls.add(gh),zs.add(vh),Ns.add(yh)}a.isSkinnedMesh&&(a.boneTransform(c,Ls),a.boneTransform(u,zs),a.boneTransform(h,Ns));const f=GE(a,e,t,n,Ls,zs,Ns,Cp);if(f){o&&(xh.fromBufferAttribute(o,c),wh.fromBufferAttribute(o,u),Ah.fromBufferAttribute(o,h),f.uv=Ht.getUV(Cp,Ls,zs,Ns,xh,wh,Ah,new te)),l&&(xh.fromBufferAttribute(l,c),wh.fromBufferAttribute(l,u),Ah.fromBufferAttribute(l,h),f.uv2=Ht.getUV(Cp,Ls,zs,Ns,xh,wh,Ah,new te));const p={a:c,b:u,c:h,normal:new A,materialIndex:0};Ht.getNormal(Ls,zs,Ns,p.normal),f.face=p}return f}class Tn extends nt{constructor(e=1,t=1,n=1,i=1,r=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:i,heightSegments:r,depthSegments:s};const o=this;i=Math.floor(i),r=Math.floor(r),s=Math.floor(s);const l=[],c=[],u=[],h=[];let d=0,f=0;p("z","y","x",-1,-1,n,t,e,s,r,0),p("z","y","x",1,-1,n,t,-e,s,r,1),p("x","z","y",1,1,e,n,t,i,s,2),p("x","z","y",1,-1,e,n,-t,i,s,3),p("x","y","z",1,-1,e,t,n,i,r,4),p("x","y","z",-1,-1,e,t,-n,i,r,5),this.setIndex(l),this.setAttribute("position",new je(c,3)),this.setAttribute("normal",new je(u,3)),this.setAttribute("uv",new je(h,2));function p(m,g,v,y,w,x,S,b,E,M,T){const I=x/E,O=S/M,R=x/2,k=S/2,P=b/2,F=E+1,N=M+1;let Y=0,_=0;const G=new A;for(let j=0;j<N;j++){const L=j*O-k;for(let H=0;H<F;H++){const q=H*I-R;G[m]=q*y,G[g]=L*w,G[v]=P,c.push(G.x,G.y,G.z),G[m]=0,G[g]=0,G[v]=b>0?1:-1,u.push(G.x,G.y,G.z),h.push(H/E),h.push(1-j/M),Y+=1}}for(let j=0;j<M;j++)for(let L=0;L<E;L++){const H=d+L+F*j,q=d+L+F*(j+1),$=d+(L+1)+F*(j+1),ee=d+(L+1)+F*j;l.push(H,q,ee),l.push(q,$,ee),_+=6}o.addGroup(f,_,T),f+=_,d+=Y}}static fromJSON(e){return new Tn(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function ol(a){const e={};for(const t in a){e[t]={};for(const n in a[t]){const i=a[t][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?e[t][n]=i.clone():Array.isArray(i)?e[t][n]=i.slice():e[t][n]=i}}return e}function li(a){const e={};for(let t=0;t<a.length;t++){const n=ol(a[t]);for(const i in n)e[i]=n[i]}return e}const Hr={clone:ol,merge:li};var VE=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,jE=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class gn extends cn{constructor(e){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=VE,this.fragmentShader=jE,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&(e.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=ol(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const s=this.uniforms[i].value;s&&s.isTexture?t.uniforms[i]={type:"t",value:s.toJSON(e).uuid}:s&&s.isColor?t.uniforms[i]={type:"c",value:s.getHex()}:s&&s.isVector2?t.uniforms[i]={type:"v2",value:s.toArray()}:s&&s.isVector3?t.uniforms[i]={type:"v3",value:s.toArray()}:s&&s.isVector4?t.uniforms[i]={type:"v4",value:s.toArray()}:s&&s.isMatrix3?t.uniforms[i]={type:"m3",value:s.toArray()}:s&&s.isMatrix4?t.uniforms[i]={type:"m4",value:s.toArray()}:t.uniforms[i]={value:s}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}}gn.prototype.isShaderMaterial=!0;class zu extends gt{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new ae,this.projectionMatrix=new ae,this.projectionMatrixInverse=new ae}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}zu.prototype.isCamera=!0;class tn extends zu{constructor(e=50,t=1,n=.1,i=2e3){super(),this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=au*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(Wa*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return au*2*Math.atan(Math.tan(Wa*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,n,i,r,s){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(Wa*.5*this.fov)/this.zoom,n=2*t,i=this.aspect*n,r=-.5*i;const s=this.view;if(this.view!==null&&this.view.enabled){const l=s.fullWidth,c=s.fullHeight;r+=s.offsetX*i/l,t-=s.offsetY*n/c,i*=s.width/l,n*=s.height/c}const o=this.filmOffset;o!==0&&(r+=e*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,t,t-n,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}tn.prototype.isPerspectiveCamera=!0;const Oo=90,Bo=1;class Af extends gt{constructor(e,t,n){if(super(),this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=n;const i=new tn(Oo,Bo,e,t);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new A(1,0,0)),this.add(i);const r=new tn(Oo,Bo,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new A(-1,0,0)),this.add(r);const s=new tn(Oo,Bo,e,t);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new A(0,1,0)),this.add(s);const o=new tn(Oo,Bo,e,t);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new A(0,-1,0)),this.add(o);const l=new tn(Oo,Bo,e,t);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new A(0,0,1)),this.add(l);const c=new tn(Oo,Bo,e,t);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new A(0,0,-1)),this.add(c)}update(e,t){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget,[i,r,s,o,l,c]=this.children,u=e.getRenderTarget(),h=e.toneMapping,d=e.xr.enabled;e.toneMapping=Nr,e.xr.enabled=!1;const f=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0),e.render(t,i),e.setRenderTarget(n,1),e.render(t,r),e.setRenderTarget(n,2),e.render(t,s),e.setRenderTarget(n,3),e.render(t,o),e.setRenderTarget(n,4),e.render(t,l),n.texture.generateMipmaps=f,e.setRenderTarget(n,5),e.render(t,c),e.setRenderTarget(u),e.toneMapping=h,e.xr.enabled=d,n.texture.needsPMREMUpdate=!0}}class bl extends bn{constructor(e,t,n,i,r,s,o,l,c,u){e=e!==void 0?e:[],t=t!==void 0?t:ra,super(e,t,n,i,r,s,o,l,c,u),this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}bl.prototype.isCubeTexture=!0;class Nu extends pn{constructor(e,t={}){super(e,e,t);const n={width:e,height:e,depth:1},i=[n,n,n,n,n,n];this.texture=new bl(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:St}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new Tn(5,5,5),r=new gn({name:"CubemapFromEquirect",uniforms:ol(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:pi,blending:Mn});r.uniforms.tEquirect.value=t;const s=new Ve(i,r),o=t.minFilter;return t.minFilter===uo&&(t.minFilter=St),new Af(1,10,this).update(e,s),t.minFilter=o,s.geometry.dispose(),s.material.dispose(),this}clear(e,t,n,i){const r=e.getRenderTarget();for(let s=0;s<6;s++)e.setRenderTarget(this,s),e.clear(t,n,i);e.setRenderTarget(r)}}Nu.prototype.isWebGLCubeRenderTarget=!0;const Ip=new A,QE=new A,WE=new Kt;class kt{constructor(e=new A(1,0,0),t=0){this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,i){return this.normal.set(e,t,n),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const i=Ip.subVectors(n,t).cross(QE.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){const n=e.delta(Ip),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const r=-(e.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:t.copy(n).multiplyScalar(r).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||WE.getNormalMatrix(e),i=this.coplanarPoint(Ip).applyMatrix4(e),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}kt.prototype.isPlane=!0;const Lo=new rn,bh=new A;class El{constructor(e=new kt,t=new kt,n=new kt,i=new kt,r=new kt,s=new kt){this.planes=[e,t,n,i,r,s]}set(e,t,n,i,r,s){const o=this.planes;return o[0].copy(e),o[1].copy(t),o[2].copy(n),o[3].copy(i),o[4].copy(r),o[5].copy(s),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e){const t=this.planes,n=e.elements,i=n[0],r=n[1],s=n[2],o=n[3],l=n[4],c=n[5],u=n[6],h=n[7],d=n[8],f=n[9],p=n[10],m=n[11],g=n[12],v=n[13],y=n[14],w=n[15];return t[0].setComponents(o-i,h-l,m-d,w-g).normalize(),t[1].setComponents(o+i,h+l,m+d,w+g).normalize(),t[2].setComponents(o+r,h+c,m+f,w+v).normalize(),t[3].setComponents(o-r,h-c,m-f,w-v).normalize(),t[4].setComponents(o-s,h-u,m-p,w-y).normalize(),t[5].setComponents(o+s,h+u,m+p,w+y).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),Lo.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(Lo)}intersectsSprite(e){return Lo.center.set(0,0,0),Lo.radius=.7071067811865476,Lo.applyMatrix4(e.matrixWorld),this.intersectsSphere(Lo)}intersectsSphere(e){const t=this.planes,n=e.center,i=-e.radius;for(let r=0;r<6;r++)if(t[r].distanceToPoint(n)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const i=t[n];if(bh.x=i.normal.x>0?e.max.x:e.min.x,bh.y=i.normal.y>0?e.max.y:e.min.y,bh.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(bh)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function tS(){let a=null,e=!1,t=null,n=null;function i(r,s){t(r,s),n=a.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(n=a.requestAnimationFrame(i),e=!0)},stop:function(){a.cancelAnimationFrame(n),e=!1},setAnimationLoop:function(r){t=r},setContext:function(r){a=r}}}function XE(a,e){const t=e.isWebGL2,n=new WeakMap;function i(c,u){const h=c.array,d=c.usage,f=a.createBuffer();a.bindBuffer(u,f),a.bufferData(u,h,d),c.onUploadCallback();let p;if(h instanceof Float32Array)p=5126;else if(h instanceof Uint16Array)if(c.isFloat16BufferAttribute)if(t)p=5131;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else p=5123;else if(h instanceof Int16Array)p=5122;else if(h instanceof Uint32Array)p=5125;else if(h instanceof Int32Array)p=5124;else if(h instanceof Int8Array)p=5120;else if(h instanceof Uint8Array)p=5121;else if(h instanceof Uint8ClampedArray)p=5121;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+h);return{buffer:f,type:p,bytesPerElement:h.BYTES_PER_ELEMENT,version:c.version}}function r(c,u,h){const d=u.array,f=u.updateRange;a.bindBuffer(h,c),f.count===-1?a.bufferSubData(h,0,d):(t?a.bufferSubData(h,f.offset*d.BYTES_PER_ELEMENT,d,f.offset,f.count):a.bufferSubData(h,f.offset*d.BYTES_PER_ELEMENT,d.subarray(f.offset,f.offset+f.count)),f.count=-1)}function s(c){return c.isInterleavedBufferAttribute&&(c=c.data),n.get(c)}function o(c){c.isInterleavedBufferAttribute&&(c=c.data);const u=n.get(c);u&&(a.deleteBuffer(u.buffer),n.delete(c))}function l(c,u){if(c.isGLBufferAttribute){const d=n.get(c);(!d||d.version<c.version)&&n.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const h=n.get(c);h===void 0?n.set(c,i(c,u)):h.version<c.version&&(r(h.buffer,c,u),h.version=c.version)}return{get:s,remove:o,update:l}}class Hi extends nt{constructor(e=1,t=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:i};const r=e/2,s=t/2,o=Math.floor(n),l=Math.floor(i),c=o+1,u=l+1,h=e/o,d=t/l,f=[],p=[],m=[],g=[];for(let v=0;v<u;v++){const y=v*d-s;for(let w=0;w<c;w++){const x=w*h-r;p.push(x,-y,0),m.push(0,0,1),g.push(w/o),g.push(1-v/l)}}for(let v=0;v<l;v++)for(let y=0;y<o;y++){const w=y+c*v,x=y+c*(v+1),S=y+1+c*(v+1),b=y+1+c*v;f.push(w,x,b),f.push(x,S,b)}this.setIndex(f),this.setAttribute("position",new je(p,3)),this.setAttribute("normal",new je(m,3)),this.setAttribute("uv",new je(g,2))}static fromJSON(e){return new Hi(e.width,e.height,e.widthSegments,e.heightSegments)}}var JE=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,ZE=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,KE=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,YE=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,qE=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,_E=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,$E="vec3 transformed = vec3( position );",eT=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,tT=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,nT=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,iT=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,rT=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,sT=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,aT=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,oT=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,lT=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,cT=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,uT=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,hT=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,dT=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,fT=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,pT=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,mT=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,gT=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,vT=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,yT="gl_FragColor = linearToOutputTexel( gl_FragColor );",xT=`vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,wT=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,AT=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,ST=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,MT=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,bT=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,ET=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,TT=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,CT=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,IT=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,RT=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,PT=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,DT=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,OT=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,BT=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,LT=`#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,zT=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,NT=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,kT=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,UT=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,FT=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,HT=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,GT=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,VT=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,jT=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,QT=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,WT=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,XT=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,JT=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,ZT=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,KT=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,YT=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,qT=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,_T=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,$T=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,e1=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,t1=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,n1=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,i1=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,r1=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,s1=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,a1=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,o1=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,l1=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,c1=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,u1=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,h1=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,d1=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,f1=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,p1=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,m1=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,g1=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,v1=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,y1=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,x1=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,w1=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,A1=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,S1=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,M1=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,b1=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,E1=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,T1=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,C1=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,I1=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,R1=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,P1=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,D1=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,O1=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,B1=`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,L1=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,z1=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,N1=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,k1=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,U1=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,F1=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,H1=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,G1=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const V1=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,j1=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Q1=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,W1=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,X1=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,J1=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,Z1=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,K1=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,Y1=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,q1=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,_1=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,$1=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,eC=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,tC=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,nC=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,iC=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,rC=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,sC=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,aC=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,oC=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,lC=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,cC=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,uC=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,hC=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,dC=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fC=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,pC=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,mC=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,gC=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,vC=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,yC=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,xC=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,bt={alphamap_fragment:JE,alphamap_pars_fragment:ZE,alphatest_fragment:KE,alphatest_pars_fragment:YE,aomap_fragment:qE,aomap_pars_fragment:_E,begin_vertex:$E,beginnormal_vertex:eT,bsdfs:tT,bumpmap_pars_fragment:nT,clipping_planes_fragment:iT,clipping_planes_pars_fragment:rT,clipping_planes_pars_vertex:sT,clipping_planes_vertex:aT,color_fragment:oT,color_pars_fragment:lT,color_pars_vertex:cT,color_vertex:uT,common:hT,cube_uv_reflection_fragment:dT,defaultnormal_vertex:fT,displacementmap_pars_vertex:pT,displacementmap_vertex:mT,emissivemap_fragment:gT,emissivemap_pars_fragment:vT,encodings_fragment:yT,encodings_pars_fragment:xT,envmap_fragment:wT,envmap_common_pars_fragment:AT,envmap_pars_fragment:ST,envmap_pars_vertex:MT,envmap_physical_pars_fragment:LT,envmap_vertex:bT,fog_vertex:ET,fog_pars_vertex:TT,fog_fragment:CT,fog_pars_fragment:IT,gradientmap_pars_fragment:RT,lightmap_fragment:PT,lightmap_pars_fragment:DT,lights_lambert_vertex:OT,lights_pars_begin:BT,lights_toon_fragment:zT,lights_toon_pars_fragment:NT,lights_phong_fragment:kT,lights_phong_pars_fragment:UT,lights_physical_fragment:FT,lights_physical_pars_fragment:HT,lights_fragment_begin:GT,lights_fragment_maps:VT,lights_fragment_end:jT,logdepthbuf_fragment:QT,logdepthbuf_pars_fragment:WT,logdepthbuf_pars_vertex:XT,logdepthbuf_vertex:JT,map_fragment:ZT,map_pars_fragment:KT,map_particle_fragment:YT,map_particle_pars_fragment:qT,metalnessmap_fragment:_T,metalnessmap_pars_fragment:$T,morphcolor_vertex:e1,morphnormal_vertex:t1,morphtarget_pars_vertex:n1,morphtarget_vertex:i1,normal_fragment_begin:r1,normal_fragment_maps:s1,normal_pars_fragment:a1,normal_pars_vertex:o1,normal_vertex:l1,normalmap_pars_fragment:c1,clearcoat_normal_fragment_begin:u1,clearcoat_normal_fragment_maps:h1,clearcoat_pars_fragment:d1,output_fragment:f1,packing:p1,premultiplied_alpha_fragment:m1,project_vertex:g1,dithering_fragment:v1,dithering_pars_fragment:y1,roughnessmap_fragment:x1,roughnessmap_pars_fragment:w1,shadowmap_pars_fragment:A1,shadowmap_pars_vertex:S1,shadowmap_vertex:M1,shadowmask_pars_fragment:b1,skinbase_vertex:E1,skinning_pars_vertex:T1,skinning_vertex:C1,skinnormal_vertex:I1,specularmap_fragment:R1,specularmap_pars_fragment:P1,tonemapping_fragment:D1,tonemapping_pars_fragment:O1,transmission_fragment:B1,transmission_pars_fragment:L1,uv_pars_fragment:z1,uv_pars_vertex:N1,uv_vertex:k1,uv2_pars_fragment:U1,uv2_pars_vertex:F1,uv2_vertex:H1,worldpos_vertex:G1,background_vert:V1,background_frag:j1,cube_vert:Q1,cube_frag:W1,depth_vert:X1,depth_frag:J1,distanceRGBA_vert:Z1,distanceRGBA_frag:K1,equirect_vert:Y1,equirect_frag:q1,linedashed_vert:_1,linedashed_frag:$1,meshbasic_vert:eC,meshbasic_frag:tC,meshlambert_vert:nC,meshlambert_frag:iC,meshmatcap_vert:rC,meshmatcap_frag:sC,meshnormal_vert:aC,meshnormal_frag:oC,meshphong_vert:lC,meshphong_frag:cC,meshphysical_vert:uC,meshphysical_frag:hC,meshtoon_vert:dC,meshtoon_frag:fC,points_vert:pC,points_frag:mC,shadow_vert:gC,shadow_frag:vC,sprite_vert:yC,sprite_frag:xC},Ke={common:{diffuse:{value:new Ie(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Kt},uv2Transform:{value:new Kt},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new te(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Ie(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Ie(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Kt}},sprite:{diffuse:{value:new Ie(16777215)},opacity:{value:1},center:{value:new te(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Kt}}},Rn={basic:{uniforms:li([Ke.common,Ke.specularmap,Ke.envmap,Ke.aomap,Ke.lightmap,Ke.fog]),vertexShader:bt.meshbasic_vert,fragmentShader:bt.meshbasic_frag},lambert:{uniforms:li([Ke.common,Ke.specularmap,Ke.envmap,Ke.aomap,Ke.lightmap,Ke.emissivemap,Ke.fog,Ke.lights,{emissive:{value:new Ie(0)}}]),vertexShader:bt.meshlambert_vert,fragmentShader:bt.meshlambert_frag},phong:{uniforms:li([Ke.common,Ke.specularmap,Ke.envmap,Ke.aomap,Ke.lightmap,Ke.emissivemap,Ke.bumpmap,Ke.normalmap,Ke.displacementmap,Ke.fog,Ke.lights,{emissive:{value:new Ie(0)},specular:{value:new Ie(1118481)},shininess:{value:30}}]),vertexShader:bt.meshphong_vert,fragmentShader:bt.meshphong_frag},standard:{uniforms:li([Ke.common,Ke.envmap,Ke.aomap,Ke.lightmap,Ke.emissivemap,Ke.bumpmap,Ke.normalmap,Ke.displacementmap,Ke.roughnessmap,Ke.metalnessmap,Ke.fog,Ke.lights,{emissive:{value:new Ie(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:bt.meshphysical_vert,fragmentShader:bt.meshphysical_frag},toon:{uniforms:li([Ke.common,Ke.aomap,Ke.lightmap,Ke.emissivemap,Ke.bumpmap,Ke.normalmap,Ke.displacementmap,Ke.gradientmap,Ke.fog,Ke.lights,{emissive:{value:new Ie(0)}}]),vertexShader:bt.meshtoon_vert,fragmentShader:bt.meshtoon_frag},matcap:{uniforms:li([Ke.common,Ke.bumpmap,Ke.normalmap,Ke.displacementmap,Ke.fog,{matcap:{value:null}}]),vertexShader:bt.meshmatcap_vert,fragmentShader:bt.meshmatcap_frag},points:{uniforms:li([Ke.points,Ke.fog]),vertexShader:bt.points_vert,fragmentShader:bt.points_frag},dashed:{uniforms:li([Ke.common,Ke.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:bt.linedashed_vert,fragmentShader:bt.linedashed_frag},depth:{uniforms:li([Ke.common,Ke.displacementmap]),vertexShader:bt.depth_vert,fragmentShader:bt.depth_frag},normal:{uniforms:li([Ke.common,Ke.bumpmap,Ke.normalmap,Ke.displacementmap,{opacity:{value:1}}]),vertexShader:bt.meshnormal_vert,fragmentShader:bt.meshnormal_frag},sprite:{uniforms:li([Ke.sprite,Ke.fog]),vertexShader:bt.sprite_vert,fragmentShader:bt.sprite_frag},background:{uniforms:{uvTransform:{value:new Kt},t2D:{value:null}},vertexShader:bt.background_vert,fragmentShader:bt.background_frag},cube:{uniforms:li([Ke.envmap,{opacity:{value:1}}]),vertexShader:bt.cube_vert,fragmentShader:bt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:bt.equirect_vert,fragmentShader:bt.equirect_frag},distanceRGBA:{uniforms:li([Ke.common,Ke.displacementmap,{referencePosition:{value:new A},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:bt.distanceRGBA_vert,fragmentShader:bt.distanceRGBA_frag},shadow:{uniforms:li([Ke.lights,Ke.fog,{color:{value:new Ie(0)},opacity:{value:1}}]),vertexShader:bt.shadow_vert,fragmentShader:bt.shadow_frag}};Rn.physical={uniforms:li([Rn.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new te(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new Ie(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new te},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Ie(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new Ie(1,1,1)},specularColorMap:{value:null}}]),vertexShader:bt.meshphysical_vert,fragmentShader:bt.meshphysical_frag};function wC(a,e,t,n,i,r){const s=new Ie(0);let o=i===!0?0:1,l,c,u=null,h=0,d=null;function f(m,g){let v=!1,y=g.isScene===!0?g.background:null;y&&y.isTexture&&(y=e.get(y));const w=a.xr,x=w.getSession&&w.getSession();x&&x.environmentBlendMode==="additive"&&(y=null),y===null?p(s,o):y&&y.isColor&&(p(y,1),v=!0),(a.autoClear||v)&&a.clear(a.autoClearColor,a.autoClearDepth,a.autoClearStencil),y&&(y.isCubeTexture||y.mapping===Sl)?(c===void 0&&(c=new Ve(new Tn(1,1,1),new gn({name:"BackgroundCubeMaterial",uniforms:ol(Rn.cube.uniforms),vertexShader:Rn.cube.vertexShader,fragmentShader:Rn.cube.fragmentShader,side:pi,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(S,b,E){this.matrixWorld.copyPosition(E.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(c)),c.material.uniforms.envMap.value=y,c.material.uniforms.flipEnvMap.value=y.isCubeTexture&&y.isRenderTargetTexture===!1?-1:1,(u!==y||h!==y.version||d!==a.toneMapping)&&(c.material.needsUpdate=!0,u=y,h=y.version,d=a.toneMapping),c.layers.enableAll(),m.unshift(c,c.geometry,c.material,0,0,null)):y&&y.isTexture&&(l===void 0&&(l=new Ve(new Hi(2,2),new gn({name:"BackgroundMaterial",uniforms:ol(Rn.background.uniforms),vertexShader:Rn.background.vertexShader,fragmentShader:Rn.background.fragmentShader,side:An,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(l)),l.material.uniforms.t2D.value=y,y.matrixAutoUpdate===!0&&y.updateMatrix(),l.material.uniforms.uvTransform.value.copy(y.matrix),(u!==y||h!==y.version||d!==a.toneMapping)&&(l.material.needsUpdate=!0,u=y,h=y.version,d=a.toneMapping),l.layers.enableAll(),m.unshift(l,l.geometry,l.material,0,0,null))}function p(m,g){t.buffers.color.setClear(m.r,m.g,m.b,g,r)}return{getClearColor:function(){return s},setClearColor:function(m,g=1){s.set(m),o=g,p(s,o)},getClearAlpha:function(){return o},setClearAlpha:function(m){o=m,p(s,o)},render:f}}function AC(a,e,t,n){const i=a.getParameter(34921),r=n.isWebGL2?null:e.get("OES_vertex_array_object"),s=n.isWebGL2||r!==null,o={},l=g(null);let c=l,u=!1;function h(P,F,N,Y,_){let G=!1;if(s){const j=m(Y,N,F);c!==j&&(c=j,f(c.object)),G=v(P,Y,N,_),G&&y(P,Y,N,_)}else{const j=F.wireframe===!0;(c.geometry!==Y.id||c.program!==N.id||c.wireframe!==j)&&(c.geometry=Y.id,c.program=N.id,c.wireframe=j,G=!0)}_!==null&&t.update(_,34963),(G||u)&&(u=!1,M(P,F,N,Y),_!==null&&a.bindBuffer(34963,t.get(_).buffer))}function d(){return n.isWebGL2?a.createVertexArray():r.createVertexArrayOES()}function f(P){return n.isWebGL2?a.bindVertexArray(P):r.bindVertexArrayOES(P)}function p(P){return n.isWebGL2?a.deleteVertexArray(P):r.deleteVertexArrayOES(P)}function m(P,F,N){const Y=N.wireframe===!0;let _=o[P.id];_===void 0&&(_={},o[P.id]=_);let G=_[F.id];G===void 0&&(G={},_[F.id]=G);let j=G[Y];return j===void 0&&(j=g(d()),G[Y]=j),j}function g(P){const F=[],N=[],Y=[];for(let _=0;_<i;_++)F[_]=0,N[_]=0,Y[_]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:F,enabledAttributes:N,attributeDivisors:Y,object:P,attributes:{},index:null}}function v(P,F,N,Y){const _=c.attributes,G=F.attributes;let j=0;const L=N.getAttributes();for(const H in L)if(L[H].location>=0){const $=_[H];let ee=G[H];if(ee===void 0&&(H==="instanceMatrix"&&P.instanceMatrix&&(ee=P.instanceMatrix),H==="instanceColor"&&P.instanceColor&&(ee=P.instanceColor)),$===void 0||$.attribute!==ee||ee&&$.data!==ee.data)return!0;j++}return c.attributesNum!==j||c.index!==Y}function y(P,F,N,Y){const _={},G=F.attributes;let j=0;const L=N.getAttributes();for(const H in L)if(L[H].location>=0){let $=G[H];$===void 0&&(H==="instanceMatrix"&&P.instanceMatrix&&($=P.instanceMatrix),H==="instanceColor"&&P.instanceColor&&($=P.instanceColor));const ee={};ee.attribute=$,$&&$.data&&(ee.data=$.data),_[H]=ee,j++}c.attributes=_,c.attributesNum=j,c.index=Y}function w(){const P=c.newAttributes;for(let F=0,N=P.length;F<N;F++)P[F]=0}function x(P){S(P,0)}function S(P,F){const N=c.newAttributes,Y=c.enabledAttributes,_=c.attributeDivisors;N[P]=1,Y[P]===0&&(a.enableVertexAttribArray(P),Y[P]=1),_[P]!==F&&((n.isWebGL2?a:e.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](P,F),_[P]=F)}function b(){const P=c.newAttributes,F=c.enabledAttributes;for(let N=0,Y=F.length;N<Y;N++)F[N]!==P[N]&&(a.disableVertexAttribArray(N),F[N]=0)}function E(P,F,N,Y,_,G){n.isWebGL2===!0&&(N===5124||N===5125)?a.vertexAttribIPointer(P,F,N,_,G):a.vertexAttribPointer(P,F,N,Y,_,G)}function M(P,F,N,Y){if(n.isWebGL2===!1&&(P.isInstancedMesh||Y.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;w();const _=Y.attributes,G=N.getAttributes(),j=F.defaultAttributeValues;for(const L in G){const H=G[L];if(H.location>=0){let q=_[L];if(q===void 0&&(L==="instanceMatrix"&&P.instanceMatrix&&(q=P.instanceMatrix),L==="instanceColor"&&P.instanceColor&&(q=P.instanceColor)),q!==void 0){const $=q.normalized,ee=q.itemSize,W=t.get(q);if(W===void 0)continue;const le=W.buffer,K=W.type,pe=W.bytesPerElement;if(q.isInterleavedBufferAttribute){const se=q.data,ve=se.stride,Z=q.offset;if(se.isInstancedInterleavedBuffer){for(let oe=0;oe<H.locationSize;oe++)S(H.location+oe,se.meshPerAttribute);P.isInstancedMesh!==!0&&Y._maxInstanceCount===void 0&&(Y._maxInstanceCount=se.meshPerAttribute*se.count)}else for(let oe=0;oe<H.locationSize;oe++)x(H.location+oe);a.bindBuffer(34962,le);for(let oe=0;oe<H.locationSize;oe++)E(H.location+oe,ee/H.locationSize,K,$,ve*pe,(Z+ee/H.locationSize*oe)*pe)}else{if(q.isInstancedBufferAttribute){for(let se=0;se<H.locationSize;se++)S(H.location+se,q.meshPerAttribute);P.isInstancedMesh!==!0&&Y._maxInstanceCount===void 0&&(Y._maxInstanceCount=q.meshPerAttribute*q.count)}else for(let se=0;se<H.locationSize;se++)x(H.location+se);a.bindBuffer(34962,le);for(let se=0;se<H.locationSize;se++)E(H.location+se,ee/H.locationSize,K,$,ee*pe,ee/H.locationSize*se*pe)}}else if(j!==void 0){const $=j[L];if($!==void 0)switch($.length){case 2:a.vertexAttrib2fv(H.location,$);break;case 3:a.vertexAttrib3fv(H.location,$);break;case 4:a.vertexAttrib4fv(H.location,$);break;default:a.vertexAttrib1fv(H.location,$)}}}}b()}function T(){R();for(const P in o){const F=o[P];for(const N in F){const Y=F[N];for(const _ in Y)p(Y[_].object),delete Y[_];delete F[N]}delete o[P]}}function I(P){if(o[P.id]===void 0)return;const F=o[P.id];for(const N in F){const Y=F[N];for(const _ in Y)p(Y[_].object),delete Y[_];delete F[N]}delete o[P.id]}function O(P){for(const F in o){const N=o[F];if(N[P.id]===void 0)continue;const Y=N[P.id];for(const _ in Y)p(Y[_].object),delete Y[_];delete N[P.id]}}function R(){k(),u=!0,c!==l&&(c=l,f(c.object))}function k(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:h,reset:R,resetDefaultState:k,dispose:T,releaseStatesOfGeometry:I,releaseStatesOfProgram:O,initAttributes:w,enableAttribute:x,disableUnusedAttributes:b}}function SC(a,e,t,n){const i=n.isWebGL2;let r;function s(c){r=c}function o(c,u){a.drawArrays(r,c,u),t.update(u,r,1)}function l(c,u,h){if(h===0)return;let d,f;if(i)d=a,f="drawArraysInstanced";else if(d=e.get("ANGLE_instanced_arrays"),f="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[f](r,c,u,h),t.update(u,r,h)}this.setMode=s,this.render=o,this.renderInstances=l}function MC(a,e,t){let n;function i(){if(n!==void 0)return n;if(e.has("EXT_texture_filter_anisotropic")===!0){const E=e.get("EXT_texture_filter_anisotropic");n=a.getParameter(E.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function r(E){if(E==="highp"){if(a.getShaderPrecisionFormat(35633,36338).precision>0&&a.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";E="mediump"}return E==="mediump"&&a.getShaderPrecisionFormat(35633,36337).precision>0&&a.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const s=typeof WebGL2RenderingContext<"u"&&a instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&a instanceof WebGL2ComputeRenderingContext;let o=t.precision!==void 0?t.precision:"highp";const l=r(o);l!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",l,"instead."),o=l);const c=s||e.has("WEBGL_draw_buffers"),u=t.logarithmicDepthBuffer===!0,h=a.getParameter(34930),d=a.getParameter(35660),f=a.getParameter(3379),p=a.getParameter(34076),m=a.getParameter(34921),g=a.getParameter(36347),v=a.getParameter(36348),y=a.getParameter(36349),w=d>0,x=s||e.has("OES_texture_float"),S=w&&x,b=s?a.getParameter(36183):0;return{isWebGL2:s,drawBuffers:c,getMaxAnisotropy:i,getMaxPrecision:r,precision:o,logarithmicDepthBuffer:u,maxTextures:h,maxVertexTextures:d,maxTextureSize:f,maxCubemapSize:p,maxAttributes:m,maxVertexUniforms:g,maxVaryings:v,maxFragmentUniforms:y,vertexTextures:w,floatFragmentTextures:x,floatVertexTextures:S,maxSamples:b}}function bC(a){const e=this;let t=null,n=0,i=!1,r=!1;const s=new kt,o=new Kt,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(h,d,f){const p=h.length!==0||d||n!==0||i;return i=d,t=u(h,f,0),n=h.length,p},this.beginShadows=function(){r=!0,u(null)},this.endShadows=function(){r=!1,c()},this.setState=function(h,d,f){const p=h.clippingPlanes,m=h.clipIntersection,g=h.clipShadows,v=a.get(h);if(!i||p===null||p.length===0||r&&!g)r?u(null):c();else{const y=r?0:n,w=y*4;let x=v.clippingState||null;l.value=x,x=u(p,d,w,f);for(let S=0;S!==w;++S)x[S]=t[S];v.clippingState=x,this.numIntersection=m?this.numPlanes:0,this.numPlanes+=y}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=n>0),e.numPlanes=n,e.numIntersection=0}function u(h,d,f,p){const m=h!==null?h.length:0;let g=null;if(m!==0){if(g=l.value,p!==!0||g===null){const v=f+m*4,y=d.matrixWorldInverse;o.getNormalMatrix(y),(g===null||g.length<v)&&(g=new Float32Array(v));for(let w=0,x=f;w!==m;++w,x+=4)s.copy(h[w]).applyMatrix4(y,o),s.normal.toArray(g,x),g[x+3]=s.constant}l.value=g,l.needsUpdate=!0}return e.numPlanes=m,e.numIntersection=0,g}}function EC(a){let e=new WeakMap;function t(s,o){return o===Oc?s.mapping=ra:o===Bc&&(s.mapping=sa),s}function n(s){if(s&&s.isTexture&&s.isRenderTargetTexture===!1){const o=s.mapping;if(o===Oc||o===Bc)if(e.has(s)){const l=e.get(s).texture;return t(l,s.mapping)}else{const l=s.image;if(l&&l.height>0){const c=new Nu(l.height/2);return c.fromEquirectangularTexture(a,s),e.set(s,c),s.addEventListener("dispose",i),t(c.texture,s.mapping)}else return null}}return s}function i(s){const o=s.target;o.removeEventListener("dispose",i);const l=e.get(o);l!==void 0&&(e.delete(o),l.dispose())}function r(){e=new WeakMap}return{get:n,dispose:r}}class ki extends zu{constructor(e=-1,t=1,n=1,i=-1,r=.1,s=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=i,this.near=r,this.far=s,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,n,i,r,s){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-e,s=n+e,o=i+t,l=i-t;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=c*this.view.offsetX,s=r+c*this.view.width,o-=u*this.view.offsetY,l=o-u*this.view.height}this.projectionMatrix.makeOrthographic(r,s,o,l,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}ki.prototype.isOrthographicCamera=!0;const qo=4,V0=[.125,.215,.35,.446,.526,.582],za=20,Rp=new ki,j0=new Ie;let Pp=null;const Ba=(1+Math.sqrt(5))/2,zo=1/Ba,Q0=[new A(1,1,1),new A(-1,1,1),new A(1,1,-1),new A(-1,1,-1),new A(0,Ba,zo),new A(0,Ba,-zo),new A(zo,0,Ba),new A(-zo,0,Ba),new A(Ba,zo,0),new A(-Ba,zo,0)];class Kd{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,i=100){Pp=this._renderer.getRenderTarget(),this._setSize(256);const r=this._allocateTargets();return r.depthBuffer=!0,this._sceneToCubeUV(e,n,i,r),t>0&&this._blur(r,0,0,t),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=J0(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=X0(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(Pp),e.scissorTest=!1,Eh(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===ra||e.mapping===sa?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),Pp=this._renderer.getRenderTarget();const n=t||this._allocateTargets();return this._textureToCubeUV(e,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,n={magFilter:St,minFilter:St,generateMipmaps:!1,type:di,format:Hn,encoding:Fi,depthBuffer:!1},i=W0(e,t,n);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=W0(e,t,n);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=TC(r)),this._blurMaterial=CC(r,e,t)}return i}_compileMaterial(e){const t=new Ve(this._lodPlanes[0],e);this._renderer.compile(t,Rp)}_sceneToCubeUV(e,t,n,i){const o=new tn(90,1,t,n),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],u=this._renderer,h=u.autoClear,d=u.toneMapping;u.getClearColor(j0),u.toneMapping=Nr,u.autoClear=!1;const f=new ti({name:"PMREM.Background",side:pi,depthWrite:!1,depthTest:!1}),p=new Ve(new Tn,f);let m=!1;const g=e.background;g?g.isColor&&(f.color.copy(g),e.background=null,m=!0):(f.color.copy(j0),m=!0);for(let v=0;v<6;v++){const y=v%3;y===0?(o.up.set(0,l[v],0),o.lookAt(c[v],0,0)):y===1?(o.up.set(0,0,l[v]),o.lookAt(0,c[v],0)):(o.up.set(0,l[v],0),o.lookAt(0,0,c[v]));const w=this._cubeSize;Eh(i,y*w,v>2?w:0,w,w),u.setRenderTarget(i),m&&u.render(p,o),u.render(e,o)}p.geometry.dispose(),p.material.dispose(),u.toneMapping=d,u.autoClear=h,e.background=g}_textureToCubeUV(e,t){const n=this._renderer,i=e.mapping===ra||e.mapping===sa;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=J0()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=X0());const r=i?this._cubemapMaterial:this._equirectMaterial,s=new Ve(this._lodPlanes[0],r),o=r.uniforms;o.envMap.value=e;const l=this._cubeSize;Eh(t,0,0,3*l,2*l),n.setRenderTarget(t),n.render(s,Rp)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let i=1;i<this._lodPlanes.length;i++){const r=Math.sqrt(this._sigmas[i]*this._sigmas[i]-this._sigmas[i-1]*this._sigmas[i-1]),s=Q0[(i-1)%Q0.length];this._blur(e,i-1,i,r,s)}t.autoClear=n}_blur(e,t,n,i,r){const s=this._pingPongRenderTarget;this._halfBlur(e,s,t,n,i,"latitudinal",r),this._halfBlur(s,e,n,n,i,"longitudinal",r)}_halfBlur(e,t,n,i,r,s,o){const l=this._renderer,c=this._blurMaterial;s!=="latitudinal"&&s!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,h=new Ve(this._lodPlanes[i],c),d=c.uniforms,f=this._sizeLods[n]-1,p=isFinite(r)?Math.PI/(2*f):2*Math.PI/(2*za-1),m=r/p,g=isFinite(r)?1+Math.floor(u*m):za;g>za&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${za}`);const v=[];let y=0;for(let E=0;E<za;++E){const M=E/m,T=Math.exp(-M*M/2);v.push(T),E===0?y+=T:E<g&&(y+=2*T)}for(let E=0;E<v.length;E++)v[E]=v[E]/y;d.envMap.value=e.texture,d.samples.value=g,d.weights.value=v,d.latitudinal.value=s==="latitudinal",o&&(d.poleAxis.value=o);const{_lodMax:w}=this;d.dTheta.value=p,d.mipInt.value=w-n;const x=this._sizeLods[i],S=3*x*(i>w-qo?i-w+qo:0),b=4*(this._cubeSize-x);Eh(t,S,b,3*x,2*x),l.setRenderTarget(t),l.render(h,Rp)}}function TC(a){const e=[],t=[],n=[];let i=a;const r=a-qo+1+V0.length;for(let s=0;s<r;s++){const o=Math.pow(2,i);t.push(o);let l=1/o;s>a-qo?l=V0[s-a+qo-1]:s===0&&(l=0),n.push(l);const c=1/(o-2),u=-c,h=1+c,d=[u,u,h,u,h,h,u,u,h,h,u,h],f=6,p=6,m=3,g=2,v=1,y=new Float32Array(m*p*f),w=new Float32Array(g*p*f),x=new Float32Array(v*p*f);for(let b=0;b<f;b++){const E=b%3*2/3-1,M=b>2?0:-1,T=[E,M,0,E+2/3,M,0,E+2/3,M+1,0,E,M,0,E+2/3,M+1,0,E,M+1,0];y.set(T,m*p*b),w.set(d,g*p*b);const I=[b,b,b,b,b,b];x.set(I,v*p*b)}const S=new nt;S.setAttribute("position",new wt(y,m)),S.setAttribute("uv",new wt(w,g)),S.setAttribute("faceIndex",new wt(x,v)),e.push(S),i>qo&&i--}return{lodPlanes:e,sizeLods:t,sigmas:n}}function W0(a,e,t){const n=new pn(a,e,t);return n.texture.mapping=Sl,n.texture.name="PMREM.cubeUv",n.scissorTest=!0,n}function Eh(a,e,t,n,i){a.viewport.set(e,t,n,i),a.scissor.set(e,t,n,i)}function CC(a,e,t){const n=new Float32Array(za),i=new A(0,1,0);return new gn({name:"SphericalGaussianBlur",defines:{n:za,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${a}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:sv(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Mn,depthTest:!1,depthWrite:!1})}function X0(){return new gn({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:sv(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:Mn,depthTest:!1,depthWrite:!1})}function J0(){return new gn({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:sv(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:Mn,depthTest:!1,depthWrite:!1})}function sv(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function IC(a){let e=new WeakMap,t=null;function n(o){if(o&&o.isTexture){const l=o.mapping,c=l===Oc||l===Bc,u=l===ra||l===sa;if(c||u)if(o.isRenderTargetTexture&&o.needsPMREMUpdate===!0){o.needsPMREMUpdate=!1;let h=e.get(o);return t===null&&(t=new Kd(a)),h=c?t.fromEquirectangular(o,h):t.fromCubemap(o,h),e.set(o,h),h.texture}else{if(e.has(o))return e.get(o).texture;{const h=o.image;if(c&&h&&h.height>0||u&&h&&i(h)){t===null&&(t=new Kd(a));const d=c?t.fromEquirectangular(o):t.fromCubemap(o);return e.set(o,d),o.addEventListener("dispose",r),d.texture}else return null}}}return o}function i(o){let l=0;const c=6;for(let u=0;u<c;u++)o[u]!==void 0&&l++;return l===c}function r(o){const l=o.target;l.removeEventListener("dispose",r);const c=e.get(l);c!==void 0&&(e.delete(l),c.dispose())}function s(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:n,dispose:s}}function RC(a){const e={};function t(n){if(e[n]!==void 0)return e[n];let i;switch(n){case"WEBGL_depth_texture":i=a.getExtension("WEBGL_depth_texture")||a.getExtension("MOZ_WEBGL_depth_texture")||a.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=a.getExtension("EXT_texture_filter_anisotropic")||a.getExtension("MOZ_EXT_texture_filter_anisotropic")||a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=a.getExtension("WEBGL_compressed_texture_s3tc")||a.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=a.getExtension("WEBGL_compressed_texture_pvrtc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=a.getExtension(n)}return e[n]=i,i}return{has:function(n){return t(n)!==null},init:function(n){n.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(n){const i=t(n);return i===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function PC(a,e,t,n){const i={},r=new WeakMap;function s(h){const d=h.target;d.index!==null&&e.remove(d.index);for(const p in d.attributes)e.remove(d.attributes[p]);d.removeEventListener("dispose",s),delete i[d.id];const f=r.get(d);f&&(e.remove(f),r.delete(d)),n.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,t.memory.geometries--}function o(h,d){return i[d.id]===!0||(d.addEventListener("dispose",s),i[d.id]=!0,t.memory.geometries++),d}function l(h){const d=h.attributes;for(const p in d)e.update(d[p],34962);const f=h.morphAttributes;for(const p in f){const m=f[p];for(let g=0,v=m.length;g<v;g++)e.update(m[g],34962)}}function c(h){const d=[],f=h.index,p=h.attributes.position;let m=0;if(f!==null){const y=f.array;m=f.version;for(let w=0,x=y.length;w<x;w+=3){const S=y[w+0],b=y[w+1],E=y[w+2];d.push(S,b,b,E,E,S)}}else{const y=p.array;m=p.version;for(let w=0,x=y.length/3-1;w<x;w+=3){const S=w+0,b=w+1,E=w+2;d.push(S,b,b,E,E,S)}}const g=new(WA(d)?ys:_i)(d,1);g.version=m;const v=r.get(h);v&&e.remove(v),r.set(h,g)}function u(h){const d=r.get(h);if(d){const f=h.index;f!==null&&d.version<f.version&&c(h)}else c(h);return r.get(h)}return{get:o,update:l,getWireframeAttribute:u}}function DC(a,e,t,n){const i=n.isWebGL2;let r;function s(d){r=d}let o,l;function c(d){o=d.type,l=d.bytesPerElement}function u(d,f){a.drawElements(r,f,o,d*l),t.update(f,r,1)}function h(d,f,p){if(p===0)return;let m,g;if(i)m=a,g="drawElementsInstanced";else if(m=e.get("ANGLE_instanced_arrays"),g="drawElementsInstancedANGLE",m===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}m[g](r,f,o,d*l,p),t.update(f,r,p)}this.setMode=s,this.setIndex=c,this.render=u,this.renderInstances=h}function OC(a){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function n(r,s,o){switch(t.calls++,s){case 4:t.triangles+=o*(r/3);break;case 1:t.lines+=o*(r/2);break;case 3:t.lines+=o*(r-1);break;case 2:t.lines+=o*r;break;case 0:t.points+=o*r;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",s);break}}function i(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:i,update:n}}function BC(a,e){return a[0]-e[0]}function LC(a,e){return Math.abs(e[1])-Math.abs(a[1])}function Dp(a,e){let t=1;const n=e.isInterleavedBufferAttribute?e.data.array:e.array;n instanceof Int8Array?t=127:n instanceof Int16Array?t=32767:n instanceof Int32Array?t=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",n),a.divideScalar(t)}function zC(a,e,t){const n={},i=new Float32Array(8),r=new WeakMap,s=new lt,o=[];for(let c=0;c<8;c++)o[c]=[c,0];function l(c,u,h,d){const f=c.morphTargetInfluences;if(e.isWebGL2===!0){const p=u.morphAttributes.position||u.morphAttributes.normal||u.morphAttributes.color,m=p!==void 0?p.length:0;let g=r.get(u);if(g===void 0||g.count!==m){let F=function(){k.dispose(),r.delete(u),u.removeEventListener("dispose",F)};g!==void 0&&g.texture.dispose();const w=u.morphAttributes.position!==void 0,x=u.morphAttributes.normal!==void 0,S=u.morphAttributes.color!==void 0,b=u.morphAttributes.position||[],E=u.morphAttributes.normal||[],M=u.morphAttributes.color||[];let T=0;w===!0&&(T=1),x===!0&&(T=2),S===!0&&(T=3);let I=u.attributes.position.count*T,O=1;I>e.maxTextureSize&&(O=Math.ceil(I/e.maxTextureSize),I=e.maxTextureSize);const R=new Float32Array(I*O*4*m),k=new Ml(R,I,O,m);k.type=Dn,k.needsUpdate=!0;const P=T*4;for(let N=0;N<m;N++){const Y=b[N],_=E[N],G=M[N],j=I*O*4*N;for(let L=0;L<Y.count;L++){const H=L*P;w===!0&&(s.fromBufferAttribute(Y,L),Y.normalized===!0&&Dp(s,Y),R[j+H+0]=s.x,R[j+H+1]=s.y,R[j+H+2]=s.z,R[j+H+3]=0),x===!0&&(s.fromBufferAttribute(_,L),_.normalized===!0&&Dp(s,_),R[j+H+4]=s.x,R[j+H+5]=s.y,R[j+H+6]=s.z,R[j+H+7]=0),S===!0&&(s.fromBufferAttribute(G,L),G.normalized===!0&&Dp(s,G),R[j+H+8]=s.x,R[j+H+9]=s.y,R[j+H+10]=s.z,R[j+H+11]=G.itemSize===4?s.w:1)}}g={count:m,texture:k,size:new te(I,O)},r.set(u,g),u.addEventListener("dispose",F)}let v=0;for(let w=0;w<f.length;w++)v+=f[w];const y=u.morphTargetsRelative?1:1-v;d.getUniforms().setValue(a,"morphTargetBaseInfluence",y),d.getUniforms().setValue(a,"morphTargetInfluences",f),d.getUniforms().setValue(a,"morphTargetsTexture",g.texture,t),d.getUniforms().setValue(a,"morphTargetsTextureSize",g.size)}else{const p=f===void 0?0:f.length;let m=n[u.id];if(m===void 0||m.length!==p){m=[];for(let x=0;x<p;x++)m[x]=[x,0];n[u.id]=m}for(let x=0;x<p;x++){const S=m[x];S[0]=x,S[1]=f[x]}m.sort(LC);for(let x=0;x<8;x++)x<p&&m[x][1]?(o[x][0]=m[x][0],o[x][1]=m[x][1]):(o[x][0]=Number.MAX_SAFE_INTEGER,o[x][1]=0);o.sort(BC);const g=u.morphAttributes.position,v=u.morphAttributes.normal;let y=0;for(let x=0;x<8;x++){const S=o[x],b=S[0],E=S[1];b!==Number.MAX_SAFE_INTEGER&&E?(g&&u.getAttribute("morphTarget"+x)!==g[b]&&u.setAttribute("morphTarget"+x,g[b]),v&&u.getAttribute("morphNormal"+x)!==v[b]&&u.setAttribute("morphNormal"+x,v[b]),i[x]=E,y+=E):(g&&u.hasAttribute("morphTarget"+x)===!0&&u.deleteAttribute("morphTarget"+x),v&&u.hasAttribute("morphNormal"+x)===!0&&u.deleteAttribute("morphNormal"+x),i[x]=0)}const w=u.morphTargetsRelative?1:1-y;d.getUniforms().setValue(a,"morphTargetBaseInfluence",w),d.getUniforms().setValue(a,"morphTargetInfluences",i)}}return{update:l}}function NC(a,e,t,n){let i=new WeakMap;function r(l){const c=n.render.frame,u=l.geometry,h=e.get(l,u);return i.get(h)!==c&&(e.update(h),i.set(h,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",o)===!1&&l.addEventListener("dispose",o),t.update(l.instanceMatrix,34962),l.instanceColor!==null&&t.update(l.instanceColor,34962)),h}function s(){i=new WeakMap}function o(l){const c=l.target;c.removeEventListener("dispose",o),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:r,dispose:s}}const nS=new bn,iS=new Ml,rS=new Lu,sS=new bl,Z0=[],K0=[],Y0=new Float32Array(16),q0=new Float32Array(9),_0=new Float32Array(4);function Tl(a,e,t){const n=a[0];if(n<=0||n>0)return a;const i=e*t;let r=Z0[i];if(r===void 0&&(r=new Float32Array(i),Z0[i]=r),e!==0){n.toArray(r,0);for(let s=1,o=0;s!==e;++s)o+=t,a[s].toArray(r,o)}return r}function Ei(a,e){if(a.length!==e.length)return!1;for(let t=0,n=a.length;t<n;t++)if(a[t]!==e[t])return!1;return!0}function Ti(a,e){for(let t=0,n=e.length;t<n;t++)a[t]=e[t]}function Sf(a,e){let t=K0[e];t===void 0&&(t=new Int32Array(e),K0[e]=t);for(let n=0;n!==e;++n)t[n]=a.allocateTextureUnit();return t}function kC(a,e){const t=this.cache;t[0]!==e&&(a.uniform1f(this.addr,e),t[0]=e)}function UC(a,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(a.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Ei(t,e))return;a.uniform2fv(this.addr,e),Ti(t,e)}}function FC(a,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(a.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(a.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Ei(t,e))return;a.uniform3fv(this.addr,e),Ti(t,e)}}function HC(a,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(a.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Ei(t,e))return;a.uniform4fv(this.addr,e),Ti(t,e)}}function GC(a,e){const t=this.cache,n=e.elements;if(n===void 0){if(Ei(t,e))return;a.uniformMatrix2fv(this.addr,!1,e),Ti(t,e)}else{if(Ei(t,n))return;_0.set(n),a.uniformMatrix2fv(this.addr,!1,_0),Ti(t,n)}}function VC(a,e){const t=this.cache,n=e.elements;if(n===void 0){if(Ei(t,e))return;a.uniformMatrix3fv(this.addr,!1,e),Ti(t,e)}else{if(Ei(t,n))return;q0.set(n),a.uniformMatrix3fv(this.addr,!1,q0),Ti(t,n)}}function jC(a,e){const t=this.cache,n=e.elements;if(n===void 0){if(Ei(t,e))return;a.uniformMatrix4fv(this.addr,!1,e),Ti(t,e)}else{if(Ei(t,n))return;Y0.set(n),a.uniformMatrix4fv(this.addr,!1,Y0),Ti(t,n)}}function QC(a,e){const t=this.cache;t[0]!==e&&(a.uniform1i(this.addr,e),t[0]=e)}function WC(a,e){const t=this.cache;Ei(t,e)||(a.uniform2iv(this.addr,e),Ti(t,e))}function XC(a,e){const t=this.cache;Ei(t,e)||(a.uniform3iv(this.addr,e),Ti(t,e))}function JC(a,e){const t=this.cache;Ei(t,e)||(a.uniform4iv(this.addr,e),Ti(t,e))}function ZC(a,e){const t=this.cache;t[0]!==e&&(a.uniform1ui(this.addr,e),t[0]=e)}function KC(a,e){const t=this.cache;Ei(t,e)||(a.uniform2uiv(this.addr,e),Ti(t,e))}function YC(a,e){const t=this.cache;Ei(t,e)||(a.uniform3uiv(this.addr,e),Ti(t,e))}function qC(a,e){const t=this.cache;Ei(t,e)||(a.uniform4uiv(this.addr,e),Ti(t,e))}function _C(a,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(a.uniform1i(this.addr,i),n[0]=i),t.setTexture2D(e||nS,i)}function $C(a,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(a.uniform1i(this.addr,i),n[0]=i),t.setTexture3D(e||rS,i)}function eI(a,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(a.uniform1i(this.addr,i),n[0]=i),t.setTextureCube(e||sS,i)}function tI(a,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(a.uniform1i(this.addr,i),n[0]=i),t.setTexture2DArray(e||iS,i)}function nI(a){switch(a){case 5126:return kC;case 35664:return UC;case 35665:return FC;case 35666:return HC;case 35674:return GC;case 35675:return VC;case 35676:return jC;case 5124:case 35670:return QC;case 35667:case 35671:return WC;case 35668:case 35672:return XC;case 35669:case 35673:return JC;case 5125:return ZC;case 36294:return KC;case 36295:return YC;case 36296:return qC;case 35678:case 36198:case 36298:case 36306:case 35682:return _C;case 35679:case 36299:case 36307:return $C;case 35680:case 36300:case 36308:case 36293:return eI;case 36289:case 36303:case 36311:case 36292:return tI}}function iI(a,e){a.uniform1fv(this.addr,e)}function rI(a,e){const t=Tl(e,this.size,2);a.uniform2fv(this.addr,t)}function sI(a,e){const t=Tl(e,this.size,3);a.uniform3fv(this.addr,t)}function aI(a,e){const t=Tl(e,this.size,4);a.uniform4fv(this.addr,t)}function oI(a,e){const t=Tl(e,this.size,4);a.uniformMatrix2fv(this.addr,!1,t)}function lI(a,e){const t=Tl(e,this.size,9);a.uniformMatrix3fv(this.addr,!1,t)}function cI(a,e){const t=Tl(e,this.size,16);a.uniformMatrix4fv(this.addr,!1,t)}function uI(a,e){a.uniform1iv(this.addr,e)}function hI(a,e){a.uniform2iv(this.addr,e)}function dI(a,e){a.uniform3iv(this.addr,e)}function fI(a,e){a.uniform4iv(this.addr,e)}function pI(a,e){a.uniform1uiv(this.addr,e)}function mI(a,e){a.uniform2uiv(this.addr,e)}function gI(a,e){a.uniform3uiv(this.addr,e)}function vI(a,e){a.uniform4uiv(this.addr,e)}function yI(a,e,t){const n=e.length,i=Sf(t,n);a.uniform1iv(this.addr,i);for(let r=0;r!==n;++r)t.setTexture2D(e[r]||nS,i[r])}function xI(a,e,t){const n=e.length,i=Sf(t,n);a.uniform1iv(this.addr,i);for(let r=0;r!==n;++r)t.setTexture3D(e[r]||rS,i[r])}function wI(a,e,t){const n=e.length,i=Sf(t,n);a.uniform1iv(this.addr,i);for(let r=0;r!==n;++r)t.setTextureCube(e[r]||sS,i[r])}function AI(a,e,t){const n=e.length,i=Sf(t,n);a.uniform1iv(this.addr,i);for(let r=0;r!==n;++r)t.setTexture2DArray(e[r]||iS,i[r])}function SI(a){switch(a){case 5126:return iI;case 35664:return rI;case 35665:return sI;case 35666:return aI;case 35674:return oI;case 35675:return lI;case 35676:return cI;case 5124:case 35670:return uI;case 35667:case 35671:return hI;case 35668:case 35672:return dI;case 35669:case 35673:return fI;case 5125:return pI;case 36294:return mI;case 36295:return gI;case 36296:return vI;case 35678:case 36198:case 36298:case 36306:case 35682:return yI;case 35679:case 36299:case 36307:return xI;case 35680:case 36300:case 36308:case 36293:return wI;case 36289:case 36303:case 36311:case 36292:return AI}}function MI(a,e,t){this.id=a,this.addr=t,this.cache=[],this.setValue=nI(e.type)}function bI(a,e,t){this.id=a,this.addr=t,this.cache=[],this.size=e.size,this.setValue=SI(e.type)}function aS(a){this.id=a,this.seq=[],this.map={}}aS.prototype.setValue=function(a,e,t){const n=this.seq;for(let i=0,r=n.length;i!==r;++i){const s=n[i];s.setValue(a,e[s.id],t)}};const Op=/(\w+)(\])?(\[|\.)?/g;function $0(a,e){a.seq.push(e),a.map[e.id]=e}function EI(a,e,t){const n=a.name,i=n.length;for(Op.lastIndex=0;;){const r=Op.exec(n),s=Op.lastIndex;let o=r[1];const l=r[2]==="]",c=r[3];if(l&&(o=o|0),c===void 0||c==="["&&s+2===i){$0(t,c===void 0?new MI(o,a,e):new bI(o,a,e));break}else{let h=t.map[o];h===void 0&&(h=new aS(o),$0(t,h)),t=h}}}function ea(a,e){this.seq=[],this.map={};const t=a.getProgramParameter(e,35718);for(let n=0;n<t;++n){const i=a.getActiveUniform(e,n),r=a.getUniformLocation(e,i.name);EI(i,r,this)}}ea.prototype.setValue=function(a,e,t,n){const i=this.map[e];i!==void 0&&i.setValue(a,t,n)};ea.prototype.setOptional=function(a,e,t){const n=e[t];n!==void 0&&this.setValue(a,t,n)};ea.upload=function(a,e,t,n){for(let i=0,r=e.length;i!==r;++i){const s=e[i],o=t[s.id];o.needsUpdate!==!1&&s.setValue(a,o.value,n)}};ea.seqWithValue=function(a,e){const t=[];for(let n=0,i=a.length;n!==i;++n){const r=a[n];r.id in e&&t.push(r)}return t};function ey(a,e,t){const n=a.createShader(e);return a.shaderSource(n,t),a.compileShader(n),n}let TI=0;function CI(a,e){const t=a.split(`
`),n=[],i=Math.max(e-6,0),r=Math.min(e+6,t.length);for(let s=i;s<r;s++)n.push(s+1+": "+t[s]);return n.join(`
`)}function II(a){switch(a){case Fi:return["Linear","( value )"];case vt:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",a),["Linear","( value )"]}}function ty(a,e,t){const n=a.getShaderParameter(e,35713),i=a.getShaderInfoLog(e).trim();if(n&&i==="")return"";const r=/ERROR: 0:(\d+)/.exec(i);if(r){const s=parseInt(r[0]);return t.toUpperCase()+`

`+i+`

`+CI(a.getShaderSource(e),s)}else return i}function RI(a,e){const t=II(e);return"vec4 "+a+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function PI(a,e){let t;switch(e){case BA:t="Linear";break;case LA:t="Reinhard";break;case zA:t="OptimizedCineon";break;case Hg:t="ACESFilmic";break;case NA:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+a+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function DI(a){return[a.extensionDerivatives||a.envMapCubeUVHeight||a.bumpMap||a.tangentSpaceNormalMap||a.clearcoatNormalMap||a.flatShading||a.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(a.extensionFragDepth||a.logarithmicDepthBuffer)&&a.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",a.extensionDrawBuffers&&a.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(a.extensionShaderTextureLOD||a.envMap||a.transmission)&&a.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(uc).join(`
`)}function OI(a){const e=[];for(const t in a){const n=a[t];n!==!1&&e.push("#define "+t+" "+n)}return e.join(`
`)}function BI(a,e){const t={},n=a.getProgramParameter(e,35721);for(let i=0;i<n;i++){const r=a.getActiveAttrib(e,i),s=r.name;let o=1;r.type===35674&&(o=2),r.type===35675&&(o=3),r.type===35676&&(o=4),t[s]={type:r.type,location:a.getAttribLocation(e,s),locationSize:o}}return t}function uc(a){return a!==""}function ny(a,e){return a.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function iy(a,e){return a.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const LI=/^[ \t]*#include +<([\w\d./]+)>/gm;function $m(a){return a.replace(LI,zI)}function zI(a,e){const t=bt[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return $m(t)}const NI=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,kI=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function ry(a){return a.replace(kI,oS).replace(NI,UI)}function UI(a,e,t,n){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),oS(a,e,t,n)}function oS(a,e,t,n){let i="";for(let r=parseInt(e);r<parseInt(t);r++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return i}function sy(a){let e="precision "+a.precision+` float;
precision `+a.precision+" int;";return a.precision==="highp"?e+=`
#define HIGH_PRECISION`:a.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:a.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function FI(a){let e="SHADOWMAP_TYPE_BASIC";return a.shadowMapType===Lg?e="SHADOWMAP_TYPE_PCF":a.shadowMapType===vA?e="SHADOWMAP_TYPE_PCF_SOFT":a.shadowMapType===Na&&(e="SHADOWMAP_TYPE_VSM"),e}function HI(a){let e="ENVMAP_TYPE_CUBE";if(a.envMap)switch(a.envMapMode){case ra:case sa:e="ENVMAP_TYPE_CUBE";break;case Sl:e="ENVMAP_TYPE_CUBE_UV";break}return e}function GI(a){let e="ENVMAP_MODE_REFLECTION";return a.envMap&&a.envMapMode===sa&&(e="ENVMAP_MODE_REFRACTION"),e}function VI(a){let e="ENVMAP_BLENDING_NONE";if(a.envMap)switch(a.combine){case Ou:e="ENVMAP_BLENDING_MULTIPLY";break;case DA:e="ENVMAP_BLENDING_MIX";break;case OA:e="ENVMAP_BLENDING_ADD";break}return e}function jI(a){const e=a.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,n=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),112)),texelHeight:n,maxMip:t}}function QI(a,e,t,n){const i=a.getContext(),r=t.defines;let s=t.vertexShader,o=t.fragmentShader;const l=FI(t),c=HI(t),u=GI(t),h=VI(t),d=jI(t),f=t.isWebGL2?"":DI(t),p=OI(r),m=i.createProgram();let g,v,y=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(g=[p].filter(uc).join(`
`),g.length>0&&(g+=`
`),v=[f,p].filter(uc).join(`
`),v.length>0&&(v+=`
`)):(g=[sy(t),"#define SHADER_NAME "+t.shaderName,p,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(uc).join(`
`),v=[f,sy(t),"#define SHADER_NAME "+t.shaderName,p,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+u:"",t.envMap?"#define "+h:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Nr?"#define TONE_MAPPING":"",t.toneMapping!==Nr?bt.tonemapping_pars_fragment:"",t.toneMapping!==Nr?PI("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",bt.encodings_pars_fragment,RI("linearToOutputTexel",t.outputEncoding),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(uc).join(`
`)),s=$m(s),s=ny(s,t),s=iy(s,t),o=$m(o),o=ny(o,t),o=iy(o,t),s=ry(s),o=ry(o),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(y=`#version 300 es
`,g=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+g,v=["#define varying in",t.glslVersion===qm?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===qm?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+v);const w=y+g+s,x=y+v+o,S=ey(i,35633,w),b=ey(i,35632,x);if(i.attachShader(m,S),i.attachShader(m,b),t.index0AttributeName!==void 0?i.bindAttribLocation(m,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(m,0,"position"),i.linkProgram(m),a.debug.checkShaderErrors){const T=i.getProgramInfoLog(m).trim(),I=i.getShaderInfoLog(S).trim(),O=i.getShaderInfoLog(b).trim();let R=!0,k=!0;if(i.getProgramParameter(m,35714)===!1){R=!1;const P=ty(i,S,"vertex"),F=ty(i,b,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(m,35715)+`

Program Info Log: `+T+`
`+P+`
`+F)}else T!==""?console.warn("THREE.WebGLProgram: Program Info Log:",T):(I===""||O==="")&&(k=!1);k&&(this.diagnostics={runnable:R,programLog:T,vertexShader:{log:I,prefix:g},fragmentShader:{log:O,prefix:v}})}i.deleteShader(S),i.deleteShader(b);let E;this.getUniforms=function(){return E===void 0&&(E=new ea(i,m)),E};let M;return this.getAttributes=function(){return M===void 0&&(M=BI(i,m)),M},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(m),this.program=void 0},this.name=t.shaderName,this.id=TI++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=S,this.fragmentShader=b,this}let WI=0;class XI{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,n=e.fragmentShader,i=this._getShaderStage(t),r=this._getShaderStage(n),s=this._getShaderCacheForMaterial(e);return s.has(i)===!1&&(s.add(i),i.usedTimes++),s.has(r)===!1&&(s.add(r),r.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const n of t)n.usedTimes--,n.usedTimes===0&&this.shaderCache.delete(n.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;return t.has(e)===!1&&t.set(e,new Set),t.get(e)}_getShaderStage(e){const t=this.shaderCache;if(t.has(e)===!1){const n=new JI(e);t.set(e,n)}return t.get(e)}}class JI{constructor(e){this.id=WI++,this.code=e,this.usedTimes=0}}function ZI(a,e,t,n,i,r,s){const o=new xf,l=new XI,c=[],u=i.isWebGL2,h=i.logarithmicDepthBuffer,d=i.vertexTextures;let f=i.precision;const p={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function m(M,T,I,O,R){const k=O.fog,P=R.geometry,F=M.isMeshStandardMaterial?O.environment:null,N=(M.isMeshStandardMaterial?t:e).get(M.envMap||F),Y=N&&N.mapping===Sl?N.image.height:null,_=p[M.type];M.precision!==null&&(f=i.getMaxPrecision(M.precision),f!==M.precision&&console.warn("THREE.WebGLProgram.getParameters:",M.precision,"not supported, using",f,"instead."));const G=P.morphAttributes.position||P.morphAttributes.normal||P.morphAttributes.color,j=G!==void 0?G.length:0;let L=0;P.morphAttributes.position!==void 0&&(L=1),P.morphAttributes.normal!==void 0&&(L=2),P.morphAttributes.color!==void 0&&(L=3);let H,q,$,ee;if(_){const se=Rn[_];H=se.vertexShader,q=se.fragmentShader}else H=M.vertexShader,q=M.fragmentShader,l.update(M),$=l.getVertexShaderID(M),ee=l.getFragmentShaderID(M);const W=a.getRenderTarget(),le=M.alphaTest>0,K=M.clearcoat>0;return{isWebGL2:u,shaderID:_,shaderName:M.type,vertexShader:H,fragmentShader:q,defines:M.defines,customVertexShaderID:$,customFragmentShaderID:ee,isRawShaderMaterial:M.isRawShaderMaterial===!0,glslVersion:M.glslVersion,precision:f,instancing:R.isInstancedMesh===!0,instancingColor:R.isInstancedMesh===!0&&R.instanceColor!==null,supportsVertexTextures:d,outputEncoding:W===null?a.outputEncoding:W.isXRRenderTarget===!0?W.texture.encoding:Fi,map:!!M.map,matcap:!!M.matcap,envMap:!!N,envMapMode:N&&N.mapping,envMapCubeUVHeight:Y,lightMap:!!M.lightMap,aoMap:!!M.aoMap,emissiveMap:!!M.emissiveMap,bumpMap:!!M.bumpMap,normalMap:!!M.normalMap,objectSpaceNormalMap:M.normalMapType===GA,tangentSpaceNormalMap:M.normalMapType===ho,decodeVideoTexture:!!M.map&&M.map.isVideoTexture===!0&&M.map.encoding===vt,clearcoat:K,clearcoatMap:K&&!!M.clearcoatMap,clearcoatRoughnessMap:K&&!!M.clearcoatRoughnessMap,clearcoatNormalMap:K&&!!M.clearcoatNormalMap,displacementMap:!!M.displacementMap,roughnessMap:!!M.roughnessMap,metalnessMap:!!M.metalnessMap,specularMap:!!M.specularMap,specularIntensityMap:!!M.specularIntensityMap,specularColorMap:!!M.specularColorMap,opaque:M.transparent===!1&&M.blending===qs,alphaMap:!!M.alphaMap,alphaTest:le,gradientMap:!!M.gradientMap,sheen:M.sheen>0,sheenColorMap:!!M.sheenColorMap,sheenRoughnessMap:!!M.sheenRoughnessMap,transmission:M.transmission>0,transmissionMap:!!M.transmissionMap,thicknessMap:!!M.thicknessMap,combine:M.combine,vertexTangents:!!M.normalMap&&!!P.attributes.tangent,vertexColors:M.vertexColors,vertexAlphas:M.vertexColors===!0&&!!P.attributes.color&&P.attributes.color.itemSize===4,vertexUvs:!!M.map||!!M.bumpMap||!!M.normalMap||!!M.specularMap||!!M.alphaMap||!!M.emissiveMap||!!M.roughnessMap||!!M.metalnessMap||!!M.clearcoatMap||!!M.clearcoatRoughnessMap||!!M.clearcoatNormalMap||!!M.displacementMap||!!M.transmissionMap||!!M.thicknessMap||!!M.specularIntensityMap||!!M.specularColorMap||!!M.sheenColorMap||!!M.sheenRoughnessMap,uvsVertexOnly:!(M.map||M.bumpMap||M.normalMap||M.specularMap||M.alphaMap||M.emissiveMap||M.roughnessMap||M.metalnessMap||M.clearcoatNormalMap||M.transmission>0||M.transmissionMap||M.thicknessMap||M.specularIntensityMap||M.specularColorMap||M.sheen>0||M.sheenColorMap||M.sheenRoughnessMap)&&!!M.displacementMap,fog:!!k,useFog:M.fog===!0,fogExp2:k&&k.isFogExp2,flatShading:!!M.flatShading,sizeAttenuation:M.sizeAttenuation,logarithmicDepthBuffer:h,skinning:R.isSkinnedMesh===!0,morphTargets:P.morphAttributes.position!==void 0,morphNormals:P.morphAttributes.normal!==void 0,morphColors:P.morphAttributes.color!==void 0,morphTargetsCount:j,morphTextureStride:L,numDirLights:T.directional.length,numPointLights:T.point.length,numSpotLights:T.spot.length,numRectAreaLights:T.rectArea.length,numHemiLights:T.hemi.length,numDirLightShadows:T.directionalShadowMap.length,numPointLightShadows:T.pointShadowMap.length,numSpotLightShadows:T.spotShadowMap.length,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,dithering:M.dithering,shadowMapEnabled:a.shadowMap.enabled&&I.length>0,shadowMapType:a.shadowMap.type,toneMapping:M.toneMapped?a.toneMapping:Nr,physicallyCorrectLights:a.physicallyCorrectLights,premultipliedAlpha:M.premultipliedAlpha,doubleSided:M.side===yt,flipSided:M.side===pi,useDepthPacking:!!M.depthPacking,depthPacking:M.depthPacking||0,index0AttributeName:M.index0AttributeName,extensionDerivatives:M.extensions&&M.extensions.derivatives,extensionFragDepth:M.extensions&&M.extensions.fragDepth,extensionDrawBuffers:M.extensions&&M.extensions.drawBuffers,extensionShaderTextureLOD:M.extensions&&M.extensions.shaderTextureLOD,rendererExtensionFragDepth:u||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:u||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:u||n.has("EXT_shader_texture_lod"),customProgramCacheKey:M.customProgramCacheKey()}}function g(M){const T=[];if(M.shaderID?T.push(M.shaderID):(T.push(M.customVertexShaderID),T.push(M.customFragmentShaderID)),M.defines!==void 0)for(const I in M.defines)T.push(I),T.push(M.defines[I]);return M.isRawShaderMaterial===!1&&(v(T,M),y(T,M),T.push(a.outputEncoding)),T.push(M.customProgramCacheKey),T.join()}function v(M,T){M.push(T.precision),M.push(T.outputEncoding),M.push(T.envMapMode),M.push(T.envMapCubeUVHeight),M.push(T.combine),M.push(T.vertexUvs),M.push(T.fogExp2),M.push(T.sizeAttenuation),M.push(T.morphTargetsCount),M.push(T.morphAttributeCount),M.push(T.numDirLights),M.push(T.numPointLights),M.push(T.numSpotLights),M.push(T.numHemiLights),M.push(T.numRectAreaLights),M.push(T.numDirLightShadows),M.push(T.numPointLightShadows),M.push(T.numSpotLightShadows),M.push(T.shadowMapType),M.push(T.toneMapping),M.push(T.numClippingPlanes),M.push(T.numClipIntersection),M.push(T.depthPacking)}function y(M,T){o.disableAll(),T.isWebGL2&&o.enable(0),T.supportsVertexTextures&&o.enable(1),T.instancing&&o.enable(2),T.instancingColor&&o.enable(3),T.map&&o.enable(4),T.matcap&&o.enable(5),T.envMap&&o.enable(6),T.lightMap&&o.enable(7),T.aoMap&&o.enable(8),T.emissiveMap&&o.enable(9),T.bumpMap&&o.enable(10),T.normalMap&&o.enable(11),T.objectSpaceNormalMap&&o.enable(12),T.tangentSpaceNormalMap&&o.enable(13),T.clearcoat&&o.enable(14),T.clearcoatMap&&o.enable(15),T.clearcoatRoughnessMap&&o.enable(16),T.clearcoatNormalMap&&o.enable(17),T.displacementMap&&o.enable(18),T.specularMap&&o.enable(19),T.roughnessMap&&o.enable(20),T.metalnessMap&&o.enable(21),T.gradientMap&&o.enable(22),T.alphaMap&&o.enable(23),T.alphaTest&&o.enable(24),T.vertexColors&&o.enable(25),T.vertexAlphas&&o.enable(26),T.vertexUvs&&o.enable(27),T.vertexTangents&&o.enable(28),T.uvsVertexOnly&&o.enable(29),T.fog&&o.enable(30),M.push(o.mask),o.disableAll(),T.useFog&&o.enable(0),T.flatShading&&o.enable(1),T.logarithmicDepthBuffer&&o.enable(2),T.skinning&&o.enable(3),T.morphTargets&&o.enable(4),T.morphNormals&&o.enable(5),T.morphColors&&o.enable(6),T.premultipliedAlpha&&o.enable(7),T.shadowMapEnabled&&o.enable(8),T.physicallyCorrectLights&&o.enable(9),T.doubleSided&&o.enable(10),T.flipSided&&o.enable(11),T.useDepthPacking&&o.enable(12),T.dithering&&o.enable(13),T.specularIntensityMap&&o.enable(14),T.specularColorMap&&o.enable(15),T.transmission&&o.enable(16),T.transmissionMap&&o.enable(17),T.thicknessMap&&o.enable(18),T.sheen&&o.enable(19),T.sheenColorMap&&o.enable(20),T.sheenRoughnessMap&&o.enable(21),T.decodeVideoTexture&&o.enable(22),T.opaque&&o.enable(23),M.push(o.mask)}function w(M){const T=p[M.type];let I;if(T){const O=Rn[T];I=Hr.clone(O.uniforms)}else I=M.uniforms;return I}function x(M,T){let I;for(let O=0,R=c.length;O<R;O++){const k=c[O];if(k.cacheKey===T){I=k,++I.usedTimes;break}}return I===void 0&&(I=new QI(a,T,M,r),c.push(I)),I}function S(M){if(--M.usedTimes===0){const T=c.indexOf(M);c[T]=c[c.length-1],c.pop(),M.destroy()}}function b(M){l.remove(M)}function E(){l.dispose()}return{getParameters:m,getProgramCacheKey:g,getUniforms:w,acquireProgram:x,releaseProgram:S,releaseShaderCache:b,programs:c,dispose:E}}function KI(){let a=new WeakMap;function e(r){let s=a.get(r);return s===void 0&&(s={},a.set(r,s)),s}function t(r){a.delete(r)}function n(r,s,o){a.get(r)[s]=o}function i(){a=new WeakMap}return{get:e,remove:t,update:n,dispose:i}}function YI(a,e){return a.groupOrder!==e.groupOrder?a.groupOrder-e.groupOrder:a.renderOrder!==e.renderOrder?a.renderOrder-e.renderOrder:a.material.id!==e.material.id?a.material.id-e.material.id:a.z!==e.z?a.z-e.z:a.id-e.id}function ay(a,e){return a.groupOrder!==e.groupOrder?a.groupOrder-e.groupOrder:a.renderOrder!==e.renderOrder?a.renderOrder-e.renderOrder:a.z!==e.z?e.z-a.z:a.id-e.id}function oy(){const a=[];let e=0;const t=[],n=[],i=[];function r(){e=0,t.length=0,n.length=0,i.length=0}function s(h,d,f,p,m,g){let v=a[e];return v===void 0?(v={id:h.id,object:h,geometry:d,material:f,groupOrder:p,renderOrder:h.renderOrder,z:m,group:g},a[e]=v):(v.id=h.id,v.object=h,v.geometry=d,v.material=f,v.groupOrder=p,v.renderOrder=h.renderOrder,v.z=m,v.group=g),e++,v}function o(h,d,f,p,m,g){const v=s(h,d,f,p,m,g);f.transmission>0?n.push(v):f.transparent===!0?i.push(v):t.push(v)}function l(h,d,f,p,m,g){const v=s(h,d,f,p,m,g);f.transmission>0?n.unshift(v):f.transparent===!0?i.unshift(v):t.unshift(v)}function c(h,d){t.length>1&&t.sort(h||YI),n.length>1&&n.sort(d||ay),i.length>1&&i.sort(d||ay)}function u(){for(let h=e,d=a.length;h<d;h++){const f=a[h];if(f.id===null)break;f.id=null,f.object=null,f.geometry=null,f.material=null,f.group=null}}return{opaque:t,transmissive:n,transparent:i,init:r,push:o,unshift:l,finish:u,sort:c}}function qI(){let a=new WeakMap;function e(n,i){let r;return a.has(n)===!1?(r=new oy,a.set(n,[r])):i>=a.get(n).length?(r=new oy,a.get(n).push(r)):r=a.get(n)[i],r}function t(){a=new WeakMap}return{get:e,dispose:t}}function _I(){const a={};return{get:function(e){if(a[e.id]!==void 0)return a[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new A,color:new Ie};break;case"SpotLight":t={position:new A,direction:new A,color:new Ie,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new A,color:new Ie,distance:0,decay:0};break;case"HemisphereLight":t={direction:new A,skyColor:new Ie,groundColor:new Ie};break;case"RectAreaLight":t={color:new Ie,position:new A,halfWidth:new A,halfHeight:new A};break}return a[e.id]=t,t}}}function $I(){const a={};return{get:function(e){if(a[e.id]!==void 0)return a[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new te};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new te};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new te,shadowCameraNear:1,shadowCameraFar:1e3};break}return a[e.id]=t,t}}}let eR=0;function tR(a,e){return(e.castShadow?1:0)-(a.castShadow?1:0)}function nR(a,e){const t=new _I,n=$I(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let u=0;u<9;u++)i.probe.push(new A);const r=new A,s=new ae,o=new ae;function l(u,h){let d=0,f=0,p=0;for(let T=0;T<9;T++)i.probe[T].set(0,0,0);let m=0,g=0,v=0,y=0,w=0,x=0,S=0,b=0;u.sort(tR);const E=h!==!0?Math.PI:1;for(let T=0,I=u.length;T<I;T++){const O=u[T],R=O.color,k=O.intensity,P=O.distance,F=O.shadow&&O.shadow.map?O.shadow.map.texture:null;if(O.isAmbientLight)d+=R.r*k*E,f+=R.g*k*E,p+=R.b*k*E;else if(O.isLightProbe)for(let N=0;N<9;N++)i.probe[N].addScaledVector(O.sh.coefficients[N],k);else if(O.isDirectionalLight){const N=t.get(O);if(N.color.copy(O.color).multiplyScalar(O.intensity*E),O.castShadow){const Y=O.shadow,_=n.get(O);_.shadowBias=Y.bias,_.shadowNormalBias=Y.normalBias,_.shadowRadius=Y.radius,_.shadowMapSize=Y.mapSize,i.directionalShadow[m]=_,i.directionalShadowMap[m]=F,i.directionalShadowMatrix[m]=O.shadow.matrix,x++}i.directional[m]=N,m++}else if(O.isSpotLight){const N=t.get(O);if(N.position.setFromMatrixPosition(O.matrixWorld),N.color.copy(R).multiplyScalar(k*E),N.distance=P,N.coneCos=Math.cos(O.angle),N.penumbraCos=Math.cos(O.angle*(1-O.penumbra)),N.decay=O.decay,O.castShadow){const Y=O.shadow,_=n.get(O);_.shadowBias=Y.bias,_.shadowNormalBias=Y.normalBias,_.shadowRadius=Y.radius,_.shadowMapSize=Y.mapSize,i.spotShadow[v]=_,i.spotShadowMap[v]=F,i.spotShadowMatrix[v]=O.shadow.matrix,b++}i.spot[v]=N,v++}else if(O.isRectAreaLight){const N=t.get(O);N.color.copy(R).multiplyScalar(k),N.halfWidth.set(O.width*.5,0,0),N.halfHeight.set(0,O.height*.5,0),i.rectArea[y]=N,y++}else if(O.isPointLight){const N=t.get(O);if(N.color.copy(O.color).multiplyScalar(O.intensity*E),N.distance=O.distance,N.decay=O.decay,O.castShadow){const Y=O.shadow,_=n.get(O);_.shadowBias=Y.bias,_.shadowNormalBias=Y.normalBias,_.shadowRadius=Y.radius,_.shadowMapSize=Y.mapSize,_.shadowCameraNear=Y.camera.near,_.shadowCameraFar=Y.camera.far,i.pointShadow[g]=_,i.pointShadowMap[g]=F,i.pointShadowMatrix[g]=O.shadow.matrix,S++}i.point[g]=N,g++}else if(O.isHemisphereLight){const N=t.get(O);N.skyColor.copy(O.color).multiplyScalar(k*E),N.groundColor.copy(O.groundColor).multiplyScalar(k*E),i.hemi[w]=N,w++}}y>0&&(e.isWebGL2||a.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=Ke.LTC_FLOAT_1,i.rectAreaLTC2=Ke.LTC_FLOAT_2):a.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=Ke.LTC_HALF_1,i.rectAreaLTC2=Ke.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=d,i.ambient[1]=f,i.ambient[2]=p;const M=i.hash;(M.directionalLength!==m||M.pointLength!==g||M.spotLength!==v||M.rectAreaLength!==y||M.hemiLength!==w||M.numDirectionalShadows!==x||M.numPointShadows!==S||M.numSpotShadows!==b)&&(i.directional.length=m,i.spot.length=v,i.rectArea.length=y,i.point.length=g,i.hemi.length=w,i.directionalShadow.length=x,i.directionalShadowMap.length=x,i.pointShadow.length=S,i.pointShadowMap.length=S,i.spotShadow.length=b,i.spotShadowMap.length=b,i.directionalShadowMatrix.length=x,i.pointShadowMatrix.length=S,i.spotShadowMatrix.length=b,M.directionalLength=m,M.pointLength=g,M.spotLength=v,M.rectAreaLength=y,M.hemiLength=w,M.numDirectionalShadows=x,M.numPointShadows=S,M.numSpotShadows=b,i.version=eR++)}function c(u,h){let d=0,f=0,p=0,m=0,g=0;const v=h.matrixWorldInverse;for(let y=0,w=u.length;y<w;y++){const x=u[y];if(x.isDirectionalLight){const S=i.directional[d];S.direction.setFromMatrixPosition(x.matrixWorld),r.setFromMatrixPosition(x.target.matrixWorld),S.direction.sub(r),S.direction.transformDirection(v),d++}else if(x.isSpotLight){const S=i.spot[p];S.position.setFromMatrixPosition(x.matrixWorld),S.position.applyMatrix4(v),S.direction.setFromMatrixPosition(x.matrixWorld),r.setFromMatrixPosition(x.target.matrixWorld),S.direction.sub(r),S.direction.transformDirection(v),p++}else if(x.isRectAreaLight){const S=i.rectArea[m];S.position.setFromMatrixPosition(x.matrixWorld),S.position.applyMatrix4(v),o.identity(),s.copy(x.matrixWorld),s.premultiply(v),o.extractRotation(s),S.halfWidth.set(x.width*.5,0,0),S.halfHeight.set(0,x.height*.5,0),S.halfWidth.applyMatrix4(o),S.halfHeight.applyMatrix4(o),m++}else if(x.isPointLight){const S=i.point[f];S.position.setFromMatrixPosition(x.matrixWorld),S.position.applyMatrix4(v),f++}else if(x.isHemisphereLight){const S=i.hemi[g];S.direction.setFromMatrixPosition(x.matrixWorld),S.direction.transformDirection(v),g++}}}return{setup:l,setupView:c,state:i}}function ly(a,e){const t=new nR(a,e),n=[],i=[];function r(){n.length=0,i.length=0}function s(h){n.push(h)}function o(h){i.push(h)}function l(h){t.setup(n,h)}function c(h){t.setupView(n,h)}return{init:r,state:{lightsArray:n,shadowsArray:i,lights:t},setupLights:l,setupLightsView:c,pushLight:s,pushShadow:o}}function iR(a,e){let t=new WeakMap;function n(r,s=0){let o;return t.has(r)===!1?(o=new ly(a,e),t.set(r,[o])):s>=t.get(r).length?(o=new ly(a,e),t.get(r).push(o)):o=t.get(r)[s],o}function i(){t=new WeakMap}return{get:n,dispose:i}}class Cl extends cn{constructor(e){super(),this.type="MeshDepthMaterial",this.depthPacking=iv,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}Cl.prototype.isMeshDepthMaterial=!0;class ku extends cn{constructor(e){super(),this.type="MeshDistanceMaterial",this.referencePosition=new A,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}ku.prototype.isMeshDistanceMaterial=!0;const rR=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,sR=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function lS(a,e,t){let n=new El;const i=new te,r=new te,s=new lt,o=new Cl({depthPacking:da}),l=new ku,c={},u=t.maxTextureSize,h={0:pi,1:An,2:yt},d=new gn({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new te},radius:{value:4}},vertexShader:rR,fragmentShader:sR}),f=d.clone();f.defines.HORIZONTAL_PASS=1;const p=new nt;p.setAttribute("position",new wt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const m=new Ve(p,d),g=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Lg,this.render=function(x,S,b){if(g.enabled===!1||g.autoUpdate===!1&&g.needsUpdate===!1||x.length===0)return;const E=a.getRenderTarget(),M=a.getActiveCubeFace(),T=a.getActiveMipmapLevel(),I=a.state;I.setBlending(Mn),I.buffers.color.setClear(1,1,1,1),I.buffers.depth.setTest(!0),I.setScissorTest(!1);for(let O=0,R=x.length;O<R;O++){const k=x[O],P=k.shadow;if(P===void 0){console.warn("THREE.WebGLShadowMap:",k,"has no shadow.");continue}if(P.autoUpdate===!1&&P.needsUpdate===!1)continue;i.copy(P.mapSize);const F=P.getFrameExtents();if(i.multiply(F),r.copy(P.mapSize),(i.x>u||i.y>u)&&(i.x>u&&(r.x=Math.floor(u/F.x),i.x=r.x*F.x,P.mapSize.x=r.x),i.y>u&&(r.y=Math.floor(u/F.y),i.y=r.y*F.y,P.mapSize.y=r.y)),P.map===null&&!P.isPointLightShadow&&this.type===Na&&(P.map=new pn(i.x,i.y),P.map.texture.name=k.name+".shadowMap",P.mapPass=new pn(i.x,i.y),P.camera.updateProjectionMatrix()),P.map===null){const Y={minFilter:Dt,magFilter:Dt,format:Hn};P.map=new pn(i.x,i.y,Y),P.map.texture.name=k.name+".shadowMap",P.camera.updateProjectionMatrix()}a.setRenderTarget(P.map),a.clear();const N=P.getViewportCount();for(let Y=0;Y<N;Y++){const _=P.getViewport(Y);s.set(r.x*_.x,r.y*_.y,r.x*_.z,r.y*_.w),I.viewport(s),P.updateMatrices(k,Y),n=P.getFrustum(),w(S,b,P.camera,k,this.type)}!P.isPointLightShadow&&this.type===Na&&v(P,b),P.needsUpdate=!1}g.needsUpdate=!1,a.setRenderTarget(E,M,T)};function v(x,S){const b=e.update(m);d.defines.VSM_SAMPLES!==x.blurSamples&&(d.defines.VSM_SAMPLES=x.blurSamples,f.defines.VSM_SAMPLES=x.blurSamples,d.needsUpdate=!0,f.needsUpdate=!0),d.uniforms.shadow_pass.value=x.map.texture,d.uniforms.resolution.value=x.mapSize,d.uniforms.radius.value=x.radius,a.setRenderTarget(x.mapPass),a.clear(),a.renderBufferDirect(S,null,b,d,m,null),f.uniforms.shadow_pass.value=x.mapPass.texture,f.uniforms.resolution.value=x.mapSize,f.uniforms.radius.value=x.radius,a.setRenderTarget(x.map),a.clear(),a.renderBufferDirect(S,null,b,f,m,null)}function y(x,S,b,E,M,T){let I=null;const O=b.isPointLight===!0?x.customDistanceMaterial:x.customDepthMaterial;if(O!==void 0?I=O:I=b.isPointLight===!0?l:o,a.localClippingEnabled&&S.clipShadows===!0&&S.clippingPlanes.length!==0||S.displacementMap&&S.displacementScale!==0||S.alphaMap&&S.alphaTest>0){const R=I.uuid,k=S.uuid;let P=c[R];P===void 0&&(P={},c[R]=P);let F=P[k];F===void 0&&(F=I.clone(),P[k]=F),I=F}return I.visible=S.visible,I.wireframe=S.wireframe,T===Na?I.side=S.shadowSide!==null?S.shadowSide:S.side:I.side=S.shadowSide!==null?S.shadowSide:h[S.side],I.alphaMap=S.alphaMap,I.alphaTest=S.alphaTest,I.clipShadows=S.clipShadows,I.clippingPlanes=S.clippingPlanes,I.clipIntersection=S.clipIntersection,I.displacementMap=S.displacementMap,I.displacementScale=S.displacementScale,I.displacementBias=S.displacementBias,I.wireframeLinewidth=S.wireframeLinewidth,I.linewidth=S.linewidth,b.isPointLight===!0&&I.isMeshDistanceMaterial===!0&&(I.referencePosition.setFromMatrixPosition(b.matrixWorld),I.nearDistance=E,I.farDistance=M),I}function w(x,S,b,E,M){if(x.visible===!1)return;if(x.layers.test(S.layers)&&(x.isMesh||x.isLine||x.isPoints)&&(x.castShadow||x.receiveShadow&&M===Na)&&(!x.frustumCulled||n.intersectsObject(x))){x.modelViewMatrix.multiplyMatrices(b.matrixWorldInverse,x.matrixWorld);const O=e.update(x),R=x.material;if(Array.isArray(R)){const k=O.groups;for(let P=0,F=k.length;P<F;P++){const N=k[P],Y=R[N.materialIndex];if(Y&&Y.visible){const _=y(x,Y,E,b.near,b.far,M);a.renderBufferDirect(b,null,O,_,x,N)}}}else if(R.visible){const k=y(x,R,E,b.near,b.far,M);a.renderBufferDirect(b,null,O,k,x,null)}}const I=x.children;for(let O=0,R=I.length;O<R;O++)w(I[O],S,b,E,M)}}function aR(a,e,t){const n=t.isWebGL2;function i(){let X=!1;const Ce=new lt;let Te=null;const Ye=new lt(0,0,0,0);return{setMask:function(Ne){Te!==Ne&&!X&&(a.colorMask(Ne,Ne,Ne,Ne),Te=Ne)},setLocked:function(Ne){X=Ne},setClear:function(Ne,Ze,Be,ce,_e){_e===!0&&(Ne*=ce,Ze*=ce,Be*=ce),Ce.set(Ne,Ze,Be,ce),Ye.equals(Ce)===!1&&(a.clearColor(Ne,Ze,Be,ce),Ye.copy(Ce))},reset:function(){X=!1,Te=null,Ye.set(-1,0,0,0)}}}function r(){let X=!1,Ce=null,Te=null,Ye=null;return{setTest:function(Ne){Ne?ee(2929):W(2929)},setMask:function(Ne){Ce!==Ne&&!X&&(a.depthMask(Ne),Ce=Ne)},setFunc:function(Ne){if(Te!==Ne){if(Ne)switch(Ne){case bA:a.depthFunc(512);break;case EA:a.depthFunc(519);break;case TA:a.depthFunc(513);break;case Wd:a.depthFunc(515);break;case CA:a.depthFunc(514);break;case IA:a.depthFunc(518);break;case RA:a.depthFunc(516);break;case PA:a.depthFunc(517);break;default:a.depthFunc(515)}else a.depthFunc(515);Te=Ne}},setLocked:function(Ne){X=Ne},setClear:function(Ne){Ye!==Ne&&(a.clearDepth(Ne),Ye=Ne)},reset:function(){X=!1,Ce=null,Te=null,Ye=null}}}function s(){let X=!1,Ce=null,Te=null,Ye=null,Ne=null,Ze=null,Be=null,ce=null,_e=null;return{setTest:function(pt){X||(pt?ee(2960):W(2960))},setMask:function(pt){Ce!==pt&&!X&&(a.stencilMask(pt),Ce=pt)},setFunc:function(pt,At,ht){(Te!==pt||Ye!==At||Ne!==ht)&&(a.stencilFunc(pt,At,ht),Te=pt,Ye=At,Ne=ht)},setOp:function(pt,At,ht){(Ze!==pt||Be!==At||ce!==ht)&&(a.stencilOp(pt,At,ht),Ze=pt,Be=At,ce=ht)},setLocked:function(pt){X=pt},setClear:function(pt){_e!==pt&&(a.clearStencil(pt),_e=pt)},reset:function(){X=!1,Ce=null,Te=null,Ye=null,Ne=null,Ze=null,Be=null,ce=null,_e=null}}}const o=new i,l=new r,c=new s;let u={},h={},d=new WeakMap,f=[],p=null,m=!1,g=null,v=null,y=null,w=null,x=null,S=null,b=null,E=!1,M=null,T=null,I=null,O=null,R=null;const k=a.getParameter(35661);let P=!1,F=0;const N=a.getParameter(7938);N.indexOf("WebGL")!==-1?(F=parseFloat(/^WebGL (\d)/.exec(N)[1]),P=F>=1):N.indexOf("OpenGL ES")!==-1&&(F=parseFloat(/^OpenGL ES (\d)/.exec(N)[1]),P=F>=2);let Y=null,_={};const G=a.getParameter(3088),j=a.getParameter(2978),L=new lt().fromArray(G),H=new lt().fromArray(j);function q(X,Ce,Te){const Ye=new Uint8Array(4),Ne=a.createTexture();a.bindTexture(X,Ne),a.texParameteri(X,10241,9728),a.texParameteri(X,10240,9728);for(let Ze=0;Ze<Te;Ze++)a.texImage2D(Ce+Ze,0,6408,1,1,0,6408,5121,Ye);return Ne}const $={};$[3553]=q(3553,3553,1),$[34067]=q(34067,34069,6),o.setClear(0,0,0,1),l.setClear(1),c.setClear(0),ee(2929),l.setFunc(Wd),Ae(!1),Ee(Xm),ee(2884),Z(Mn);function ee(X){u[X]!==!0&&(a.enable(X),u[X]=!0)}function W(X){u[X]!==!1&&(a.disable(X),u[X]=!1)}function le(X,Ce){return h[X]!==Ce?(a.bindFramebuffer(X,Ce),h[X]=Ce,n&&(X===36009&&(h[36160]=Ce),X===36160&&(h[36009]=Ce)),!0):!1}function K(X,Ce){let Te=f,Ye=!1;if(X)if(Te=d.get(Ce),Te===void 0&&(Te=[],d.set(Ce,Te)),X.isWebGLMultipleRenderTargets){const Ne=X.texture;if(Te.length!==Ne.length||Te[0]!==36064){for(let Ze=0,Be=Ne.length;Ze<Be;Ze++)Te[Ze]=36064+Ze;Te.length=Ne.length,Ye=!0}}else Te[0]!==36064&&(Te[0]=36064,Ye=!0);else Te[0]!==1029&&(Te[0]=1029,Ye=!0);Ye&&(t.isWebGL2?a.drawBuffers(Te):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Te))}function pe(X){return p!==X?(a.useProgram(X),p=X,!0):!1}const se={[hr]:32774,[yA]:32778,[Ng]:32779};if(n)se[Ym]=32775,se[Qd]=32776;else{const X=e.get("EXT_blend_minmax");X!==null&&(se[Ym]=X.MIN_EXT,se[Qd]=X.MAX_EXT)}const ve={[Dc]:0,[Js]:1,[xA]:768,[kg]:770,[MA]:776,[Fg]:774,[pf]:772,[wA]:769,[Ug]:771,[SA]:775,[AA]:773};function Z(X,Ce,Te,Ye,Ne,Ze,Be,ce){if(X===Mn){m===!0&&(W(3042),m=!1);return}if(m===!1&&(ee(3042),m=!0),X!==Du){if(X!==g||ce!==E){if((v!==hr||x!==hr)&&(a.blendEquation(32774),v=hr,x=hr),ce)switch(X){case qs:a.blendFuncSeparate(1,771,1,771);break;case Jm:a.blendFunc(1,1);break;case Zm:a.blendFuncSeparate(0,769,0,1);break;case Km:a.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",X);break}else switch(X){case qs:a.blendFuncSeparate(770,771,1,771);break;case Jm:a.blendFunc(770,1);break;case Zm:a.blendFuncSeparate(0,769,0,1);break;case Km:a.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",X);break}y=null,w=null,S=null,b=null,g=X,E=ce}return}Ne=Ne||Ce,Ze=Ze||Te,Be=Be||Ye,(Ce!==v||Ne!==x)&&(a.blendEquationSeparate(se[Ce],se[Ne]),v=Ce,x=Ne),(Te!==y||Ye!==w||Ze!==S||Be!==b)&&(a.blendFuncSeparate(ve[Te],ve[Ye],ve[Ze],ve[Be]),y=Te,w=Ye,S=Ze,b=Be),g=X,E=null}function oe(X,Ce){X.side===yt?W(2884):ee(2884);let Te=X.side===pi;Ce&&(Te=!Te),Ae(Te),X.blending===qs&&X.transparent===!1?Z(Mn):Z(X.blending,X.blendEquation,X.blendSrc,X.blendDst,X.blendEquationAlpha,X.blendSrcAlpha,X.blendDstAlpha,X.premultipliedAlpha),l.setFunc(X.depthFunc),l.setTest(X.depthTest),l.setMask(X.depthWrite),o.setMask(X.colorWrite);const Ye=X.stencilWrite;c.setTest(Ye),Ye&&(c.setMask(X.stencilWriteMask),c.setFunc(X.stencilFunc,X.stencilRef,X.stencilFuncMask),c.setOp(X.stencilFail,X.stencilZFail,X.stencilZPass)),ke(X.polygonOffset,X.polygonOffsetFactor,X.polygonOffsetUnits),X.alphaToCoverage===!0?ee(32926):W(32926)}function Ae(X){M!==X&&(X?a.frontFace(2304):a.frontFace(2305),M=X)}function Ee(X){X!==mA?(ee(2884),X!==T&&(X===Xm?a.cullFace(1029):X===gA?a.cullFace(1028):a.cullFace(1032))):W(2884),T=X}function Se(X){X!==I&&(P&&a.lineWidth(X),I=X)}function ke(X,Ce,Te){X?(ee(32823),(O!==Ce||R!==Te)&&(a.polygonOffset(Ce,Te),O=Ce,R=Te)):W(32823)}function ye(X){X?ee(3089):W(3089)}function ge(X){X===void 0&&(X=33984+k-1),Y!==X&&(a.activeTexture(X),Y=X)}function Fe(X,Ce){Y===null&&ge();let Te=_[Y];Te===void 0&&(Te={type:void 0,texture:void 0},_[Y]=Te),(Te.type!==X||Te.texture!==Ce)&&(a.bindTexture(X,Ce||$[X]),Te.type=X,Te.texture=Ce)}function Me(){const X=_[Y];X!==void 0&&X.type!==void 0&&(a.bindTexture(X.type,null),X.type=void 0,X.texture=void 0)}function z(){try{a.compressedTexImage2D.apply(a,arguments)}catch(X){console.error("THREE.WebGLState:",X)}}function D(){try{a.texSubImage2D.apply(a,arguments)}catch(X){console.error("THREE.WebGLState:",X)}}function U(){try{a.texSubImage3D.apply(a,arguments)}catch(X){console.error("THREE.WebGLState:",X)}}function J(){try{a.compressedTexSubImage2D.apply(a,arguments)}catch(X){console.error("THREE.WebGLState:",X)}}function be(){try{a.texStorage2D.apply(a,arguments)}catch(X){console.error("THREE.WebGLState:",X)}}function we(){try{a.texStorage3D.apply(a,arguments)}catch(X){console.error("THREE.WebGLState:",X)}}function Pe(){try{a.texImage2D.apply(a,arguments)}catch(X){console.error("THREE.WebGLState:",X)}}function ie(){try{a.texImage3D.apply(a,arguments)}catch(X){console.error("THREE.WebGLState:",X)}}function We(X){L.equals(X)===!1&&(a.scissor(X.x,X.y,X.z,X.w),L.copy(X))}function qe(X){H.equals(X)===!1&&(a.viewport(X.x,X.y,X.z,X.w),H.copy(X))}function Je(){a.disable(3042),a.disable(2884),a.disable(2929),a.disable(32823),a.disable(3089),a.disable(2960),a.disable(32926),a.blendEquation(32774),a.blendFunc(1,0),a.blendFuncSeparate(1,0,1,0),a.colorMask(!0,!0,!0,!0),a.clearColor(0,0,0,0),a.depthMask(!0),a.depthFunc(513),a.clearDepth(1),a.stencilMask(4294967295),a.stencilFunc(519,0,4294967295),a.stencilOp(7680,7680,7680),a.clearStencil(0),a.cullFace(1029),a.frontFace(2305),a.polygonOffset(0,0),a.activeTexture(33984),a.bindFramebuffer(36160,null),n===!0&&(a.bindFramebuffer(36009,null),a.bindFramebuffer(36008,null)),a.useProgram(null),a.lineWidth(1),a.scissor(0,0,a.canvas.width,a.canvas.height),a.viewport(0,0,a.canvas.width,a.canvas.height),u={},Y=null,_={},h={},d=new WeakMap,f=[],p=null,m=!1,g=null,v=null,y=null,w=null,x=null,S=null,b=null,E=!1,M=null,T=null,I=null,O=null,R=null,L.set(0,0,a.canvas.width,a.canvas.height),H.set(0,0,a.canvas.width,a.canvas.height),o.reset(),l.reset(),c.reset()}return{buffers:{color:o,depth:l,stencil:c},enable:ee,disable:W,bindFramebuffer:le,drawBuffers:K,useProgram:pe,setBlending:Z,setMaterial:oe,setFlipSided:Ae,setCullFace:Ee,setLineWidth:Se,setPolygonOffset:ke,setScissorTest:ye,activeTexture:ge,bindTexture:Fe,unbindTexture:Me,compressedTexImage2D:z,texImage2D:Pe,texImage3D:ie,texStorage2D:be,texStorage3D:we,texSubImage2D:D,texSubImage3D:U,compressedTexSubImage2D:J,scissor:We,viewport:qe,reset:Je}}function oR(a,e,t,n,i,r,s){const o=i.isWebGL2,l=i.maxTextures,c=i.maxCubemapSize,u=i.maxTextureSize,h=i.maxSamples,d=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,f=/OculusBrowser/g.test(navigator.userAgent),p=new WeakMap;let m;const g=new WeakMap;let v=!1;try{v=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function y(z,D){return v?new OffscreenCanvas(z,D):ou("canvas")}function w(z,D,U,J){let be=1;if((z.width>J||z.height>J)&&(be=J/Math.max(z.width,z.height)),be<1||D===!0)if(typeof HTMLImageElement<"u"&&z instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&z instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&z instanceof ImageBitmap){const we=D?Zd:Math.floor,Pe=we(be*z.width),ie=we(be*z.height);m===void 0&&(m=y(Pe,ie));const We=U?y(Pe,ie):m;return We.width=Pe,We.height=ie,We.getContext("2d").drawImage(z,0,0,Pe,ie),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+z.width+"x"+z.height+") to ("+Pe+"x"+ie+")."),We}else return"data"in z&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+z.width+"x"+z.height+")."),z;return z}function x(z){return _m(z.width)&&_m(z.height)}function S(z){return o?!1:z.wrapS!==bi||z.wrapT!==bi||z.minFilter!==Dt&&z.minFilter!==St}function b(z,D){return z.generateMipmaps&&D&&z.minFilter!==Dt&&z.minFilter!==St}function E(z){a.generateMipmap(z)}function M(z,D,U,J,be=!1){if(o===!1)return D;if(z!==null){if(a[z]!==void 0)return a[z];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+z+"'")}let we=D;return D===6403&&(U===5126&&(we=33326),U===5131&&(we=33325),U===5121&&(we=33321)),D===33319&&(U===5126&&(we=33328),U===5131&&(we=33327),U===5121&&(we=33323)),D===6408&&(U===5126&&(we=34836),U===5131&&(we=34842),U===5121&&(we=J===vt&&be===!1?35907:32856),U===32819&&(we=32854),U===32820&&(we=32855)),(we===33325||we===33326||we===33327||we===33328||we===34842||we===34836)&&e.get("EXT_color_buffer_float"),we}function T(z,D,U){return b(z,U)===!0||z.isFramebufferTexture&&z.minFilter!==Dt&&z.minFilter!==St?Math.log2(Math.max(D.width,D.height))+1:z.mipmaps!==void 0&&z.mipmaps.length>0?z.mipmaps.length:z.isCompressedTexture&&Array.isArray(z.image)?D.mipmaps.length:1}function I(z){return z===Dt||z===Xd||z===Jd?9728:9729}function O(z){const D=z.target;D.removeEventListener("dispose",O),k(D),D.isVideoTexture&&p.delete(D)}function R(z){const D=z.target;D.removeEventListener("dispose",R),F(D)}function k(z){const D=n.get(z);if(D.__webglInit===void 0)return;const U=z.source,J=g.get(U);if(J){const be=J[D.__cacheKey];be.usedTimes--,be.usedTimes===0&&P(z),Object.keys(J).length===0&&g.delete(U)}n.remove(z)}function P(z){const D=n.get(z);a.deleteTexture(D.__webglTexture);const U=z.source,J=g.get(U);delete J[D.__cacheKey],s.memory.textures--}function F(z){const D=z.texture,U=n.get(z),J=n.get(D);if(J.__webglTexture!==void 0&&(a.deleteTexture(J.__webglTexture),s.memory.textures--),z.depthTexture&&z.depthTexture.dispose(),z.isWebGLCubeRenderTarget)for(let be=0;be<6;be++)a.deleteFramebuffer(U.__webglFramebuffer[be]),U.__webglDepthbuffer&&a.deleteRenderbuffer(U.__webglDepthbuffer[be]);else a.deleteFramebuffer(U.__webglFramebuffer),U.__webglDepthbuffer&&a.deleteRenderbuffer(U.__webglDepthbuffer),U.__webglMultisampledFramebuffer&&a.deleteFramebuffer(U.__webglMultisampledFramebuffer),U.__webglColorRenderbuffer&&a.deleteRenderbuffer(U.__webglColorRenderbuffer),U.__webglDepthRenderbuffer&&a.deleteRenderbuffer(U.__webglDepthRenderbuffer);if(z.isWebGLMultipleRenderTargets)for(let be=0,we=D.length;be<we;be++){const Pe=n.get(D[be]);Pe.__webglTexture&&(a.deleteTexture(Pe.__webglTexture),s.memory.textures--),n.remove(D[be])}n.remove(D),n.remove(z)}let N=0;function Y(){N=0}function _(){const z=N;return z>=l&&console.warn("THREE.WebGLTextures: Trying to use "+z+" texture units while this GPU supports only "+l),N+=1,z}function G(z){const D=[];return D.push(z.wrapS),D.push(z.wrapT),D.push(z.magFilter),D.push(z.minFilter),D.push(z.anisotropy),D.push(z.internalFormat),D.push(z.format),D.push(z.type),D.push(z.generateMipmaps),D.push(z.premultiplyAlpha),D.push(z.flipY),D.push(z.unpackAlignment),D.push(z.encoding),D.join()}function j(z,D){const U=n.get(z);if(z.isVideoTexture&&Fe(z),z.isRenderTargetTexture===!1&&z.version>0&&U.__version!==z.version){const J=z.image;if(J===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(J.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{K(U,z,D);return}}t.activeTexture(33984+D),t.bindTexture(3553,U.__webglTexture)}function L(z,D){const U=n.get(z);if(z.version>0&&U.__version!==z.version){K(U,z,D);return}t.activeTexture(33984+D),t.bindTexture(35866,U.__webglTexture)}function H(z,D){const U=n.get(z);if(z.version>0&&U.__version!==z.version){K(U,z,D);return}t.activeTexture(33984+D),t.bindTexture(32879,U.__webglTexture)}function q(z,D){const U=n.get(z);if(z.version>0&&U.__version!==z.version){pe(U,z,D);return}t.activeTexture(33984+D),t.bindTexture(34067,U.__webglTexture)}const $={[vs]:10497,[bi]:33071,[Lc]:33648},ee={[Dt]:9728,[Xd]:9984,[Jd]:9986,[St]:9729,[Gg]:9985,[uo]:9987};function W(z,D,U){if(U?(a.texParameteri(z,10242,$[D.wrapS]),a.texParameteri(z,10243,$[D.wrapT]),(z===32879||z===35866)&&a.texParameteri(z,32882,$[D.wrapR]),a.texParameteri(z,10240,ee[D.magFilter]),a.texParameteri(z,10241,ee[D.minFilter])):(a.texParameteri(z,10242,33071),a.texParameteri(z,10243,33071),(z===32879||z===35866)&&a.texParameteri(z,32882,33071),(D.wrapS!==bi||D.wrapT!==bi)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),a.texParameteri(z,10240,I(D.magFilter)),a.texParameteri(z,10241,I(D.minFilter)),D.minFilter!==Dt&&D.minFilter!==St&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),e.has("EXT_texture_filter_anisotropic")===!0){const J=e.get("EXT_texture_filter_anisotropic");if(D.type===Dn&&e.has("OES_texture_float_linear")===!1||o===!1&&D.type===di&&e.has("OES_texture_half_float_linear")===!1)return;(D.anisotropy>1||n.get(D).__currentAnisotropy)&&(a.texParameterf(z,J.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(D.anisotropy,i.getMaxAnisotropy())),n.get(D).__currentAnisotropy=D.anisotropy)}}function le(z,D){let U=!1;z.__webglInit===void 0&&(z.__webglInit=!0,D.addEventListener("dispose",O));const J=D.source;let be=g.get(J);be===void 0&&(be={},g.set(J,be));const we=G(D);if(we!==z.__cacheKey){be[we]===void 0&&(be[we]={texture:a.createTexture(),usedTimes:0},s.memory.textures++,U=!0),be[we].usedTimes++;const Pe=be[z.__cacheKey];Pe!==void 0&&(be[z.__cacheKey].usedTimes--,Pe.usedTimes===0&&P(D)),z.__cacheKey=we,z.__webglTexture=be[we].texture}return U}function K(z,D,U){let J=3553;D.isDataArrayTexture&&(J=35866),D.isData3DTexture&&(J=32879);const be=le(z,D),we=D.source;if(t.activeTexture(33984+U),t.bindTexture(J,z.__webglTexture),we.version!==we.__currentVersion||be===!0){a.pixelStorei(37440,D.flipY),a.pixelStorei(37441,D.premultiplyAlpha),a.pixelStorei(3317,D.unpackAlignment),a.pixelStorei(37443,0);const Pe=S(D)&&x(D.image)===!1;let ie=w(D.image,Pe,!1,u);ie=Me(D,ie);const We=x(ie)||o,qe=r.convert(D.format,D.encoding);let Je=r.convert(D.type),X=M(D.internalFormat,qe,Je,D.encoding,D.isVideoTexture);W(J,D,We);let Ce;const Te=D.mipmaps,Ye=o&&D.isVideoTexture!==!0,Ne=z.__version===void 0||be===!0,Ze=T(D,ie,We);if(D.isDepthTexture)X=6402,o?D.type===Dn?X=36012:D.type===tl?X=33190:D.type===_s?X=35056:X=33189:D.type===Dn&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),D.format===ps&&X===6402&&D.type!==qa&&D.type!==tl&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),D.type=qa,Je=r.convert(D.type)),D.format===aa&&X===6402&&(X=34041,D.type!==_s&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),D.type=_s,Je=r.convert(D.type))),Ne&&(Ye?t.texStorage2D(3553,1,X,ie.width,ie.height):t.texImage2D(3553,0,X,ie.width,ie.height,0,qe,Je,null));else if(D.isDataTexture)if(Te.length>0&&We){Ye&&Ne&&t.texStorage2D(3553,Ze,X,Te[0].width,Te[0].height);for(let Be=0,ce=Te.length;Be<ce;Be++)Ce=Te[Be],Ye?t.texSubImage2D(3553,Be,0,0,Ce.width,Ce.height,qe,Je,Ce.data):t.texImage2D(3553,Be,X,Ce.width,Ce.height,0,qe,Je,Ce.data);D.generateMipmaps=!1}else Ye?(Ne&&t.texStorage2D(3553,Ze,X,ie.width,ie.height),t.texSubImage2D(3553,0,0,0,ie.width,ie.height,qe,Je,ie.data)):t.texImage2D(3553,0,X,ie.width,ie.height,0,qe,Je,ie.data);else if(D.isCompressedTexture){Ye&&Ne&&t.texStorage2D(3553,Ze,X,Te[0].width,Te[0].height);for(let Be=0,ce=Te.length;Be<ce;Be++)Ce=Te[Be],D.format!==Hn?qe!==null?Ye?t.compressedTexSubImage2D(3553,Be,0,0,Ce.width,Ce.height,qe,Ce.data):t.compressedTexImage2D(3553,Be,X,Ce.width,Ce.height,0,Ce.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Ye?t.texSubImage2D(3553,Be,0,0,Ce.width,Ce.height,qe,Je,Ce.data):t.texImage2D(3553,Be,X,Ce.width,Ce.height,0,qe,Je,Ce.data)}else if(D.isDataArrayTexture)Ye?(Ne&&t.texStorage3D(35866,Ze,X,ie.width,ie.height,ie.depth),t.texSubImage3D(35866,0,0,0,0,ie.width,ie.height,ie.depth,qe,Je,ie.data)):t.texImage3D(35866,0,X,ie.width,ie.height,ie.depth,0,qe,Je,ie.data);else if(D.isData3DTexture)Ye?(Ne&&t.texStorage3D(32879,Ze,X,ie.width,ie.height,ie.depth),t.texSubImage3D(32879,0,0,0,0,ie.width,ie.height,ie.depth,qe,Je,ie.data)):t.texImage3D(32879,0,X,ie.width,ie.height,ie.depth,0,qe,Je,ie.data);else if(D.isFramebufferTexture){if(Ne)if(Ye)t.texStorage2D(3553,Ze,X,ie.width,ie.height);else{let Be=ie.width,ce=ie.height;for(let _e=0;_e<Ze;_e++)t.texImage2D(3553,_e,X,Be,ce,0,qe,Je,null),Be>>=1,ce>>=1}}else if(Te.length>0&&We){Ye&&Ne&&t.texStorage2D(3553,Ze,X,Te[0].width,Te[0].height);for(let Be=0,ce=Te.length;Be<ce;Be++)Ce=Te[Be],Ye?t.texSubImage2D(3553,Be,0,0,qe,Je,Ce):t.texImage2D(3553,Be,X,qe,Je,Ce);D.generateMipmaps=!1}else Ye?(Ne&&t.texStorage2D(3553,Ze,X,ie.width,ie.height),t.texSubImage2D(3553,0,0,0,qe,Je,ie)):t.texImage2D(3553,0,X,qe,Je,ie);b(D,We)&&E(J),we.__currentVersion=we.version,D.onUpdate&&D.onUpdate(D)}z.__version=D.version}function pe(z,D,U){if(D.image.length!==6)return;const J=le(z,D),be=D.source;if(t.activeTexture(33984+U),t.bindTexture(34067,z.__webglTexture),be.version!==be.__currentVersion||J===!0){a.pixelStorei(37440,D.flipY),a.pixelStorei(37441,D.premultiplyAlpha),a.pixelStorei(3317,D.unpackAlignment),a.pixelStorei(37443,0);const we=D.isCompressedTexture||D.image[0].isCompressedTexture,Pe=D.image[0]&&D.image[0].isDataTexture,ie=[];for(let Be=0;Be<6;Be++)!we&&!Pe?ie[Be]=w(D.image[Be],!1,!0,c):ie[Be]=Pe?D.image[Be].image:D.image[Be],ie[Be]=Me(D,ie[Be]);const We=ie[0],qe=x(We)||o,Je=r.convert(D.format,D.encoding),X=r.convert(D.type),Ce=M(D.internalFormat,Je,X,D.encoding),Te=o&&D.isVideoTexture!==!0,Ye=z.__version===void 0;let Ne=T(D,We,qe);W(34067,D,qe);let Ze;if(we){Te&&Ye&&t.texStorage2D(34067,Ne,Ce,We.width,We.height);for(let Be=0;Be<6;Be++){Ze=ie[Be].mipmaps;for(let ce=0;ce<Ze.length;ce++){const _e=Ze[ce];D.format!==Hn?Je!==null?Te?t.compressedTexSubImage2D(34069+Be,ce,0,0,_e.width,_e.height,Je,_e.data):t.compressedTexImage2D(34069+Be,ce,Ce,_e.width,_e.height,0,_e.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Te?t.texSubImage2D(34069+Be,ce,0,0,_e.width,_e.height,Je,X,_e.data):t.texImage2D(34069+Be,ce,Ce,_e.width,_e.height,0,Je,X,_e.data)}}}else{Ze=D.mipmaps,Te&&Ye&&(Ze.length>0&&Ne++,t.texStorage2D(34067,Ne,Ce,ie[0].width,ie[0].height));for(let Be=0;Be<6;Be++)if(Pe){Te?t.texSubImage2D(34069+Be,0,0,0,ie[Be].width,ie[Be].height,Je,X,ie[Be].data):t.texImage2D(34069+Be,0,Ce,ie[Be].width,ie[Be].height,0,Je,X,ie[Be].data);for(let ce=0;ce<Ze.length;ce++){const pt=Ze[ce].image[Be].image;Te?t.texSubImage2D(34069+Be,ce+1,0,0,pt.width,pt.height,Je,X,pt.data):t.texImage2D(34069+Be,ce+1,Ce,pt.width,pt.height,0,Je,X,pt.data)}}else{Te?t.texSubImage2D(34069+Be,0,0,0,Je,X,ie[Be]):t.texImage2D(34069+Be,0,Ce,Je,X,ie[Be]);for(let ce=0;ce<Ze.length;ce++){const _e=Ze[ce];Te?t.texSubImage2D(34069+Be,ce+1,0,0,Je,X,_e.image[Be]):t.texImage2D(34069+Be,ce+1,Ce,Je,X,_e.image[Be])}}}b(D,qe)&&E(34067),be.__currentVersion=be.version,D.onUpdate&&D.onUpdate(D)}z.__version=D.version}function se(z,D,U,J,be){const we=r.convert(U.format,U.encoding),Pe=r.convert(U.type),ie=M(U.internalFormat,we,Pe,U.encoding);n.get(D).__hasExternalTextures||(be===32879||be===35866?t.texImage3D(be,0,ie,D.width,D.height,D.depth,0,we,Pe,null):t.texImage2D(be,0,ie,D.width,D.height,0,we,Pe,null)),t.bindFramebuffer(36160,z),ge(D)?d.framebufferTexture2DMultisampleEXT(36160,J,be,n.get(U).__webglTexture,0,ye(D)):a.framebufferTexture2D(36160,J,be,n.get(U).__webglTexture,0),t.bindFramebuffer(36160,null)}function ve(z,D,U){if(a.bindRenderbuffer(36161,z),D.depthBuffer&&!D.stencilBuffer){let J=33189;if(U||ge(D)){const be=D.depthTexture;be&&be.isDepthTexture&&(be.type===Dn?J=36012:be.type===tl&&(J=33190));const we=ye(D);ge(D)?d.renderbufferStorageMultisampleEXT(36161,we,J,D.width,D.height):a.renderbufferStorageMultisample(36161,we,J,D.width,D.height)}else a.renderbufferStorage(36161,J,D.width,D.height);a.framebufferRenderbuffer(36160,36096,36161,z)}else if(D.depthBuffer&&D.stencilBuffer){const J=ye(D);U&&ge(D)===!1?a.renderbufferStorageMultisample(36161,J,35056,D.width,D.height):ge(D)?d.renderbufferStorageMultisampleEXT(36161,J,35056,D.width,D.height):a.renderbufferStorage(36161,34041,D.width,D.height),a.framebufferRenderbuffer(36160,33306,36161,z)}else{const J=D.isWebGLMultipleRenderTargets===!0?D.texture[0]:D.texture,be=r.convert(J.format,J.encoding),we=r.convert(J.type),Pe=M(J.internalFormat,be,we,J.encoding),ie=ye(D);U&&ge(D)===!1?a.renderbufferStorageMultisample(36161,ie,Pe,D.width,D.height):ge(D)?d.renderbufferStorageMultisampleEXT(36161,ie,Pe,D.width,D.height):a.renderbufferStorage(36161,Pe,D.width,D.height)}a.bindRenderbuffer(36161,null)}function Z(z,D){if(D&&D.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,z),!(D.depthTexture&&D.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(D.depthTexture).__webglTexture||D.depthTexture.image.width!==D.width||D.depthTexture.image.height!==D.height)&&(D.depthTexture.image.width=D.width,D.depthTexture.image.height=D.height,D.depthTexture.needsUpdate=!0),j(D.depthTexture,0);const J=n.get(D.depthTexture).__webglTexture,be=ye(D);if(D.depthTexture.format===ps)ge(D)?d.framebufferTexture2DMultisampleEXT(36160,36096,3553,J,0,be):a.framebufferTexture2D(36160,36096,3553,J,0);else if(D.depthTexture.format===aa)ge(D)?d.framebufferTexture2DMultisampleEXT(36160,33306,3553,J,0,be):a.framebufferTexture2D(36160,33306,3553,J,0);else throw new Error("Unknown depthTexture format")}function oe(z){const D=n.get(z),U=z.isWebGLCubeRenderTarget===!0;if(z.depthTexture&&!D.__autoAllocateDepthBuffer){if(U)throw new Error("target.depthTexture not supported in Cube render targets");Z(D.__webglFramebuffer,z)}else if(U){D.__webglDepthbuffer=[];for(let J=0;J<6;J++)t.bindFramebuffer(36160,D.__webglFramebuffer[J]),D.__webglDepthbuffer[J]=a.createRenderbuffer(),ve(D.__webglDepthbuffer[J],z,!1)}else t.bindFramebuffer(36160,D.__webglFramebuffer),D.__webglDepthbuffer=a.createRenderbuffer(),ve(D.__webglDepthbuffer,z,!1);t.bindFramebuffer(36160,null)}function Ae(z,D,U){const J=n.get(z);D!==void 0&&se(J.__webglFramebuffer,z,z.texture,36064,3553),U!==void 0&&oe(z)}function Ee(z){const D=z.texture,U=n.get(z),J=n.get(D);z.addEventListener("dispose",R),z.isWebGLMultipleRenderTargets!==!0&&(J.__webglTexture===void 0&&(J.__webglTexture=a.createTexture()),J.__version=D.version,s.memory.textures++);const be=z.isWebGLCubeRenderTarget===!0,we=z.isWebGLMultipleRenderTargets===!0,Pe=x(z)||o;if(be){U.__webglFramebuffer=[];for(let ie=0;ie<6;ie++)U.__webglFramebuffer[ie]=a.createFramebuffer()}else if(U.__webglFramebuffer=a.createFramebuffer(),we)if(i.drawBuffers){const ie=z.texture;for(let We=0,qe=ie.length;We<qe;We++){const Je=n.get(ie[We]);Je.__webglTexture===void 0&&(Je.__webglTexture=a.createTexture(),s.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(o&&z.samples>0&&ge(z)===!1){U.__webglMultisampledFramebuffer=a.createFramebuffer(),U.__webglColorRenderbuffer=a.createRenderbuffer(),a.bindRenderbuffer(36161,U.__webglColorRenderbuffer);const ie=r.convert(D.format,D.encoding),We=r.convert(D.type),qe=M(D.internalFormat,ie,We,D.encoding),Je=ye(z);a.renderbufferStorageMultisample(36161,Je,qe,z.width,z.height),t.bindFramebuffer(36160,U.__webglMultisampledFramebuffer),a.framebufferRenderbuffer(36160,36064,36161,U.__webglColorRenderbuffer),a.bindRenderbuffer(36161,null),z.depthBuffer&&(U.__webglDepthRenderbuffer=a.createRenderbuffer(),ve(U.__webglDepthRenderbuffer,z,!0)),t.bindFramebuffer(36160,null)}if(be){t.bindTexture(34067,J.__webglTexture),W(34067,D,Pe);for(let ie=0;ie<6;ie++)se(U.__webglFramebuffer[ie],z,D,36064,34069+ie);b(D,Pe)&&E(34067),t.unbindTexture()}else if(we){const ie=z.texture;for(let We=0,qe=ie.length;We<qe;We++){const Je=ie[We],X=n.get(Je);t.bindTexture(3553,X.__webglTexture),W(3553,Je,Pe),se(U.__webglFramebuffer,z,Je,36064+We,3553),b(Je,Pe)&&E(3553)}t.unbindTexture()}else{let ie=3553;(z.isWebGL3DRenderTarget||z.isWebGLArrayRenderTarget)&&(o?ie=z.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(ie,J.__webglTexture),W(ie,D,Pe),se(U.__webglFramebuffer,z,D,36064,ie),b(D,Pe)&&E(ie),t.unbindTexture()}z.depthBuffer&&oe(z)}function Se(z){const D=x(z)||o,U=z.isWebGLMultipleRenderTargets===!0?z.texture:[z.texture];for(let J=0,be=U.length;J<be;J++){const we=U[J];if(b(we,D)){const Pe=z.isWebGLCubeRenderTarget?34067:3553,ie=n.get(we).__webglTexture;t.bindTexture(Pe,ie),E(Pe),t.unbindTexture()}}}function ke(z){if(o&&z.samples>0&&ge(z)===!1){const D=z.width,U=z.height;let J=16384;const be=[36064],we=z.stencilBuffer?33306:36096;z.depthBuffer&&be.push(we);const Pe=n.get(z),ie=Pe.__ignoreDepthValues!==void 0?Pe.__ignoreDepthValues:!1;ie===!1&&(z.depthBuffer&&(J|=256),z.stencilBuffer&&(J|=1024)),t.bindFramebuffer(36008,Pe.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,Pe.__webglFramebuffer),ie===!0&&(a.invalidateFramebuffer(36008,[we]),a.invalidateFramebuffer(36009,[we])),a.blitFramebuffer(0,0,D,U,0,0,D,U,J,9728),f&&a.invalidateFramebuffer(36008,be),t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,Pe.__webglMultisampledFramebuffer)}}function ye(z){return Math.min(h,z.samples)}function ge(z){const D=n.get(z);return o&&z.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&D.__useRenderToTexture!==!1}function Fe(z){const D=s.render.frame;p.get(z)!==D&&(p.set(z,D),z.update())}function Me(z,D){const U=z.encoding,J=z.format,be=z.type;return z.isCompressedTexture===!0||z.isVideoTexture===!0||z.format===su||U!==Fi&&(U===vt?o===!1?e.has("EXT_sRGB")===!0&&J===Hn?(z.format=su,z.minFilter=St,z.generateMipmaps=!1):D=fa.sRGBToLinear(D):(J!==Hn||be!==Fr)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",U)),D}this.allocateTextureUnit=_,this.resetTextureUnits=Y,this.setTexture2D=j,this.setTexture2DArray=L,this.setTexture3D=H,this.setTextureCube=q,this.rebindTextures=Ae,this.setupRenderTarget=Ee,this.updateRenderTargetMipmap=Se,this.updateMultisampleRenderTarget=ke,this.setupDepthRenderbuffer=oe,this.setupFrameBufferTexture=se,this.useMultisampledRTT=ge}function cS(a,e,t){const n=t.isWebGL2;function i(r,s=null){let o;if(r===Fr)return 5121;if(r===Wg)return 32819;if(r===Xg)return 32820;if(r===Vg)return 5120;if(r===jg)return 5122;if(r===qa)return 5123;if(r===Qg)return 5124;if(r===tl)return 5125;if(r===Dn)return 5126;if(r===di)return n?5131:(o=e.get("OES_texture_half_float"),o!==null?o.HALF_FLOAT_OES:null);if(r===Jg)return 6406;if(r===Hn)return 6408;if(r===Kg)return 6409;if(r===Yg)return 6410;if(r===ps)return 6402;if(r===aa)return 34041;if(r===gf)return 6403;if(r===Zg)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(r===su)return o=e.get("EXT_sRGB"),o!==null?o.SRGB_ALPHA_EXT:null;if(r===qg)return 36244;if(r===_g)return 33319;if(r===$g)return 33320;if(r===ev)return 36249;if(r===Ga||r===Va||r===ja||r===Qa)if(s===vt)if(o=e.get("WEBGL_compressed_texture_s3tc_srgb"),o!==null){if(r===Ga)return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(r===Va)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(r===ja)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(r===Qa)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(o=e.get("WEBGL_compressed_texture_s3tc"),o!==null){if(r===Ga)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(r===Va)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(r===ja)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(r===Qa)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(r===zc||r===Nc||r===kc||r===Uc)if(o=e.get("WEBGL_compressed_texture_pvrtc"),o!==null){if(r===zc)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(r===Nc)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(r===kc)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(r===Uc)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(r===tv)return o=e.get("WEBGL_compressed_texture_etc1"),o!==null?o.COMPRESSED_RGB_ETC1_WEBGL:null;if(r===Fc||r===Hc)if(o=e.get("WEBGL_compressed_texture_etc"),o!==null){if(r===Fc)return s===vt?o.COMPRESSED_SRGB8_ETC2:o.COMPRESSED_RGB8_ETC2;if(r===Hc)return s===vt?o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:o.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(r===Gc||r===Vc||r===jc||r===Qc||r===Wc||r===Xc||r===Jc||r===Zc||r===Kc||r===Yc||r===qc||r===_c||r===$c||r===eu)if(o=e.get("WEBGL_compressed_texture_astc"),o!==null){if(r===Gc)return s===vt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:o.COMPRESSED_RGBA_ASTC_4x4_KHR;if(r===Vc)return s===vt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:o.COMPRESSED_RGBA_ASTC_5x4_KHR;if(r===jc)return s===vt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:o.COMPRESSED_RGBA_ASTC_5x5_KHR;if(r===Qc)return s===vt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:o.COMPRESSED_RGBA_ASTC_6x5_KHR;if(r===Wc)return s===vt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:o.COMPRESSED_RGBA_ASTC_6x6_KHR;if(r===Xc)return s===vt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:o.COMPRESSED_RGBA_ASTC_8x5_KHR;if(r===Jc)return s===vt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:o.COMPRESSED_RGBA_ASTC_8x6_KHR;if(r===Zc)return s===vt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:o.COMPRESSED_RGBA_ASTC_8x8_KHR;if(r===Kc)return s===vt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:o.COMPRESSED_RGBA_ASTC_10x5_KHR;if(r===Yc)return s===vt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:o.COMPRESSED_RGBA_ASTC_10x6_KHR;if(r===qc)return s===vt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:o.COMPRESSED_RGBA_ASTC_10x8_KHR;if(r===_c)return s===vt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:o.COMPRESSED_RGBA_ASTC_10x10_KHR;if(r===$c)return s===vt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:o.COMPRESSED_RGBA_ASTC_12x10_KHR;if(r===eu)return s===vt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:o.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(r===tu)if(o=e.get("EXT_texture_compression_bptc"),o!==null){if(r===tu)return s===vt?o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:o.COMPRESSED_RGBA_BPTC_UNORM_EXT}else return null;return r===_s?n?34042:(o=e.get("WEBGL_depth_texture"),o!==null?o.UNSIGNED_INT_24_8_WEBGL:null):a[r]!==void 0?a[r]:null}return{convert:i}}class av extends tn{constructor(e=[]){super(),this.cameras=e}}av.prototype.isArrayCamera=!0;class fi extends gt{constructor(){super(),this.type="Group"}}fi.prototype.isGroup=!0;const lR={type:"move"};class Bp{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new fi,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new fi,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new A,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new A),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new fi,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new A,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new A),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,n){let i=null,r=null,s=null;const o=this._targetRay,l=this._grip,c=this._hand;if(e&&t.session.visibilityState!=="visible-blurred")if(o!==null&&(i=t.getPose(e.targetRaySpace,n),i!==null&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),i.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(i.linearVelocity)):o.hasLinearVelocity=!1,i.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(i.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(lR))),c&&e.hand){s=!0;for(const m of e.hand.values()){const g=t.getJointPose(m,n);if(c.joints[m.jointName]===void 0){const y=new fi;y.matrixAutoUpdate=!1,y.visible=!1,c.joints[m.jointName]=y,c.add(y)}const v=c.joints[m.jointName];g!==null&&(v.matrix.fromArray(g.transform.matrix),v.matrix.decompose(v.position,v.rotation,v.scale),v.jointRadius=g.radius),v.visible=g!==null}const u=c.joints["index-finger-tip"],h=c.joints["thumb-tip"],d=u.position.distanceTo(h.position),f=.02,p=.005;c.inputState.pinching&&d>f+p?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&d<=f-p&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(r=t.getPose(e.gripSpace,n),r!==null&&(l.matrix.fromArray(r.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),r.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(r.linearVelocity)):l.hasLinearVelocity=!1,r.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(r.angularVelocity)):l.hasAngularVelocity=!1));return o!==null&&(o.visible=i!==null),l!==null&&(l.visible=r!==null),c!==null&&(c.visible=s!==null),this}}class ov extends bn{constructor(e,t,n,i,r,s,o,l,c,u){if(u=u!==void 0?u:ps,u!==ps&&u!==aa)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&u===ps&&(n=qa),n===void 0&&u===aa&&(n=_s),super(null,i,r,s,o,l,u,n,c),this.image={width:e,height:t},this.magFilter=o!==void 0?o:Dt,this.minFilter=l!==void 0?l:Dt,this.flipY=!1,this.generateMipmaps=!1}}ov.prototype.isDepthTexture=!0;class cR extends Ss{constructor(e,t){super();const n=this;let i=null,r=1,s=null,o="local-floor",l=null,c=null,u=null,h=null,d=null,f=null;const p=t.getContextAttributes();let m=null,g=null;const v=[],y=new Map,w=new tn;w.layers.enable(1),w.viewport=new lt;const x=new tn;x.layers.enable(2),x.viewport=new lt;const S=[w,x],b=new av;b.layers.enable(1),b.layers.enable(2);let E=null,M=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(G){let j=v[G];return j===void 0&&(j=new Bp,v[G]=j),j.getTargetRaySpace()},this.getControllerGrip=function(G){let j=v[G];return j===void 0&&(j=new Bp,v[G]=j),j.getGripSpace()},this.getHand=function(G){let j=v[G];return j===void 0&&(j=new Bp,v[G]=j),j.getHandSpace()};function T(G){const j=y.get(G.inputSource);j&&j.dispatchEvent({type:G.type,data:G.inputSource})}function I(){y.forEach(function(G,j){G.disconnect(j)}),y.clear(),E=null,M=null,e.setRenderTarget(m),d=null,h=null,u=null,i=null,g=null,_.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(G){r=G,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(G){o=G,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l||s},this.setReferenceSpace=function(G){l=G},this.getBaseLayer=function(){return h!==null?h:d},this.getBinding=function(){return u},this.getFrame=function(){return f},this.getSession=function(){return i},this.setSession=async function(G){if(i=G,i!==null){if(m=e.getRenderTarget(),i.addEventListener("select",T),i.addEventListener("selectstart",T),i.addEventListener("selectend",T),i.addEventListener("squeeze",T),i.addEventListener("squeezestart",T),i.addEventListener("squeezeend",T),i.addEventListener("end",I),i.addEventListener("inputsourceschange",O),p.xrCompatible!==!0&&await t.makeXRCompatible(),i.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const j={antialias:i.renderState.layers===void 0?p.antialias:!0,alpha:p.alpha,depth:p.depth,stencil:p.stencil,framebufferScaleFactor:r};d=new XRWebGLLayer(i,t,j),i.updateRenderState({baseLayer:d}),g=new pn(d.framebufferWidth,d.framebufferHeight,{format:Hn,type:Fr,encoding:e.outputEncoding})}else{let j=null,L=null,H=null;p.depth&&(H=p.stencil?35056:33190,j=p.stencil?aa:ps,L=p.stencil?_s:qa);const q={colorFormat:e.outputEncoding===vt?35907:32856,depthFormat:H,scaleFactor:r};u=new XRWebGLBinding(i,t),h=u.createProjectionLayer(q),i.updateRenderState({layers:[h]}),g=new pn(h.textureWidth,h.textureHeight,{format:Hn,type:Fr,depthTexture:new ov(h.textureWidth,h.textureHeight,L,void 0,void 0,void 0,void 0,void 0,void 0,j),stencilBuffer:p.stencil,encoding:e.outputEncoding,samples:p.antialias?4:0});const $=e.properties.get(g);$.__ignoreDepthValues=h.ignoreDepthValues}g.isXRRenderTarget=!0,this.setFoveation(1),s=await i.requestReferenceSpace(o),_.setContext(i),_.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};function O(G){const j=i.inputSources;for(let L=0;L<j.length;L++){const H=j[L].handedness==="right"?1:0;y.set(j[L],v[H])}for(let L=0;L<G.removed.length;L++){const H=G.removed[L],q=y.get(H);q&&(q.dispatchEvent({type:"disconnected",data:H}),y.delete(H))}for(let L=0;L<G.added.length;L++){const H=G.added[L],q=y.get(H);q&&q.dispatchEvent({type:"connected",data:H})}}const R=new A,k=new A;function P(G,j,L){R.setFromMatrixPosition(j.matrixWorld),k.setFromMatrixPosition(L.matrixWorld);const H=R.distanceTo(k),q=j.projectionMatrix.elements,$=L.projectionMatrix.elements,ee=q[14]/(q[10]-1),W=q[14]/(q[10]+1),le=(q[9]+1)/q[5],K=(q[9]-1)/q[5],pe=(q[8]-1)/q[0],se=($[8]+1)/$[0],ve=ee*pe,Z=ee*se,oe=H/(-pe+se),Ae=oe*-pe;j.matrixWorld.decompose(G.position,G.quaternion,G.scale),G.translateX(Ae),G.translateZ(oe),G.matrixWorld.compose(G.position,G.quaternion,G.scale),G.matrixWorldInverse.copy(G.matrixWorld).invert();const Ee=ee+oe,Se=W+oe,ke=ve-Ae,ye=Z+(H-Ae),ge=le*W/Se*Ee,Fe=K*W/Se*Ee;G.projectionMatrix.makePerspective(ke,ye,ge,Fe,Ee,Se)}function F(G,j){j===null?G.matrixWorld.copy(G.matrix):G.matrixWorld.multiplyMatrices(j.matrixWorld,G.matrix),G.matrixWorldInverse.copy(G.matrixWorld).invert()}this.updateCamera=function(G){if(i===null)return;b.near=x.near=w.near=G.near,b.far=x.far=w.far=G.far,(E!==b.near||M!==b.far)&&(i.updateRenderState({depthNear:b.near,depthFar:b.far}),E=b.near,M=b.far);const j=G.parent,L=b.cameras;F(b,j);for(let q=0;q<L.length;q++)F(L[q],j);b.matrixWorld.decompose(b.position,b.quaternion,b.scale),G.position.copy(b.position),G.quaternion.copy(b.quaternion),G.scale.copy(b.scale),G.matrix.copy(b.matrix),G.matrixWorld.copy(b.matrixWorld);const H=G.children;for(let q=0,$=H.length;q<$;q++)H[q].updateMatrixWorld(!0);L.length===2?P(b,w,x):b.projectionMatrix.copy(w.projectionMatrix)},this.getCamera=function(){return b},this.getFoveation=function(){if(h!==null)return h.fixedFoveation;if(d!==null)return d.fixedFoveation},this.setFoveation=function(G){h!==null&&(h.fixedFoveation=G),d!==null&&d.fixedFoveation!==void 0&&(d.fixedFoveation=G)};let N=null;function Y(G,j){if(c=j.getViewerPose(l||s),f=j,c!==null){const H=c.views;d!==null&&(e.setRenderTargetFramebuffer(g,d.framebuffer),e.setRenderTarget(g));let q=!1;H.length!==b.cameras.length&&(b.cameras.length=0,q=!0);for(let $=0;$<H.length;$++){const ee=H[$];let W=null;if(d!==null)W=d.getViewport(ee);else{const K=u.getViewSubImage(h,ee);W=K.viewport,$===0&&(e.setRenderTargetTextures(g,K.colorTexture,h.ignoreDepthValues?void 0:K.depthStencilTexture),e.setRenderTarget(g))}const le=S[$];le.matrix.fromArray(ee.transform.matrix),le.projectionMatrix.fromArray(ee.projectionMatrix),le.viewport.set(W.x,W.y,W.width,W.height),$===0&&b.matrix.copy(le.matrix),q===!0&&b.cameras.push(le)}}const L=i.inputSources;for(let H=0;H<v.length;H++){const q=L[H],$=y.get(q);$!==void 0&&$.update(q,j,l||s)}N&&N(G,j),f=null}const _=new tS;_.setAnimationLoop(Y),this.setAnimationLoop=function(G){N=G},this.dispose=function(){}}}function uR(a,e){function t(m,g){m.fogColor.value.copy(g.color),g.isFog?(m.fogNear.value=g.near,m.fogFar.value=g.far):g.isFogExp2&&(m.fogDensity.value=g.density)}function n(m,g,v,y,w){g.isMeshBasicMaterial||g.isMeshLambertMaterial?i(m,g):g.isMeshToonMaterial?(i(m,g),u(m,g)):g.isMeshPhongMaterial?(i(m,g),c(m,g)):g.isMeshStandardMaterial?(i(m,g),h(m,g),g.isMeshPhysicalMaterial&&d(m,g,w)):g.isMeshMatcapMaterial?(i(m,g),f(m,g)):g.isMeshDepthMaterial?i(m,g):g.isMeshDistanceMaterial?(i(m,g),p(m,g)):g.isMeshNormalMaterial?i(m,g):g.isLineBasicMaterial?(r(m,g),g.isLineDashedMaterial&&s(m,g)):g.isPointsMaterial?o(m,g,v,y):g.isSpriteMaterial?l(m,g):g.isShadowMaterial?(m.color.value.copy(g.color),m.opacity.value=g.opacity):g.isShaderMaterial&&(g.uniformsNeedUpdate=!1)}function i(m,g){m.opacity.value=g.opacity,g.color&&m.diffuse.value.copy(g.color),g.emissive&&m.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),g.map&&(m.map.value=g.map),g.alphaMap&&(m.alphaMap.value=g.alphaMap),g.bumpMap&&(m.bumpMap.value=g.bumpMap,m.bumpScale.value=g.bumpScale,g.side===pi&&(m.bumpScale.value*=-1)),g.displacementMap&&(m.displacementMap.value=g.displacementMap,m.displacementScale.value=g.displacementScale,m.displacementBias.value=g.displacementBias),g.emissiveMap&&(m.emissiveMap.value=g.emissiveMap),g.normalMap&&(m.normalMap.value=g.normalMap,m.normalScale.value.copy(g.normalScale),g.side===pi&&m.normalScale.value.negate()),g.specularMap&&(m.specularMap.value=g.specularMap),g.alphaTest>0&&(m.alphaTest.value=g.alphaTest);const v=e.get(g).envMap;if(v&&(m.envMap.value=v,m.flipEnvMap.value=v.isCubeTexture&&v.isRenderTargetTexture===!1?-1:1,m.reflectivity.value=g.reflectivity,m.ior.value=g.ior,m.refractionRatio.value=g.refractionRatio),g.lightMap){m.lightMap.value=g.lightMap;const x=a.physicallyCorrectLights!==!0?Math.PI:1;m.lightMapIntensity.value=g.lightMapIntensity*x}g.aoMap&&(m.aoMap.value=g.aoMap,m.aoMapIntensity.value=g.aoMapIntensity);let y;g.map?y=g.map:g.specularMap?y=g.specularMap:g.displacementMap?y=g.displacementMap:g.normalMap?y=g.normalMap:g.bumpMap?y=g.bumpMap:g.roughnessMap?y=g.roughnessMap:g.metalnessMap?y=g.metalnessMap:g.alphaMap?y=g.alphaMap:g.emissiveMap?y=g.emissiveMap:g.clearcoatMap?y=g.clearcoatMap:g.clearcoatNormalMap?y=g.clearcoatNormalMap:g.clearcoatRoughnessMap?y=g.clearcoatRoughnessMap:g.specularIntensityMap?y=g.specularIntensityMap:g.specularColorMap?y=g.specularColorMap:g.transmissionMap?y=g.transmissionMap:g.thicknessMap?y=g.thicknessMap:g.sheenColorMap?y=g.sheenColorMap:g.sheenRoughnessMap&&(y=g.sheenRoughnessMap),y!==void 0&&(y.isWebGLRenderTarget&&(y=y.texture),y.matrixAutoUpdate===!0&&y.updateMatrix(),m.uvTransform.value.copy(y.matrix));let w;g.aoMap?w=g.aoMap:g.lightMap&&(w=g.lightMap),w!==void 0&&(w.isWebGLRenderTarget&&(w=w.texture),w.matrixAutoUpdate===!0&&w.updateMatrix(),m.uv2Transform.value.copy(w.matrix))}function r(m,g){m.diffuse.value.copy(g.color),m.opacity.value=g.opacity}function s(m,g){m.dashSize.value=g.dashSize,m.totalSize.value=g.dashSize+g.gapSize,m.scale.value=g.scale}function o(m,g,v,y){m.diffuse.value.copy(g.color),m.opacity.value=g.opacity,m.size.value=g.size*v,m.scale.value=y*.5,g.map&&(m.map.value=g.map),g.alphaMap&&(m.alphaMap.value=g.alphaMap),g.alphaTest>0&&(m.alphaTest.value=g.alphaTest);let w;g.map?w=g.map:g.alphaMap&&(w=g.alphaMap),w!==void 0&&(w.matrixAutoUpdate===!0&&w.updateMatrix(),m.uvTransform.value.copy(w.matrix))}function l(m,g){m.diffuse.value.copy(g.color),m.opacity.value=g.opacity,m.rotation.value=g.rotation,g.map&&(m.map.value=g.map),g.alphaMap&&(m.alphaMap.value=g.alphaMap),g.alphaTest>0&&(m.alphaTest.value=g.alphaTest);let v;g.map?v=g.map:g.alphaMap&&(v=g.alphaMap),v!==void 0&&(v.matrixAutoUpdate===!0&&v.updateMatrix(),m.uvTransform.value.copy(v.matrix))}function c(m,g){m.specular.value.copy(g.specular),m.shininess.value=Math.max(g.shininess,1e-4)}function u(m,g){g.gradientMap&&(m.gradientMap.value=g.gradientMap)}function h(m,g){m.roughness.value=g.roughness,m.metalness.value=g.metalness,g.roughnessMap&&(m.roughnessMap.value=g.roughnessMap),g.metalnessMap&&(m.metalnessMap.value=g.metalnessMap),e.get(g).envMap&&(m.envMapIntensity.value=g.envMapIntensity)}function d(m,g,v){m.ior.value=g.ior,g.sheen>0&&(m.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),m.sheenRoughness.value=g.sheenRoughness,g.sheenColorMap&&(m.sheenColorMap.value=g.sheenColorMap),g.sheenRoughnessMap&&(m.sheenRoughnessMap.value=g.sheenRoughnessMap)),g.clearcoat>0&&(m.clearcoat.value=g.clearcoat,m.clearcoatRoughness.value=g.clearcoatRoughness,g.clearcoatMap&&(m.clearcoatMap.value=g.clearcoatMap),g.clearcoatRoughnessMap&&(m.clearcoatRoughnessMap.value=g.clearcoatRoughnessMap),g.clearcoatNormalMap&&(m.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),m.clearcoatNormalMap.value=g.clearcoatNormalMap,g.side===pi&&m.clearcoatNormalScale.value.negate())),g.transmission>0&&(m.transmission.value=g.transmission,m.transmissionSamplerMap.value=v.texture,m.transmissionSamplerSize.value.set(v.width,v.height),g.transmissionMap&&(m.transmissionMap.value=g.transmissionMap),m.thickness.value=g.thickness,g.thicknessMap&&(m.thicknessMap.value=g.thicknessMap),m.attenuationDistance.value=g.attenuationDistance,m.attenuationColor.value.copy(g.attenuationColor)),m.specularIntensity.value=g.specularIntensity,m.specularColor.value.copy(g.specularColor),g.specularIntensityMap&&(m.specularIntensityMap.value=g.specularIntensityMap),g.specularColorMap&&(m.specularColorMap.value=g.specularColorMap)}function f(m,g){g.matcap&&(m.matcap.value=g.matcap)}function p(m,g){m.referencePosition.value.copy(g.referencePosition),m.nearDistance.value=g.nearDistance,m.farDistance.value=g.farDistance}return{refreshFogUniforms:t,refreshMaterialUniforms:n}}function hR(){const a=ou("canvas");return a.style.display="block",a}function Wt(a={}){const e=a.canvas!==void 0?a.canvas:hR(),t=a.context!==void 0?a.context:null,n=a.depth!==void 0?a.depth:!0,i=a.stencil!==void 0?a.stencil:!0,r=a.antialias!==void 0?a.antialias:!1,s=a.premultipliedAlpha!==void 0?a.premultipliedAlpha:!0,o=a.preserveDrawingBuffer!==void 0?a.preserveDrawingBuffer:!1,l=a.powerPreference!==void 0?a.powerPreference:"default",c=a.failIfMajorPerformanceCaveat!==void 0?a.failIfMajorPerformanceCaveat:!1;let u;t!==null?u=t.getContextAttributes().alpha:u=a.alpha!==void 0?a.alpha:!1;let h=null,d=null;const f=[],p=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=Fi,this.physicallyCorrectLights=!1,this.toneMapping=Nr,this.toneMappingExposure=1;const m=this;let g=!1,v=0,y=0,w=null,x=-1,S=null;const b=new lt,E=new lt;let M=null,T=e.width,I=e.height,O=1,R=null,k=null;const P=new lt(0,0,T,I),F=new lt(0,0,T,I);let N=!1;const Y=new El;let _=!1,G=!1,j=null;const L=new ae,H=new te,q=new A,$={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function ee(){return w===null?O:1}let W=t;function le(V,ue){for(let xe=0;xe<V.length;xe++){const me=V[xe],fe=e.getContext(me,ue);if(fe!==null)return fe}return null}try{const V={alpha:!0,depth:n,stencil:i,antialias:r,premultipliedAlpha:s,preserveDrawingBuffer:o,powerPreference:l,failIfMajorPerformanceCaveat:c};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${ff}`),e.addEventListener("webglcontextlost",X,!1),e.addEventListener("webglcontextrestored",Ce,!1),W===null){const ue=["webgl2","webgl","experimental-webgl"];if(m.isWebGL1Renderer===!0&&ue.shift(),W=le(ue,V),W===null)throw le(ue)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}W.getShaderPrecisionFormat===void 0&&(W.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(V){throw console.error("THREE.WebGLRenderer: "+V.message),V}let K,pe,se,ve,Z,oe,Ae,Ee,Se,ke,ye,ge,Fe,Me,z,D,U,J,be,we,Pe,ie,We;function qe(){K=new RC(W),pe=new MC(W,K,a),K.init(pe),ie=new cS(W,K,pe),se=new aR(W,K,pe),ve=new OC,Z=new KI,oe=new oR(W,K,se,Z,pe,ie,ve),Ae=new EC(m),Ee=new IC(m),Se=new XE(W,pe),We=new AC(W,K,Se,pe),ke=new PC(W,Se,ve,We),ye=new NC(W,ke,Se,ve),be=new zC(W,pe,oe),D=new bC(Z),ge=new ZI(m,Ae,Ee,K,pe,We,D),Fe=new uR(m,Z),Me=new qI,z=new iR(K,pe),J=new wC(m,Ae,se,ye,u,s),U=new lS(m,ye,pe),we=new SC(W,K,ve,pe),Pe=new DC(W,K,ve,pe),ve.programs=ge.programs,m.capabilities=pe,m.extensions=K,m.properties=Z,m.renderLists=Me,m.shadowMap=U,m.state=se,m.info=ve}qe();const Je=new cR(m,W);this.xr=Je,this.getContext=function(){return W},this.getContextAttributes=function(){return W.getContextAttributes()},this.forceContextLoss=function(){const V=K.get("WEBGL_lose_context");V&&V.loseContext()},this.forceContextRestore=function(){const V=K.get("WEBGL_lose_context");V&&V.restoreContext()},this.getPixelRatio=function(){return O},this.setPixelRatio=function(V){V!==void 0&&(O=V,this.setSize(T,I,!1))},this.getSize=function(V){return V.set(T,I)},this.setSize=function(V,ue,xe){if(Je.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}T=V,I=ue,e.width=Math.floor(V*O),e.height=Math.floor(ue*O),xe!==!1&&(e.style.width=V+"px",e.style.height=ue+"px"),this.setViewport(0,0,V,ue)},this.getDrawingBufferSize=function(V){return V.set(T*O,I*O).floor()},this.setDrawingBufferSize=function(V,ue,xe){T=V,I=ue,O=xe,e.width=Math.floor(V*xe),e.height=Math.floor(ue*xe),this.setViewport(0,0,V,ue)},this.getCurrentViewport=function(V){return V.copy(b)},this.getViewport=function(V){return V.copy(P)},this.setViewport=function(V,ue,xe,me){V.isVector4?P.set(V.x,V.y,V.z,V.w):P.set(V,ue,xe,me),se.viewport(b.copy(P).multiplyScalar(O).floor())},this.getScissor=function(V){return V.copy(F)},this.setScissor=function(V,ue,xe,me){V.isVector4?F.set(V.x,V.y,V.z,V.w):F.set(V,ue,xe,me),se.scissor(E.copy(F).multiplyScalar(O).floor())},this.getScissorTest=function(){return N},this.setScissorTest=function(V){se.setScissorTest(N=V)},this.setOpaqueSort=function(V){R=V},this.setTransparentSort=function(V){k=V},this.getClearColor=function(V){return V.copy(J.getClearColor())},this.setClearColor=function(){J.setClearColor.apply(J,arguments)},this.getClearAlpha=function(){return J.getClearAlpha()},this.setClearAlpha=function(){J.setClearAlpha.apply(J,arguments)},this.clear=function(V=!0,ue=!0,xe=!0){let me=0;V&&(me|=16384),ue&&(me|=256),xe&&(me|=1024),W.clear(me)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",X,!1),e.removeEventListener("webglcontextrestored",Ce,!1),Me.dispose(),z.dispose(),Z.dispose(),Ae.dispose(),Ee.dispose(),ye.dispose(),We.dispose(),ge.dispose(),Je.dispose(),Je.removeEventListener("sessionstart",ce),Je.removeEventListener("sessionend",_e),j&&(j.dispose(),j=null),pt.stop()};function X(V){V.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),g=!0}function Ce(){console.log("THREE.WebGLRenderer: Context Restored."),g=!1;const V=ve.autoReset,ue=U.enabled,xe=U.autoUpdate,me=U.needsUpdate,fe=U.type;qe(),ve.autoReset=V,U.enabled=ue,U.autoUpdate=xe,U.needsUpdate=me,U.type=fe}function Te(V){const ue=V.target;ue.removeEventListener("dispose",Te),Ye(ue)}function Ye(V){Ne(V),Z.remove(V)}function Ne(V){const ue=Z.get(V).programs;ue!==void 0&&(ue.forEach(function(xe){ge.releaseProgram(xe)}),V.isShaderMaterial&&ge.releaseShaderCache(V))}this.renderBufferDirect=function(V,ue,xe,me,fe,it){ue===null&&(ue=$);const ct=fe.isMesh&&fe.matrixWorld.determinant()<0,C=Ln(V,ue,xe,me,fe);se.setMaterial(me,ct);let B=xe.index;const Q=xe.attributes.position;if(B===null){if(Q===void 0||Q.count===0)return}else if(B.count===0)return;let ne=1;me.wireframe===!0&&(B=ke.getWireframeAttribute(xe),ne=2),We.setup(fe,me,C,xe,B);let de,he=we;B!==null&&(de=Se.get(B),he=Pe,he.setIndex(de));const Ue=B!==null?B.count:Q.count,Ge=xe.drawRange.start*ne,Qe=xe.drawRange.count*ne,Le=it!==null?it.start*ne:0,Oe=it!==null?it.count*ne:1/0,Re=Math.max(Ge,Le),Xe=Math.min(Ue,Ge+Qe,Le+Oe)-1,rt=Math.max(0,Xe-Re+1);if(rt!==0){if(fe.isMesh)me.wireframe===!0?(se.setLineWidth(me.wireframeLinewidth*ee()),he.setMode(1)):he.setMode(4);else if(fe.isLine){let ot=me.linewidth;ot===void 0&&(ot=1),se.setLineWidth(ot*ee()),fe.isLineSegments?he.setMode(1):fe.isLineLoop?he.setMode(2):he.setMode(3)}else fe.isPoints?he.setMode(0):fe.isSprite&&he.setMode(4);if(fe.isInstancedMesh)he.renderInstances(Re,rt,fe.count);else if(xe.isInstancedBufferGeometry){const ot=Math.min(xe.instanceCount,xe._maxInstanceCount);he.renderInstances(Re,rt,ot)}else he.render(Re,rt)}},this.compile=function(V,ue){d=z.get(V),d.init(),p.push(d),V.traverseVisible(function(xe){xe.isLight&&xe.layers.test(ue.layers)&&(d.pushLight(xe),xe.castShadow&&d.pushShadow(xe))}),d.setupLights(m.physicallyCorrectLights),V.traverse(function(xe){const me=xe.material;if(me)if(Array.isArray(me))for(let fe=0;fe<me.length;fe++){const it=me[fe];Gt(it,V,xe)}else Gt(me,V,xe)}),p.pop(),d=null};let Ze=null;function Be(V){Ze&&Ze(V)}function ce(){pt.stop()}function _e(){pt.start()}const pt=new tS;pt.setAnimationLoop(Be),typeof self<"u"&&pt.setContext(self),this.setAnimationLoop=function(V){Ze=V,Je.setAnimationLoop(V),V===null?pt.stop():pt.start()},Je.addEventListener("sessionstart",ce),Je.addEventListener("sessionend",_e),this.render=function(V,ue){if(ue!==void 0&&ue.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(g===!0)return;V.autoUpdate===!0&&V.updateMatrixWorld(),ue.parent===null&&ue.updateMatrixWorld(),Je.enabled===!0&&Je.isPresenting===!0&&(Je.cameraAutoUpdate===!0&&Je.updateCamera(ue),ue=Je.getCamera()),V.isScene===!0&&V.onBeforeRender(m,V,ue,w),d=z.get(V,p.length),d.init(),p.push(d),L.multiplyMatrices(ue.projectionMatrix,ue.matrixWorldInverse),Y.setFromProjectionMatrix(L),G=this.localClippingEnabled,_=D.init(this.clippingPlanes,G,ue),h=Me.get(V,f.length),h.init(),f.push(h),At(V,ue,0,m.sortObjects),h.finish(),m.sortObjects===!0&&h.sort(R,k),_===!0&&D.beginShadows();const xe=d.state.shadowsArray;if(U.render(xe,V,ue),_===!0&&D.endShadows(),this.info.autoReset===!0&&this.info.reset(),J.render(h,V),d.setupLights(m.physicallyCorrectLights),ue.isArrayCamera){const me=ue.cameras;for(let fe=0,it=me.length;fe<it;fe++){const ct=me[fe];ht(h,V,ct,ct.viewport)}}else ht(h,V,ue);w!==null&&(oe.updateMultisampleRenderTarget(w),oe.updateRenderTargetMipmap(w)),V.isScene===!0&&V.onAfterRender(m,V,ue),We.resetDefaultState(),x=-1,S=null,p.pop(),p.length>0?d=p[p.length-1]:d=null,f.pop(),f.length>0?h=f[f.length-1]:h=null};function At(V,ue,xe,me){if(V.visible===!1)return;if(V.layers.test(ue.layers)){if(V.isGroup)xe=V.renderOrder;else if(V.isLOD)V.autoUpdate===!0&&V.update(ue);else if(V.isLight)d.pushLight(V),V.castShadow&&d.pushShadow(V);else if(V.isSprite){if(!V.frustumCulled||Y.intersectsSprite(V)){me&&q.setFromMatrixPosition(V.matrixWorld).applyMatrix4(L);const ct=ye.update(V),C=V.material;C.visible&&h.push(V,ct,C,xe,q.z,null)}}else if((V.isMesh||V.isLine||V.isPoints)&&(V.isSkinnedMesh&&V.skeleton.frame!==ve.render.frame&&(V.skeleton.update(),V.skeleton.frame=ve.render.frame),!V.frustumCulled||Y.intersectsObject(V))){me&&q.setFromMatrixPosition(V.matrixWorld).applyMatrix4(L);const ct=ye.update(V),C=V.material;if(Array.isArray(C)){const B=ct.groups;for(let Q=0,ne=B.length;Q<ne;Q++){const de=B[Q],he=C[de.materialIndex];he&&he.visible&&h.push(V,ct,he,xe,q.z,de)}}else C.visible&&h.push(V,ct,C,xe,q.z,null)}}const it=V.children;for(let ct=0,C=it.length;ct<C;ct++)At(it[ct],ue,xe,me)}function ht(V,ue,xe,me){const fe=V.opaque,it=V.transmissive,ct=V.transparent;d.setupLightsView(xe),it.length>0&&sn(fe,ue,xe),me&&se.viewport(b.copy(me)),fe.length>0&&Ut(fe,ue,xe),it.length>0&&Ut(it,ue,xe),ct.length>0&&Ut(ct,ue,xe),se.buffers.depth.setTest(!0),se.buffers.depth.setMask(!0),se.buffers.color.setMask(!0),se.setPolygonOffset(!1)}function sn(V,ue,xe){const me=pe.isWebGL2;j===null&&(j=new pn(1,1,{generateMipmaps:!0,type:K.has("EXT_color_buffer_half_float")?di:Fr,minFilter:uo,samples:me&&r===!0?4:0})),m.getDrawingBufferSize(H),me?j.setSize(H.x,H.y):j.setSize(Zd(H.x),Zd(H.y));const fe=m.getRenderTarget();m.setRenderTarget(j),m.clear();const it=m.toneMapping;m.toneMapping=Nr,Ut(V,ue,xe),m.toneMapping=it,oe.updateMultisampleRenderTarget(j),oe.updateRenderTargetMipmap(j),m.setRenderTarget(fe)}function Ut(V,ue,xe){const me=ue.isScene===!0?ue.overrideMaterial:null;for(let fe=0,it=V.length;fe<it;fe++){const ct=V[fe],C=ct.object,B=ct.geometry,Q=me===null?ct.material:me,ne=ct.group;C.layers.test(xe.layers)&&mt(C,ue,xe,B,Q,ne)}}function mt(V,ue,xe,me,fe,it){V.onBeforeRender(m,ue,xe,me,fe,it),V.modelViewMatrix.multiplyMatrices(xe.matrixWorldInverse,V.matrixWorld),V.normalMatrix.getNormalMatrix(V.modelViewMatrix),fe.onBeforeRender(m,ue,xe,me,V,it),fe.transparent===!0&&fe.side===yt?(fe.side=pi,fe.needsUpdate=!0,m.renderBufferDirect(xe,ue,me,fe,V,it),fe.side=An,fe.needsUpdate=!0,m.renderBufferDirect(xe,ue,me,fe,V,it),fe.side=yt):m.renderBufferDirect(xe,ue,me,fe,V,it),V.onAfterRender(m,ue,xe,me,fe,it)}function Gt(V,ue,xe){ue.isScene!==!0&&(ue=$);const me=Z.get(V),fe=d.state.lights,it=d.state.shadowsArray,ct=fe.state.version,C=ge.getParameters(V,fe.state,it,ue,xe),B=ge.getProgramCacheKey(C);let Q=me.programs;me.environment=V.isMeshStandardMaterial?ue.environment:null,me.fog=ue.fog,me.envMap=(V.isMeshStandardMaterial?Ee:Ae).get(V.envMap||me.environment),Q===void 0&&(V.addEventListener("dispose",Te),Q=new Map,me.programs=Q);let ne=Q.get(B);if(ne!==void 0){if(me.currentProgram===ne&&me.lightsStateVersion===ct)return Bn(V,C),ne}else C.uniforms=ge.getUniforms(V),V.onBuild(xe,C,m),V.onBeforeCompile(C,m),ne=ge.acquireProgram(C,B),Q.set(B,ne),me.uniforms=C.uniforms;const de=me.uniforms;(!V.isShaderMaterial&&!V.isRawShaderMaterial||V.clipping===!0)&&(de.clippingPlanes=D.uniform),Bn(V,C),me.needsLights=vi(V),me.lightsStateVersion=ct,me.needsLights&&(de.ambientLightColor.value=fe.state.ambient,de.lightProbe.value=fe.state.probe,de.directionalLights.value=fe.state.directional,de.directionalLightShadows.value=fe.state.directionalShadow,de.spotLights.value=fe.state.spot,de.spotLightShadows.value=fe.state.spotShadow,de.rectAreaLights.value=fe.state.rectArea,de.ltc_1.value=fe.state.rectAreaLTC1,de.ltc_2.value=fe.state.rectAreaLTC2,de.pointLights.value=fe.state.point,de.pointLightShadows.value=fe.state.pointShadow,de.hemisphereLights.value=fe.state.hemi,de.directionalShadowMap.value=fe.state.directionalShadowMap,de.directionalShadowMatrix.value=fe.state.directionalShadowMatrix,de.spotShadowMap.value=fe.state.spotShadowMap,de.spotShadowMatrix.value=fe.state.spotShadowMatrix,de.pointShadowMap.value=fe.state.pointShadowMap,de.pointShadowMatrix.value=fe.state.pointShadowMatrix);const he=ne.getUniforms(),Ue=ea.seqWithValue(he.seq,de);return me.currentProgram=ne,me.uniformsList=Ue,ne}function Bn(V,ue){const xe=Z.get(V);xe.outputEncoding=ue.outputEncoding,xe.instancing=ue.instancing,xe.skinning=ue.skinning,xe.morphTargets=ue.morphTargets,xe.morphNormals=ue.morphNormals,xe.morphColors=ue.morphColors,xe.morphTargetsCount=ue.morphTargetsCount,xe.numClippingPlanes=ue.numClippingPlanes,xe.numIntersection=ue.numClipIntersection,xe.vertexAlphas=ue.vertexAlphas,xe.vertexTangents=ue.vertexTangents,xe.toneMapping=ue.toneMapping}function Ln(V,ue,xe,me,fe){ue.isScene!==!0&&(ue=$),oe.resetTextureUnits();const it=ue.fog,ct=me.isMeshStandardMaterial?ue.environment:null,C=w===null?m.outputEncoding:w.isXRRenderTarget===!0?w.texture.encoding:Fi,B=(me.isMeshStandardMaterial?Ee:Ae).get(me.envMap||ct),Q=me.vertexColors===!0&&!!xe.attributes.color&&xe.attributes.color.itemSize===4,ne=!!me.normalMap&&!!xe.attributes.tangent,de=!!xe.morphAttributes.position,he=!!xe.morphAttributes.normal,Ue=!!xe.morphAttributes.color,Ge=me.toneMapped?m.toneMapping:Nr,Qe=xe.morphAttributes.position||xe.morphAttributes.normal||xe.morphAttributes.color,Le=Qe!==void 0?Qe.length:0,Oe=Z.get(me),Re=d.state.lights;if(_===!0&&(G===!0||V!==S)){const Xt=V===S&&me.id===x;D.setState(me,V,Xt)}let Xe=!1;me.version===Oe.__version?(Oe.needsLights&&Oe.lightsStateVersion!==Re.state.version||Oe.outputEncoding!==C||fe.isInstancedMesh&&Oe.instancing===!1||!fe.isInstancedMesh&&Oe.instancing===!0||fe.isSkinnedMesh&&Oe.skinning===!1||!fe.isSkinnedMesh&&Oe.skinning===!0||Oe.envMap!==B||me.fog===!0&&Oe.fog!==it||Oe.numClippingPlanes!==void 0&&(Oe.numClippingPlanes!==D.numPlanes||Oe.numIntersection!==D.numIntersection)||Oe.vertexAlphas!==Q||Oe.vertexTangents!==ne||Oe.morphTargets!==de||Oe.morphNormals!==he||Oe.morphColors!==Ue||Oe.toneMapping!==Ge||pe.isWebGL2===!0&&Oe.morphTargetsCount!==Le)&&(Xe=!0):(Xe=!0,Oe.__version=me.version);let rt=Oe.currentProgram;Xe===!0&&(rt=Gt(me,ue,fe));let ot=!1,$e=!1,st=!1;const at=rt.getUniforms(),Ot=Oe.uniforms;if(se.useProgram(rt.program)&&(ot=!0,$e=!0,st=!0),me.id!==x&&(x=me.id,$e=!0),ot||S!==V){if(at.setValue(W,"projectionMatrix",V.projectionMatrix),pe.logarithmicDepthBuffer&&at.setValue(W,"logDepthBufFC",2/(Math.log(V.far+1)/Math.LN2)),S!==V&&(S=V,$e=!0,st=!0),me.isShaderMaterial||me.isMeshPhongMaterial||me.isMeshToonMaterial||me.isMeshStandardMaterial||me.envMap){const Xt=at.map.cameraPosition;Xt!==void 0&&Xt.setValue(W,q.setFromMatrixPosition(V.matrixWorld))}(me.isMeshPhongMaterial||me.isMeshToonMaterial||me.isMeshLambertMaterial||me.isMeshBasicMaterial||me.isMeshStandardMaterial||me.isShaderMaterial)&&at.setValue(W,"isOrthographic",V.isOrthographicCamera===!0),(me.isMeshPhongMaterial||me.isMeshToonMaterial||me.isMeshLambertMaterial||me.isMeshBasicMaterial||me.isMeshStandardMaterial||me.isShaderMaterial||me.isShadowMaterial||fe.isSkinnedMesh)&&at.setValue(W,"viewMatrix",V.matrixWorldInverse)}if(fe.isSkinnedMesh){at.setOptional(W,fe,"bindMatrix"),at.setOptional(W,fe,"bindMatrixInverse");const Xt=fe.skeleton;Xt&&(pe.floatVertexTextures?(Xt.boneTexture===null&&Xt.computeBoneTexture(),at.setValue(W,"boneTexture",Xt.boneTexture,oe),at.setValue(W,"boneTextureSize",Xt.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const Vt=xe.morphAttributes;return(Vt.position!==void 0||Vt.normal!==void 0||Vt.color!==void 0&&pe.isWebGL2===!0)&&be.update(fe,xe,me,rt),($e||Oe.receiveShadow!==fe.receiveShadow)&&(Oe.receiveShadow=fe.receiveShadow,at.setValue(W,"receiveShadow",fe.receiveShadow)),$e&&(at.setValue(W,"toneMappingExposure",m.toneMappingExposure),Oe.needsLights&&un(Ot,st),it&&me.fog===!0&&Fe.refreshFogUniforms(Ot,it),Fe.refreshMaterialUniforms(Ot,me,O,I,j),ea.upload(W,Oe.uniformsList,Ot,oe)),me.isShaderMaterial&&me.uniformsNeedUpdate===!0&&(ea.upload(W,Oe.uniformsList,Ot,oe),me.uniformsNeedUpdate=!1),me.isSpriteMaterial&&at.setValue(W,"center",fe.center),at.setValue(W,"modelViewMatrix",fe.modelViewMatrix),at.setValue(W,"normalMatrix",fe.normalMatrix),at.setValue(W,"modelMatrix",fe.matrixWorld),rt}function un(V,ue){V.ambientLightColor.needsUpdate=ue,V.lightProbe.needsUpdate=ue,V.directionalLights.needsUpdate=ue,V.directionalLightShadows.needsUpdate=ue,V.pointLights.needsUpdate=ue,V.pointLightShadows.needsUpdate=ue,V.spotLights.needsUpdate=ue,V.spotLightShadows.needsUpdate=ue,V.rectAreaLights.needsUpdate=ue,V.hemisphereLights.needsUpdate=ue}function vi(V){return V.isMeshLambertMaterial||V.isMeshToonMaterial||V.isMeshPhongMaterial||V.isMeshStandardMaterial||V.isShadowMaterial||V.isShaderMaterial&&V.lights===!0}this.getActiveCubeFace=function(){return v},this.getActiveMipmapLevel=function(){return y},this.getRenderTarget=function(){return w},this.setRenderTargetTextures=function(V,ue,xe){Z.get(V.texture).__webglTexture=ue,Z.get(V.depthTexture).__webglTexture=xe;const me=Z.get(V);me.__hasExternalTextures=!0,me.__hasExternalTextures&&(me.__autoAllocateDepthBuffer=xe===void 0,me.__autoAllocateDepthBuffer||K.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),me.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(V,ue){const xe=Z.get(V);xe.__webglFramebuffer=ue,xe.__useDefaultFramebuffer=ue===void 0},this.setRenderTarget=function(V,ue=0,xe=0){w=V,v=ue,y=xe;let me=!0;if(V){const B=Z.get(V);B.__useDefaultFramebuffer!==void 0?(se.bindFramebuffer(36160,null),me=!1):B.__webglFramebuffer===void 0?oe.setupRenderTarget(V):B.__hasExternalTextures&&oe.rebindTextures(V,Z.get(V.texture).__webglTexture,Z.get(V.depthTexture).__webglTexture)}let fe=null,it=!1,ct=!1;if(V){const B=V.texture;(B.isData3DTexture||B.isDataArrayTexture)&&(ct=!0);const Q=Z.get(V).__webglFramebuffer;V.isWebGLCubeRenderTarget?(fe=Q[ue],it=!0):pe.isWebGL2&&V.samples>0&&oe.useMultisampledRTT(V)===!1?fe=Z.get(V).__webglMultisampledFramebuffer:fe=Q,b.copy(V.viewport),E.copy(V.scissor),M=V.scissorTest}else b.copy(P).multiplyScalar(O).floor(),E.copy(F).multiplyScalar(O).floor(),M=N;if(se.bindFramebuffer(36160,fe)&&pe.drawBuffers&&me&&se.drawBuffers(V,fe),se.viewport(b),se.scissor(E),se.setScissorTest(M),it){const B=Z.get(V.texture);W.framebufferTexture2D(36160,36064,34069+ue,B.__webglTexture,xe)}else if(ct){const B=Z.get(V.texture),Q=ue||0;W.framebufferTextureLayer(36160,36064,B.__webglTexture,xe||0,Q)}x=-1},this.readRenderTargetPixels=function(V,ue,xe,me,fe,it,ct){if(!(V&&V.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let C=Z.get(V).__webglFramebuffer;if(V.isWebGLCubeRenderTarget&&ct!==void 0&&(C=C[ct]),C){se.bindFramebuffer(36160,C);try{const B=V.texture,Q=B.format,ne=B.type;if(Q!==Hn&&ie.convert(Q)!==W.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const de=ne===di&&(K.has("EXT_color_buffer_half_float")||pe.isWebGL2&&K.has("EXT_color_buffer_float"));if(ne!==Fr&&ie.convert(ne)!==W.getParameter(35738)&&!(ne===Dn&&(pe.isWebGL2||K.has("OES_texture_float")||K.has("WEBGL_color_buffer_float")))&&!de){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}ue>=0&&ue<=V.width-me&&xe>=0&&xe<=V.height-fe&&W.readPixels(ue,xe,me,fe,ie.convert(Q),ie.convert(ne),it)}finally{const B=w!==null?Z.get(w).__webglFramebuffer:null;se.bindFramebuffer(36160,B)}}},this.copyFramebufferToTexture=function(V,ue,xe=0){if(ue.isFramebufferTexture!==!0){console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");return}const me=Math.pow(2,-xe),fe=Math.floor(ue.image.width*me),it=Math.floor(ue.image.height*me);oe.setTexture2D(ue,0),W.copyTexSubImage2D(3553,xe,0,0,V.x,V.y,fe,it),se.unbindTexture()},this.copyTextureToTexture=function(V,ue,xe,me=0){const fe=ue.image.width,it=ue.image.height,ct=ie.convert(xe.format),C=ie.convert(xe.type);oe.setTexture2D(xe,0),W.pixelStorei(37440,xe.flipY),W.pixelStorei(37441,xe.premultiplyAlpha),W.pixelStorei(3317,xe.unpackAlignment),ue.isDataTexture?W.texSubImage2D(3553,me,V.x,V.y,fe,it,ct,C,ue.image.data):ue.isCompressedTexture?W.compressedTexSubImage2D(3553,me,V.x,V.y,ue.mipmaps[0].width,ue.mipmaps[0].height,ct,ue.mipmaps[0].data):W.texSubImage2D(3553,me,V.x,V.y,ct,C,ue.image),me===0&&xe.generateMipmaps&&W.generateMipmap(3553),se.unbindTexture()},this.copyTextureToTexture3D=function(V,ue,xe,me,fe=0){if(m.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const it=V.max.x-V.min.x+1,ct=V.max.y-V.min.y+1,C=V.max.z-V.min.z+1,B=ie.convert(me.format),Q=ie.convert(me.type);let ne;if(me.isData3DTexture)oe.setTexture3D(me,0),ne=32879;else if(me.isDataArrayTexture)oe.setTexture2DArray(me,0),ne=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}W.pixelStorei(37440,me.flipY),W.pixelStorei(37441,me.premultiplyAlpha),W.pixelStorei(3317,me.unpackAlignment);const de=W.getParameter(3314),he=W.getParameter(32878),Ue=W.getParameter(3316),Ge=W.getParameter(3315),Qe=W.getParameter(32877),Le=xe.isCompressedTexture?xe.mipmaps[0]:xe.image;W.pixelStorei(3314,Le.width),W.pixelStorei(32878,Le.height),W.pixelStorei(3316,V.min.x),W.pixelStorei(3315,V.min.y),W.pixelStorei(32877,V.min.z),xe.isDataTexture||xe.isData3DTexture?W.texSubImage3D(ne,fe,ue.x,ue.y,ue.z,it,ct,C,B,Q,Le.data):xe.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),W.compressedTexSubImage3D(ne,fe,ue.x,ue.y,ue.z,it,ct,C,B,Le.data)):W.texSubImage3D(ne,fe,ue.x,ue.y,ue.z,it,ct,C,B,Q,Le),W.pixelStorei(3314,de),W.pixelStorei(32878,he),W.pixelStorei(3316,Ue),W.pixelStorei(3315,Ge),W.pixelStorei(32877,Qe),fe===0&&me.generateMipmaps&&W.generateMipmap(ne),se.unbindTexture()},this.initTexture=function(V){oe.setTexture2D(V,0),se.unbindTexture()},this.resetState=function(){v=0,y=0,w=null,se.reset(),We.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}Wt.prototype.isWebGLRenderer=!0;class uS extends Wt{}uS.prototype.isWebGL1Renderer=!0;class Uu{constructor(e,t=25e-5){this.name="",this.color=new Ie(e),this.density=t}clone(){return new Uu(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}Uu.prototype.isFogExp2=!0;class Fu{constructor(e,t=1,n=1e3){this.name="",this.color=new Ie(e),this.near=t,this.far=n}clone(){return new Fu(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}Fu.prototype.isFog=!0;class Hu extends gt{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}}Hu.prototype.isScene=!0;class fo{constructor(e,t){this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=al,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Ni()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,n){e*=this.stride,n*=t.stride;for(let i=0,r=this.stride;i<r;i++)this.array[e+i]=t.array[n+i];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ni()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(t,this.stride);return n.setUsage(this.usage),n}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ni()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}fo.prototype.isInterleavedBuffer=!0;const wi=new A;class Wn{constructor(e,t,n,i=!1){this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=i===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,n=this.data.count;t<n;t++)wi.fromBufferAttribute(this,t),wi.applyMatrix4(e),this.setXYZ(t,wi.x,wi.y,wi.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)wi.fromBufferAttribute(this,t),wi.applyNormalMatrix(e),this.setXYZ(t,wi.x,wi.y,wi.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)wi.fromBufferAttribute(this,t),wi.transformDirection(e),this.setXYZ(t,wi.x,wi.y,wi.z);return this}setX(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){return this.data.array[e*this.data.stride+this.offset]}getY(e){return this.data.array[e*this.data.stride+this.offset+1]}getZ(e){return this.data.array[e*this.data.stride+this.offset+2]}getW(e){return this.data.array[e*this.data.stride+this.offset+3]}setXY(e,t,n){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this}setXYZ(e,t,n,i){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this}setXYZW(e,t,n,i,r){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this.data.array[e+3]=r,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return new wt(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Wn(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}Wn.prototype.isInterleavedBufferAttribute=!0;class Mf extends cn{constructor(e){super(),this.type="SpriteMaterial",this.color=new Ie(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}Mf.prototype.isSpriteMaterial=!0;let No;const Jl=new A,ko=new A,Uo=new A,Fo=new te,Zl=new te,hS=new ae,Th=new A,Kl=new A,Ch=new A,cy=new te,Lp=new te,uy=new te;class bf extends gt{constructor(e){if(super(),this.type="Sprite",No===void 0){No=new nt;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new fo(t,5);No.setIndex([0,1,2,0,2,3]),No.setAttribute("position",new Wn(n,3,0,!1)),No.setAttribute("uv",new Wn(n,2,3,!1))}this.geometry=No,this.material=e!==void 0?e:new Mf,this.center=new te(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),ko.setFromMatrixScale(this.matrixWorld),hS.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Uo.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&ko.multiplyScalar(-Uo.z);const n=this.material.rotation;let i,r;n!==0&&(r=Math.cos(n),i=Math.sin(n));const s=this.center;Ih(Th.set(-.5,-.5,0),Uo,s,ko,i,r),Ih(Kl.set(.5,-.5,0),Uo,s,ko,i,r),Ih(Ch.set(.5,.5,0),Uo,s,ko,i,r),cy.set(0,0),Lp.set(1,0),uy.set(1,1);let o=e.ray.intersectTriangle(Th,Kl,Ch,!1,Jl);if(o===null&&(Ih(Kl.set(-.5,.5,0),Uo,s,ko,i,r),Lp.set(0,1),o=e.ray.intersectTriangle(Th,Ch,Kl,!1,Jl),o===null))return;const l=e.ray.origin.distanceTo(Jl);l<e.near||l>e.far||t.push({distance:l,point:Jl.clone(),uv:Ht.getUV(Jl,Th,Kl,Ch,cy,Lp,uy,new te),face:null,object:this})}copy(e){return super.copy(e),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}bf.prototype.isSprite=!0;function Ih(a,e,t,n,i,r){Fo.subVectors(a,t).addScalar(.5).multiply(n),i!==void 0?(Zl.x=r*Fo.x-i*Fo.y,Zl.y=i*Fo.x+r*Fo.y):Zl.copy(Fo),a.copy(e),a.x+=Zl.x,a.y+=Zl.y,a.applyMatrix4(hS)}const Rh=new A,hy=new A;class dS extends gt{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let n=0,i=t.length;n<i;n++){const r=t[n];this.addLevel(r.object.clone(),r.distance)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0){t=Math.abs(t);const n=this.levels;let i;for(i=0;i<n.length&&!(t<n[i].distance);i++);return n.splice(i,0,{distance:t,object:e}),this.add(e),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let n,i;for(n=1,i=t.length;n<i&&!(e<t[n].distance);n++);return t[n-1].object}return null}raycast(e,t){if(this.levels.length>0){Rh.setFromMatrixPosition(this.matrixWorld);const i=e.ray.origin.distanceTo(Rh);this.getObjectForDistance(i).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){Rh.setFromMatrixPosition(e.matrixWorld),hy.setFromMatrixPosition(this.matrixWorld);const n=Rh.distanceTo(hy)/e.zoom;t[0].object.visible=!0;let i,r;for(i=1,r=t.length;i<r&&n>=t[i].distance;i++)t[i-1].object.visible=!1,t[i].object.visible=!0;for(this._currentLevel=i-1;i<r;i++)t[i].object.visible=!1}}toJSON(e){const t=super.toJSON(e);this.autoUpdate===!1&&(t.object.autoUpdate=!1),t.object.levels=[];const n=this.levels;for(let i=0,r=n.length;i<r;i++){const s=n[i];t.object.levels.push({object:s.object.uuid,distance:s.distance})}return t}}const dy=new A,fy=new lt,py=new lt,dR=new A,my=new ae;class Ef extends Ve{constructor(e,t){super(e,t),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new ae,this.bindMatrixInverse=new ae}copy(e){return super.copy(e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new lt,t=this.geometry.attributes.skinWeight;for(let n=0,i=t.count;n<i;n++){e.fromBufferAttribute(t,n);const r=1/e.manhattanLength();r!==1/0?e.multiplyScalar(r):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){const n=this.skeleton,i=this.geometry;fy.fromBufferAttribute(i.attributes.skinIndex,e),py.fromBufferAttribute(i.attributes.skinWeight,e),dy.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let r=0;r<4;r++){const s=py.getComponent(r);if(s!==0){const o=fy.getComponent(r);my.multiplyMatrices(n.bones[o].matrixWorld,n.boneInverses[o]),t.addScaledVector(dR.copy(dy).applyMatrix4(my),s)}}return t.applyMatrix4(this.bindMatrixInverse)}}Ef.prototype.isSkinnedMesh=!0;class Tf extends gt{constructor(){super(),this.type="Bone"}}Tf.prototype.isBone=!0;class Yi extends bn{constructor(e=null,t=1,n=1,i,r,s,o,l,c=Dt,u=Dt,h,d){super(null,s,o,l,c,u,i,r,h,d),this.image={data:e,width:t,height:n},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}Yi.prototype.isDataTexture=!0;const gy=new ae,fR=new ae;class Cf{constructor(e=[],t=[]){this.uuid=Ni(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let n=0,i=this.bones.length;n<i;n++)this.boneInverses.push(new ae)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const n=new ae;this.bones[e]&&n.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(n)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&n.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&(n.parent&&n.parent.isBone?(n.matrix.copy(n.parent.matrixWorld).invert(),n.matrix.multiply(n.matrixWorld)):n.matrix.copy(n.matrixWorld),n.matrix.decompose(n.position,n.quaternion,n.scale))}}update(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let r=0,s=e.length;r<s;r++){const o=e[r]?e[r].matrixWorld:fR;gy.multiplyMatrices(o,t[r]),gy.toArray(n,r*16)}i!==null&&(i.needsUpdate=!0)}clone(){return new Cf(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=QA(e),e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const n=new Yi(t,e,e,Hn,Dn);return n.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=n,this.boneTextureSize=e,this}getBoneByName(e){for(let t=0,n=this.bones.length;t<n;t++){const i=this.bones[t];if(i.name===e)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let n=0,i=e.bones.length;n<i;n++){const r=e.bones[n];let s=t[r];s===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),s=new Tf),this.bones.push(s),this.boneInverses.push(new ae().fromArray(e.boneInverses[n]))}return this.init(),this}toJSON(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,n=this.boneInverses;for(let i=0,r=t.length;i<r;i++){const s=t[i];e.bones.push(s.uuid);const o=n[i];e.boneInverses.push(o.toArray())}return e}}class yr extends wt{constructor(e,t,n,i=1){typeof n=="number"&&(i=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(e,t,n),this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}yr.prototype.isInstancedBufferAttribute=!0;const vy=new ae,yy=new ae,Ph=[],Yl=new Ve;class If extends Ve{constructor(e,t,n){super(e,t),this.instanceMatrix=new yr(new Float32Array(n*16),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(e){return super.copy(e),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}raycast(e,t){const n=this.matrixWorld,i=this.count;if(Yl.geometry=this.geometry,Yl.material=this.material,Yl.material!==void 0)for(let r=0;r<i;r++){this.getMatrixAt(r,vy),yy.multiplyMatrices(n,vy),Yl.matrixWorld=yy,Yl.raycast(e,Ph);for(let s=0,o=Ph.length;s<o;s++){const l=Ph[s];l.instanceId=r,l.object=this,t.push(l)}Ph.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new yr(new Float32Array(this.instanceMatrix.count*3),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}If.prototype.isInstancedMesh=!0;class mn extends cn{constructor(e){super(),this.type="LineBasicMaterial",this.color=new Ie(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}mn.prototype.isLineBasicMaterial=!0;const xy=new A,wy=new A,Ay=new ae,zp=new On,Dh=new rn;class $n extends gt{constructor(e=new nt,t=new mn){super(),this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,n=[0];for(let i=1,r=t.count;i<r;i++)xy.fromBufferAttribute(t,i-1),wy.fromBufferAttribute(t,i),n[i]=n[i-1],n[i]+=xy.distanceTo(wy);e.setAttribute("lineDistance",new je(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,r=e.params.Line.threshold,s=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Dh.copy(n.boundingSphere),Dh.applyMatrix4(i),Dh.radius+=r,e.ray.intersectsSphere(Dh)===!1)return;Ay.copy(i).invert(),zp.copy(e.ray).applyMatrix4(Ay);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,c=new A,u=new A,h=new A,d=new A,f=this.isLineSegments?2:1;if(n.isBufferGeometry){const p=n.index,g=n.attributes.position;if(p!==null){const v=Math.max(0,s.start),y=Math.min(p.count,s.start+s.count);for(let w=v,x=y-1;w<x;w+=f){const S=p.getX(w),b=p.getX(w+1);if(c.fromBufferAttribute(g,S),u.fromBufferAttribute(g,b),zp.distanceSqToSegment(c,u,d,h)>l)continue;d.applyMatrix4(this.matrixWorld);const M=e.ray.origin.distanceTo(d);M<e.near||M>e.far||t.push({distance:M,point:h.clone().applyMatrix4(this.matrixWorld),index:w,face:null,faceIndex:null,object:this})}}else{const v=Math.max(0,s.start),y=Math.min(g.count,s.start+s.count);for(let w=v,x=y-1;w<x;w+=f){if(c.fromBufferAttribute(g,w),u.fromBufferAttribute(g,w+1),zp.distanceSqToSegment(c,u,d,h)>l)continue;d.applyMatrix4(this.matrixWorld);const b=e.ray.origin.distanceTo(d);b<e.near||b>e.far||t.push({distance:b,point:h.clone().applyMatrix4(this.matrixWorld),index:w,face:null,faceIndex:null,object:this})}}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=i.length;r<s;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}$n.prototype.isLine=!0;const Sy=new A,My=new A;class gi extends $n{constructor(e,t){super(e,t),this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,n=[];for(let i=0,r=t.count;i<r;i+=2)Sy.fromBufferAttribute(t,i),My.fromBufferAttribute(t,i+1),n[i]=i===0?0:n[i-1],n[i+1]=n[i]+Sy.distanceTo(My);e.setAttribute("lineDistance",new je(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}gi.prototype.isLineSegments=!0;class lv extends $n{constructor(e,t){super(e,t),this.type="LineLoop"}}lv.prototype.isLineLoop=!0;class Ki extends cn{constructor(e){super(),this.type="PointsMaterial",this.color=new Ie(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}Ki.prototype.isPointsMaterial=!0;const by=new ae,eg=new On,Oh=new rn,Bh=new A;class ms extends gt{constructor(e=new nt,t=new Ki){super(),this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,r=e.params.Points.threshold,s=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Oh.copy(n.boundingSphere),Oh.applyMatrix4(i),Oh.radius+=r,e.ray.intersectsSphere(Oh)===!1)return;by.copy(i).invert(),eg.copy(e.ray).applyMatrix4(by);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o;if(n.isBufferGeometry){const c=n.index,h=n.attributes.position;if(c!==null){const d=Math.max(0,s.start),f=Math.min(c.count,s.start+s.count);for(let p=d,m=f;p<m;p++){const g=c.getX(p);Bh.fromBufferAttribute(h,g),Ey(Bh,g,l,i,e,t,this)}}else{const d=Math.max(0,s.start),f=Math.min(h.count,s.start+s.count);for(let p=d,m=f;p<m;p++)Bh.fromBufferAttribute(h,p),Ey(Bh,p,l,i,e,t,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=i.length;r<s;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}ms.prototype.isPoints=!0;function Ey(a,e,t,n,i,r,s){const o=eg.distanceSqToPoint(a);if(o<t){const l=new A;eg.closestPointToPoint(a,l),l.applyMatrix4(n);const c=i.ray.origin.distanceTo(l);if(c<i.near||c>i.far)return;r.push({distance:c,distanceToRay:Math.sqrt(o),point:l,index:e,face:null,object:s})}}class fS extends bn{constructor(e,t,n,i,r,s,o,l,c){super(e,t,n,i,r,s,o,l,c),this.minFilter=s!==void 0?s:St,this.magFilter=r!==void 0?r:St,this.generateMipmaps=!1;const u=this;function h(){u.needsUpdate=!0,e.requestVideoFrameCallback(h)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(h)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}fS.prototype.isVideoTexture=!0;class pS extends bn{constructor(e,t,n){super({width:e,height:t}),this.format=n,this.magFilter=Dt,this.minFilter=Dt,this.generateMipmaps=!1,this.needsUpdate=!0}}pS.prototype.isFramebufferTexture=!0;class cv extends bn{constructor(e,t,n,i,r,s,o,l,c,u,h,d){super(null,s,o,l,c,u,i,r,h,d),this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}cv.prototype.isCompressedTexture=!0;class mS extends bn{constructor(e,t,n,i,r,s,o,l,c){super(e,t,n,i,r,s,o,l,c),this.needsUpdate=!0}}mS.prototype.isCanvasTexture=!0;class Gi{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)}getPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t}getSpacedPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,i=this.getPoint(0),r=0;t.push(0);for(let s=1;s<=e;s++)n=this.getPoint(s/e),r+=n.distanceTo(i),t.push(r),i=n;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const n=this.getLengths();let i=0;const r=n.length;let s;t?s=t:s=e*n[r-1];let o=0,l=r-1,c;for(;o<=l;)if(i=Math.floor(o+(l-o)/2),c=n[i]-s,c<0)o=i+1;else if(c>0)l=i-1;else{l=i;break}if(i=l,n[i]===s)return i/(r-1);const u=n[i],d=n[i+1]-u,f=(s-u)/d;return(i+f)/(r-1)}getTangent(e,t){let i=e-1e-4,r=e+1e-4;i<0&&(i=0),r>1&&(r=1);const s=this.getPoint(i),o=this.getPoint(r),l=t||(s.isVector2?new te:new A);return l.copy(o).sub(s).normalize(),l}getTangentAt(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)}computeFrenetFrames(e,t){const n=new A,i=[],r=[],s=[],o=new A,l=new ae;for(let f=0;f<=e;f++){const p=f/e;i[f]=this.getTangentAt(p,new A)}r[0]=new A,s[0]=new A;let c=Number.MAX_VALUE;const u=Math.abs(i[0].x),h=Math.abs(i[0].y),d=Math.abs(i[0].z);u<=c&&(c=u,n.set(1,0,0)),h<=c&&(c=h,n.set(0,1,0)),d<=c&&n.set(0,0,1),o.crossVectors(i[0],n).normalize(),r[0].crossVectors(i[0],o),s[0].crossVectors(i[0],r[0]);for(let f=1;f<=e;f++){if(r[f]=r[f-1].clone(),s[f]=s[f-1].clone(),o.crossVectors(i[f-1],i[f]),o.length()>Number.EPSILON){o.normalize();const p=Math.acos(In(i[f-1].dot(i[f]),-1,1));r[f].applyMatrix4(l.makeRotationAxis(o,p))}s[f].crossVectors(i[f],r[f])}if(t===!0){let f=Math.acos(In(r[0].dot(r[e]),-1,1));f/=e,i[0].dot(o.crossVectors(r[0],r[e]))>0&&(f=-f);for(let p=1;p<=e;p++)r[p].applyMatrix4(l.makeRotationAxis(i[p],f*p)),s[p].crossVectors(i[p],r[p])}return{tangents:i,normals:r,binormals:s}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class Il extends Gi{constructor(e=0,t=0,n=1,i=1,r=0,s=Math.PI*2,o=!1,l=0){super(),this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=n,this.yRadius=i,this.aStartAngle=r,this.aEndAngle=s,this.aClockwise=o,this.aRotation=l}getPoint(e,t){const n=t||new te,i=Math.PI*2;let r=this.aEndAngle-this.aStartAngle;const s=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(s?r=0:r=i),this.aClockwise===!0&&!s&&(r===i?r=-i:r=r-i);const o=this.aStartAngle+e*r;let l=this.aX+this.xRadius*Math.cos(o),c=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const u=Math.cos(this.aRotation),h=Math.sin(this.aRotation),d=l-this.aX,f=c-this.aY;l=d*u-f*h+this.aX,c=d*h+f*u+this.aY}return n.set(l,c)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}Il.prototype.isEllipseCurve=!0;class uv extends Il{constructor(e,t,n,i,r,s){super(e,t,n,n,i,r,s),this.type="ArcCurve"}}uv.prototype.isArcCurve=!0;function hv(){let a=0,e=0,t=0,n=0;function i(r,s,o,l){a=r,e=o,t=-3*r+3*s-2*o-l,n=2*r-2*s+o+l}return{initCatmullRom:function(r,s,o,l,c){i(s,o,c*(o-r),c*(l-s))},initNonuniformCatmullRom:function(r,s,o,l,c,u,h){let d=(s-r)/c-(o-r)/(c+u)+(o-s)/u,f=(o-s)/u-(l-s)/(u+h)+(l-o)/h;d*=u,f*=u,i(s,o,d,f)},calc:function(r){const s=r*r,o=s*r;return a+e*r+t*s+n*o}}}const Lh=new A,Np=new hv,kp=new hv,Up=new hv;class dv extends Gi{constructor(e=[],t=!1,n="centripetal",i=.5){super(),this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=i}getPoint(e,t=new A){const n=t,i=this.points,r=i.length,s=(r-(this.closed?0:1))*e;let o=Math.floor(s),l=s-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/r)+1)*r:l===0&&o===r-1&&(o=r-2,l=1);let c,u;this.closed||o>0?c=i[(o-1)%r]:(Lh.subVectors(i[0],i[1]).add(i[0]),c=Lh);const h=i[o%r],d=i[(o+1)%r];if(this.closed||o+2<r?u=i[(o+2)%r]:(Lh.subVectors(i[r-1],i[r-2]).add(i[r-1]),u=Lh),this.curveType==="centripetal"||this.curveType==="chordal"){const f=this.curveType==="chordal"?.5:.25;let p=Math.pow(c.distanceToSquared(h),f),m=Math.pow(h.distanceToSquared(d),f),g=Math.pow(d.distanceToSquared(u),f);m<1e-4&&(m=1),p<1e-4&&(p=m),g<1e-4&&(g=m),Np.initNonuniformCatmullRom(c.x,h.x,d.x,u.x,p,m,g),kp.initNonuniformCatmullRom(c.y,h.y,d.y,u.y,p,m,g),Up.initNonuniformCatmullRom(c.z,h.z,d.z,u.z,p,m,g)}else this.curveType==="catmullrom"&&(Np.initCatmullRom(c.x,h.x,d.x,u.x,this.tension),kp.initCatmullRom(c.y,h.y,d.y,u.y,this.tension),Up.initCatmullRom(c.z,h.z,d.z,u.z,this.tension));return n.set(Np.calc(l),kp.calc(l),Up.calc(l)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new A().fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}dv.prototype.isCatmullRomCurve3=!0;function Ty(a,e,t,n,i){const r=(n-e)*.5,s=(i-t)*.5,o=a*a,l=a*o;return(2*t-2*n+r+s)*l+(-3*t+3*n-2*r-s)*o+r*a+t}function pR(a,e){const t=1-a;return t*t*e}function mR(a,e){return 2*(1-a)*a*e}function gR(a,e){return a*a*e}function wc(a,e,t,n){return pR(a,e)+mR(a,t)+gR(a,n)}function vR(a,e){const t=1-a;return t*t*t*e}function yR(a,e){const t=1-a;return 3*t*t*a*e}function xR(a,e){return 3*(1-a)*a*a*e}function wR(a,e){return a*a*a*e}function Ac(a,e,t,n,i){return vR(a,e)+yR(a,t)+xR(a,n)+wR(a,i)}class Rf extends Gi{constructor(e=new te,t=new te,n=new te,i=new te){super(),this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new te){const n=t,i=this.v0,r=this.v1,s=this.v2,o=this.v3;return n.set(Ac(e,i.x,r.x,s.x,o.x),Ac(e,i.y,r.y,s.y,o.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}Rf.prototype.isCubicBezierCurve=!0;class fv extends Gi{constructor(e=new A,t=new A,n=new A,i=new A){super(),this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new A){const n=t,i=this.v0,r=this.v1,s=this.v2,o=this.v3;return n.set(Ac(e,i.x,r.x,s.x,o.x),Ac(e,i.y,r.y,s.y,o.y),Ac(e,i.z,r.z,s.z,o.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}fv.prototype.isCubicBezierCurve3=!0;class Gu extends Gi{constructor(e=new te,t=new te){super(),this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new te){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t){const n=t||new te;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Gu.prototype.isLineCurve=!0;class gS extends Gi{constructor(e=new A,t=new A){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=e,this.v2=t}getPoint(e,t=new A){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class Pf extends Gi{constructor(e=new te,t=new te,n=new te){super(),this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new te){const n=t,i=this.v0,r=this.v1,s=this.v2;return n.set(wc(e,i.x,r.x,s.x),wc(e,i.y,r.y,s.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Pf.prototype.isQuadraticBezierCurve=!0;class Df extends Gi{constructor(e=new A,t=new A,n=new A){super(),this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new A){const n=t,i=this.v0,r=this.v1,s=this.v2;return n.set(wc(e,i.x,r.x,s.x),wc(e,i.y,r.y,s.y),wc(e,i.z,r.z,s.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Df.prototype.isQuadraticBezierCurve3=!0;class Of extends Gi{constructor(e=[]){super(),this.type="SplineCurve",this.points=e}getPoint(e,t=new te){const n=t,i=this.points,r=(i.length-1)*e,s=Math.floor(r),o=r-s,l=i[s===0?s:s-1],c=i[s],u=i[s>i.length-2?i.length-1:s+1],h=i[s>i.length-3?i.length-1:s+2];return n.set(Ty(o,l.x,c.x,u.x,h.x),Ty(o,l.y,c.y,u.y,h.y)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new te().fromArray(i))}return this}}Of.prototype.isSplineCurve=!0;var pv=Object.freeze({__proto__:null,ArcCurve:uv,CatmullRomCurve3:dv,CubicBezierCurve:Rf,CubicBezierCurve3:fv,EllipseCurve:Il,LineCurve:Gu,LineCurve3:gS,QuadraticBezierCurve:Pf,QuadraticBezierCurve3:Df,SplineCurve:Of});class vS extends Gi{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new Gu(t,e))}getPoint(e,t){const n=e*this.getLength(),i=this.getCurveLengths();let r=0;for(;r<i.length;){if(i[r]>=n){const s=i[r]-n,o=this.curves[r],l=o.getLength(),c=l===0?0:1-s/l;return o.getPointAt(c,t)}r++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,i=this.curves.length;n<i;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let n;for(let i=0,r=this.curves;i<r.length;i++){const s=r[i],o=s.isEllipseCurve?e*2:s.isLineCurve||s.isLineCurve3?1:s.isSplineCurve?e*s.points.length:e,l=s.getPoints(o);for(let c=0;c<l.length;c++){const u=l[c];n&&n.equals(u)||(t.push(u),n=u)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const i=this.curves[t];e.curves.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(new pv[i.type]().fromJSON(i))}return this}}class ll extends vS{constructor(e){super(),this.type="Path",this.currentPoint=new te,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const n=new Gu(this.currentPoint.clone(),new te(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,n,i){const r=new Pf(this.currentPoint.clone(),new te(e,t),new te(n,i));return this.curves.push(r),this.currentPoint.set(n,i),this}bezierCurveTo(e,t,n,i,r,s){const o=new Rf(this.currentPoint.clone(),new te(e,t),new te(n,i),new te(r,s));return this.curves.push(o),this.currentPoint.set(r,s),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),n=new Of(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,n,i,r,s){const o=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(e+o,t+l,n,i,r,s),this}absarc(e,t,n,i,r,s){return this.absellipse(e,t,n,n,i,r,s),this}ellipse(e,t,n,i,r,s,o,l){const c=this.currentPoint.x,u=this.currentPoint.y;return this.absellipse(e+c,t+u,n,i,r,s,o,l),this}absellipse(e,t,n,i,r,s,o,l){const c=new Il(e,t,n,i,r,s,o,l);if(this.curves.length>0){const h=c.getPoint(0);h.equals(this.currentPoint)||this.lineTo(h.x,h.y)}this.curves.push(c);const u=c.getPoint(1);return this.currentPoint.copy(u),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class _a extends nt{constructor(e=[new te(0,.5),new te(.5,0),new te(0,-.5)],t=12,n=0,i=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:n,phiLength:i},t=Math.floor(t),i=In(i,0,Math.PI*2);const r=[],s=[],o=[],l=[],c=[],u=1/t,h=new A,d=new te,f=new A,p=new A,m=new A;let g=0,v=0;for(let y=0;y<=e.length-1;y++)switch(y){case 0:g=e[y+1].x-e[y].x,v=e[y+1].y-e[y].y,f.x=v*1,f.y=-g,f.z=v*0,m.copy(f),f.normalize(),l.push(f.x,f.y,f.z);break;case e.length-1:l.push(m.x,m.y,m.z);break;default:g=e[y+1].x-e[y].x,v=e[y+1].y-e[y].y,f.x=v*1,f.y=-g,f.z=v*0,p.copy(f),f.x+=m.x,f.y+=m.y,f.z+=m.z,f.normalize(),l.push(f.x,f.y,f.z),m.copy(p)}for(let y=0;y<=t;y++){const w=n+y*u*i,x=Math.sin(w),S=Math.cos(w);for(let b=0;b<=e.length-1;b++){h.x=e[b].x*x,h.y=e[b].y,h.z=e[b].x*S,s.push(h.x,h.y,h.z),d.x=y/t,d.y=b/(e.length-1),o.push(d.x,d.y);const E=l[3*b+0]*x,M=l[3*b+1],T=l[3*b+0]*S;c.push(E,M,T)}}for(let y=0;y<t;y++)for(let w=0;w<e.length-1;w++){const x=w+y*e.length,S=x,b=x+e.length,E=x+e.length+1,M=x+1;r.push(S,b,M),r.push(E,M,b)}this.setIndex(r),this.setAttribute("position",new je(s,3)),this.setAttribute("uv",new je(o,2)),this.setAttribute("normal",new je(c,3))}static fromJSON(e){return new _a(e.points,e.segments,e.phiStart,e.phiLength)}}class cl extends _a{constructor(e=1,t=1,n=4,i=8){const r=new ll;r.absarc(0,-t/2,e,Math.PI*1.5,0),r.absarc(0,t/2,e,0,Math.PI*.5),super(r.getPoints(n),i),this.type="CapsuleGeometry",this.parameters={radius:e,height:t,capSegments:n,radialSegments:i}}static fromJSON(e){return new cl(e.radius,e.length,e.capSegments,e.radialSegments)}}class $a extends nt{constructor(e=1,t=8,n=0,i=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:n,thetaLength:i},t=Math.max(3,t);const r=[],s=[],o=[],l=[],c=new A,u=new te;s.push(0,0,0),o.push(0,0,1),l.push(.5,.5);for(let h=0,d=3;h<=t;h++,d+=3){const f=n+h/t*i;c.x=e*Math.cos(f),c.y=e*Math.sin(f),s.push(c.x,c.y,c.z),o.push(0,0,1),u.x=(s[d]/e+1)/2,u.y=(s[d+1]/e+1)/2,l.push(u.x,u.y)}for(let h=1;h<=t;h++)r.push(h,h+1,0);this.setIndex(r),this.setAttribute("position",new je(s,3)),this.setAttribute("normal",new je(o,3)),this.setAttribute("uv",new je(l,2))}static fromJSON(e){return new $a(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class yn extends nt{constructor(e=1,t=1,n=1,i=8,r=1,s=!1,o=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:i,heightSegments:r,openEnded:s,thetaStart:o,thetaLength:l};const c=this;i=Math.floor(i),r=Math.floor(r);const u=[],h=[],d=[],f=[];let p=0;const m=[],g=n/2;let v=0;y(),s===!1&&(e>0&&w(!0),t>0&&w(!1)),this.setIndex(u),this.setAttribute("position",new je(h,3)),this.setAttribute("normal",new je(d,3)),this.setAttribute("uv",new je(f,2));function y(){const x=new A,S=new A;let b=0;const E=(t-e)/n;for(let M=0;M<=r;M++){const T=[],I=M/r,O=I*(t-e)+e;for(let R=0;R<=i;R++){const k=R/i,P=k*l+o,F=Math.sin(P),N=Math.cos(P);S.x=O*F,S.y=-I*n+g,S.z=O*N,h.push(S.x,S.y,S.z),x.set(F,E,N).normalize(),d.push(x.x,x.y,x.z),f.push(k,1-I),T.push(p++)}m.push(T)}for(let M=0;M<i;M++)for(let T=0;T<r;T++){const I=m[T][M],O=m[T+1][M],R=m[T+1][M+1],k=m[T][M+1];u.push(I,O,k),u.push(O,R,k),b+=6}c.addGroup(v,b,0),v+=b}function w(x){const S=p,b=new te,E=new A;let M=0;const T=x===!0?e:t,I=x===!0?1:-1;for(let R=1;R<=i;R++)h.push(0,g*I,0),d.push(0,I,0),f.push(.5,.5),p++;const O=p;for(let R=0;R<=i;R++){const P=R/i*l+o,F=Math.cos(P),N=Math.sin(P);E.x=T*N,E.y=g*I,E.z=T*F,h.push(E.x,E.y,E.z),d.push(0,I,0),b.x=F*.5+.5,b.y=N*.5*I+.5,f.push(b.x,b.y),p++}for(let R=0;R<i;R++){const k=S+R,P=O+R;x===!0?u.push(P,P+1,k):u.push(P+1,P,k),M+=3}c.addGroup(v,M,x===!0?1:2),v+=M}}static fromJSON(e){return new yn(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class ul extends yn{constructor(e=1,t=1,n=8,i=1,r=!1,s=0,o=Math.PI*2){super(0,e,t,n,i,r,s,o),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:n,heightSegments:i,openEnded:r,thetaStart:s,thetaLength:o}}static fromJSON(e){return new ul(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class Gr extends nt{constructor(e=[],t=[],n=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:n,detail:i};const r=[],s=[];o(i),c(n),u(),this.setAttribute("position",new je(r,3)),this.setAttribute("normal",new je(r.slice(),3)),this.setAttribute("uv",new je(s,2)),i===0?this.computeVertexNormals():this.normalizeNormals();function o(y){const w=new A,x=new A,S=new A;for(let b=0;b<t.length;b+=3)f(t[b+0],w),f(t[b+1],x),f(t[b+2],S),l(w,x,S,y)}function l(y,w,x,S){const b=S+1,E=[];for(let M=0;M<=b;M++){E[M]=[];const T=y.clone().lerp(x,M/b),I=w.clone().lerp(x,M/b),O=b-M;for(let R=0;R<=O;R++)R===0&&M===b?E[M][R]=T:E[M][R]=T.clone().lerp(I,R/O)}for(let M=0;M<b;M++)for(let T=0;T<2*(b-M)-1;T++){const I=Math.floor(T/2);T%2===0?(d(E[M][I+1]),d(E[M+1][I]),d(E[M][I])):(d(E[M][I+1]),d(E[M+1][I+1]),d(E[M+1][I]))}}function c(y){const w=new A;for(let x=0;x<r.length;x+=3)w.x=r[x+0],w.y=r[x+1],w.z=r[x+2],w.normalize().multiplyScalar(y),r[x+0]=w.x,r[x+1]=w.y,r[x+2]=w.z}function u(){const y=new A;for(let w=0;w<r.length;w+=3){y.x=r[w+0],y.y=r[w+1],y.z=r[w+2];const x=g(y)/2/Math.PI+.5,S=v(y)/Math.PI+.5;s.push(x,1-S)}p(),h()}function h(){for(let y=0;y<s.length;y+=6){const w=s[y+0],x=s[y+2],S=s[y+4],b=Math.max(w,x,S),E=Math.min(w,x,S);b>.9&&E<.1&&(w<.2&&(s[y+0]+=1),x<.2&&(s[y+2]+=1),S<.2&&(s[y+4]+=1))}}function d(y){r.push(y.x,y.y,y.z)}function f(y,w){const x=y*3;w.x=e[x+0],w.y=e[x+1],w.z=e[x+2]}function p(){const y=new A,w=new A,x=new A,S=new A,b=new te,E=new te,M=new te;for(let T=0,I=0;T<r.length;T+=9,I+=6){y.set(r[T+0],r[T+1],r[T+2]),w.set(r[T+3],r[T+4],r[T+5]),x.set(r[T+6],r[T+7],r[T+8]),b.set(s[I+0],s[I+1]),E.set(s[I+2],s[I+3]),M.set(s[I+4],s[I+5]),S.copy(y).add(w).add(x).divideScalar(3);const O=g(S);m(b,I+0,y,O),m(E,I+2,w,O),m(M,I+4,x,O)}}function m(y,w,x,S){S<0&&y.x===1&&(s[w]=y.x-1),x.x===0&&x.z===0&&(s[w]=S/2/Math.PI+.5)}function g(y){return Math.atan2(y.z,-y.x)}function v(y){return Math.atan2(-y.y,Math.sqrt(y.x*y.x+y.z*y.z))}}static fromJSON(e){return new Gr(e.vertices,e.indices,e.radius,e.details)}}class hl extends Gr{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2,i=1/n,r=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-n,0,-i,n,0,i,-n,0,i,n,-i,-n,0,-i,n,0,i,-n,0,i,n,0,-n,0,-i,n,0,-i,-n,0,i,n,0,i],s=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(r,s,e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new hl(e.radius,e.detail)}}const zh=new A,Nh=new A,Fp=new A,kh=new Ht;class mv extends nt{constructor(e=null,t=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:t},e!==null){const i=Math.pow(10,4),r=Math.cos(Wa*t),s=e.getIndex(),o=e.getAttribute("position"),l=s?s.count:o.count,c=[0,0,0],u=["a","b","c"],h=new Array(3),d={},f=[];for(let p=0;p<l;p+=3){s?(c[0]=s.getX(p),c[1]=s.getX(p+1),c[2]=s.getX(p+2)):(c[0]=p,c[1]=p+1,c[2]=p+2);const{a:m,b:g,c:v}=kh;if(m.fromBufferAttribute(o,c[0]),g.fromBufferAttribute(o,c[1]),v.fromBufferAttribute(o,c[2]),kh.getNormal(Fp),h[0]=`${Math.round(m.x*i)},${Math.round(m.y*i)},${Math.round(m.z*i)}`,h[1]=`${Math.round(g.x*i)},${Math.round(g.y*i)},${Math.round(g.z*i)}`,h[2]=`${Math.round(v.x*i)},${Math.round(v.y*i)},${Math.round(v.z*i)}`,!(h[0]===h[1]||h[1]===h[2]||h[2]===h[0]))for(let y=0;y<3;y++){const w=(y+1)%3,x=h[y],S=h[w],b=kh[u[y]],E=kh[u[w]],M=`${x}_${S}`,T=`${S}_${x}`;T in d&&d[T]?(Fp.dot(d[T].normal)<=r&&(f.push(b.x,b.y,b.z),f.push(E.x,E.y,E.z)),d[T]=null):M in d||(d[M]={index0:c[y],index1:c[w],normal:Fp.clone()})}}for(const p in d)if(d[p]){const{index0:m,index1:g}=d[p];zh.fromBufferAttribute(o,m),Nh.fromBufferAttribute(o,g),f.push(zh.x,zh.y,zh.z),f.push(Nh.x,Nh.y,Nh.z)}this.setAttribute("position",new je(f,3))}}}class kr extends ll{constructor(e){super(e),this.uuid=Ni(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let n=0,i=this.holes.length;n<i;n++)t[n]=this.holes[n].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const i=this.holes[t];e.holes.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(new ll().fromJSON(i))}return this}}const AR={triangulate:function(a,e,t=2){const n=e&&e.length,i=n?e[0]*t:a.length;let r=yS(a,0,i,t,!0);const s=[];if(!r||r.next===r.prev)return s;let o,l,c,u,h,d,f;if(n&&(r=TR(a,e,r,t)),a.length>80*t){o=c=a[0],l=u=a[1];for(let p=t;p<i;p+=t)h=a[p],d=a[p+1],h<o&&(o=h),d<l&&(l=d),h>c&&(c=h),d>u&&(u=d);f=Math.max(c-o,u-l),f=f!==0?1/f:0}return lu(r,s,t,o,l,f),s}};function yS(a,e,t,n,i){let r,s;if(i===kR(a,e,t,n)>0)for(r=e;r<t;r+=n)s=Cy(r,a[r],a[r+1],s);else for(r=t-n;r>=e;r-=n)s=Cy(r,a[r],a[r+1],s);return s&&Bf(s,s.next)&&(uu(s),s=s.next),s}function oa(a,e){if(!a)return a;e||(e=a);let t=a,n;do if(n=!1,!t.steiner&&(Bf(t,t.next)||fn(t.prev,t,t.next)===0)){if(uu(t),t=e=t.prev,t===t.next)break;n=!0}else t=t.next;while(n||t!==e);return e}function lu(a,e,t,n,i,r,s){if(!a)return;!s&&r&&DR(a,n,i,r);let o=a,l,c;for(;a.prev!==a.next;){if(l=a.prev,c=a.next,r?MR(a,n,i,r):SR(a)){e.push(l.i/t),e.push(a.i/t),e.push(c.i/t),uu(a),a=c.next,o=c.next;continue}if(a=c,a===o){s?s===1?(a=bR(oa(a),e,t),lu(a,e,t,n,i,r,2)):s===2&&ER(a,e,t,n,i,r):lu(oa(a),e,t,n,i,r,1);break}}}function SR(a){const e=a.prev,t=a,n=a.next;if(fn(e,t,n)>=0)return!1;let i=a.next.next;for(;i!==a.prev;){if(_o(e.x,e.y,t.x,t.y,n.x,n.y,i.x,i.y)&&fn(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function MR(a,e,t,n){const i=a.prev,r=a,s=a.next;if(fn(i,r,s)>=0)return!1;const o=i.x<r.x?i.x<s.x?i.x:s.x:r.x<s.x?r.x:s.x,l=i.y<r.y?i.y<s.y?i.y:s.y:r.y<s.y?r.y:s.y,c=i.x>r.x?i.x>s.x?i.x:s.x:r.x>s.x?r.x:s.x,u=i.y>r.y?i.y>s.y?i.y:s.y:r.y>s.y?r.y:s.y,h=tg(o,l,e,t,n),d=tg(c,u,e,t,n);let f=a.prevZ,p=a.nextZ;for(;f&&f.z>=h&&p&&p.z<=d;){if(f!==a.prev&&f!==a.next&&_o(i.x,i.y,r.x,r.y,s.x,s.y,f.x,f.y)&&fn(f.prev,f,f.next)>=0||(f=f.prevZ,p!==a.prev&&p!==a.next&&_o(i.x,i.y,r.x,r.y,s.x,s.y,p.x,p.y)&&fn(p.prev,p,p.next)>=0))return!1;p=p.nextZ}for(;f&&f.z>=h;){if(f!==a.prev&&f!==a.next&&_o(i.x,i.y,r.x,r.y,s.x,s.y,f.x,f.y)&&fn(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;p&&p.z<=d;){if(p!==a.prev&&p!==a.next&&_o(i.x,i.y,r.x,r.y,s.x,s.y,p.x,p.y)&&fn(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}function bR(a,e,t){let n=a;do{const i=n.prev,r=n.next.next;!Bf(i,r)&&xS(i,n,n.next,r)&&cu(i,r)&&cu(r,i)&&(e.push(i.i/t),e.push(n.i/t),e.push(r.i/t),uu(n),uu(n.next),n=a=r),n=n.next}while(n!==a);return oa(n)}function ER(a,e,t,n,i,r){let s=a;do{let o=s.next.next;for(;o!==s.prev;){if(s.i!==o.i&&LR(s,o)){let l=wS(s,o);s=oa(s,s.next),l=oa(l,l.next),lu(s,e,t,n,i,r),lu(l,e,t,n,i,r);return}o=o.next}s=s.next}while(s!==a)}function TR(a,e,t,n){const i=[];let r,s,o,l,c;for(r=0,s=e.length;r<s;r++)o=e[r]*n,l=r<s-1?e[r+1]*n:a.length,c=yS(a,o,l,n,!1),c===c.next&&(c.steiner=!0),i.push(BR(c));for(i.sort(CR),r=0;r<i.length;r++)IR(i[r],t),t=oa(t,t.next);return t}function CR(a,e){return a.x-e.x}function IR(a,e){if(e=RR(a,e),e){const t=wS(e,a);oa(e,e.next),oa(t,t.next)}}function RR(a,e){let t=e;const n=a.x,i=a.y;let r=-1/0,s;do{if(i<=t.y&&i>=t.next.y&&t.next.y!==t.y){const d=t.x+(i-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(d<=n&&d>r){if(r=d,d===n){if(i===t.y)return t;if(i===t.next.y)return t.next}s=t.x<t.next.x?t:t.next}}t=t.next}while(t!==e);if(!s)return null;if(n===r)return s;const o=s,l=s.x,c=s.y;let u=1/0,h;t=s;do n>=t.x&&t.x>=l&&n!==t.x&&_o(i<c?n:r,i,l,c,i<c?r:n,i,t.x,t.y)&&(h=Math.abs(i-t.y)/(n-t.x),cu(t,a)&&(h<u||h===u&&(t.x>s.x||t.x===s.x&&PR(s,t)))&&(s=t,u=h)),t=t.next;while(t!==o);return s}function PR(a,e){return fn(a.prev,a,e.prev)<0&&fn(e.next,a,a.next)<0}function DR(a,e,t,n){let i=a;do i.z===null&&(i.z=tg(i.x,i.y,e,t,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==a);i.prevZ.nextZ=null,i.prevZ=null,OR(i)}function OR(a){let e,t,n,i,r,s,o,l,c=1;do{for(t=a,a=null,r=null,s=0;t;){for(s++,n=t,o=0,e=0;e<c&&(o++,n=n.nextZ,!!n);e++);for(l=c;o>0||l>0&&n;)o!==0&&(l===0||!n||t.z<=n.z)?(i=t,t=t.nextZ,o--):(i=n,n=n.nextZ,l--),r?r.nextZ=i:a=i,i.prevZ=r,r=i;t=n}r.nextZ=null,c*=2}while(s>1);return a}function tg(a,e,t,n,i){return a=32767*(a-t)*i,e=32767*(e-n)*i,a=(a|a<<8)&16711935,a=(a|a<<4)&252645135,a=(a|a<<2)&858993459,a=(a|a<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,a|e<<1}function BR(a){let e=a,t=a;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==a);return t}function _o(a,e,t,n,i,r,s,o){return(i-s)*(e-o)-(a-s)*(r-o)>=0&&(a-s)*(n-o)-(t-s)*(e-o)>=0&&(t-s)*(r-o)-(i-s)*(n-o)>=0}function LR(a,e){return a.next.i!==e.i&&a.prev.i!==e.i&&!zR(a,e)&&(cu(a,e)&&cu(e,a)&&NR(a,e)&&(fn(a.prev,a,e.prev)||fn(a,e.prev,e))||Bf(a,e)&&fn(a.prev,a,a.next)>0&&fn(e.prev,e,e.next)>0)}function fn(a,e,t){return(e.y-a.y)*(t.x-e.x)-(e.x-a.x)*(t.y-e.y)}function Bf(a,e){return a.x===e.x&&a.y===e.y}function xS(a,e,t,n){const i=Fh(fn(a,e,t)),r=Fh(fn(a,e,n)),s=Fh(fn(t,n,a)),o=Fh(fn(t,n,e));return!!(i!==r&&s!==o||i===0&&Uh(a,t,e)||r===0&&Uh(a,n,e)||s===0&&Uh(t,a,n)||o===0&&Uh(t,e,n))}function Uh(a,e,t){return e.x<=Math.max(a.x,t.x)&&e.x>=Math.min(a.x,t.x)&&e.y<=Math.max(a.y,t.y)&&e.y>=Math.min(a.y,t.y)}function Fh(a){return a>0?1:a<0?-1:0}function zR(a,e){let t=a;do{if(t.i!==a.i&&t.next.i!==a.i&&t.i!==e.i&&t.next.i!==e.i&&xS(t,t.next,a,e))return!0;t=t.next}while(t!==a);return!1}function cu(a,e){return fn(a.prev,a,a.next)<0?fn(a,e,a.next)>=0&&fn(a,a.prev,e)>=0:fn(a,e,a.prev)<0||fn(a,a.next,e)<0}function NR(a,e){let t=a,n=!1;const i=(a.x+e.x)/2,r=(a.y+e.y)/2;do t.y>r!=t.next.y>r&&t.next.y!==t.y&&i<(t.next.x-t.x)*(r-t.y)/(t.next.y-t.y)+t.x&&(n=!n),t=t.next;while(t!==a);return n}function wS(a,e){const t=new ng(a.i,a.x,a.y),n=new ng(e.i,e.x,e.y),i=a.next,r=e.prev;return a.next=e,e.prev=a,t.next=i,i.prev=t,n.next=t,t.prev=n,r.next=n,n.prev=r,n}function Cy(a,e,t,n){const i=new ng(a,e,t);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function uu(a){a.next.prev=a.prev,a.prev.next=a.next,a.prevZ&&(a.prevZ.nextZ=a.nextZ),a.nextZ&&(a.nextZ.prevZ=a.prevZ)}function ng(a,e,t){this.i=a,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function kR(a,e,t,n){let i=0;for(let r=e,s=t-n;r<t;r+=n)i+=(a[s]-a[r])*(a[r+1]+a[s+1]),s=r;return i}class Ur{static area(e){const t=e.length;let n=0;for(let i=t-1,r=0;r<t;i=r++)n+=e[i].x*e[r].y-e[r].x*e[i].y;return n*.5}static isClockWise(e){return Ur.area(e)<0}static triangulateShape(e,t){const n=[],i=[],r=[];Iy(e),Ry(n,e);let s=e.length;t.forEach(Iy);for(let l=0;l<t.length;l++)i.push(s),s+=t[l].length,Ry(n,t[l]);const o=AR.triangulate(n,i);for(let l=0;l<o.length;l+=3)r.push(o.slice(l,l+3));return r}}function Iy(a){const e=a.length;e>2&&a[e-1].equals(a[0])&&a.pop()}function Ry(a,e){for(let t=0;t<e.length;t++)a.push(e[t].x),a.push(e[t].y)}class Vr extends nt{constructor(e=new kr([new te(.5,.5),new te(-.5,.5),new te(-.5,-.5),new te(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const n=this,i=[],r=[];for(let o=0,l=e.length;o<l;o++){const c=e[o];s(c)}this.setAttribute("position",new je(i,3)),this.setAttribute("uv",new je(r,2)),this.computeVertexNormals();function s(o){const l=[],c=t.curveSegments!==void 0?t.curveSegments:12,u=t.steps!==void 0?t.steps:1;let h=t.depth!==void 0?t.depth:1,d=t.bevelEnabled!==void 0?t.bevelEnabled:!0,f=t.bevelThickness!==void 0?t.bevelThickness:.2,p=t.bevelSize!==void 0?t.bevelSize:f-.1,m=t.bevelOffset!==void 0?t.bevelOffset:0,g=t.bevelSegments!==void 0?t.bevelSegments:3;const v=t.extrudePath,y=t.UVGenerator!==void 0?t.UVGenerator:UR;t.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),h=t.amount);let w,x=!1,S,b,E,M;v&&(w=v.getSpacedPoints(u),x=!0,d=!1,S=v.computeFrenetFrames(u,!1),b=new A,E=new A,M=new A),d||(g=0,f=0,p=0,m=0);const T=o.extractPoints(c);let I=T.shape;const O=T.holes;if(!Ur.isClockWise(I)){I=I.reverse();for(let Z=0,oe=O.length;Z<oe;Z++){const Ae=O[Z];Ur.isClockWise(Ae)&&(O[Z]=Ae.reverse())}}const k=Ur.triangulateShape(I,O),P=I;for(let Z=0,oe=O.length;Z<oe;Z++){const Ae=O[Z];I=I.concat(Ae)}function F(Z,oe,Ae){return oe||console.error("THREE.ExtrudeGeometry: vec does not exist"),oe.clone().multiplyScalar(Ae).add(Z)}const N=I.length,Y=k.length;function _(Z,oe,Ae){let Ee,Se,ke;const ye=Z.x-oe.x,ge=Z.y-oe.y,Fe=Ae.x-Z.x,Me=Ae.y-Z.y,z=ye*ye+ge*ge,D=ye*Me-ge*Fe;if(Math.abs(D)>Number.EPSILON){const U=Math.sqrt(z),J=Math.sqrt(Fe*Fe+Me*Me),be=oe.x-ge/U,we=oe.y+ye/U,Pe=Ae.x-Me/J,ie=Ae.y+Fe/J,We=((Pe-be)*Me-(ie-we)*Fe)/(ye*Me-ge*Fe);Ee=be+ye*We-Z.x,Se=we+ge*We-Z.y;const qe=Ee*Ee+Se*Se;if(qe<=2)return new te(Ee,Se);ke=Math.sqrt(qe/2)}else{let U=!1;ye>Number.EPSILON?Fe>Number.EPSILON&&(U=!0):ye<-Number.EPSILON?Fe<-Number.EPSILON&&(U=!0):Math.sign(ge)===Math.sign(Me)&&(U=!0),U?(Ee=-ge,Se=ye,ke=Math.sqrt(z)):(Ee=ye,Se=ge,ke=Math.sqrt(z/2))}return new te(Ee/ke,Se/ke)}const G=[];for(let Z=0,oe=P.length,Ae=oe-1,Ee=Z+1;Z<oe;Z++,Ae++,Ee++)Ae===oe&&(Ae=0),Ee===oe&&(Ee=0),G[Z]=_(P[Z],P[Ae],P[Ee]);const j=[];let L,H=G.concat();for(let Z=0,oe=O.length;Z<oe;Z++){const Ae=O[Z];L=[];for(let Ee=0,Se=Ae.length,ke=Se-1,ye=Ee+1;Ee<Se;Ee++,ke++,ye++)ke===Se&&(ke=0),ye===Se&&(ye=0),L[Ee]=_(Ae[Ee],Ae[ke],Ae[ye]);j.push(L),H=H.concat(L)}for(let Z=0;Z<g;Z++){const oe=Z/g,Ae=f*Math.cos(oe*Math.PI/2),Ee=p*Math.sin(oe*Math.PI/2)+m;for(let Se=0,ke=P.length;Se<ke;Se++){const ye=F(P[Se],G[Se],Ee);le(ye.x,ye.y,-Ae)}for(let Se=0,ke=O.length;Se<ke;Se++){const ye=O[Se];L=j[Se];for(let ge=0,Fe=ye.length;ge<Fe;ge++){const Me=F(ye[ge],L[ge],Ee);le(Me.x,Me.y,-Ae)}}}const q=p+m;for(let Z=0;Z<N;Z++){const oe=d?F(I[Z],H[Z],q):I[Z];x?(E.copy(S.normals[0]).multiplyScalar(oe.x),b.copy(S.binormals[0]).multiplyScalar(oe.y),M.copy(w[0]).add(E).add(b),le(M.x,M.y,M.z)):le(oe.x,oe.y,0)}for(let Z=1;Z<=u;Z++)for(let oe=0;oe<N;oe++){const Ae=d?F(I[oe],H[oe],q):I[oe];x?(E.copy(S.normals[Z]).multiplyScalar(Ae.x),b.copy(S.binormals[Z]).multiplyScalar(Ae.y),M.copy(w[Z]).add(E).add(b),le(M.x,M.y,M.z)):le(Ae.x,Ae.y,h/u*Z)}for(let Z=g-1;Z>=0;Z--){const oe=Z/g,Ae=f*Math.cos(oe*Math.PI/2),Ee=p*Math.sin(oe*Math.PI/2)+m;for(let Se=0,ke=P.length;Se<ke;Se++){const ye=F(P[Se],G[Se],Ee);le(ye.x,ye.y,h+Ae)}for(let Se=0,ke=O.length;Se<ke;Se++){const ye=O[Se];L=j[Se];for(let ge=0,Fe=ye.length;ge<Fe;ge++){const Me=F(ye[ge],L[ge],Ee);x?le(Me.x,Me.y+w[u-1].y,w[u-1].x+Ae):le(Me.x,Me.y,h+Ae)}}}$(),ee();function $(){const Z=i.length/3;if(d){let oe=0,Ae=N*oe;for(let Ee=0;Ee<Y;Ee++){const Se=k[Ee];K(Se[2]+Ae,Se[1]+Ae,Se[0]+Ae)}oe=u+g*2,Ae=N*oe;for(let Ee=0;Ee<Y;Ee++){const Se=k[Ee];K(Se[0]+Ae,Se[1]+Ae,Se[2]+Ae)}}else{for(let oe=0;oe<Y;oe++){const Ae=k[oe];K(Ae[2],Ae[1],Ae[0])}for(let oe=0;oe<Y;oe++){const Ae=k[oe];K(Ae[0]+N*u,Ae[1]+N*u,Ae[2]+N*u)}}n.addGroup(Z,i.length/3-Z,0)}function ee(){const Z=i.length/3;let oe=0;W(P,oe),oe+=P.length;for(let Ae=0,Ee=O.length;Ae<Ee;Ae++){const Se=O[Ae];W(Se,oe),oe+=Se.length}n.addGroup(Z,i.length/3-Z,1)}function W(Z,oe){let Ae=Z.length;for(;--Ae>=0;){const Ee=Ae;let Se=Ae-1;Se<0&&(Se=Z.length-1);for(let ke=0,ye=u+g*2;ke<ye;ke++){const ge=N*ke,Fe=N*(ke+1),Me=oe+Ee+ge,z=oe+Se+ge,D=oe+Se+Fe,U=oe+Ee+Fe;pe(Me,z,D,U)}}}function le(Z,oe,Ae){l.push(Z),l.push(oe),l.push(Ae)}function K(Z,oe,Ae){se(Z),se(oe),se(Ae);const Ee=i.length/3,Se=y.generateTopUV(n,i,Ee-3,Ee-2,Ee-1);ve(Se[0]),ve(Se[1]),ve(Se[2])}function pe(Z,oe,Ae,Ee){se(Z),se(oe),se(Ee),se(oe),se(Ae),se(Ee);const Se=i.length/3,ke=y.generateSideWallUV(n,i,Se-6,Se-3,Se-2,Se-1);ve(ke[0]),ve(ke[1]),ve(ke[3]),ve(ke[1]),ve(ke[2]),ve(ke[3])}function se(Z){i.push(l[Z*3+0]),i.push(l[Z*3+1]),i.push(l[Z*3+2])}function ve(Z){r.push(Z.x),r.push(Z.y)}}}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,n=this.parameters.options;return FR(t,n,e)}static fromJSON(e,t){const n=[];for(let r=0,s=e.shapes.length;r<s;r++){const o=t[e.shapes[r]];n.push(o)}const i=e.options.extrudePath;return i!==void 0&&(e.options.extrudePath=new pv[i.type]().fromJSON(i)),new Vr(n,e.options)}}const UR={generateTopUV:function(a,e,t,n,i){const r=e[t*3],s=e[t*3+1],o=e[n*3],l=e[n*3+1],c=e[i*3],u=e[i*3+1];return[new te(r,s),new te(o,l),new te(c,u)]},generateSideWallUV:function(a,e,t,n,i,r){const s=e[t*3],o=e[t*3+1],l=e[t*3+2],c=e[n*3],u=e[n*3+1],h=e[n*3+2],d=e[i*3],f=e[i*3+1],p=e[i*3+2],m=e[r*3],g=e[r*3+1],v=e[r*3+2];return Math.abs(o-u)<Math.abs(s-c)?[new te(s,1-l),new te(c,1-h),new te(d,1-p),new te(m,1-v)]:[new te(o,1-l),new te(u,1-h),new te(f,1-p),new te(g,1-v)]}};function FR(a,e,t){if(t.shapes=[],Array.isArray(a))for(let n=0,i=a.length;n<i;n++){const r=a[n];t.shapes.push(r.uuid)}else t.shapes.push(a.uuid);return e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class dl extends Gr{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2,i=[-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],r=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(i,r,e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new dl(e.radius,e.detail)}}class mr extends Gr{constructor(e=1,t=0){const n=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],i=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(n,i,e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new mr(e.radius,e.detail)}}class fl extends nt{constructor(e=.5,t=1,n=8,i=1,r=0,s=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:n,phiSegments:i,thetaStart:r,thetaLength:s},n=Math.max(3,n),i=Math.max(1,i);const o=[],l=[],c=[],u=[];let h=e;const d=(t-e)/i,f=new A,p=new te;for(let m=0;m<=i;m++){for(let g=0;g<=n;g++){const v=r+g/n*s;f.x=h*Math.cos(v),f.y=h*Math.sin(v),l.push(f.x,f.y,f.z),c.push(0,0,1),p.x=(f.x/t+1)/2,p.y=(f.y/t+1)/2,u.push(p.x,p.y)}h+=d}for(let m=0;m<i;m++){const g=m*(n+1);for(let v=0;v<n;v++){const y=v+g,w=y,x=y+n+1,S=y+n+2,b=y+1;o.push(w,x,b),o.push(x,S,b)}}this.setIndex(o),this.setAttribute("position",new je(l,3)),this.setAttribute("normal",new je(c,3)),this.setAttribute("uv",new je(u,2))}static fromJSON(e){return new fl(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class eo extends nt{constructor(e=new kr([new te(0,.5),new te(-.5,-.5),new te(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const n=[],i=[],r=[],s=[];let o=0,l=0;if(Array.isArray(e)===!1)c(e);else for(let u=0;u<e.length;u++)c(e[u]),this.addGroup(o,l,u),o+=l,l=0;this.setIndex(n),this.setAttribute("position",new je(i,3)),this.setAttribute("normal",new je(r,3)),this.setAttribute("uv",new je(s,2));function c(u){const h=i.length/3,d=u.extractPoints(t);let f=d.shape;const p=d.holes;Ur.isClockWise(f)===!1&&(f=f.reverse());for(let g=0,v=p.length;g<v;g++){const y=p[g];Ur.isClockWise(y)===!0&&(p[g]=y.reverse())}const m=Ur.triangulateShape(f,p);for(let g=0,v=p.length;g<v;g++){const y=p[g];f=f.concat(y)}for(let g=0,v=f.length;g<v;g++){const y=f[g];i.push(y.x,y.y,0),r.push(0,0,1),s.push(y.x,y.y)}for(let g=0,v=m.length;g<v;g++){const y=m[g],w=y[0]+h,x=y[1]+h,S=y[2]+h;n.push(w,x,S),l+=3}}}toJSON(){const e=super.toJSON(),t=this.parameters.shapes;return HR(t,e)}static fromJSON(e,t){const n=[];for(let i=0,r=e.shapes.length;i<r;i++){const s=t[e.shapes[i]];n.push(s)}return new eo(n,e.curveSegments)}}function HR(a,e){if(e.shapes=[],Array.isArray(a))for(let t=0,n=a.length;t<n;t++){const i=a[t];e.shapes.push(i.uuid)}else e.shapes.push(a.uuid);return e}class xs extends nt{constructor(e=1,t=32,n=16,i=0,r=Math.PI*2,s=0,o=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:i,phiLength:r,thetaStart:s,thetaLength:o},t=Math.max(3,Math.floor(t)),n=Math.max(2,Math.floor(n));const l=Math.min(s+o,Math.PI);let c=0;const u=[],h=new A,d=new A,f=[],p=[],m=[],g=[];for(let v=0;v<=n;v++){const y=[],w=v/n;let x=0;v==0&&s==0?x=.5/t:v==n&&l==Math.PI&&(x=-.5/t);for(let S=0;S<=t;S++){const b=S/t;h.x=-e*Math.cos(i+b*r)*Math.sin(s+w*o),h.y=e*Math.cos(s+w*o),h.z=e*Math.sin(i+b*r)*Math.sin(s+w*o),p.push(h.x,h.y,h.z),d.copy(h).normalize(),m.push(d.x,d.y,d.z),g.push(b+x,1-w),y.push(c++)}u.push(y)}for(let v=0;v<n;v++)for(let y=0;y<t;y++){const w=u[v][y+1],x=u[v][y],S=u[v+1][y],b=u[v+1][y+1];(v!==0||s>0)&&f.push(w,x,b),(v!==n-1||l<Math.PI)&&f.push(x,S,b)}this.setIndex(f),this.setAttribute("position",new je(p,3)),this.setAttribute("normal",new je(m,3)),this.setAttribute("uv",new je(g,2))}static fromJSON(e){return new xs(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class pl extends Gr{constructor(e=1,t=0){const n=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],i=[2,1,0,0,3,2,1,3,0,2,3,1];super(n,i,e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new pl(e.radius,e.detail)}}class Lr extends nt{constructor(e=1,t=.4,n=8,i=6,r=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:n,tubularSegments:i,arc:r},n=Math.floor(n),i=Math.floor(i);const s=[],o=[],l=[],c=[],u=new A,h=new A,d=new A;for(let f=0;f<=n;f++)for(let p=0;p<=i;p++){const m=p/i*r,g=f/n*Math.PI*2;h.x=(e+t*Math.cos(g))*Math.cos(m),h.y=(e+t*Math.cos(g))*Math.sin(m),h.z=t*Math.sin(g),o.push(h.x,h.y,h.z),u.x=e*Math.cos(m),u.y=e*Math.sin(m),d.subVectors(h,u).normalize(),l.push(d.x,d.y,d.z),c.push(p/i),c.push(f/n)}for(let f=1;f<=n;f++)for(let p=1;p<=i;p++){const m=(i+1)*f+p-1,g=(i+1)*(f-1)+p-1,v=(i+1)*(f-1)+p,y=(i+1)*f+p;s.push(m,g,y),s.push(g,v,y)}this.setIndex(s),this.setAttribute("position",new je(o,3)),this.setAttribute("normal",new je(l,3)),this.setAttribute("uv",new je(c,2))}static fromJSON(e){return new Lr(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class ml extends nt{constructor(e=1,t=.4,n=64,i=8,r=2,s=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:n,radialSegments:i,p:r,q:s},n=Math.floor(n),i=Math.floor(i);const o=[],l=[],c=[],u=[],h=new A,d=new A,f=new A,p=new A,m=new A,g=new A,v=new A;for(let w=0;w<=n;++w){const x=w/n*r*Math.PI*2;y(x,r,s,e,f),y(x+.01,r,s,e,p),g.subVectors(p,f),v.addVectors(p,f),m.crossVectors(g,v),v.crossVectors(m,g),m.normalize(),v.normalize();for(let S=0;S<=i;++S){const b=S/i*Math.PI*2,E=-t*Math.cos(b),M=t*Math.sin(b);h.x=f.x+(E*v.x+M*m.x),h.y=f.y+(E*v.y+M*m.y),h.z=f.z+(E*v.z+M*m.z),l.push(h.x,h.y,h.z),d.subVectors(h,f).normalize(),c.push(d.x,d.y,d.z),u.push(w/n),u.push(S/i)}}for(let w=1;w<=n;w++)for(let x=1;x<=i;x++){const S=(i+1)*(w-1)+(x-1),b=(i+1)*w+(x-1),E=(i+1)*w+x,M=(i+1)*(w-1)+x;o.push(S,b,M),o.push(b,E,M)}this.setIndex(o),this.setAttribute("position",new je(l,3)),this.setAttribute("normal",new je(c,3)),this.setAttribute("uv",new je(u,2));function y(w,x,S,b,E){const M=Math.cos(w),T=Math.sin(w),I=S/x*w,O=Math.cos(I);E.x=b*(2+O)*.5*M,E.y=b*(2+O)*T*.5,E.z=b*Math.sin(I)*.5}}static fromJSON(e){return new ml(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class gl extends nt{constructor(e=new Df(new A(-1,-1,0),new A(-1,1,0),new A(1,1,0)),t=64,n=1,i=8,r=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:n,radialSegments:i,closed:r};const s=e.computeFrenetFrames(t,r);this.tangents=s.tangents,this.normals=s.normals,this.binormals=s.binormals;const o=new A,l=new A,c=new te;let u=new A;const h=[],d=[],f=[],p=[];m(),this.setIndex(p),this.setAttribute("position",new je(h,3)),this.setAttribute("normal",new je(d,3)),this.setAttribute("uv",new je(f,2));function m(){for(let w=0;w<t;w++)g(w);g(r===!1?t:0),y(),v()}function g(w){u=e.getPointAt(w/t,u);const x=s.normals[w],S=s.binormals[w];for(let b=0;b<=i;b++){const E=b/i*Math.PI*2,M=Math.sin(E),T=-Math.cos(E);l.x=T*x.x+M*S.x,l.y=T*x.y+M*S.y,l.z=T*x.z+M*S.z,l.normalize(),d.push(l.x,l.y,l.z),o.x=u.x+n*l.x,o.y=u.y+n*l.y,o.z=u.z+n*l.z,h.push(o.x,o.y,o.z)}}function v(){for(let w=1;w<=t;w++)for(let x=1;x<=i;x++){const S=(i+1)*(w-1)+(x-1),b=(i+1)*w+(x-1),E=(i+1)*w+x,M=(i+1)*(w-1)+x;p.push(S,b,M),p.push(b,E,M)}}function y(){for(let w=0;w<=t;w++)for(let x=0;x<=i;x++)c.x=w/t,c.y=x/i,f.push(c.x,c.y)}}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new gl(new pv[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class Lf extends nt{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},e!==null){const t=[],n=new Set,i=new A,r=new A;if(e.index!==null){const s=e.attributes.position,o=e.index;let l=e.groups;l.length===0&&(l=[{start:0,count:o.count,materialIndex:0}]);for(let c=0,u=l.length;c<u;++c){const h=l[c],d=h.start,f=h.count;for(let p=d,m=d+f;p<m;p+=3)for(let g=0;g<3;g++){const v=o.getX(p+g),y=o.getX(p+(g+1)%3);i.fromBufferAttribute(s,v),r.fromBufferAttribute(s,y),Py(i,r,n)===!0&&(t.push(i.x,i.y,i.z),t.push(r.x,r.y,r.z))}}}else{const s=e.attributes.position;for(let o=0,l=s.count/3;o<l;o++)for(let c=0;c<3;c++){const u=3*o+c,h=3*o+(c+1)%3;i.fromBufferAttribute(s,u),r.fromBufferAttribute(s,h),Py(i,r,n)===!0&&(t.push(i.x,i.y,i.z),t.push(r.x,r.y,r.z))}}this.setAttribute("position",new je(t,3))}}}function Py(a,e,t){const n=`${a.x},${a.y},${a.z}-${e.x},${e.y},${e.z}`,i=`${e.x},${e.y},${e.z}-${a.x},${a.y},${a.z}`;return t.has(n)===!0||t.has(i)===!0?!1:(t.add(n),t.add(i),!0)}var Dy=Object.freeze({__proto__:null,BoxGeometry:Tn,BoxBufferGeometry:Tn,CapsuleGeometry:cl,CapsuleBufferGeometry:cl,CircleGeometry:$a,CircleBufferGeometry:$a,ConeGeometry:ul,ConeBufferGeometry:ul,CylinderGeometry:yn,CylinderBufferGeometry:yn,DodecahedronGeometry:hl,DodecahedronBufferGeometry:hl,EdgesGeometry:mv,ExtrudeGeometry:Vr,ExtrudeBufferGeometry:Vr,IcosahedronGeometry:dl,IcosahedronBufferGeometry:dl,LatheGeometry:_a,LatheBufferGeometry:_a,OctahedronGeometry:mr,OctahedronBufferGeometry:mr,PlaneGeometry:Hi,PlaneBufferGeometry:Hi,PolyhedronGeometry:Gr,PolyhedronBufferGeometry:Gr,RingGeometry:fl,RingBufferGeometry:fl,ShapeGeometry:eo,ShapeBufferGeometry:eo,SphereGeometry:xs,SphereBufferGeometry:xs,TetrahedronGeometry:pl,TetrahedronBufferGeometry:pl,TorusGeometry:Lr,TorusBufferGeometry:Lr,TorusKnotGeometry:ml,TorusKnotBufferGeometry:ml,TubeGeometry:gl,TubeBufferGeometry:gl,WireframeGeometry:Lf});class gv extends cn{constructor(e){super(),this.type="ShadowMaterial",this.color=new Ie(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}gv.prototype.isShadowMaterial=!0;class vv extends gn{constructor(e){super(e),this.type="RawShaderMaterial"}}vv.prototype.isRawShaderMaterial=!0;class Vu extends cn{constructor(e){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Ie(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ie(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ho,this.normalScale=new te(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}Vu.prototype.isMeshStandardMaterial=!0;class yv extends Vu{constructor(e){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new te(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return In(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.sheenColor=new Ie(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new Ie(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Ie(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._transmission=0,this.setValues(e)}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}yv.prototype.isMeshPhysicalMaterial=!0;class zf extends cn{constructor(e){super(),this.type="MeshPhongMaterial",this.color=new Ie(16777215),this.specular=new Ie(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ie(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ho,this.normalScale=new te(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ou,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}zf.prototype.isMeshPhongMaterial=!0;class xv extends cn{constructor(e){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Ie(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ie(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ho,this.normalScale=new te(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}xv.prototype.isMeshToonMaterial=!0;class Nf extends cn{constructor(e){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ho,this.normalScale=new te(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}Nf.prototype.isMeshNormalMaterial=!0;class wv extends cn{constructor(e){super(),this.type="MeshLambertMaterial",this.color=new Ie(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ie(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ou,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}wv.prototype.isMeshLambertMaterial=!0;class kf extends cn{constructor(e){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Ie(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ho,this.normalScale=new te(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}kf.prototype.isMeshMatcapMaterial=!0;class Av extends mn{constructor(e){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}Av.prototype.isLineDashedMaterial=!0;const GR={ShadowMaterial:gv,SpriteMaterial:Mf,RawShaderMaterial:vv,ShaderMaterial:gn,PointsMaterial:Ki,MeshPhysicalMaterial:yv,MeshStandardMaterial:Vu,MeshPhongMaterial:zf,MeshToonMaterial:xv,MeshNormalMaterial:Nf,MeshLambertMaterial:wv,MeshDepthMaterial:Cl,MeshDistanceMaterial:ku,MeshBasicMaterial:ti,MeshMatcapMaterial:kf,LineDashedMaterial:Av,LineBasicMaterial:mn,Material:cn};cn.fromType=function(a){return new GR[a]};const $t={arraySlice:function(a,e,t){return $t.isTypedArray(a)?new a.constructor(a.subarray(e,t!==void 0?t:a.length)):a.slice(e,t)},convertArray:function(a,e,t){return!a||!t&&a.constructor===e?a:typeof e.BYTES_PER_ELEMENT=="number"?new e(a):Array.prototype.slice.call(a)},isTypedArray:function(a){return ArrayBuffer.isView(a)&&!(a instanceof DataView)},getKeyframeOrder:function(a){function e(i,r){return a[i]-a[r]}const t=a.length,n=new Array(t);for(let i=0;i!==t;++i)n[i]=i;return n.sort(e),n},sortedArray:function(a,e,t){const n=a.length,i=new a.constructor(n);for(let r=0,s=0;s!==n;++r){const o=t[r]*e;for(let l=0;l!==e;++l)i[s++]=a[o+l]}return i},flattenJSON:function(a,e,t,n){let i=1,r=a[0];for(;r!==void 0&&r[n]===void 0;)r=a[i++];if(r===void 0)return;let s=r[n];if(s!==void 0)if(Array.isArray(s))do s=r[n],s!==void 0&&(e.push(r.time),t.push.apply(t,s)),r=a[i++];while(r!==void 0);else if(s.toArray!==void 0)do s=r[n],s!==void 0&&(e.push(r.time),s.toArray(t,t.length)),r=a[i++];while(r!==void 0);else do s=r[n],s!==void 0&&(e.push(r.time),t.push(s)),r=a[i++];while(r!==void 0)},subclip:function(a,e,t,n,i=30){const r=a.clone();r.name=e;const s=[];for(let l=0;l<r.tracks.length;++l){const c=r.tracks[l],u=c.getValueSize(),h=[],d=[];for(let f=0;f<c.times.length;++f){const p=c.times[f]*i;if(!(p<t||p>=n)){h.push(c.times[f]);for(let m=0;m<u;++m)d.push(c.values[f*u+m])}}h.length!==0&&(c.times=$t.convertArray(h,c.times.constructor),c.values=$t.convertArray(d,c.values.constructor),s.push(c))}r.tracks=s;let o=1/0;for(let l=0;l<r.tracks.length;++l)o>r.tracks[l].times[0]&&(o=r.tracks[l].times[0]);for(let l=0;l<r.tracks.length;++l)r.tracks[l].shift(-1*o);return r.resetDuration(),r},makeClipAdditive:function(a,e=0,t=a,n=30){n<=0&&(n=30);const i=t.tracks.length,r=e/n;for(let s=0;s<i;++s){const o=t.tracks[s],l=o.ValueTypeName;if(l==="bool"||l==="string")continue;const c=a.tracks.find(function(v){return v.name===o.name&&v.ValueTypeName===l});if(c===void 0)continue;let u=0;const h=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(u=h/3);let d=0;const f=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=f/3);const p=o.times.length-1;let m;if(r<=o.times[0]){const v=u,y=h-u;m=$t.arraySlice(o.values,v,y)}else if(r>=o.times[p]){const v=p*h+u,y=v+h-u;m=$t.arraySlice(o.values,v,y)}else{const v=o.createInterpolant(),y=u,w=h-u;v.evaluate(r),m=$t.arraySlice(v.resultBuffer,y,w)}l==="quaternion"&&new dt().fromArray(m).normalize().conjugate().toArray(m);const g=c.times.length;for(let v=0;v<g;++v){const y=v*f+d;if(l==="quaternion")dt.multiplyQuaternionsFlat(c.values,y,m,0,c.values,y);else{const w=f-d*2;for(let x=0;x<w;++x)c.values[y+x]-=m[x]}}}return a.blendMode=nv,a}};class ws{constructor(e,t,n,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(n),this.sampleValues=t,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let n=this._cachedIndex,i=t[n],r=t[n-1];e:{t:{let s;n:{i:if(!(e<i)){for(let o=n+2;;){if(i===void 0){if(e<r)break i;return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,e,r)}if(n===o)break;if(r=i,i=t[++n],e<i)break t}s=t.length;break n}if(!(e>=r)){const o=t[1];e<o&&(n=2,r=o);for(let l=n-2;;){if(r===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,i);if(n===l)break;if(i=r,r=t[--n-1],e>=r)break t}s=n,n=0;break n}break e}for(;n<s;){const o=n+s>>>1;e<t[o]?s=o:n=o+1}if(i=t[n],r=t[n-1],r===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,i);if(i===void 0)return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,r,e)}this._cachedIndex=n,this.intervalChanged_(n,r,i)}return this.interpolate_(n,r,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=e*i;for(let s=0;s!==i;++s)t[s]=n[r+s];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}ws.prototype.beforeStart_=ws.prototype.copySampleValue_;ws.prototype.afterEnd_=ws.prototype.copySampleValue_;class AS extends ws{constructor(e,t,n,i){super(e,t,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:ka,endingEnd:ka}}intervalChanged_(e,t,n){const i=this.parameterPositions;let r=e-2,s=e+1,o=i[r],l=i[s];if(o===void 0)switch(this.getSettings_().endingStart){case Ua:r=e,o=2*t-n;break;case ru:r=i.length-2,o=t+i[r]-i[r+1];break;default:r=e,o=n}if(l===void 0)switch(this.getSettings_().endingEnd){case Ua:s=e,l=2*n-t;break;case ru:s=1,l=n+i[1]-i[0];break;default:s=e-1,l=t}const c=(n-t)*.5,u=this.valueSize;this._weightPrev=c/(t-o),this._weightNext=c/(l-n),this._offsetPrev=r*u,this._offsetNext=s*u}interpolate_(e,t,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,l=e*o,c=l-o,u=this._offsetPrev,h=this._offsetNext,d=this._weightPrev,f=this._weightNext,p=(n-t)/(i-t),m=p*p,g=m*p,v=-d*g+2*d*m-d*p,y=(1+d)*g+(-1.5-2*d)*m+(-.5+d)*p+1,w=(-1-f)*g+(1.5+f)*m+.5*p,x=f*g-f*m;for(let S=0;S!==o;++S)r[S]=v*s[u+S]+y*s[c+S]+w*s[l+S]+x*s[h+S];return r}}class Sv extends ws{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,l=e*o,c=l-o,u=(n-t)/(i-t),h=1-u;for(let d=0;d!==o;++d)r[d]=s[c+d]*h+s[l+d]*u;return r}}class SS extends ws{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e){return this.copySampleValue_(e-1)}}class wr{constructor(e,t,n,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=$t.convertArray(t,this.TimeBufferType),this.values=$t.convertArray(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:$t.convertArray(e.times,Array),values:$t.convertArray(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(n.interpolation=i)}return n.type=e.ValueTypeName,n}InterpolantFactoryMethodDiscrete(e){return new SS(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new Sv(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new AS(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case nu:t=this.InterpolantFactoryMethodDiscrete;break;case iu:t=this.InterpolantFactoryMethodLinear;break;case Od:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return nu;case this.InterpolantFactoryMethodLinear:return iu;case this.InterpolantFactoryMethodSmooth:return Od}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]*=e}return this}trim(e,t){const n=this.times,i=n.length;let r=0,s=i-1;for(;r!==i&&n[r]<e;)++r;for(;s!==-1&&n[s]>t;)--s;if(++s,r!==0||s!==i){r>=s&&(s=Math.max(s,1),r=s-1);const o=this.getValueSize();this.times=$t.arraySlice(n,r,s),this.values=$t.arraySlice(this.values,r*o,s*o)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,i=this.values,r=n.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let s=null;for(let o=0;o!==r;o++){const l=n[o];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,l),e=!1;break}if(s!==null&&s>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,l,s),e=!1;break}s=l}if(i!==void 0&&$t.isTypedArray(i))for(let o=0,l=i.length;o!==l;++o){const c=i[o];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,c),e=!1;break}}return e}optimize(){const e=$t.arraySlice(this.times),t=$t.arraySlice(this.values),n=this.getValueSize(),i=this.getInterpolation()===Od,r=e.length-1;let s=1;for(let o=1;o<r;++o){let l=!1;const c=e[o],u=e[o+1];if(c!==u&&(o!==1||c!==e[0]))if(i)l=!0;else{const h=o*n,d=h-n,f=h+n;for(let p=0;p!==n;++p){const m=t[h+p];if(m!==t[d+p]||m!==t[f+p]){l=!0;break}}}if(l){if(o!==s){e[s]=e[o];const h=o*n,d=s*n;for(let f=0;f!==n;++f)t[d+f]=t[h+f]}++s}}if(r>0){e[s]=e[r];for(let o=r*n,l=s*n,c=0;c!==n;++c)t[l+c]=t[o+c];++s}return s!==e.length?(this.times=$t.arraySlice(e,0,s),this.values=$t.arraySlice(t,0,s*n)):(this.times=e,this.values=t),this}clone(){const e=$t.arraySlice(this.times,0),t=$t.arraySlice(this.values,0),n=this.constructor,i=new n(this.name,e,t);return i.createInterpolant=this.createInterpolant,i}}wr.prototype.TimeBufferType=Float32Array;wr.prototype.ValueBufferType=Float32Array;wr.prototype.DefaultInterpolation=iu;class po extends wr{}po.prototype.ValueTypeName="bool";po.prototype.ValueBufferType=Array;po.prototype.DefaultInterpolation=nu;po.prototype.InterpolantFactoryMethodLinear=void 0;po.prototype.InterpolantFactoryMethodSmooth=void 0;class Mv extends wr{}Mv.prototype.ValueTypeName="color";class hu extends wr{}hu.prototype.ValueTypeName="number";class MS extends ws{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,l=(n-t)/(i-t);let c=e*o;for(let u=c+o;c!==u;c+=4)dt.slerpFlat(r,0,s,c-o,s,c,l);return r}}class Rl extends wr{InterpolantFactoryMethodLinear(e){return new MS(this.times,this.values,this.getValueSize(),e)}}Rl.prototype.ValueTypeName="quaternion";Rl.prototype.DefaultInterpolation=iu;Rl.prototype.InterpolantFactoryMethodSmooth=void 0;class mo extends wr{}mo.prototype.ValueTypeName="string";mo.prototype.ValueBufferType=Array;mo.prototype.DefaultInterpolation=nu;mo.prototype.InterpolantFactoryMethodLinear=void 0;mo.prototype.InterpolantFactoryMethodSmooth=void 0;class du extends wr{}du.prototype.ValueTypeName="vector";class fu{constructor(e,t=-1,n,i=vf){this.name=e,this.tracks=n,this.duration=t,this.blendMode=i,this.uuid=Ni(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],n=e.tracks,i=1/(e.fps||1);for(let s=0,o=n.length;s!==o;++s)t.push(jR(n[s]).scale(i));const r=new this(e.name,e.duration,t,e.blendMode);return r.uuid=e.uuid,r}static toJSON(e){const t=[],n=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let r=0,s=n.length;r!==s;++r)t.push(wr.toJSON(n[r]));return i}static CreateFromMorphTargetSequence(e,t,n,i){const r=t.length,s=[];for(let o=0;o<r;o++){let l=[],c=[];l.push((o+r-1)%r,o,(o+1)%r),c.push(0,1,0);const u=$t.getKeyframeOrder(l);l=$t.sortedArray(l,1,u),c=$t.sortedArray(c,1,u),!i&&l[0]===0&&(l.push(r),c.push(c[0])),s.push(new hu(".morphTargetInfluences["+t[o].name+"]",l,c).scale(1/n))}return new this(e,-1,s)}static findByName(e,t){let n=e;if(!Array.isArray(e)){const i=e;n=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<n.length;i++)if(n[i].name===t)return n[i];return null}static CreateClipsFromMorphTargetSequences(e,t,n){const i={},r=/^([\w-]*?)([\d]+)$/;for(let o=0,l=e.length;o<l;o++){const c=e[o],u=c.name.match(r);if(u&&u.length>1){const h=u[1];let d=i[h];d||(i[h]=d=[]),d.push(c)}}const s=[];for(const o in i)s.push(this.CreateFromMorphTargetSequence(o,i[o],t,n));return s}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(h,d,f,p,m){if(f.length!==0){const g=[],v=[];$t.flattenJSON(f,g,v,p),g.length!==0&&m.push(new h(d,g,v))}},i=[],r=e.name||"default",s=e.fps||30,o=e.blendMode;let l=e.length||-1;const c=e.hierarchy||[];for(let h=0;h<c.length;h++){const d=c[h].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const f={};let p;for(p=0;p<d.length;p++)if(d[p].morphTargets)for(let m=0;m<d[p].morphTargets.length;m++)f[d[p].morphTargets[m]]=-1;for(const m in f){const g=[],v=[];for(let y=0;y!==d[p].morphTargets.length;++y){const w=d[p];g.push(w.time),v.push(w.morphTarget===m?1:0)}i.push(new hu(".morphTargetInfluence["+m+"]",g,v))}l=f.length*s}else{const f=".bones["+t[h].name+"]";n(du,f+".position",d,"pos",i),n(Rl,f+".quaternion",d,"rot",i),n(du,f+".scale",d,"scl",i)}}return i.length===0?null:new this(r,l,i,o)}resetDuration(){const e=this.tracks;let t=0;for(let n=0,i=e.length;n!==i;++n){const r=this.tracks[n];t=Math.max(t,r.times[r.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function VR(a){switch(a.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return hu;case"vector":case"vector2":case"vector3":case"vector4":return du;case"color":return Mv;case"quaternion":return Rl;case"bool":case"boolean":return po;case"string":return mo}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+a)}function jR(a){if(a.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=VR(a.type);if(a.times===void 0){const t=[],n=[];$t.flattenJSON(a.keys,t,n,"value"),a.times=t,a.values=n}return e.parse!==void 0?e.parse(a):new e(a.name,a.times,a.values,a.interpolation)}const to={enabled:!1,files:{},add:function(a,e){this.enabled!==!1&&(this.files[a]=e)},get:function(a){if(this.enabled!==!1)return this.files[a]},remove:function(a){delete this.files[a]},clear:function(){this.files={}}};class bv{constructor(e,t,n){const i=this;let r=!1,s=0,o=0,l;const c=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(u){o++,r===!1&&i.onStart!==void 0&&i.onStart(u,s,o),r=!0},this.itemEnd=function(u){s++,i.onProgress!==void 0&&i.onProgress(u,s,o),s===o&&(r=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(u){i.onError!==void 0&&i.onError(u)},this.resolveURL=function(u){return l?l(u):u},this.setURLModifier=function(u){return l=u,this},this.addHandler=function(u,h){return c.push(u,h),this},this.removeHandler=function(u){const h=c.indexOf(u);return h!==-1&&c.splice(h,2),this},this.getHandler=function(u){for(let h=0,d=c.length;h<d;h+=2){const f=c[h],p=c[h+1];if(f.global&&(f.lastIndex=0),f.test(u))return p}return null}}}const bS=new bv;class ni{constructor(e){this.manager=e!==void 0?e:bS,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const n=this;return new Promise(function(i,r){n.load(e,i,t,r)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}const ts={};class $i extends ni{constructor(e){super(e)}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=to.get(e);if(r!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(r),this.manager.itemEnd(e)},0),r;if(ts[e]!==void 0){ts[e].push({onLoad:t,onProgress:n,onError:i});return}ts[e]=[],ts[e].push({onLoad:t,onProgress:n,onError:i});const s=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),o=this.mimeType,l=this.responseType;fetch(s).then(c=>{if(c.status===200||c.status===0){if(c.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||c.body===void 0||c.body.getReader===void 0)return c;const u=ts[e],h=c.body.getReader(),d=c.headers.get("Content-Length"),f=d?parseInt(d):0,p=f!==0;let m=0;const g=new ReadableStream({start(v){y();function y(){h.read().then(({done:w,value:x})=>{if(w)v.close();else{m+=x.byteLength;const S=new ProgressEvent("progress",{lengthComputable:p,loaded:m,total:f});for(let b=0,E=u.length;b<E;b++){const M=u[b];M.onProgress&&M.onProgress(S)}v.enqueue(x),y()}})}}});return new Response(g)}else throw Error(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`)}).then(c=>{switch(l){case"arraybuffer":return c.arrayBuffer();case"blob":return c.blob();case"document":return c.text().then(u=>new DOMParser().parseFromString(u,o));case"json":return c.json();default:if(o===void 0)return c.text();{const h=/charset="?([^;"\s]*)"?/i.exec(o),d=h&&h[1]?h[1].toLowerCase():void 0,f=new TextDecoder(d);return c.arrayBuffer().then(p=>f.decode(p))}}}).then(c=>{to.add(e,c);const u=ts[e];delete ts[e];for(let h=0,d=u.length;h<d;h++){const f=u[h];f.onLoad&&f.onLoad(c)}}).catch(c=>{const u=ts[e];if(u===void 0)throw this.manager.itemError(e),c;delete ts[e];for(let h=0,d=u.length;h<d;h++){const f=u[h];f.onError&&f.onError(c)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class QR extends ni{constructor(e){super(e)}load(e,t,n,i){const r=this,s=new $i(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(e,function(o){try{t(r.parse(JSON.parse(o)))}catch(l){i?i(l):console.error(l),r.manager.itemError(e)}},n,i)}parse(e){const t=[];for(let n=0;n<e.length;n++){const i=fu.parse(e[n]);t.push(i)}return t}}class WR extends ni{constructor(e){super(e)}load(e,t,n,i){const r=this,s=[],o=new cv,l=new $i(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(r.withCredentials);let c=0;function u(h){l.load(e[h],function(d){const f=r.parse(d,!0);s[h]={width:f.width,height:f.height,format:f.format,mipmaps:f.mipmaps},c+=1,c===6&&(f.mipmapCount===1&&(o.minFilter=St),o.image=s,o.format=f.format,o.needsUpdate=!0,t&&t(o))},n,i)}if(Array.isArray(e))for(let h=0,d=e.length;h<d;++h)u(h);else l.load(e,function(h){const d=r.parse(h,!0);if(d.isCubemap){const f=d.mipmaps.length/d.mipmapCount;for(let p=0;p<f;p++){s[p]={mipmaps:[]};for(let m=0;m<d.mipmapCount;m++)s[p].mipmaps.push(d.mipmaps[p*d.mipmapCount+m]),s[p].format=d.format,s[p].width=d.width,s[p].height=d.height}o.image=s}else o.image.width=d.width,o.image.height=d.height,o.mipmaps=d.mipmaps;d.mipmapCount===1&&(o.minFilter=St),o.format=d.format,o.needsUpdate=!0,t&&t(o)},n,i);return o}}class pu extends ni{constructor(e){super(e)}load(e,t,n,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,s=to.get(e);if(s!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(s),r.manager.itemEnd(e)},0),s;const o=ou("img");function l(){u(),to.add(e,this),t&&t(this),r.manager.itemEnd(e)}function c(h){u(),i&&i(h),r.manager.itemError(e),r.manager.itemEnd(e)}function u(){o.removeEventListener("load",l,!1),o.removeEventListener("error",c,!1)}return o.addEventListener("load",l,!1),o.addEventListener("error",c,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),r.manager.itemStart(e),o.src=e,o}}class ES extends ni{constructor(e){super(e)}load(e,t,n,i){const r=new bl,s=new pu(this.manager);s.setCrossOrigin(this.crossOrigin),s.setPath(this.path);let o=0;function l(c){s.load(e[c],function(u){r.images[c]=u,o++,o===6&&(r.needsUpdate=!0,t&&t(r))},void 0,i)}for(let c=0;c<e.length;++c)l(c);return r}}class Uf extends ni{constructor(e){super(e)}load(e,t,n,i){const r=this,s=new Yi,o=new $i(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(r.withCredentials),o.load(e,function(l){const c=r.parse(l);c&&(c.image!==void 0?s.image=c.image:c.data!==void 0&&(s.image.width=c.width,s.image.height=c.height,s.image.data=c.data),s.wrapS=c.wrapS!==void 0?c.wrapS:bi,s.wrapT=c.wrapT!==void 0?c.wrapT:bi,s.magFilter=c.magFilter!==void 0?c.magFilter:St,s.minFilter=c.minFilter!==void 0?c.minFilter:St,s.anisotropy=c.anisotropy!==void 0?c.anisotropy:1,c.encoding!==void 0&&(s.encoding=c.encoding),c.flipY!==void 0&&(s.flipY=c.flipY),c.format!==void 0&&(s.format=c.format),c.type!==void 0&&(s.type=c.type),c.mipmaps!==void 0&&(s.mipmaps=c.mipmaps,s.minFilter=uo),c.mipmapCount===1&&(s.minFilter=St),c.generateMipmaps!==void 0&&(s.generateMipmaps=c.generateMipmaps),s.needsUpdate=!0,t&&t(s,c))},n,i),s}}class Ev extends ni{constructor(e){super(e)}load(e,t,n,i){const r=new bn,s=new pu(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(e,function(o){r.image=o,r.needsUpdate=!0,t!==void 0&&t(r)},n,i),r}}class xr extends gt{constructor(e,t=1){super(),this.type="Light",this.color=new Ie(e),this.intensity=t}dispose(){}copy(e){return super.copy(e),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}xr.prototype.isLight=!0;class Tv extends xr{constructor(e,t,n){super(e,n),this.type="HemisphereLight",this.position.copy(gt.DefaultUp),this.updateMatrix(),this.groundColor=new Ie(t)}copy(e){return xr.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}}Tv.prototype.isHemisphereLight=!0;const Oy=new ae,By=new A,Ly=new A;class Cv{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new te(512,512),this.map=null,this.mapPass=null,this.matrix=new ae,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new El,this._frameExtents=new te(1,1),this._viewportCount=1,this._viewports=[new lt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,n=this.matrix;By.setFromMatrixPosition(e.matrixWorld),t.position.copy(By),Ly.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(Ly),t.updateMatrixWorld(),Oy.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Oy),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(t.projectionMatrix),n.multiply(t.matrixWorldInverse)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class TS extends Cv{constructor(){super(new tn(50,1,.5,500)),this.focus=1}updateMatrices(e){const t=this.camera,n=au*2*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=e.distance||t.far;(n!==t.fov||i!==t.aspect||r!==t.far)&&(t.fov=n,t.aspect=i,t.far=r,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}TS.prototype.isSpotLightShadow=!0;class Iv extends xr{constructor(e,t,n=0,i=Math.PI/3,r=0,s=1){super(e,t),this.type="SpotLight",this.position.copy(gt.DefaultUp),this.updateMatrix(),this.target=new gt,this.distance=n,this.angle=i,this.penumbra=r,this.decay=s,this.shadow=new TS}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}Iv.prototype.isSpotLight=!0;const zy=new ae,ql=new A,Hp=new A;class CS extends Cv{constructor(){super(new tn(90,1,.5,500)),this._frameExtents=new te(4,2),this._viewportCount=6,this._viewports=[new lt(2,1,1,1),new lt(0,1,1,1),new lt(3,1,1,1),new lt(1,1,1,1),new lt(3,0,1,1),new lt(1,0,1,1)],this._cubeDirections=[new A(1,0,0),new A(-1,0,0),new A(0,0,1),new A(0,0,-1),new A(0,1,0),new A(0,-1,0)],this._cubeUps=[new A(0,1,0),new A(0,1,0),new A(0,1,0),new A(0,1,0),new A(0,0,1),new A(0,0,-1)]}updateMatrices(e,t=0){const n=this.camera,i=this.matrix,r=e.distance||n.far;r!==n.far&&(n.far=r,n.updateProjectionMatrix()),ql.setFromMatrixPosition(e.matrixWorld),n.position.copy(ql),Hp.copy(n.position),Hp.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(Hp),n.updateMatrixWorld(),i.makeTranslation(-ql.x,-ql.y,-ql.z),zy.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(zy)}}CS.prototype.isPointLightShadow=!0;class Rv extends xr{constructor(e,t,n=0,i=1){super(e,t),this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new CS}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}Rv.prototype.isPointLight=!0;class IS extends Cv{constructor(){super(new ki(-5,5,5,-5,.5,500))}}IS.prototype.isDirectionalLightShadow=!0;class Ff extends xr{constructor(e,t){super(e,t),this.type="DirectionalLight",this.position.copy(gt.DefaultUp),this.updateMatrix(),this.target=new gt,this.shadow=new IS}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}Ff.prototype.isDirectionalLight=!0;class Pv extends xr{constructor(e,t){super(e,t),this.type="AmbientLight"}}Pv.prototype.isAmbientLight=!0;class Dv extends xr{constructor(e,t,n=10,i=10){super(e,t),this.type="RectAreaLight",this.width=n,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}Dv.prototype.isRectAreaLight=!0;class Ov{constructor(){this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new A)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const n=e.x,i=e.y,r=e.z,s=this.coefficients;return t.copy(s[0]).multiplyScalar(.282095),t.addScaledVector(s[1],.488603*i),t.addScaledVector(s[2],.488603*r),t.addScaledVector(s[3],.488603*n),t.addScaledVector(s[4],1.092548*(n*i)),t.addScaledVector(s[5],1.092548*(i*r)),t.addScaledVector(s[6],.315392*(3*r*r-1)),t.addScaledVector(s[7],1.092548*(n*r)),t.addScaledVector(s[8],.546274*(n*n-i*i)),t}getIrradianceAt(e,t){const n=e.x,i=e.y,r=e.z,s=this.coefficients;return t.copy(s[0]).multiplyScalar(.886227),t.addScaledVector(s[1],2*.511664*i),t.addScaledVector(s[2],2*.511664*r),t.addScaledVector(s[3],2*.511664*n),t.addScaledVector(s[4],2*.429043*n*i),t.addScaledVector(s[5],2*.429043*i*r),t.addScaledVector(s[6],.743125*r*r-.247708),t.addScaledVector(s[7],2*.429043*n*r),t.addScaledVector(s[8],.429043*(n*n-i*i)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(e,t+i*3);return this}toArray(e=[],t=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(e,t+i*3);return e}static getBasisAt(e,t){const n=e.x,i=e.y,r=e.z;t[0]=.282095,t[1]=.488603*i,t[2]=.488603*r,t[3]=.488603*n,t[4]=1.092548*n*i,t[5]=1.092548*i*r,t[6]=.315392*(3*r*r-1),t[7]=1.092548*n*r,t[8]=.546274*(n*n-i*i)}}Ov.prototype.isSphericalHarmonics3=!0;class ju extends xr{constructor(e=new Ov,t=1){super(void 0,t),this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}ju.prototype.isLightProbe=!0;class RS extends ni{constructor(e){super(e),this.textures={}}load(e,t,n,i){const r=this,s=new $i(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(e,function(o){try{t(r.parse(JSON.parse(o)))}catch(l){i?i(l):console.error(l),r.manager.itemError(e)}},n,i)}parse(e){const t=this.textures;function n(r){return t[r]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",r),t[r]}const i=cn.fromType(e.type);if(e.uuid!==void 0&&(i.uuid=e.uuid),e.name!==void 0&&(i.name=e.name),e.color!==void 0&&i.color!==void 0&&i.color.setHex(e.color),e.roughness!==void 0&&(i.roughness=e.roughness),e.metalness!==void 0&&(i.metalness=e.metalness),e.sheen!==void 0&&(i.sheen=e.sheen),e.sheenColor!==void 0&&(i.sheenColor=new Ie().setHex(e.sheenColor)),e.sheenRoughness!==void 0&&(i.sheenRoughness=e.sheenRoughness),e.emissive!==void 0&&i.emissive!==void 0&&i.emissive.setHex(e.emissive),e.specular!==void 0&&i.specular!==void 0&&i.specular.setHex(e.specular),e.specularIntensity!==void 0&&(i.specularIntensity=e.specularIntensity),e.specularColor!==void 0&&i.specularColor!==void 0&&i.specularColor.setHex(e.specularColor),e.shininess!==void 0&&(i.shininess=e.shininess),e.clearcoat!==void 0&&(i.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=e.clearcoatRoughness),e.transmission!==void 0&&(i.transmission=e.transmission),e.thickness!==void 0&&(i.thickness=e.thickness),e.attenuationDistance!==void 0&&(i.attenuationDistance=e.attenuationDistance),e.attenuationColor!==void 0&&i.attenuationColor!==void 0&&i.attenuationColor.setHex(e.attenuationColor),e.fog!==void 0&&(i.fog=e.fog),e.flatShading!==void 0&&(i.flatShading=e.flatShading),e.blending!==void 0&&(i.blending=e.blending),e.combine!==void 0&&(i.combine=e.combine),e.side!==void 0&&(i.side=e.side),e.shadowSide!==void 0&&(i.shadowSide=e.shadowSide),e.opacity!==void 0&&(i.opacity=e.opacity),e.transparent!==void 0&&(i.transparent=e.transparent),e.alphaTest!==void 0&&(i.alphaTest=e.alphaTest),e.depthTest!==void 0&&(i.depthTest=e.depthTest),e.depthWrite!==void 0&&(i.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(i.colorWrite=e.colorWrite),e.stencilWrite!==void 0&&(i.stencilWrite=e.stencilWrite),e.stencilWriteMask!==void 0&&(i.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(i.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(i.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(i.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(i.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(i.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(i.stencilZPass=e.stencilZPass),e.wireframe!==void 0&&(i.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(i.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(i.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(i.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(i.rotation=e.rotation),e.linewidth!==1&&(i.linewidth=e.linewidth),e.dashSize!==void 0&&(i.dashSize=e.dashSize),e.gapSize!==void 0&&(i.gapSize=e.gapSize),e.scale!==void 0&&(i.scale=e.scale),e.polygonOffset!==void 0&&(i.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(i.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(i.polygonOffsetUnits=e.polygonOffsetUnits),e.dithering!==void 0&&(i.dithering=e.dithering),e.alphaToCoverage!==void 0&&(i.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(i.premultipliedAlpha=e.premultipliedAlpha),e.visible!==void 0&&(i.visible=e.visible),e.toneMapped!==void 0&&(i.toneMapped=e.toneMapped),e.userData!==void 0&&(i.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?i.vertexColors=e.vertexColors>0:i.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const r in e.uniforms){const s=e.uniforms[r];switch(i.uniforms[r]={},s.type){case"t":i.uniforms[r].value=n(s.value);break;case"c":i.uniforms[r].value=new Ie().setHex(s.value);break;case"v2":i.uniforms[r].value=new te().fromArray(s.value);break;case"v3":i.uniforms[r].value=new A().fromArray(s.value);break;case"v4":i.uniforms[r].value=new lt().fromArray(s.value);break;case"m3":i.uniforms[r].value=new Kt().fromArray(s.value);break;case"m4":i.uniforms[r].value=new ae().fromArray(s.value);break;default:i.uniforms[r].value=s.value}}if(e.defines!==void 0&&(i.defines=e.defines),e.vertexShader!==void 0&&(i.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(i.fragmentShader=e.fragmentShader),e.extensions!==void 0)for(const r in e.extensions)i.extensions[r]=e.extensions[r];if(e.shading!==void 0&&(i.flatShading=e.shading===1),e.size!==void 0&&(i.size=e.size),e.sizeAttenuation!==void 0&&(i.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(i.map=n(e.map)),e.matcap!==void 0&&(i.matcap=n(e.matcap)),e.alphaMap!==void 0&&(i.alphaMap=n(e.alphaMap)),e.bumpMap!==void 0&&(i.bumpMap=n(e.bumpMap)),e.bumpScale!==void 0&&(i.bumpScale=e.bumpScale),e.normalMap!==void 0&&(i.normalMap=n(e.normalMap)),e.normalMapType!==void 0&&(i.normalMapType=e.normalMapType),e.normalScale!==void 0){let r=e.normalScale;Array.isArray(r)===!1&&(r=[r,r]),i.normalScale=new te().fromArray(r)}return e.displacementMap!==void 0&&(i.displacementMap=n(e.displacementMap)),e.displacementScale!==void 0&&(i.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(i.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(i.roughnessMap=n(e.roughnessMap)),e.metalnessMap!==void 0&&(i.metalnessMap=n(e.metalnessMap)),e.emissiveMap!==void 0&&(i.emissiveMap=n(e.emissiveMap)),e.emissiveIntensity!==void 0&&(i.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(i.specularMap=n(e.specularMap)),e.specularIntensityMap!==void 0&&(i.specularIntensityMap=n(e.specularIntensityMap)),e.specularColorMap!==void 0&&(i.specularColorMap=n(e.specularColorMap)),e.envMap!==void 0&&(i.envMap=n(e.envMap)),e.envMapIntensity!==void 0&&(i.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(i.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(i.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(i.lightMap=n(e.lightMap)),e.lightMapIntensity!==void 0&&(i.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(i.aoMap=n(e.aoMap)),e.aoMapIntensity!==void 0&&(i.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(i.gradientMap=n(e.gradientMap)),e.clearcoatMap!==void 0&&(i.clearcoatMap=n(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(i.clearcoatRoughnessMap=n(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(i.clearcoatNormalMap=n(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(i.clearcoatNormalScale=new te().fromArray(e.clearcoatNormalScale)),e.transmissionMap!==void 0&&(i.transmissionMap=n(e.transmissionMap)),e.thicknessMap!==void 0&&(i.thicknessMap=n(e.thicknessMap)),e.sheenColorMap!==void 0&&(i.sheenColorMap=n(e.sheenColorMap)),e.sheenRoughnessMap!==void 0&&(i.sheenRoughnessMap=n(e.sheenRoughnessMap)),i}setTextures(e){return this.textures=e,this}}class Yd{static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let n=0,i=e.length;n<i;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class Qu extends nt{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const e=super.toJSON(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}Qu.prototype.isInstancedBufferGeometry=!0;class PS extends ni{constructor(e){super(e)}load(e,t,n,i){const r=this,s=new $i(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(e,function(o){try{t(r.parse(JSON.parse(o)))}catch(l){i?i(l):console.error(l),r.manager.itemError(e)}},n,i)}parse(e){const t={},n={};function i(f,p){if(t[p]!==void 0)return t[p];const g=f.interleavedBuffers[p],v=r(f,g.buffer),y=Yo(g.type,v),w=new fo(y,g.stride);return w.uuid=g.uuid,t[p]=w,w}function r(f,p){if(n[p]!==void 0)return n[p];const g=f.arrayBuffers[p],v=new Uint32Array(g).buffer;return n[p]=v,v}const s=e.isInstancedBufferGeometry?new Qu:new nt,o=e.data.index;if(o!==void 0){const f=Yo(o.type,o.array);s.setIndex(new wt(f,1))}const l=e.data.attributes;for(const f in l){const p=l[f];let m;if(p.isInterleavedBufferAttribute){const g=i(e.data,p.data);m=new Wn(g,p.itemSize,p.offset,p.normalized)}else{const g=Yo(p.type,p.array),v=p.isInstancedBufferAttribute?yr:wt;m=new v(g,p.itemSize,p.normalized)}p.name!==void 0&&(m.name=p.name),p.usage!==void 0&&m.setUsage(p.usage),p.updateRange!==void 0&&(m.updateRange.offset=p.updateRange.offset,m.updateRange.count=p.updateRange.count),s.setAttribute(f,m)}const c=e.data.morphAttributes;if(c)for(const f in c){const p=c[f],m=[];for(let g=0,v=p.length;g<v;g++){const y=p[g];let w;if(y.isInterleavedBufferAttribute){const x=i(e.data,y.data);w=new Wn(x,y.itemSize,y.offset,y.normalized)}else{const x=Yo(y.type,y.array);w=new wt(x,y.itemSize,y.normalized)}y.name!==void 0&&(w.name=y.name),m.push(w)}s.morphAttributes[f]=m}e.data.morphTargetsRelative&&(s.morphTargetsRelative=!0);const h=e.data.groups||e.data.drawcalls||e.data.offsets;if(h!==void 0)for(let f=0,p=h.length;f!==p;++f){const m=h[f];s.addGroup(m.start,m.count,m.materialIndex)}const d=e.data.boundingSphere;if(d!==void 0){const f=new A;d.center!==void 0&&f.fromArray(d.center),s.boundingSphere=new rn(f,d.radius)}return e.name&&(s.name=e.name),e.userData&&(s.userData=e.userData),s}}class XR extends ni{constructor(e){super(e)}load(e,t,n,i){const r=this,s=this.path===""?Yd.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||s;const o=new $i(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(l){let c=null;try{c=JSON.parse(l)}catch(h){i!==void 0&&i(h),console.error("THREE:ObjectLoader: Can't parse "+e+".",h.message);return}const u=c.metadata;if(u===void 0||u.type===void 0||u.type.toLowerCase()==="geometry"){console.error("THREE.ObjectLoader: Can't load "+e);return}r.parse(c,t)},n,i)}async loadAsync(e,t){const n=this,i=this.path===""?Yd.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||i;const r=new $i(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials);const s=await r.loadAsync(e,t),o=JSON.parse(s),l=o.metadata;if(l===void 0||l.type===void 0||l.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+e);return await n.parseAsync(o)}parse(e,t){const n=this.parseAnimations(e.animations),i=this.parseShapes(e.shapes),r=this.parseGeometries(e.geometries,i),s=this.parseImages(e.images,function(){t!==void 0&&t(c)}),o=this.parseTextures(e.textures,s),l=this.parseMaterials(e.materials,o),c=this.parseObject(e.object,r,l,o,n),u=this.parseSkeletons(e.skeletons,c);if(this.bindSkeletons(c,u),t!==void 0){let h=!1;for(const d in s)if(s[d]instanceof HTMLImageElement){h=!0;break}h===!1&&t(c)}return c}async parseAsync(e){const t=this.parseAnimations(e.animations),n=this.parseShapes(e.shapes),i=this.parseGeometries(e.geometries,n),r=await this.parseImagesAsync(e.images),s=this.parseTextures(e.textures,r),o=this.parseMaterials(e.materials,s),l=this.parseObject(e.object,i,o,s,t),c=this.parseSkeletons(e.skeletons,l);return this.bindSkeletons(l,c),l}parseShapes(e){const t={};if(e!==void 0)for(let n=0,i=e.length;n<i;n++){const r=new kr().fromJSON(e[n]);t[r.uuid]=r}return t}parseSkeletons(e,t){const n={},i={};if(t.traverse(function(r){r.isBone&&(i[r.uuid]=r)}),e!==void 0)for(let r=0,s=e.length;r<s;r++){const o=new Cf().fromJSON(e[r],i);n[o.uuid]=o}return n}parseGeometries(e,t){const n={};if(e!==void 0){const i=new PS;for(let r=0,s=e.length;r<s;r++){let o;const l=e[r];switch(l.type){case"BufferGeometry":case"InstancedBufferGeometry":o=i.parse(l);break;case"Geometry":console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");break;default:l.type in Dy?o=Dy[l.type].fromJSON(l,t):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)}o.uuid=l.uuid,l.name!==void 0&&(o.name=l.name),o.isBufferGeometry===!0&&l.userData!==void 0&&(o.userData=l.userData),n[l.uuid]=o}}return n}parseMaterials(e,t){const n={},i={};if(e!==void 0){const r=new RS;r.setTextures(t);for(let s=0,o=e.length;s<o;s++){const l=e[s];if(l.type==="MultiMaterial"){const c=[];for(let u=0;u<l.materials.length;u++){const h=l.materials[u];n[h.uuid]===void 0&&(n[h.uuid]=r.parse(h)),c.push(n[h.uuid])}i[l.uuid]=c}else n[l.uuid]===void 0&&(n[l.uuid]=r.parse(l)),i[l.uuid]=n[l.uuid]}}return i}parseAnimations(e){const t={};if(e!==void 0)for(let n=0;n<e.length;n++){const i=e[n],r=fu.parse(i);t[r.uuid]=r}return t}parseImages(e,t){const n=this,i={};let r;function s(l){return n.manager.itemStart(l),r.load(l,function(){n.manager.itemEnd(l)},void 0,function(){n.manager.itemError(l),n.manager.itemEnd(l)})}function o(l){if(typeof l=="string"){const c=l,u=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(c)?c:n.resourcePath+c;return s(u)}else return l.data?{data:Yo(l.type,l.data),width:l.width,height:l.height}:null}if(e!==void 0&&e.length>0){const l=new bv(t);r=new pu(l),r.setCrossOrigin(this.crossOrigin);for(let c=0,u=e.length;c<u;c++){const h=e[c],d=h.url;if(Array.isArray(d)){const f=[];for(let p=0,m=d.length;p<m;p++){const g=d[p],v=o(g);v!==null&&(v instanceof HTMLImageElement?f.push(v):f.push(new Yi(v.data,v.width,v.height)))}i[h.uuid]=new Ks(f)}else{const f=o(h.url);i[h.uuid]=new Ks(f)}}}return i}async parseImagesAsync(e){const t=this,n={};let i;async function r(s){if(typeof s=="string"){const o=s,l=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(o)?o:t.resourcePath+o;return await i.loadAsync(l)}else return s.data?{data:Yo(s.type,s.data),width:s.width,height:s.height}:null}if(e!==void 0&&e.length>0){i=new pu(this.manager),i.setCrossOrigin(this.crossOrigin);for(let s=0,o=e.length;s<o;s++){const l=e[s],c=l.url;if(Array.isArray(c)){const u=[];for(let h=0,d=c.length;h<d;h++){const f=c[h],p=await r(f);p!==null&&(p instanceof HTMLImageElement?u.push(p):u.push(new Yi(p.data,p.width,p.height)))}n[l.uuid]=new Ks(u)}else{const u=await r(l.url);n[l.uuid]=new Ks(u)}}}return n}parseTextures(e,t){function n(r,s){return typeof r=="number"?r:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",r),s[r])}const i={};if(e!==void 0)for(let r=0,s=e.length;r<s;r++){const o=e[r];o.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',o.uuid),t[o.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",o.image);const l=t[o.image],c=l.data;let u;Array.isArray(c)?(u=new bl,c.length===6&&(u.needsUpdate=!0)):(c&&c.data?u=new Yi:u=new bn,c&&(u.needsUpdate=!0)),u.source=l,u.uuid=o.uuid,o.name!==void 0&&(u.name=o.name),o.mapping!==void 0&&(u.mapping=n(o.mapping,JR)),o.offset!==void 0&&u.offset.fromArray(o.offset),o.repeat!==void 0&&u.repeat.fromArray(o.repeat),o.center!==void 0&&u.center.fromArray(o.center),o.rotation!==void 0&&(u.rotation=o.rotation),o.wrap!==void 0&&(u.wrapS=n(o.wrap[0],Ny),u.wrapT=n(o.wrap[1],Ny)),o.format!==void 0&&(u.format=o.format),o.type!==void 0&&(u.type=o.type),o.encoding!==void 0&&(u.encoding=o.encoding),o.minFilter!==void 0&&(u.minFilter=n(o.minFilter,ky)),o.magFilter!==void 0&&(u.magFilter=n(o.magFilter,ky)),o.anisotropy!==void 0&&(u.anisotropy=o.anisotropy),o.flipY!==void 0&&(u.flipY=o.flipY),o.premultiplyAlpha!==void 0&&(u.premultiplyAlpha=o.premultiplyAlpha),o.unpackAlignment!==void 0&&(u.unpackAlignment=o.unpackAlignment),o.userData!==void 0&&(u.userData=o.userData),i[o.uuid]=u}return i}parseObject(e,t,n,i,r){let s;function o(d){return t[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",d),t[d]}function l(d){if(d!==void 0){if(Array.isArray(d)){const f=[];for(let p=0,m=d.length;p<m;p++){const g=d[p];n[g]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",g),f.push(n[g])}return f}return n[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",d),n[d]}}function c(d){return i[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",d),i[d]}let u,h;switch(e.type){case"Scene":s=new Hu,e.background!==void 0&&(Number.isInteger(e.background)?s.background=new Ie(e.background):s.background=c(e.background)),e.environment!==void 0&&(s.environment=c(e.environment)),e.fog!==void 0&&(e.fog.type==="Fog"?s.fog=new Fu(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(s.fog=new Uu(e.fog.color,e.fog.density)));break;case"PerspectiveCamera":s=new tn(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(s.focus=e.focus),e.zoom!==void 0&&(s.zoom=e.zoom),e.filmGauge!==void 0&&(s.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(s.filmOffset=e.filmOffset),e.view!==void 0&&(s.view=Object.assign({},e.view));break;case"OrthographicCamera":s=new ki(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(s.zoom=e.zoom),e.view!==void 0&&(s.view=Object.assign({},e.view));break;case"AmbientLight":s=new Pv(e.color,e.intensity);break;case"DirectionalLight":s=new Ff(e.color,e.intensity);break;case"PointLight":s=new Rv(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":s=new Dv(e.color,e.intensity,e.width,e.height);break;case"SpotLight":s=new Iv(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":s=new Tv(e.color,e.groundColor,e.intensity);break;case"LightProbe":s=new ju().fromJSON(e);break;case"SkinnedMesh":u=o(e.geometry),h=l(e.material),s=new Ef(u,h),e.bindMode!==void 0&&(s.bindMode=e.bindMode),e.bindMatrix!==void 0&&s.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(s.skeleton=e.skeleton);break;case"Mesh":u=o(e.geometry),h=l(e.material),s=new Ve(u,h);break;case"InstancedMesh":u=o(e.geometry),h=l(e.material);const d=e.count,f=e.instanceMatrix,p=e.instanceColor;s=new If(u,h,d),s.instanceMatrix=new yr(new Float32Array(f.array),16),p!==void 0&&(s.instanceColor=new yr(new Float32Array(p.array),p.itemSize));break;case"LOD":s=new dS;break;case"Line":s=new $n(o(e.geometry),l(e.material));break;case"LineLoop":s=new lv(o(e.geometry),l(e.material));break;case"LineSegments":s=new gi(o(e.geometry),l(e.material));break;case"PointCloud":case"Points":s=new ms(o(e.geometry),l(e.material));break;case"Sprite":s=new bf(l(e.material));break;case"Group":s=new fi;break;case"Bone":s=new Tf;break;default:s=new gt}if(s.uuid=e.uuid,e.name!==void 0&&(s.name=e.name),e.matrix!==void 0?(s.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(s.matrixAutoUpdate=e.matrixAutoUpdate),s.matrixAutoUpdate&&s.matrix.decompose(s.position,s.quaternion,s.scale)):(e.position!==void 0&&s.position.fromArray(e.position),e.rotation!==void 0&&s.rotation.fromArray(e.rotation),e.quaternion!==void 0&&s.quaternion.fromArray(e.quaternion),e.scale!==void 0&&s.scale.fromArray(e.scale)),e.castShadow!==void 0&&(s.castShadow=e.castShadow),e.receiveShadow!==void 0&&(s.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.bias!==void 0&&(s.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(s.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(s.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&s.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(s.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(s.visible=e.visible),e.frustumCulled!==void 0&&(s.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(s.renderOrder=e.renderOrder),e.userData!==void 0&&(s.userData=e.userData),e.layers!==void 0&&(s.layers.mask=e.layers),e.children!==void 0){const d=e.children;for(let f=0;f<d.length;f++)s.add(this.parseObject(d[f],t,n,i,r))}if(e.animations!==void 0){const d=e.animations;for(let f=0;f<d.length;f++){const p=d[f];s.animations.push(r[p])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(s.autoUpdate=e.autoUpdate);const d=e.levels;for(let f=0;f<d.length;f++){const p=d[f],m=s.getObjectByProperty("uuid",p.object);m!==void 0&&s.addLevel(m,p.distance)}}return s}bindSkeletons(e,t){Object.keys(t).length!==0&&e.traverse(function(n){if(n.isSkinnedMesh===!0&&n.skeleton!==void 0){const i=t[n.skeleton];i===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",n.skeleton):n.bind(i,n.bindMatrix)}})}setTexturePath(e){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(e)}}const JR={UVMapping:mf,CubeReflectionMapping:ra,CubeRefractionMapping:sa,EquirectangularReflectionMapping:Oc,EquirectangularRefractionMapping:Bc,CubeUVReflectionMapping:Sl},Ny={RepeatWrapping:vs,ClampToEdgeWrapping:bi,MirroredRepeatWrapping:Lc},ky={NearestFilter:Dt,NearestMipmapNearestFilter:Xd,NearestMipmapLinearFilter:Jd,LinearFilter:St,LinearMipmapNearestFilter:Gg,LinearMipmapLinearFilter:uo};class DS extends ni{constructor(e){super(e),typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,s=to.get(e);if(s!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(s),r.manager.itemEnd(e)},0),s;const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",o.headers=this.requestHeader,fetch(e,o).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(l){to.add(e,l),t&&t(l),r.manager.itemEnd(e)}).catch(function(l){i&&i(l),r.manager.itemError(e),r.manager.itemEnd(e)}),r.manager.itemStart(e)}}DS.prototype.isImageBitmapLoader=!0;let Hh;const Bv={getContext:function(){return Hh===void 0&&(Hh=new(window.AudioContext||window.webkitAudioContext)),Hh},setContext:function(a){Hh=a}};class OS extends ni{constructor(e){super(e)}load(e,t,n,i){const r=this,s=new $i(this.manager);s.setResponseType("arraybuffer"),s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(e,function(o){try{const l=o.slice(0);Bv.getContext().decodeAudioData(l,function(u){t(u)})}catch(l){i?i(l):console.error(l),r.manager.itemError(e)}},n,i)}}class BS extends ju{constructor(e,t,n=1){super(void 0,n);const i=new Ie().set(e),r=new Ie().set(t),s=new A(i.r,i.g,i.b),o=new A(r.r,r.g,r.b),l=Math.sqrt(Math.PI),c=l*Math.sqrt(.75);this.sh.coefficients[0].copy(s).add(o).multiplyScalar(l),this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(c)}}BS.prototype.isHemisphereLightProbe=!0;class LS extends ju{constructor(e,t=1){super(void 0,t);const n=new Ie().set(e);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}LS.prototype.isAmbientLightProbe=!0;const Uy=new ae,Fy=new ae,ya=new ae;class ZR{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new tn,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new tn,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep,ya.copy(e.projectionMatrix);const i=t.eyeSep/2,r=i*t.near/t.focus,s=t.near*Math.tan(Wa*t.fov*.5)/t.zoom;let o,l;Fy.elements[12]=-i,Uy.elements[12]=i,o=-s*t.aspect+r,l=s*t.aspect+r,ya.elements[0]=2*t.near/(l-o),ya.elements[8]=(l+o)/(l-o),this.cameraL.projectionMatrix.copy(ya),o=-s*t.aspect-r,l=s*t.aspect-r,ya.elements[0]=2*t.near/(l-o),ya.elements[8]=(l+o)/(l-o),this.cameraR.projectionMatrix.copy(ya)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Fy),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Uy)}}class Lv{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=Hy(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=Hy();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function Hy(){return(typeof performance>"u"?Date:performance).now()}const xa=new A,Gy=new dt,KR=new A,wa=new A;class YR extends gt{constructor(){super(),this.type="AudioListener",this.context=Bv.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Lv}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,n=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(xa,Gy,KR),wa.set(0,0,-1).applyQuaternion(Gy),t.positionX){const i=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(xa.x,i),t.positionY.linearRampToValueAtTime(xa.y,i),t.positionZ.linearRampToValueAtTime(xa.z,i),t.forwardX.linearRampToValueAtTime(wa.x,i),t.forwardY.linearRampToValueAtTime(wa.y,i),t.forwardZ.linearRampToValueAtTime(wa.z,i),t.upX.linearRampToValueAtTime(n.x,i),t.upY.linearRampToValueAtTime(n.y,i),t.upZ.linearRampToValueAtTime(n.z,i)}else t.setPosition(xa.x,xa.y,xa.z),t.setOrientation(wa.x,wa.y,wa.z,n.x,n.y,n.z)}}class zv extends gt{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const Aa=new A,Vy=new dt,qR=new A,Sa=new A;class _R extends zv{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,n){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=n,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(Aa,Vy,qR),Sa.set(0,0,1).applyQuaternion(Vy);const t=this.panner;if(t.positionX){const n=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(Aa.x,n),t.positionY.linearRampToValueAtTime(Aa.y,n),t.positionZ.linearRampToValueAtTime(Aa.z,n),t.orientationX.linearRampToValueAtTime(Sa.x,n),t.orientationY.linearRampToValueAtTime(Sa.y,n),t.orientationZ.linearRampToValueAtTime(Sa.z,n)}else t.setPosition(Aa.x,Aa.y,Aa.z),t.setOrientation(Sa.x,Sa.y,Sa.z)}}class zS{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let n=0;n<t.length;n++)e+=t[n];return e/t.length}}class NS{constructor(e,t,n){this.binding=e,this.valueSize=n;let i,r,s;switch(t){case"quaternion":i=this._slerp,r=this._slerpAdditive,s=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(n*6),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,s=this._setAdditiveIdentityOther,this.buffer=new Array(n*5);break;default:i=this._lerp,r=this._lerpAdditive,s=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(n*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=s,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const n=this.buffer,i=this.valueSize,r=e*i+i;let s=this.cumulativeWeight;if(s===0){for(let o=0;o!==i;++o)n[r+o]=n[o];s=t}else{s+=t;const o=t/s;this._mixBufferRegion(n,r,0,o,i)}this.cumulativeWeight=s}accumulateAdditive(e){const t=this.buffer,n=this.valueSize,i=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,i,0,e,n),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,n=this.buffer,i=e*t+t,r=this.cumulativeWeight,s=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const l=t*this._origIndex;this._mixBufferRegion(n,i,l,1-r,t)}s>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*t,1,t);for(let l=t,c=t+t;l!==c;++l)if(n[l]!==n[l+t]){o.setValue(n,i);break}}saveOriginalState(){const e=this.binding,t=this.buffer,n=this.valueSize,i=n*this._origIndex;e.getValue(t,i);for(let r=n,s=i;r!==s;++r)t[r]=t[i+r%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]}_select(e,t,n,i,r){if(i>=.5)for(let s=0;s!==r;++s)e[t+s]=e[n+s]}_slerp(e,t,n,i){dt.slerpFlat(e,t,e,t,e,n,i)}_slerpAdditive(e,t,n,i,r){const s=this._workIndex*r;dt.multiplyQuaternionsFlat(e,s,e,t,e,n),dt.slerpFlat(e,t,e,t,e,s,i)}_lerp(e,t,n,i,r){const s=1-i;for(let o=0;o!==r;++o){const l=t+o;e[l]=e[l]*s+e[n+o]*i}}_lerpAdditive(e,t,n,i,r){for(let s=0;s!==r;++s){const o=t+s;e[o]=e[o]+e[n+s]*i}}}const Nv="\\[\\]\\.:\\/",$R=new RegExp("["+Nv+"]","g"),kv="[^"+Nv+"]",e3="[^"+Nv.replace("\\.","")+"]",t3=/((?:WC+[\/:])*)/.source.replace("WC",kv),n3=/(WCOD+)?/.source.replace("WCOD",e3),i3=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",kv),r3=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",kv),s3=new RegExp("^"+t3+n3+i3+r3+"$"),a3=["material","materials","bones"];class o3{constructor(e,t,n){const i=n||zt.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,i)}getValue(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];i!==void 0&&i.getValue(e,t)}setValue(e,t){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=n.length;i!==r;++i)n[i].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}class zt{constructor(e,t,n){this.path=t,this.parsedPath=n||zt.parseTrackName(t),this.node=zt.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,n){return e&&e.isAnimationObjectGroup?new zt.Composite(e,t,n):new zt(e,t,n)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace($R,"")}static parseTrackName(e){const t=s3.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const r=n.nodeName.substring(i+1);a3.indexOf(r)!==-1&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=r)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(n!==void 0)return n}if(e.children){const n=function(r){for(let s=0;s<r.length;s++){const o=r[s];if(o.name===t||o.uuid===t)return o;const l=n(o.children);if(l)return l}return null},i=n(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)e[t++]=n[i]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,n=t.objectName,i=t.propertyName;let r=t.propertyIndex;if(e||(e=zt.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(n){let c=t.objectIndex;switch(n){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let u=0;u<e.length;u++)if(e[u].name===c){c=u;break}break;default:if(e[n]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[n]}if(c!==void 0){if(e[c]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[c]}}const s=e[i];if(s===void 0){const c=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+c+"."+i+" but it wasn't found.",e);return}let o=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?o=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(r!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(e.geometry.isBufferGeometry){if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[r]!==void 0&&(r=e.morphTargetDictionary[r])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}l=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=r}else s.fromArray!==void 0&&s.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(l=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=i;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}zt.Composite=o3;zt.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};zt.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};zt.prototype.GetterByBindingType=[zt.prototype._getValue_direct,zt.prototype._getValue_array,zt.prototype._getValue_arrayElement,zt.prototype._getValue_toArray];zt.prototype.SetterByBindingTypeAndVersioning=[[zt.prototype._setValue_direct,zt.prototype._setValue_direct_setNeedsUpdate,zt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[zt.prototype._setValue_array,zt.prototype._setValue_array_setNeedsUpdate,zt.prototype._setValue_array_setMatrixWorldNeedsUpdate],[zt.prototype._setValue_arrayElement,zt.prototype._setValue_arrayElement_setNeedsUpdate,zt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[zt.prototype._setValue_fromArray,zt.prototype._setValue_fromArray_setNeedsUpdate,zt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class kS{constructor(){this.uuid=Ni(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let n=0,i=arguments.length;n!==i;++n)e[arguments[n].uuid]=n;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,n=this._paths,i=this._parsedPaths,r=this._bindings,s=r.length;let o,l=e.length,c=this.nCachedObjects_;for(let u=0,h=arguments.length;u!==h;++u){const d=arguments[u],f=d.uuid;let p=t[f];if(p===void 0){p=l++,t[f]=p,e.push(d);for(let m=0,g=s;m!==g;++m)r[m].push(new zt(d,n[m],i[m]))}else if(p<c){o=e[p];const m=--c,g=e[m];t[g.uuid]=p,e[p]=g,t[f]=m,e[m]=d;for(let v=0,y=s;v!==y;++v){const w=r[v],x=w[m];let S=w[p];w[p]=x,S===void 0&&(S=new zt(d,n[v],i[v])),w[m]=S}}else e[p]!==o&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=c}remove(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_;for(let s=0,o=arguments.length;s!==o;++s){const l=arguments[s],c=l.uuid,u=t[c];if(u!==void 0&&u>=r){const h=r++,d=e[h];t[d.uuid]=u,e[u]=d,t[c]=h,e[h]=l;for(let f=0,p=i;f!==p;++f){const m=n[f],g=m[h],v=m[u];m[u]=g,m[h]=v}}}this.nCachedObjects_=r}uncache(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_,s=e.length;for(let o=0,l=arguments.length;o!==l;++o){const c=arguments[o],u=c.uuid,h=t[u];if(h!==void 0)if(delete t[u],h<r){const d=--r,f=e[d],p=--s,m=e[p];t[f.uuid]=h,e[h]=f,t[m.uuid]=d,e[d]=m,e.pop();for(let g=0,v=i;g!==v;++g){const y=n[g],w=y[d],x=y[p];y[h]=w,y[d]=x,y.pop()}}else{const d=--s,f=e[d];d>0&&(t[f.uuid]=h),e[h]=f,e.pop();for(let p=0,m=i;p!==m;++p){const g=n[p];g[h]=g[d],g.pop()}}}this.nCachedObjects_=r}subscribe_(e,t){const n=this._bindingsIndicesByPath;let i=n[e];const r=this._bindings;if(i!==void 0)return r[i];const s=this._paths,o=this._parsedPaths,l=this._objects,c=l.length,u=this.nCachedObjects_,h=new Array(c);i=r.length,n[e]=i,s.push(e),o.push(t),r.push(h);for(let d=u,f=l.length;d!==f;++d){const p=l[d];h[d]=new zt(p,e,t)}return h}unsubscribe_(e){const t=this._bindingsIndicesByPath,n=t[e];if(n!==void 0){const i=this._paths,r=this._parsedPaths,s=this._bindings,o=s.length-1,l=s[o],c=e[o];t[c]=n,s[n]=l,s.pop(),r[n]=r[o],r.pop(),i[n]=i[o],i.pop()}}}kS.prototype.isAnimationObjectGroup=!0;class l3{constructor(e,t,n=null,i=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=n,this.blendMode=i;const r=t.tracks,s=r.length,o=new Array(s),l={endingStart:ka,endingEnd:ka};for(let c=0;c!==s;++c){const u=r[c].createInterpolant(null);o[c]=u,u.settings=l}this._interpolantSettings=l,this._interpolants=o,this._propertyBindings=new Array(s),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=UA,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,n){if(e.fadeOut(t),this.fadeIn(t),n){const i=this._clip.duration,r=e._clip.duration,s=r/i,o=i/r;e.warp(1,s,t),this.warp(o,1,t)}return this}crossFadeTo(e,t,n){return e.crossFadeFrom(this,t,n)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,n){const i=this._mixer,r=i.time,s=this.timeScale;let o=this._timeScaleInterpolant;o===null&&(o=i._lendControlInterpolant(),this._timeScaleInterpolant=o);const l=o.parameterPositions,c=o.sampleValues;return l[0]=r,l[1]=r+n,c[0]=e/s,c[1]=t/s,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,n,i){if(!this.enabled){this._updateWeight(e);return}const r=this._startTime;if(r!==null){const l=(e-r)*n;if(l<0||n===0)return;this._startTime=null,t=n*l}t*=this._updateTimeScale(e);const s=this._updateTime(t),o=this._updateWeight(e);if(o>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case nv:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(s),c[u].accumulateAdditive(o);break;case vf:default:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(s),c[u].accumulate(i,o)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const n=this._weightInterpolant;if(n!==null){const i=n.evaluate(e)[0];t*=i,e>n.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const n=this._timeScaleInterpolant;if(n!==null){const i=n.evaluate(e)[0];t*=i,e>n.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,n=this.loop;let i=this.time+e,r=this._loopCount;const s=n===FA;if(e===0)return r===-1?i:s&&(r&1)===1?t-i:i;if(n===kA){r===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(i>=t)i=t;else if(i<0)i=0;else{this.time=i;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(r===-1&&(e>=0?(r=0,this._setEndings(!0,this.repetitions===0,s)):this._setEndings(this.repetitions===0,!0,s)),i>=t||i<0){const o=Math.floor(i/t);i-=t*o,r+=Math.abs(o);const l=this.repetitions-r;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=e>0?t:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const c=e<0;this._setEndings(c,!c,s)}else this._setEndings(!1,!1,s);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:o})}}else this.time=i;if(s&&(r&1)===1)return t-i}return i}_setEndings(e,t,n){const i=this._interpolantSettings;n?(i.endingStart=Ua,i.endingEnd=Ua):(e?i.endingStart=this.zeroSlopeAtStart?Ua:ka:i.endingStart=ru,t?i.endingEnd=this.zeroSlopeAtEnd?Ua:ka:i.endingEnd=ru)}_scheduleFading(e,t,n){const i=this._mixer,r=i.time;let s=this._weightInterpolant;s===null&&(s=i._lendControlInterpolant(),this._weightInterpolant=s);const o=s.parameterPositions,l=s.sampleValues;return o[0]=r,l[0]=t,o[1]=r+e,l[1]=n,this}}class US extends Ss{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const n=e._localRoot||this._root,i=e._clip.tracks,r=i.length,s=e._propertyBindings,o=e._interpolants,l=n.uuid,c=this._bindingsByRootAndName;let u=c[l];u===void 0&&(u={},c[l]=u);for(let h=0;h!==r;++h){const d=i[h],f=d.name;let p=u[f];if(p!==void 0)++p.referenceCount,s[h]=p;else{if(p=s[h],p!==void 0){p._cacheIndex===null&&(++p.referenceCount,this._addInactiveBinding(p,l,f));continue}const m=t&&t._propertyBindings[h].binding.parsedPath;p=new NS(zt.create(n,f,m),d.ValueTypeName,d.getValueSize()),++p.referenceCount,this._addInactiveBinding(p,l,f),s[h]=p}o[h].resultBuffer=p.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const n=(e._localRoot||this._root).uuid,i=e._clip.uuid,r=this._actionsByClip[i];this._bindAction(e,r&&r.knownActions[0]),this._addInactiveAction(e,i,n)}const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const r=t[n];r.useCount++===0&&(this._lendBinding(r),r.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const r=t[n];--r.useCount===0&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,n){const i=this._actions,r=this._actionsByClip;let s=r[t];if(s===void 0)s={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,r[t]=s;else{const o=s.knownActions;e._byClipCacheIndex=o.length,o.push(e)}e._cacheIndex=i.length,i.push(e),s.actionByRoot[n]=e}_removeInactiveAction(e){const t=this._actions,n=t[t.length-1],i=e._cacheIndex;n._cacheIndex=i,t[i]=n,t.pop(),e._cacheIndex=null;const r=e._clip.uuid,s=this._actionsByClip,o=s[r],l=o.knownActions,c=l[l.length-1],u=e._byClipCacheIndex;c._byClipCacheIndex=u,l[u]=c,l.pop(),e._byClipCacheIndex=null;const h=o.actionByRoot,d=(e._localRoot||this._root).uuid;delete h[d],l.length===0&&delete s[r],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const r=t[n];--r.referenceCount===0&&this._removeInactiveBinding(r)}}_lendAction(e){const t=this._actions,n=e._cacheIndex,i=this._nActiveActions++,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r}_takeBackAction(e){const t=this._actions,n=e._cacheIndex,i=--this._nActiveActions,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r}_addInactiveBinding(e,t,n){const i=this._bindingsByRootAndName,r=this._bindings;let s=i[t];s===void 0&&(s={},i[t]=s),s[n]=e,e._cacheIndex=r.length,r.push(e)}_removeInactiveBinding(e){const t=this._bindings,n=e.binding,i=n.rootNode.uuid,r=n.path,s=this._bindingsByRootAndName,o=s[i],l=t[t.length-1],c=e._cacheIndex;l._cacheIndex=c,t[c]=l,t.pop(),delete o[r],Object.keys(o).length===0&&delete s[i]}_lendBinding(e){const t=this._bindings,n=e._cacheIndex,i=this._nActiveBindings++,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r}_takeBackBinding(e){const t=this._bindings,n=e._cacheIndex,i=--this._nActiveBindings,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return n===void 0&&(n=new Sv(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=t,e[t]=n),n}_takeBackControlInterpolant(e){const t=this._controlInterpolants,n=e.__cacheIndex,i=--this._nActiveControlInterpolants,r=t[i];e.__cacheIndex=i,t[i]=e,r.__cacheIndex=n,t[n]=r}clipAction(e,t,n){const i=t||this._root,r=i.uuid;let s=typeof e=="string"?fu.findByName(i,e):e;const o=s!==null?s.uuid:e,l=this._actionsByClip[o];let c=null;if(n===void 0&&(s!==null?n=s.blendMode:n=vf),l!==void 0){const h=l.actionByRoot[r];if(h!==void 0&&h.blendMode===n)return h;c=l.knownActions[0],s===null&&(s=c._clip)}if(s===null)return null;const u=new l3(this,s,t,n);return this._bindAction(u,c),this._addInactiveAction(u,o,r),u}existingAction(e,t){const n=t||this._root,i=n.uuid,r=typeof e=="string"?fu.findByName(n,e):e,s=r?r.uuid:e,o=this._actionsByClip[s];return o!==void 0&&o.actionByRoot[i]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let n=t-1;n>=0;--n)e[n].stop();return this}update(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,i=this.time+=e,r=Math.sign(e),s=this._accuIndex^=1;for(let c=0;c!==n;++c)t[c]._update(i,e,r,s);const o=this._bindings,l=this._nActiveBindings;for(let c=0;c!==l;++c)o[c].apply(s);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,n=e.uuid,i=this._actionsByClip,r=i[n];if(r!==void 0){const s=r.knownActions;for(let o=0,l=s.length;o!==l;++o){const c=s[o];this._deactivateAction(c);const u=c._cacheIndex,h=t[t.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,h._cacheIndex=u,t[u]=h,t.pop(),this._removeInactiveBindingsForAction(c)}delete i[n]}}uncacheRoot(e){const t=e.uuid,n=this._actionsByClip;for(const s in n){const o=n[s].actionByRoot,l=o[t];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const i=this._bindingsByRootAndName,r=i[t];if(r!==void 0)for(const s in r){const o=r[s];o.restoreOriginalState(),this._removeInactiveBinding(o)}}uncacheAction(e,t){const n=this.existingAction(e,t);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}US.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class Hf{constructor(e){typeof e=="string"&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}clone(){return new Hf(this.value.clone===void 0?this.value:this.value.clone())}}class no extends fo{constructor(e,t,n=1){super(e,t),this.meshPerAttribute=n}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}no.prototype.isInstancedInterleavedBuffer=!0;class FS{constructor(e,t,n,i,r){this.buffer=e,this.type=t,this.itemSize=n,this.elementSize=i,this.count=r,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}FS.prototype.isGLBufferAttribute=!0;class Wu{constructor(e,t,n=0,i=1/0){this.ray=new On(e,t),this.near=n,this.far=i,this.camera=null,this.layers=new xf,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}intersectObject(e,t=!0,n=[]){return ig(e,this,n,t),n.sort(jy),n}intersectObjects(e,t=!0,n=[]){for(let i=0,r=e.length;i<r;i++)ig(e[i],this,n,t);return n.sort(jy),n}}function jy(a,e){return a.distance-e.distance}function ig(a,e,t,n){if(a.layers.test(e.layers)&&a.raycast(e,t),n===!0){const i=a.children;for(let r=0,s=i.length;r<s;r++)ig(i[r],e,t,!0)}}class Sc{constructor(e=1,t=0,n=0){return this.radius=e,this.phi=t,this.theta=n,this}set(e,t,n){return this.radius=e,this.phi=t,this.theta=n,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+t*t+n*n),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,n),this.phi=Math.acos(In(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class c3{constructor(e=1,t=0,n=0){return this.radius=e,this.theta=t,this.y=n,this}set(e,t,n){return this.radius=e,this.theta=t,this.y=n,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+n*n),this.theta=Math.atan2(e,n),this.y=t,this}clone(){return new this.constructor().copy(this)}}const Qy=new te;class Pl{constructor(e=new te(1/0,1/0),t=new te(-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=Qy.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return Qy.copy(e).clamp(this.min,this.max).sub(e).length()}intersect(e){return this.min.max(e.min),this.max.min(e.max),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}Pl.prototype.isBox2=!0;const Wy=new A,Gh=new A;class Ui{constructor(e=new A,t=new A){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){Wy.subVectors(e,this.start),Gh.subVectors(this.end,this.start);const n=Gh.dot(Gh);let r=Gh.dot(Wy)/n;return t&&(r=In(r,0,1)),r}closestPointToPoint(e,t,n){const i=this.closestPointToPointParameter(e,t);return this.delta(n).multiplyScalar(i).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const Xy=new A;class u3 extends gt{constructor(e,t){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;const n=new nt,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let s=0,o=1,l=32;s<l;s++,o++){const c=s/l*Math.PI*2,u=o/l*Math.PI*2;i.push(Math.cos(c),Math.sin(c),1,Math.cos(u),Math.sin(u),1)}n.setAttribute("position",new je(i,3));const r=new mn({fog:!1,toneMapped:!1});this.cone=new gi(n,r),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),Xy.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(Xy),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const ks=new A,Vh=new ae,Gp=new ae;class HS extends gi{constructor(e){const t=GS(e),n=new nt,i=[],r=[],s=new Ie(0,0,1),o=new Ie(0,1,0);for(let c=0;c<t.length;c++){const u=t[c];u.parent&&u.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),r.push(s.r,s.g,s.b),r.push(o.r,o.g,o.b))}n.setAttribute("position",new je(i,3)),n.setAttribute("color",new je(r,3));const l=new mn({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(n,l),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,n=this.geometry,i=n.getAttribute("position");Gp.copy(this.root.matrixWorld).invert();for(let r=0,s=0;r<t.length;r++){const o=t[r];o.parent&&o.parent.isBone&&(Vh.multiplyMatrices(Gp,o.matrixWorld),ks.setFromMatrixPosition(Vh),i.setXYZ(s,ks.x,ks.y,ks.z),Vh.multiplyMatrices(Gp,o.parent.matrixWorld),ks.setFromMatrixPosition(Vh),i.setXYZ(s+1,ks.x,ks.y,ks.z),s+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}function GS(a){const e=[];a.isBone===!0&&e.push(a);for(let t=0;t<a.children.length;t++)e.push.apply(e,GS(a.children[t]));return e}class h3 extends Ve{constructor(e,t,n){const i=new xs(t,4,2),r=new ti({wireframe:!0,fog:!1,toneMapped:!1});super(i,r),this.light=e,this.light.updateMatrixWorld(),this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const d3=new A,Jy=new Ie,Zy=new Ie;class f3 extends gt{constructor(e,t,n){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n;const i=new mr(t);i.rotateY(Math.PI*.5),this.material=new ti({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const r=i.getAttribute("position"),s=new Float32Array(r.count*3);i.setAttribute("color",new wt(s,3)),this.add(new Ve(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");Jy.copy(this.light.color),Zy.copy(this.light.groundColor);for(let n=0,i=t.count;n<i;n++){const r=n<i/2?Jy:Zy;t.setXYZ(n,r.r,r.g,r.b)}t.needsUpdate=!0}e.lookAt(d3.setFromMatrixPosition(this.light.matrixWorld).negate())}}class VS extends gi{constructor(e=10,t=10,n=4473924,i=8947848){n=new Ie(n),i=new Ie(i);const r=t/2,s=e/t,o=e/2,l=[],c=[];for(let d=0,f=0,p=-o;d<=t;d++,p+=s){l.push(-o,0,p,o,0,p),l.push(p,0,-o,p,0,o);const m=d===r?n:i;m.toArray(c,f),f+=3,m.toArray(c,f),f+=3,m.toArray(c,f),f+=3,m.toArray(c,f),f+=3}const u=new nt;u.setAttribute("position",new je(l,3)),u.setAttribute("color",new je(c,3));const h=new mn({vertexColors:!0,toneMapped:!1});super(u,h),this.type="GridHelper"}}class p3 extends gi{constructor(e=10,t=16,n=8,i=64,r=4473924,s=8947848){r=new Ie(r),s=new Ie(s);const o=[],l=[];for(let h=0;h<=t;h++){const d=h/t*(Math.PI*2),f=Math.sin(d)*e,p=Math.cos(d)*e;o.push(0,0,0),o.push(f,0,p);const m=h&1?r:s;l.push(m.r,m.g,m.b),l.push(m.r,m.g,m.b)}for(let h=0;h<=n;h++){const d=h&1?r:s,f=e-e/n*h;for(let p=0;p<i;p++){let m=p/i*(Math.PI*2),g=Math.sin(m)*f,v=Math.cos(m)*f;o.push(g,0,v),l.push(d.r,d.g,d.b),m=(p+1)/i*(Math.PI*2),g=Math.sin(m)*f,v=Math.cos(m)*f,o.push(g,0,v),l.push(d.r,d.g,d.b)}}const c=new nt;c.setAttribute("position",new je(o,3)),c.setAttribute("color",new je(l,3));const u=new mn({vertexColors:!0,toneMapped:!1});super(c,u),this.type="PolarGridHelper"}}const Ky=new A,jh=new A,Yy=new A;class jS extends gt{constructor(e,t,n){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,t===void 0&&(t=1);let i=new nt;i.setAttribute("position",new je([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const r=new mn({fog:!1,toneMapped:!1});this.lightPlane=new $n(i,r),this.add(this.lightPlane),i=new nt,i.setAttribute("position",new je([0,0,0,0,0,1],3)),this.targetLine=new $n(i,r),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){Ky.setFromMatrixPosition(this.light.matrixWorld),jh.setFromMatrixPosition(this.light.target.matrixWorld),Yy.subVectors(jh,Ky),this.lightPlane.lookAt(jh),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(jh),this.targetLine.scale.z=Yy.length()}}const Qh=new A,vn=new zu;class Uv extends gi{constructor(e){const t=new nt,n=new mn({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],r=[],s={},o=new Ie(16755200),l=new Ie(16711680),c=new Ie(43775),u=new Ie(16777215),h=new Ie(3355443);d("n1","n2",o),d("n2","n4",o),d("n4","n3",o),d("n3","n1",o),d("f1","f2",o),d("f2","f4",o),d("f4","f3",o),d("f3","f1",o),d("n1","f1",o),d("n2","f2",o),d("n3","f3",o),d("n4","f4",o),d("p","n1",l),d("p","n2",l),d("p","n3",l),d("p","n4",l),d("u1","u2",c),d("u2","u3",c),d("u3","u1",c),d("c","t",u),d("p","c",h),d("cn1","cn2",h),d("cn3","cn4",h),d("cf1","cf2",h),d("cf3","cf4",h);function d(p,m,g){f(p,g),f(m,g)}function f(p,m){i.push(0,0,0),r.push(m.r,m.g,m.b),s[p]===void 0&&(s[p]=[]),s[p].push(i.length/3-1)}t.setAttribute("position",new je(i,3)),t.setAttribute("color",new je(r,3)),super(t,n),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=s,this.update()}update(){const e=this.geometry,t=this.pointMap,n=1,i=1;vn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),En("c",t,e,vn,0,0,-1),En("t",t,e,vn,0,0,1),En("n1",t,e,vn,-n,-i,-1),En("n2",t,e,vn,n,-i,-1),En("n3",t,e,vn,-n,i,-1),En("n4",t,e,vn,n,i,-1),En("f1",t,e,vn,-n,-i,1),En("f2",t,e,vn,n,-i,1),En("f3",t,e,vn,-n,i,1),En("f4",t,e,vn,n,i,1),En("u1",t,e,vn,n*.7,i*1.1,-1),En("u2",t,e,vn,-n*.7,i*1.1,-1),En("u3",t,e,vn,0,i*2,-1),En("cf1",t,e,vn,-n,0,1),En("cf2",t,e,vn,n,0,1),En("cf3",t,e,vn,0,-i,1),En("cf4",t,e,vn,0,i,1),En("cn1",t,e,vn,-n,0,-1),En("cn2",t,e,vn,n,0,-1),En("cn3",t,e,vn,0,-i,-1),En("cn4",t,e,vn,0,i,-1),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function En(a,e,t,n,i,r,s){Qh.set(i,r,s).unproject(n);const o=e[a];if(o!==void 0){const l=t.getAttribute("position");for(let c=0,u=o.length;c<u;c++)l.setXYZ(o[c],Qh.x,Qh.y,Qh.z)}}const Wh=new He;class QS extends gi{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),r=new nt;r.setIndex(new wt(n,1)),r.setAttribute("position",new wt(i,3)),super(r,new mn({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&Wh.setFromObject(this.object),Wh.isEmpty())return;const t=Wh.min,n=Wh.max,i=this.geometry.attributes.position,r=i.array;r[0]=n.x,r[1]=n.y,r[2]=n.z,r[3]=t.x,r[4]=n.y,r[5]=n.z,r[6]=t.x,r[7]=t.y,r[8]=n.z,r[9]=n.x,r[10]=t.y,r[11]=n.z,r[12]=n.x,r[13]=n.y,r[14]=t.z,r[15]=t.x,r[16]=n.y,r[17]=t.z,r[18]=t.x,r[19]=t.y,r[20]=t.z,r[21]=n.x,r[22]=t.y,r[23]=t.z,i.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e){return gi.prototype.copy.call(this,e),this.object=e.object,this}}class m3 extends gi{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],r=new nt;r.setIndex(new wt(n,1)),r.setAttribute("position",new je(i,3)),super(r,new mn({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}}class g3 extends $n{constructor(e,t=1,n=16776960){const i=n,r=[1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],s=new nt;s.setAttribute("position",new je(r,3)),s.computeBoundingSphere(),super(s,new mn({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const o=[1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],l=new nt;l.setAttribute("position",new je(o,3)),l.computeBoundingSphere(),this.add(new Ve(l,new ti({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){let t=-this.plane.constant;Math.abs(t)<1e-8&&(t=1e-8),this.scale.set(.5*this.size,.5*this.size,t),this.children[0].material.side=t<0?pi:An,this.lookAt(this.plane.normal),super.updateMatrixWorld(e)}}const qy=new A;let Xh,Vp;class v3 extends gt{constructor(e=new A(0,0,1),t=new A(0,0,0),n=1,i=16776960,r=n*.2,s=r*.2){super(),this.type="ArrowHelper",Xh===void 0&&(Xh=new nt,Xh.setAttribute("position",new je([0,0,0,0,1,0],3)),Vp=new yn(0,.5,1,5,1),Vp.translate(0,-.5,0)),this.position.copy(t),this.line=new $n(Xh,new mn({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Ve(Vp,new ti({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(n,r,s)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{qy.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(qy,t)}}setLength(e,t=e*.2,n=t*.2){this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(n,t,n),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}}class WS extends gi{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],n=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],i=new nt;i.setAttribute("position",new je(t,3)),i.setAttribute("color",new je(n,3));const r=new mn({vertexColors:!0,toneMapped:!1});super(i,r),this.type="AxesHelper"}setColors(e,t,n){const i=new Ie,r=this.geometry.attributes.color.array;return i.set(e),i.toArray(r,0),i.toArray(r,3),i.set(t),i.toArray(r,6),i.toArray(r,9),i.set(n),i.toArray(r,12),i.toArray(r,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class XS{constructor(){this.type="ShapePath",this.color=new Ie,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new ll,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,n,i){return this.currentPath.quadraticCurveTo(e,t,n,i),this}bezierCurveTo(e,t,n,i,r,s){return this.currentPath.bezierCurveTo(e,t,n,i,r,s),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e,t){function n(y){const w=[];for(let x=0,S=y.length;x<S;x++){const b=y[x],E=new kr;E.curves=b.curves,w.push(E)}return w}function i(y,w){const x=w.length;let S=!1;for(let b=x-1,E=0;E<x;b=E++){let M=w[b],T=w[E],I=T.x-M.x,O=T.y-M.y;if(Math.abs(O)>Number.EPSILON){if(O<0&&(M=w[E],I=-I,T=w[b],O=-O),y.y<M.y||y.y>T.y)continue;if(y.y===M.y){if(y.x===M.x)return!0}else{const R=O*(y.x-M.x)-I*(y.y-M.y);if(R===0)return!0;if(R<0)continue;S=!S}}else{if(y.y!==M.y)continue;if(T.x<=y.x&&y.x<=M.x||M.x<=y.x&&y.x<=T.x)return!0}}return S}const r=Ur.isClockWise,s=this.subPaths;if(s.length===0)return[];if(t===!0)return n(s);let o,l,c;const u=[];if(s.length===1)return l=s[0],c=new kr,c.curves=l.curves,u.push(c),u;let h=!r(s[0].getPoints());h=e?!h:h;const d=[],f=[];let p=[],m=0,g;f[m]=void 0,p[m]=[];for(let y=0,w=s.length;y<w;y++)l=s[y],g=l.getPoints(),o=r(g),o=e?!o:o,o?(!h&&f[m]&&m++,f[m]={s:new kr,p:g},f[m].s.curves=l.curves,h&&m++,p[m]=[]):p[m].push({h:l,p:g[0]});if(!f[0])return n(s);if(f.length>1){let y=!1,w=0;for(let x=0,S=f.length;x<S;x++)d[x]=[];for(let x=0,S=f.length;x<S;x++){const b=p[x];for(let E=0;E<b.length;E++){const M=b[E];let T=!0;for(let I=0;I<f.length;I++)i(M.p,f[I].p)&&(x!==I&&w++,T?(T=!1,d[I].push(M)):y=!0);T&&d[x].push(M)}}w>0&&y===!1&&(p=d)}let v;for(let y=0,w=f.length;y<w;y++){c=f[y].s,u.push(c),v=p[y];for(let x=0,S=v.length;x<S;x++)c.holes.push(v[x].h)}return u}}class Fa{static toHalfFloat(e){Math.abs(e)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),e=In(e,-65504,65504),_y[0]=e;const t=$y[0],n=t>>23&511;return lr[n]+((t&8388607)>>cr[n])}static fromHalfFloat(e){const t=e>>10;return $y[0]=Fv[ZS[t]+(e&1023)]+Dl[t],_y[0]}}const JS=new ArrayBuffer(4),_y=new Float32Array(JS),$y=new Uint32Array(JS),lr=new Uint32Array(512),cr=new Uint32Array(512);for(let a=0;a<256;++a){const e=a-127;e<-27?(lr[a]=0,lr[a|256]=32768,cr[a]=24,cr[a|256]=24):e<-14?(lr[a]=1024>>-e-14,lr[a|256]=1024>>-e-14|32768,cr[a]=-e-1,cr[a|256]=-e-1):e<=15?(lr[a]=e+15<<10,lr[a|256]=e+15<<10|32768,cr[a]=13,cr[a|256]=13):e<128?(lr[a]=31744,lr[a|256]=64512,cr[a]=24,cr[a|256]=24):(lr[a]=31744,lr[a|256]=64512,cr[a]=13,cr[a|256]=13)}const Fv=new Uint32Array(2048),Dl=new Uint32Array(64),ZS=new Uint32Array(64);for(let a=1;a<1024;++a){let e=a<<13,t=0;for(;(e&8388608)===0;)e<<=1,t-=8388608;e&=-8388609,t+=947912704,Fv[a]=e|t}for(let a=1024;a<2048;++a)Fv[a]=939524096+(a-1024<<13);for(let a=1;a<31;++a)Dl[a]=a<<23;Dl[31]=1199570944;Dl[32]=2147483648;for(let a=33;a<63;++a)Dl[a]=2147483648+(a-32<<23);Dl[63]=3347054592;for(let a=1;a<64;++a)a!==32&&(ZS[a]=1024);const y3=0,x3=1,w3=0,A3=1,S3=2;function M3(a){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),a}function b3(a=[]){return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),a.isMultiMaterial=!0,a.materials=a,a.clone=function(){return a.slice()},a}class E3 extends ms{constructor(e,t){console.warn("THREE.PointCloud has been renamed to THREE.Points."),super(e,t)}}class T3 extends bf{constructor(e){console.warn("THREE.Particle has been renamed to THREE.Sprite."),super(e)}}class C3 extends ms{constructor(e,t){console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),super(e,t)}}class I3 extends Ki{constructor(e){console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),super(e)}}class R3 extends Ki{constructor(e){console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),super(e)}}class P3 extends Ki{constructor(e){console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),super(e)}}class D3 extends A{constructor(e,t,n){console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),super(e,t,n)}}class O3 extends wt{constructor(e,t){console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),super(e,t),this.setUsage(Xn)}}class B3 extends KA{constructor(e,t){console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),super(e,t)}}class L3 extends YA{constructor(e,t){console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),super(e,t)}}class z3 extends qA{constructor(e,t){console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),super(e,t)}}class N3 extends wf{constructor(e,t){console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),super(e,t)}}class k3 extends _i{constructor(e,t){console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),super(e,t)}}class U3 extends _A{constructor(e,t){console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),super(e,t)}}class F3 extends ys{constructor(e,t){console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),super(e,t)}}class H3 extends je{constructor(e,t){console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),super(e,t)}}class G3 extends eS{constructor(e,t){console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),super(e,t)}}Gi.create=function(a,e){return console.log("THREE.Curve.create() has been deprecated"),a.prototype=Object.create(Gi.prototype),a.prototype.constructor=a,a.prototype.getPoint=e,a};ll.prototype.fromPoints=function(a){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(a)};class V3 extends WS{constructor(e){console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),super(e)}}class j3 extends QS{constructor(e,t){console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),super(e,t)}}class Q3 extends gi{constructor(e,t){console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),super(new mv(e.geometry),new mn({color:t!==void 0?t:16777215}))}}VS.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};HS.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};class W3 extends gi{constructor(e,t){console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),super(new Lf(e.geometry),new mn({color:t!==void 0?t:16777215}))}}ni.prototype.extractUrlBase=function(a){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),Yd.extractUrlBase(a)};ni.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};class X3 extends $i{constructor(e){console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),super(e)}}class J3 extends Uf{constructor(e){console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),super(e)}}Pl.prototype.center=function(a){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(a)};Pl.prototype.empty=function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()};Pl.prototype.isIntersectionBox=function(a){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(a)};Pl.prototype.size=function(a){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(a)};He.prototype.center=function(a){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(a)};He.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()};He.prototype.isIntersectionBox=function(a){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(a)};He.prototype.isIntersectionSphere=function(a){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(a)};He.prototype.size=function(a){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(a)};mi.prototype.toVector3=function(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")};rn.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()};El.prototype.setFromMatrix=function(a){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(a)};Ui.prototype.center=function(a){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(a)};Kt.prototype.flattenToArrayOffset=function(a,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(a,e)};Kt.prototype.multiplyVector3=function(a){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),a.applyMatrix3(this)};Kt.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")};Kt.prototype.applyToBufferAttribute=function(a){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),a.applyMatrix3(this)};Kt.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")};Kt.prototype.getInverse=function(a){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(a).invert()};ae.prototype.extractPosition=function(a){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(a)};ae.prototype.flattenToArrayOffset=function(a,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(a,e)};ae.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new A().setFromMatrixColumn(this,3)};ae.prototype.setRotationFromQuaternion=function(a){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(a)};ae.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")};ae.prototype.multiplyVector3=function(a){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),a.applyMatrix4(this)};ae.prototype.multiplyVector4=function(a){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),a.applyMatrix4(this)};ae.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")};ae.prototype.rotateAxis=function(a){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),a.transformDirection(this)};ae.prototype.crossVector=function(a){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),a.applyMatrix4(this)};ae.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")};ae.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")};ae.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")};ae.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")};ae.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")};ae.prototype.applyToBufferAttribute=function(a){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),a.applyMatrix4(this)};ae.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")};ae.prototype.makeFrustum=function(a,e,t,n,i,r){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(a,e,n,t,i,r)};ae.prototype.getInverse=function(a){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(a).invert()};kt.prototype.isIntersectionLine=function(a){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(a)};dt.prototype.multiplyVector3=function(a){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),a.applyQuaternion(this)};dt.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()};On.prototype.isIntersectionBox=function(a){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(a)};On.prototype.isIntersectionPlane=function(a){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(a)};On.prototype.isIntersectionSphere=function(a){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(a)};Ht.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()};Ht.prototype.barycoordFromPoint=function(a,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(a,e)};Ht.prototype.midpoint=function(a){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(a)};Ht.prototypenormal=function(a){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(a)};Ht.prototype.plane=function(a){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(a)};Ht.barycoordFromPoint=function(a,e,t,n,i){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Ht.getBarycoord(a,e,t,n,i)};Ht.normal=function(a,e,t,n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Ht.getNormal(a,e,t,n)};kr.prototype.extractAllPoints=function(a){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(a)};kr.prototype.extrude=function(a){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Vr(this,a)};kr.prototype.makeGeometry=function(a){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new eo(this,a)};te.prototype.fromAttribute=function(a,e,t){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(a,e,t)};te.prototype.distanceToManhattan=function(a){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(a)};te.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};A.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")};A.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")};A.prototype.getPositionFromMatrix=function(a){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(a)};A.prototype.getScaleFromMatrix=function(a){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(a)};A.prototype.getColumnFromMatrix=function(a,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,a)};A.prototype.applyProjection=function(a){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(a)};A.prototype.fromAttribute=function(a,e,t){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(a,e,t)};A.prototype.distanceToManhattan=function(a){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(a)};A.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};lt.prototype.fromAttribute=function(a,e,t){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(a,e,t)};lt.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};gt.prototype.getChildByName=function(a){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(a)};gt.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")};gt.prototype.translate=function(a,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,a)};gt.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")};gt.prototype.applyMatrix=function(a){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(a)};Object.defineProperties(gt.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(a){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=a}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});Ve.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")};Object.defineProperties(Ve.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),HA},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});Ef.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};tn.prototype.setLens=function(a,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),e!==void 0&&(this.filmGauge=e),this.setFocalLength(a)};Object.defineProperties(xr.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(a){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=a}},shadowCameraLeft:{set:function(a){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=a}},shadowCameraRight:{set:function(a){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=a}},shadowCameraTop:{set:function(a){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=a}},shadowCameraBottom:{set:function(a){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=a}},shadowCameraNear:{set:function(a){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=a}},shadowCameraFar:{set:function(a){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=a}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(a){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=a}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(a){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=a}},shadowMapHeight:{set:function(a){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=a}}});Object.defineProperties(wt.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===Xn},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(Xn)}}});wt.prototype.setDynamic=function(a){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(a===!0?Xn:al),this};wt.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},wt.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};nt.prototype.addIndex=function(a){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(a)};nt.prototype.addAttribute=function(a,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(e&&e.isBufferAttribute)&&!(e&&e.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(a,new wt(arguments[1],arguments[2]))):a==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(a,e)};nt.prototype.addDrawCall=function(a,e,t){t!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(a,e)};nt.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()};nt.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")};nt.prototype.removeAttribute=function(a){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(a)};nt.prototype.applyMatrix=function(a){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(a)};Object.defineProperties(nt.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});fo.prototype.setDynamic=function(a){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(a===!0?Xn:al),this};fo.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};Vr.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")};Vr.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")};Vr.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")};Hu.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")};Hf.prototype.onUpdate=function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this};Object.defineProperties(cn.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Ie}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(a){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=a===zg}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(a){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=a}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}});Object.defineProperties(gn.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(a){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=a}}});Wt.prototype.clearTarget=function(a,e,t,n){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(a),this.clear(e,t,n)};Wt.prototype.animate=function(a){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(a)};Wt.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()};Wt.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()};Wt.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision};Wt.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()};Wt.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")};Wt.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")};Wt.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")};Wt.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")};Wt.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")};Wt.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")};Wt.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures};Wt.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")};Wt.prototype.enableScissorTest=function(a){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(a)};Wt.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")};Wt.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")};Wt.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")};Wt.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")};Wt.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")};Wt.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")};Wt.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")};Wt.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")};Wt.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")};Wt.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()};Object.defineProperties(Wt.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(a){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=a}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(a){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=a}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(a){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=a===!0?vt:Fi}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}},gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});Object.defineProperties(lS.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});class Z3 extends Nu{constructor(e,t,n){console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),super(e,n)}}Object.defineProperties(pn.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(a){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=a}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(a){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=a}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(a){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=a}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(a){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=a}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(a){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=a}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(a){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=a}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(a){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=a}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(a){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=a}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(a){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=a}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(a){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=a}}});zv.prototype.load=function(a){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return new OS().load(a,function(n){e.setBuffer(n)}),this};zS.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()};Af.prototype.updateCubeMap=function(a,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(a,e)};Af.prototype.clear=function(a,e,t,n){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(a,e,t,n)};fa.crossOrigin=void 0;fa.loadTexture=function(a,e,t,n){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const i=new Ev;i.setCrossOrigin(this.crossOrigin);const r=i.load(a,t,void 0,n);return e&&(r.mapping=e),r};fa.loadTextureCube=function(a,e,t,n){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const i=new ES;i.setCrossOrigin(this.crossOrigin);const r=i.load(a,t,void 0,n);return e&&(r.mapping=e),r};fa.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};fa.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};function K3(){console.error("THREE.CanvasRenderer has been removed")}function Y3(){console.error("THREE.JSONLoader has been removed.")}const q3={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};function _3(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")}class $3 extends nt{constructor(){console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"),super()}}class eP extends nt{constructor(){console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"),super()}}function tP(){console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js")}function nP(){console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js")}function iP(){console.error("THREE.ImmediateRenderObject has been removed.")}class rP extends pn{constructor(e,t,n){console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'),super(e,t,n),this.samples=4}}class sP extends Ml{constructor(e,t,n,i){console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."),super(e,t,n,i)}}class aP extends Lu{constructor(e,t,n,i){console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."),super(e,t,n,i)}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:ff}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=ff);const Jk=Object.defineProperty({__proto__:null,ACESFilmicToneMapping:Hg,AddEquation:hr,AddOperation:OA,AdditiveAnimationBlendMode:nv,AdditiveBlending:Jm,AlphaFormat:Jg,AlwaysDepth:EA,AlwaysStencilFunc:Bu,AmbientLight:Pv,AmbientLightProbe:LS,AnimationClip:fu,AnimationLoader:QR,AnimationMixer:US,AnimationObjectGroup:kS,AnimationUtils:$t,ArcCurve:uv,ArrayCamera:av,ArrowHelper:v3,Audio:zv,AudioAnalyser:zS,AudioContext:Bv,AudioListener:YR,AudioLoader:OS,AxesHelper:WS,AxisHelper:V3,BackSide:pi,BasicDepthPacking:iv,BasicShadowMap:Gb,BinaryTextureLoader:J3,Bone:Tf,BooleanKeyframeTrack:po,BoundingBoxHelper:j3,Box2:Pl,Box3:He,Box3Helper:m3,BoxBufferGeometry:Tn,BoxGeometry:Tn,BoxHelper:QS,BufferAttribute:wt,BufferGeometry:nt,BufferGeometryLoader:PS,ByteType:Vg,Cache:to,Camera:zu,CameraHelper:Uv,CanvasRenderer:K3,CanvasTexture:mS,CapsuleBufferGeometry:cl,CapsuleGeometry:cl,CatmullRomCurve3:dv,CineonToneMapping:zA,CircleBufferGeometry:$a,CircleGeometry:$a,ClampToEdgeWrapping:bi,Clock:Lv,Color:Ie,ColorKeyframeTrack:Mv,ColorManagement:Wi,CompressedTexture:cv,CompressedTextureLoader:WR,ConeBufferGeometry:ul,ConeGeometry:ul,CubeCamera:Af,CubeReflectionMapping:ra,CubeRefractionMapping:sa,CubeTexture:bl,CubeTextureLoader:ES,CubeUVReflectionMapping:Sl,CubicBezierCurve:Rf,CubicBezierCurve3:fv,CubicInterpolant:AS,CullFaceBack:Xm,CullFaceFront:gA,CullFaceFrontBack:Hb,CullFaceNone:mA,Curve:Gi,CurvePath:vS,CustomBlending:Du,CustomToneMapping:NA,CylinderBufferGeometry:yn,CylinderGeometry:yn,Cylindrical:c3,Data3DTexture:Lu,DataArrayTexture:Ml,DataTexture:Yi,DataTexture2DArray:sP,DataTexture3D:aP,DataTextureLoader:Uf,DataUtils:Fa,DecrementStencilOp:_b,DecrementWrapStencilOp:eE,DefaultLoadingManager:bS,DepthFormat:ps,DepthStencilFormat:aa,DepthTexture:ov,DirectionalLight:Ff,DirectionalLightHelper:jS,DiscreteInterpolant:SS,DodecahedronBufferGeometry:hl,DodecahedronGeometry:hl,DoubleSide:yt,DstAlphaFactor:pf,DstColorFactor:Fg,DynamicBufferAttribute:O3,DynamicCopyUsage:dE,DynamicDrawUsage:Xn,DynamicReadUsage:cE,EdgesGeometry:mv,EdgesHelper:Q3,EllipseCurve:Il,EqualDepth:CA,EqualStencilFunc:VA,EquirectangularReflectionMapping:Oc,EquirectangularRefractionMapping:Bc,Euler:mi,EventDispatcher:Ss,ExtrudeBufferGeometry:Vr,ExtrudeGeometry:Vr,FaceColors:A3,FileLoader:$i,FlatShading:zg,Float16BufferAttribute:$A,Float32Attribute:H3,Float32BufferAttribute:je,Float64Attribute:G3,Float64BufferAttribute:eS,FloatType:Dn,Fog:Fu,FogExp2:Uu,Font:nP,FontLoader:tP,FramebufferTexture:pS,FrontSide:An,Frustum:El,GLBufferAttribute:FS,GLSL1:pE,GLSL3:qm,GreaterDepth:RA,GreaterEqualDepth:IA,GreaterEqualStencilFunc:aE,GreaterStencilFunc:sE,GridHelper:VS,Group:fi,HalfFloatType:di,HemisphereLight:Tv,HemisphereLightHelper:f3,HemisphereLightProbe:BS,IcosahedronBufferGeometry:dl,IcosahedronGeometry:dl,ImageBitmapLoader:DS,ImageLoader:pu,ImageUtils:fa,ImmediateRenderObject:iP,IncrementStencilOp:qb,IncrementWrapStencilOp:$b,InstancedBufferAttribute:yr,InstancedBufferGeometry:Qu,InstancedInterleavedBuffer:no,InstancedMesh:If,Int16Attribute:N3,Int16BufferAttribute:wf,Int32Attribute:U3,Int32BufferAttribute:_A,Int8Attribute:B3,Int8BufferAttribute:KA,IntType:Qg,InterleavedBuffer:fo,InterleavedBufferAttribute:Wn,Interpolant:ws,InterpolateDiscrete:nu,InterpolateLinear:iu,InterpolateSmooth:Od,InvertStencilOp:tE,JSONLoader:Y3,KeepStencilOp:yc,KeyframeTrack:wr,LOD:dS,LatheBufferGeometry:_a,LatheGeometry:_a,Layers:xf,LensFlare:_3,LessDepth:TA,LessEqualDepth:Wd,LessEqualStencilFunc:rE,LessStencilFunc:iE,Light:xr,LightProbe:ju,Line:$n,Line3:Ui,LineBasicMaterial:mn,LineCurve:Gu,LineCurve3:gS,LineDashedMaterial:Av,LineLoop:lv,LinePieces:x3,LineSegments:gi,LineStrip:y3,LinearEncoding:Fi,LinearFilter:St,LinearInterpolant:Sv,LinearMipMapLinearFilter:Xb,LinearMipMapNearestFilter:Wb,LinearMipmapLinearFilter:uo,LinearMipmapNearestFilter:Gg,LinearSRGBColorSpace:Zs,LinearToneMapping:BA,Loader:ni,LoaderUtils:Yd,LoadingManager:bv,LoopOnce:kA,LoopPingPong:FA,LoopRepeat:UA,LuminanceAlphaFormat:Yg,LuminanceFormat:Kg,MOUSE:Ub,Material:cn,MaterialLoader:RS,Math:It,MathUtils:It,Matrix3:Kt,Matrix4:ae,MaxEquation:Qd,Mesh:Ve,MeshBasicMaterial:ti,MeshDepthMaterial:Cl,MeshDistanceMaterial:ku,MeshFaceMaterial:M3,MeshLambertMaterial:wv,MeshMatcapMaterial:kf,MeshNormalMaterial:Nf,MeshPhongMaterial:zf,MeshPhysicalMaterial:yv,MeshStandardMaterial:Vu,MeshToonMaterial:xv,MinEquation:Ym,MirroredRepeatWrapping:Lc,MixOperation:DA,MultiMaterial:b3,MultiplyBlending:Km,MultiplyOperation:Ou,NearestFilter:Dt,NearestMipMapLinearFilter:Qb,NearestMipMapNearestFilter:jb,NearestMipmapLinearFilter:Jd,NearestMipmapNearestFilter:Xd,NeverDepth:bA,NeverStencilFunc:nE,NoBlending:Mn,NoColorSpace:Kb,NoColors:w3,NoToneMapping:Nr,NormalAnimationBlendMode:vf,NormalBlending:qs,NotEqualDepth:PA,NotEqualStencilFunc:jA,NumberKeyframeTrack:hu,Object3D:gt,ObjectLoader:XR,ObjectSpaceNormalMap:GA,OctahedronBufferGeometry:mr,OctahedronGeometry:mr,OneFactor:Js,OneMinusDstAlphaFactor:AA,OneMinusDstColorFactor:SA,OneMinusSrcAlphaFactor:Ug,OneMinusSrcColorFactor:wA,OrthographicCamera:ki,PCFShadowMap:Lg,PCFSoftShadowMap:vA,PMREMGenerator:Kd,ParametricGeometry:$3,Particle:T3,ParticleBasicMaterial:R3,ParticleSystem:C3,ParticleSystemMaterial:P3,Path:ll,PerspectiveCamera:tn,Plane:kt,PlaneBufferGeometry:Hi,PlaneGeometry:Hi,PlaneHelper:g3,PointCloud:E3,PointCloudMaterial:I3,PointLight:Rv,PointLightHelper:h3,Points:ms,PointsMaterial:Ki,PolarGridHelper:p3,PolyhedronBufferGeometry:Gr,PolyhedronGeometry:Gr,PositionalAudio:_R,PropertyBinding:zt,PropertyMixer:NS,QuadraticBezierCurve:Pf,QuadraticBezierCurve3:Df,Quaternion:dt,QuaternionKeyframeTrack:Rl,QuaternionLinearInterpolant:MS,REVISION:ff,RGBADepthPacking:da,RGBAFormat:Hn,RGBAIntegerFormat:ev,RGBA_ASTC_10x10_Format:_c,RGBA_ASTC_10x5_Format:Kc,RGBA_ASTC_10x6_Format:Yc,RGBA_ASTC_10x8_Format:qc,RGBA_ASTC_12x10_Format:$c,RGBA_ASTC_12x12_Format:eu,RGBA_ASTC_4x4_Format:Gc,RGBA_ASTC_5x4_Format:Vc,RGBA_ASTC_5x5_Format:jc,RGBA_ASTC_6x5_Format:Qc,RGBA_ASTC_6x6_Format:Wc,RGBA_ASTC_8x5_Format:Xc,RGBA_ASTC_8x6_Format:Jc,RGBA_ASTC_8x8_Format:Zc,RGBA_BPTC_Format:tu,RGBA_ETC2_EAC_Format:Hc,RGBA_PVRTC_2BPPV1_Format:Uc,RGBA_PVRTC_4BPPV1_Format:kc,RGBA_S3TC_DXT1_Format:Va,RGBA_S3TC_DXT3_Format:ja,RGBA_S3TC_DXT5_Format:Qa,RGBFormat:Zg,RGB_ETC1_Format:tv,RGB_ETC2_Format:Fc,RGB_PVRTC_2BPPV1_Format:Nc,RGB_PVRTC_4BPPV1_Format:zc,RGB_S3TC_DXT1_Format:Ga,RGFormat:_g,RGIntegerFormat:$g,RawShaderMaterial:vv,Ray:On,Raycaster:Wu,RectAreaLight:Dv,RedFormat:gf,RedIntegerFormat:qg,ReinhardToneMapping:LA,RepeatWrapping:vs,ReplaceStencilOp:$s,ReverseSubtractEquation:Ng,RingBufferGeometry:fl,RingGeometry:fl,SRGBColorSpace:Ir,Scene:Hu,SceneUtils:q3,ShaderChunk:bt,ShaderLib:Rn,ShaderMaterial:gn,ShadowMaterial:gv,Shape:kr,ShapeBufferGeometry:eo,ShapeGeometry:eo,ShapePath:XS,ShapeUtils:Ur,ShortType:jg,Skeleton:Cf,SkeletonHelper:HS,SkinnedMesh:Ef,SmoothShading:Vb,Source:Ks,Sphere:rn,SphereBufferGeometry:xs,SphereGeometry:xs,Spherical:Sc,SphericalHarmonics3:Ov,SplineCurve:Of,SpotLight:Iv,SpotLightHelper:u3,Sprite:bf,SpriteMaterial:Mf,SrcAlphaFactor:kg,SrcAlphaSaturateFactor:MA,SrcColorFactor:xA,StaticCopyUsage:hE,StaticDrawUsage:al,StaticReadUsage:lE,StereoCamera:ZR,StreamCopyUsage:fE,StreamDrawUsage:oE,StreamReadUsage:uE,StringKeyframeTrack:mo,SubtractEquation:yA,SubtractiveBlending:Zm,TOUCH:Fb,TangentSpaceNormalMap:ho,TetrahedronBufferGeometry:pl,TetrahedronGeometry:pl,TextGeometry:eP,Texture:bn,TextureLoader:Ev,TorusBufferGeometry:Lr,TorusGeometry:Lr,TorusKnotBufferGeometry:ml,TorusKnotGeometry:ml,Triangle:Ht,TriangleFanDrawMode:Zb,TriangleStripDrawMode:Jb,TrianglesDrawMode:HA,TubeBufferGeometry:gl,TubeGeometry:gl,UVMapping:mf,Uint16Attribute:k3,Uint16BufferAttribute:_i,Uint32Attribute:F3,Uint32BufferAttribute:ys,Uint8Attribute:L3,Uint8BufferAttribute:YA,Uint8ClampedAttribute:z3,Uint8ClampedBufferAttribute:qA,Uniform:Hf,UniformsLib:Ke,UniformsUtils:Hr,UnsignedByteType:Fr,UnsignedInt248Type:_s,UnsignedIntType:tl,UnsignedShort4444Type:Wg,UnsignedShort5551Type:Xg,UnsignedShortType:qa,VSMShadowMap:Na,Vector2:te,Vector3:A,Vector4:lt,VectorKeyframeTrack:du,Vertex:D3,VertexColors:S3,VideoTexture:fS,WebGL1Renderer:uS,WebGL3DRenderTarget:ZA,WebGLArrayRenderTarget:JA,WebGLCubeRenderTarget:Nu,WebGLMultipleRenderTargets:yf,WebGLMultisampleRenderTarget:rP,WebGLRenderTarget:pn,WebGLRenderTargetCube:Z3,WebGLRenderer:Wt,WebGLUtils:cS,WireframeGeometry:Lf,WireframeHelper:W3,WrapAroundEnding:ru,XHRLoader:X3,ZeroCurvatureEnding:ka,ZeroFactor:Dc,ZeroSlopeEnding:Ua,ZeroStencilOp:Yb,_SRGBAFormat:su,sRGBEncoding:vt},Symbol.toStringTag,{value:"Module"});var ex=function(a){return URL.createObjectURL(new Blob([a],{type:"text/javascript"}))};try{URL.revokeObjectURL(ex(""))}catch{ex=function(e){return"data:application/javascript;charset=UTF-8,"+encodeURI(e)}}var Ji=Uint8Array,Ys=Uint16Array,rg=Uint32Array,KS=new Ji([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),YS=new Ji([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),oP=new Ji([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),qS=function(a,e){for(var t=new Ys(31),n=0;n<31;++n)t[n]=e+=1<<a[n-1];for(var i=new rg(t[30]),n=1;n<30;++n)for(var r=t[n];r<t[n+1];++r)i[r]=r-t[n]<<5|n;return[t,i]},_S=qS(KS,2),$S=_S[0],lP=_S[1];$S[28]=258,lP[258]=28;var cP=qS(YS,0),uP=cP[0],sg=new Ys(32768);for(var nn=0;nn<32768;++nn){var Us=(nn&43690)>>>1|(nn&21845)<<1;Us=(Us&52428)>>>2|(Us&13107)<<2,Us=(Us&61680)>>>4|(Us&3855)<<4,sg[nn]=((Us&65280)>>>8|(Us&255)<<8)>>>1}var Mc=(function(a,e,t){for(var n=a.length,i=0,r=new Ys(e);i<n;++i)++r[a[i]-1];var s=new Ys(e);for(i=0;i<e;++i)s[i]=s[i-1]+r[i-1]<<1;var o;if(t){o=new Ys(1<<e);var l=15-e;for(i=0;i<n;++i)if(a[i])for(var c=i<<4|a[i],u=e-a[i],h=s[a[i]-1]++<<u,d=h|(1<<u)-1;h<=d;++h)o[sg[h]>>>l]=c}else for(o=new Ys(n),i=0;i<n;++i)a[i]&&(o[i]=sg[s[a[i]-1]++]>>>15-a[i]);return o}),Xu=new Ji(288);for(var nn=0;nn<144;++nn)Xu[nn]=8;for(var nn=144;nn<256;++nn)Xu[nn]=9;for(var nn=256;nn<280;++nn)Xu[nn]=7;for(var nn=280;nn<288;++nn)Xu[nn]=8;var eM=new Ji(32);for(var nn=0;nn<32;++nn)eM[nn]=5;var hP=Mc(Xu,9,1),dP=Mc(eM,5,1),jp=function(a){for(var e=a[0],t=1;t<a.length;++t)a[t]>e&&(e=a[t]);return e},ar=function(a,e,t){var n=e/8|0;return(a[n]|a[n+1]<<8)>>(e&7)&t},Qp=function(a,e){var t=e/8|0;return(a[t]|a[t+1]<<8|a[t+2]<<16)>>(e&7)},fP=function(a){return(a/8|0)+(a&7&&1)},pP=function(a,e,t){(t==null||t>a.length)&&(t=a.length);var n=new(a instanceof Ys?Ys:a instanceof rg?rg:Ji)(t-e);return n.set(a.subarray(e,t)),n},mP=function(a,e,t){var n=a.length;if(!n||t&&!t.l&&n<5)return e||new Ji(0);var i=!e||t,r=!t||t.i;t||(t={}),e||(e=new Ji(n*3));var s=function(W){var le=e.length;if(W>le){var K=new Ji(Math.max(le*2,W));K.set(e),e=K}},o=t.f||0,l=t.p||0,c=t.b||0,u=t.l,h=t.d,d=t.m,f=t.n,p=n*8;do{if(!u){t.f=o=ar(a,l,1);var m=ar(a,l+1,3);if(l+=3,m)if(m==1)u=hP,h=dP,d=9,f=5;else if(m==2){var w=ar(a,l,31)+257,x=ar(a,l+10,15)+4,S=w+ar(a,l+5,31)+1;l+=14;for(var b=new Ji(S),E=new Ji(19),M=0;M<x;++M)E[oP[M]]=ar(a,l+M*3,7);l+=x*3;for(var T=jp(E),I=(1<<T)-1,O=Mc(E,T,1),M=0;M<S;){var R=O[ar(a,l,I)];l+=R&15;var g=R>>>4;if(g<16)b[M++]=g;else{var k=0,P=0;for(g==16?(P=3+ar(a,l,3),l+=2,k=b[M-1]):g==17?(P=3+ar(a,l,7),l+=3):g==18&&(P=11+ar(a,l,127),l+=7);P--;)b[M++]=k}}var F=b.subarray(0,w),N=b.subarray(w);d=jp(F),f=jp(N),u=Mc(F,d,1),h=Mc(N,f,1)}else throw"invalid block type";else{var g=fP(l)+4,v=a[g-4]|a[g-3]<<8,y=g+v;if(y>n){if(r)throw"unexpected EOF";break}i&&s(c+v),e.set(a.subarray(g,y),c),t.b=c+=v,t.p=l=y*8;continue}if(l>p){if(r)throw"unexpected EOF";break}}i&&s(c+131072);for(var Y=(1<<d)-1,_=(1<<f)-1,G=l;;G=l){var k=u[Qp(a,l)&Y],j=k>>>4;if(l+=k&15,l>p){if(r)throw"unexpected EOF";break}if(!k)throw"invalid length/literal";if(j<256)e[c++]=j;else if(j==256){G=l,u=null;break}else{var L=j-254;if(j>264){var M=j-257,H=KS[M];L=ar(a,l,(1<<H)-1)+$S[M],l+=H}var q=h[Qp(a,l)&_],$=q>>>4;if(!q)throw"invalid distance";l+=q&15;var N=uP[$];if($>3){var H=YS[$];N+=Qp(a,l)&(1<<H)-1,l+=H}if(l>p){if(r)throw"unexpected EOF";break}i&&s(c+131072);for(var ee=c+L;c<ee;c+=4)e[c]=e[c-N],e[c+1]=e[c+1-N],e[c+2]=e[c+2-N],e[c+3]=e[c+3-N];c=ee}}t.l=u,t.p=G,t.b=c,u&&(o=1,t.m=d,t.d=h,t.n=f)}while(!o);return c==e.length?e:pP(e,0,c)},gP=new Ji(0),vP=function(a){if((a[0]&15)!=8||a[0]>>>4>7||(a[0]<<8|a[1])%31)throw"invalid zlib data";if(a[1]&32)throw"invalid zlib data: preset dictionaries not supported"};function hc(a,e){return mP((vP(a),a.subarray(2,-4)),e)}var yP=typeof TextDecoder<"u"&&new TextDecoder,xP=0;try{yP.decode(gP,{stream:!0}),xP=1}catch{}const tx=Object.defineProperty({__proto__:null,unzlibSync:hc},Symbol.toStringTag,{value:"Module"});class wP extends Uf{constructor(e){super(e),this.type=di}parse(e){const T=Math.pow(2.7182818,2.2);function I(C,B){let Q=0;for(let de=0;de<65536;++de)(de==0||C[de>>3]&1<<(de&7))&&(B[Q++]=de);const ne=Q-1;for(;Q<65536;)B[Q++]=0;return ne}function O(C){for(let B=0;B<16384;B++)C[B]={},C[B].len=0,C[B].lit=0,C[B].p=null}const R={l:0,c:0,lc:0};function k(C,B,Q,ne,de){for(;Q<C;)B=B<<8|Te(ne,de),Q+=8;Q-=C,R.l=B>>Q&(1<<C)-1,R.c=B,R.lc=Q}const P=new Array(59);function F(C){for(let Q=0;Q<=58;++Q)P[Q]=0;for(let Q=0;Q<65537;++Q)P[C[Q]]+=1;let B=0;for(let Q=58;Q>0;--Q){const ne=B+P[Q]>>1;P[Q]=B,B=ne}for(let Q=0;Q<65537;++Q){const ne=C[Q];ne>0&&(C[Q]=ne|P[ne]++<<6)}}function N(C,B,Q,ne,de,he){const Ue=B;let Ge=0,Qe=0;for(;ne<=de;ne++){if(Ue.value-B.value>Q)return!1;k(6,Ge,Qe,C,Ue);const Le=R.l;if(Ge=R.c,Qe=R.lc,he[ne]=Le,Le==63){if(Ue.value-B.value>Q)throw new Error("Something wrong with hufUnpackEncTable");k(8,Ge,Qe,C,Ue);let Oe=R.l+6;if(Ge=R.c,Qe=R.lc,ne+Oe>de+1)throw new Error("Something wrong with hufUnpackEncTable");for(;Oe--;)he[ne++]=0;ne--}else if(Le>=59){let Oe=Le-59+2;if(ne+Oe>de+1)throw new Error("Something wrong with hufUnpackEncTable");for(;Oe--;)he[ne++]=0;ne--}}F(he)}function Y(C){return C&63}function _(C){return C>>6}function G(C,B,Q,ne){for(;B<=Q;B++){const de=_(C[B]),he=Y(C[B]);if(de>>he)throw new Error("Invalid table entry");if(he>14){const Ue=ne[de>>he-14];if(Ue.len)throw new Error("Invalid table entry");if(Ue.lit++,Ue.p){const Ge=Ue.p;Ue.p=new Array(Ue.lit);for(let Qe=0;Qe<Ue.lit-1;++Qe)Ue.p[Qe]=Ge[Qe]}else Ue.p=new Array(1);Ue.p[Ue.lit-1]=B}else if(he){let Ue=0;for(let Ge=1<<14-he;Ge>0;Ge--){const Qe=ne[(de<<14-he)+Ue];if(Qe.len||Qe.p)throw new Error("Invalid table entry");Qe.len=he,Qe.lit=B,Ue++}}}return!0}const j={c:0,lc:0};function L(C,B,Q,ne){C=C<<8|Te(Q,ne),B+=8,j.c=C,j.lc=B}const H={c:0,lc:0};function q(C,B,Q,ne,de,he,Ue,Ge,Qe){if(C==B){ne<8&&(L(Q,ne,de,he),Q=j.c,ne=j.lc),ne-=8;let Le=Q>>ne;if(Le=new Uint8Array([Le])[0],Ge.value+Le>Qe)return!1;const Oe=Ue[Ge.value-1];for(;Le-- >0;)Ue[Ge.value++]=Oe}else if(Ge.value<Qe)Ue[Ge.value++]=C;else return!1;H.c=Q,H.lc=ne}function $(C){return C&65535}function ee(C){const B=$(C);return B>32767?B-65536:B}const W={a:0,b:0};function le(C,B){const Q=ee(C),de=ee(B),he=Q+(de&1)+(de>>1),Ue=he,Ge=he-de;W.a=Ue,W.b=Ge}function K(C,B){const Q=$(C),ne=$(B),de=Q-(ne>>1)&65535,he=ne+de-32768&65535;W.a=he,W.b=de}function pe(C,B,Q,ne,de,he,Ue){const Ge=Ue<16384,Qe=Q>de?de:Q;let Le=1,Oe,Re;for(;Le<=Qe;)Le<<=1;for(Le>>=1,Oe=Le,Le>>=1;Le>=1;){Re=0;const Xe=Re+he*(de-Oe),rt=he*Le,ot=he*Oe,$e=ne*Le,st=ne*Oe;let at,Ot,Vt,Xt;for(;Re<=Xe;Re+=ot){let jt=Re;const Rt=Re+ne*(Q-Oe);for(;jt<=Rt;jt+=st){const hn=jt+$e,yi=jt+rt,an=yi+$e;Ge?(le(C[jt+B],C[yi+B]),at=W.a,Vt=W.b,le(C[hn+B],C[an+B]),Ot=W.a,Xt=W.b,le(at,Ot),C[jt+B]=W.a,C[hn+B]=W.b,le(Vt,Xt),C[yi+B]=W.a,C[an+B]=W.b):(K(C[jt+B],C[yi+B]),at=W.a,Vt=W.b,K(C[hn+B],C[an+B]),Ot=W.a,Xt=W.b,K(at,Ot),C[jt+B]=W.a,C[hn+B]=W.b,K(Vt,Xt),C[yi+B]=W.a,C[an+B]=W.b)}if(Q&Le){const hn=jt+rt;Ge?le(C[jt+B],C[hn+B]):K(C[jt+B],C[hn+B]),at=W.a,C[hn+B]=W.b,C[jt+B]=at}}if(de&Le){let jt=Re;const Rt=Re+ne*(Q-Oe);for(;jt<=Rt;jt+=st){const hn=jt+$e;Ge?le(C[jt+B],C[hn+B]):K(C[jt+B],C[hn+B]),at=W.a,C[hn+B]=W.b,C[jt+B]=at}}Oe=Le,Le>>=1}return Re}function se(C,B,Q,ne,de,he,Ue,Ge,Qe){let Le=0,Oe=0;const Re=Ue,Xe=Math.trunc(ne.value+(de+7)/8);for(;ne.value<Xe;)for(L(Le,Oe,Q,ne),Le=j.c,Oe=j.lc;Oe>=14;){const ot=Le>>Oe-14&16383,$e=B[ot];if($e.len)Oe-=$e.len,q($e.lit,he,Le,Oe,Q,ne,Ge,Qe,Re),Le=H.c,Oe=H.lc;else{if(!$e.p)throw new Error("hufDecode issues");let st;for(st=0;st<$e.lit;st++){const at=Y(C[$e.p[st]]);for(;Oe<at&&ne.value<Xe;)L(Le,Oe,Q,ne),Le=j.c,Oe=j.lc;if(Oe>=at&&_(C[$e.p[st]])==(Le>>Oe-at&(1<<at)-1)){Oe-=at,q($e.p[st],he,Le,Oe,Q,ne,Ge,Qe,Re),Le=H.c,Oe=H.lc;break}}if(st==$e.lit)throw new Error("hufDecode issues")}}const rt=8-de&7;for(Le>>=rt,Oe-=rt;Oe>0;){const ot=B[Le<<14-Oe&16383];if(ot.len)Oe-=ot.len,q(ot.lit,he,Le,Oe,Q,ne,Ge,Qe,Re),Le=H.c,Oe=H.lc;else throw new Error("hufDecode issues")}return!0}function ve(C,B,Q,ne,de,he){const Ue={value:0},Ge=Q.value,Qe=Ce(B,Q),Le=Ce(B,Q);Q.value+=4;const Oe=Ce(B,Q);if(Q.value+=4,Qe<0||Qe>=65537||Le<0||Le>=65537)throw new Error("Something wrong with HUF_ENCSIZE");const Re=new Array(65537),Xe=new Array(16384);O(Xe);const rt=ne-(Q.value-Ge);if(N(C,Q,rt,Qe,Le,Re),Oe>8*(ne-(Q.value-Ge)))throw new Error("Something wrong with hufUncompress");G(Re,Qe,Le,Xe),se(Re,Xe,C,Q,Oe,Le,he,de,Ue)}function Z(C,B,Q){for(let ne=0;ne<Q;++ne)B[ne]=C[B[ne]]}function oe(C){for(let B=1;B<C.length;B++){const Q=C[B-1]+C[B]-128;C[B]=Q}}function Ae(C,B){let Q=0,ne=Math.floor((C.length+1)/2),de=0;const he=C.length-1;for(;!(de>he||(B[de++]=C[Q++],de>he));)B[de++]=C[ne++]}function Ee(C){let B=C.byteLength;const Q=new Array;let ne=0;const de=new DataView(C);for(;B>0;){const he=de.getInt8(ne++);if(he<0){const Ue=-he;B-=Ue+1;for(let Ge=0;Ge<Ue;Ge++)Q.push(de.getUint8(ne++))}else{const Ue=he;B-=2;const Ge=de.getUint8(ne++);for(let Qe=0;Qe<Ue+1;Qe++)Q.push(Ge)}}return Q}function Se(C,B,Q,ne,de,he){let Ue=new DataView(he.buffer);const Ge=Q[C.idx[0]].width,Qe=Q[C.idx[0]].height,Le=3,Oe=Math.floor(Ge/8),Re=Math.ceil(Ge/8),Xe=Math.ceil(Qe/8),rt=Ge-(Re-1)*8,ot=Qe-(Xe-1)*8,$e={value:0},st=new Array(Le),at=new Array(Le),Ot=new Array(Le),Vt=new Array(Le),Xt=new Array(Le);for(let Rt=0;Rt<Le;++Rt)Xt[Rt]=B[C.idx[Rt]],st[Rt]=Rt<1?0:st[Rt-1]+Re*Xe,at[Rt]=new Float32Array(64),Ot[Rt]=new Uint16Array(64),Vt[Rt]=new Uint16Array(Re*64);for(let Rt=0;Rt<Xe;++Rt){let hn=8;Rt==Xe-1&&(hn=ot);let yi=8;for(let Bt=0;Bt<Re;++Bt){Bt==Re-1&&(yi=rt);for(let Lt=0;Lt<Le;++Lt)Ot[Lt].fill(0),Ot[Lt][0]=de[st[Lt]++],ke($e,ne,Ot[Lt]),ye(Ot[Lt],at[Lt]),ge(at[Lt]);Fe(at);for(let Lt=0;Lt<Le;++Lt)Me(at[Lt],Vt[Lt],Bt*64)}let an=0;for(let Bt=0;Bt<Le;++Bt){const Lt=Q[C.idx[Bt]].type;for(let Di=8*Rt;Di<8*Rt+hn;++Di){an=Xt[Bt][Di];for(let Kr=0;Kr<Oe;++Kr){const Ci=Kr*64+(Di&7)*8;Ue.setUint16(an+0*Lt,Vt[Bt][Ci+0],!0),Ue.setUint16(an+2*Lt,Vt[Bt][Ci+1],!0),Ue.setUint16(an+4*Lt,Vt[Bt][Ci+2],!0),Ue.setUint16(an+6*Lt,Vt[Bt][Ci+3],!0),Ue.setUint16(an+8*Lt,Vt[Bt][Ci+4],!0),Ue.setUint16(an+10*Lt,Vt[Bt][Ci+5],!0),Ue.setUint16(an+12*Lt,Vt[Bt][Ci+6],!0),Ue.setUint16(an+14*Lt,Vt[Bt][Ci+7],!0),an+=16*Lt}}if(Oe!=Re)for(let Di=8*Rt;Di<8*Rt+hn;++Di){const Kr=Xt[Bt][Di]+8*Oe*2*Lt,Ci=Oe*64+(Di&7)*8;for(let xi=0;xi<yi;++xi)Ue.setUint16(Kr+xi*2*Lt,Vt[Bt][Ci+xi],!0)}}}const jt=new Uint16Array(Ge);Ue=new DataView(he.buffer);for(let Rt=0;Rt<Le;++Rt){Q[C.idx[Rt]].decoded=!0;const hn=Q[C.idx[Rt]].type;if(Q[Rt].type==2)for(let yi=0;yi<Qe;++yi){const an=Xt[Rt][yi];for(let Bt=0;Bt<Ge;++Bt)jt[Bt]=Ue.getUint16(an+Bt*2*hn,!0);for(let Bt=0;Bt<Ge;++Bt)Ue.setFloat32(an+Bt*2*hn,ce(jt[Bt]),!0)}}}function ke(C,B,Q){let ne,de=1;for(;de<64;)ne=B[C.value],ne==65280?de=64:ne>>8==255?de+=ne&255:(Q[de]=ne,de++),C.value++}function ye(C,B){B[0]=ce(C[0]),B[1]=ce(C[1]),B[2]=ce(C[5]),B[3]=ce(C[6]),B[4]=ce(C[14]),B[5]=ce(C[15]),B[6]=ce(C[27]),B[7]=ce(C[28]),B[8]=ce(C[2]),B[9]=ce(C[4]),B[10]=ce(C[7]),B[11]=ce(C[13]),B[12]=ce(C[16]),B[13]=ce(C[26]),B[14]=ce(C[29]),B[15]=ce(C[42]),B[16]=ce(C[3]),B[17]=ce(C[8]),B[18]=ce(C[12]),B[19]=ce(C[17]),B[20]=ce(C[25]),B[21]=ce(C[30]),B[22]=ce(C[41]),B[23]=ce(C[43]),B[24]=ce(C[9]),B[25]=ce(C[11]),B[26]=ce(C[18]),B[27]=ce(C[24]),B[28]=ce(C[31]),B[29]=ce(C[40]),B[30]=ce(C[44]),B[31]=ce(C[53]),B[32]=ce(C[10]),B[33]=ce(C[19]),B[34]=ce(C[23]),B[35]=ce(C[32]),B[36]=ce(C[39]),B[37]=ce(C[45]),B[38]=ce(C[52]),B[39]=ce(C[54]),B[40]=ce(C[20]),B[41]=ce(C[22]),B[42]=ce(C[33]),B[43]=ce(C[38]),B[44]=ce(C[46]),B[45]=ce(C[51]),B[46]=ce(C[55]),B[47]=ce(C[60]),B[48]=ce(C[21]),B[49]=ce(C[34]),B[50]=ce(C[37]),B[51]=ce(C[47]),B[52]=ce(C[50]),B[53]=ce(C[56]),B[54]=ce(C[59]),B[55]=ce(C[61]),B[56]=ce(C[35]),B[57]=ce(C[36]),B[58]=ce(C[48]),B[59]=ce(C[49]),B[60]=ce(C[57]),B[61]=ce(C[58]),B[62]=ce(C[62]),B[63]=ce(C[63])}function ge(C){const B=.5*Math.cos(.7853975),Q=.5*Math.cos(3.14159/16),ne=.5*Math.cos(3.14159/8),de=.5*Math.cos(3*3.14159/16),he=.5*Math.cos(5*3.14159/16),Ue=.5*Math.cos(3*3.14159/8),Ge=.5*Math.cos(7*3.14159/16),Qe=new Array(4),Le=new Array(4),Oe=new Array(4),Re=new Array(4);for(let Xe=0;Xe<8;++Xe){const rt=Xe*8;Qe[0]=ne*C[rt+2],Qe[1]=Ue*C[rt+2],Qe[2]=ne*C[rt+6],Qe[3]=Ue*C[rt+6],Le[0]=Q*C[rt+1]+de*C[rt+3]+he*C[rt+5]+Ge*C[rt+7],Le[1]=de*C[rt+1]-Ge*C[rt+3]-Q*C[rt+5]-he*C[rt+7],Le[2]=he*C[rt+1]-Q*C[rt+3]+Ge*C[rt+5]+de*C[rt+7],Le[3]=Ge*C[rt+1]-he*C[rt+3]+de*C[rt+5]-Q*C[rt+7],Oe[0]=B*(C[rt+0]+C[rt+4]),Oe[3]=B*(C[rt+0]-C[rt+4]),Oe[1]=Qe[0]+Qe[3],Oe[2]=Qe[1]-Qe[2],Re[0]=Oe[0]+Oe[1],Re[1]=Oe[3]+Oe[2],Re[2]=Oe[3]-Oe[2],Re[3]=Oe[0]-Oe[1],C[rt+0]=Re[0]+Le[0],C[rt+1]=Re[1]+Le[1],C[rt+2]=Re[2]+Le[2],C[rt+3]=Re[3]+Le[3],C[rt+4]=Re[3]-Le[3],C[rt+5]=Re[2]-Le[2],C[rt+6]=Re[1]-Le[1],C[rt+7]=Re[0]-Le[0]}for(let Xe=0;Xe<8;++Xe)Qe[0]=ne*C[16+Xe],Qe[1]=Ue*C[16+Xe],Qe[2]=ne*C[48+Xe],Qe[3]=Ue*C[48+Xe],Le[0]=Q*C[8+Xe]+de*C[24+Xe]+he*C[40+Xe]+Ge*C[56+Xe],Le[1]=de*C[8+Xe]-Ge*C[24+Xe]-Q*C[40+Xe]-he*C[56+Xe],Le[2]=he*C[8+Xe]-Q*C[24+Xe]+Ge*C[40+Xe]+de*C[56+Xe],Le[3]=Ge*C[8+Xe]-he*C[24+Xe]+de*C[40+Xe]-Q*C[56+Xe],Oe[0]=B*(C[Xe]+C[32+Xe]),Oe[3]=B*(C[Xe]-C[32+Xe]),Oe[1]=Qe[0]+Qe[3],Oe[2]=Qe[1]-Qe[2],Re[0]=Oe[0]+Oe[1],Re[1]=Oe[3]+Oe[2],Re[2]=Oe[3]-Oe[2],Re[3]=Oe[0]-Oe[1],C[0+Xe]=Re[0]+Le[0],C[8+Xe]=Re[1]+Le[1],C[16+Xe]=Re[2]+Le[2],C[24+Xe]=Re[3]+Le[3],C[32+Xe]=Re[3]-Le[3],C[40+Xe]=Re[2]-Le[2],C[48+Xe]=Re[1]-Le[1],C[56+Xe]=Re[0]-Le[0]}function Fe(C){for(let B=0;B<64;++B){const Q=C[0][B],ne=C[1][B],de=C[2][B];C[0][B]=Q+1.5747*de,C[1][B]=Q-.1873*ne-.4682*de,C[2][B]=Q+1.8556*ne}}function Me(C,B,Q){for(let ne=0;ne<64;++ne)B[Q+ne]=Fa.toHalfFloat(z(C[ne]))}function z(C){return C<=1?Math.sign(C)*Math.pow(Math.abs(C),2.2):Math.sign(C)*Math.pow(T,Math.abs(C)-1)}function D(C){return new DataView(C.array.buffer,C.offset.value,C.size)}function U(C){const B=C.viewer.buffer.slice(C.offset.value,C.offset.value+C.size),Q=new Uint8Array(Ee(B)),ne=new Uint8Array(Q.length);return oe(Q),Ae(Q,ne),new DataView(ne.buffer)}function J(C){const B=C.array.slice(C.offset.value,C.offset.value+C.size);typeof tx>"u"&&console.error("THREE.EXRLoader: External library fflate.min.js required.");const Q=hc(B),ne=new Uint8Array(Q.length);return oe(Q),Ae(Q,ne),new DataView(ne.buffer)}function be(C){const B=C.viewer,Q={value:C.offset.value},ne=new Uint16Array(C.width*C.scanlineBlockSize*(C.channels*C.type)),de=new Uint8Array(8192);let he=0;const Ue=new Array(C.channels);for(let ot=0;ot<C.channels;ot++)Ue[ot]={},Ue[ot].start=he,Ue[ot].end=Ue[ot].start,Ue[ot].nx=C.width,Ue[ot].ny=C.lines,Ue[ot].size=C.type,he+=Ue[ot].nx*Ue[ot].ny*Ue[ot].size;const Ge=_e(B,Q),Qe=_e(B,Q);if(Qe>=8192)throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");if(Ge<=Qe)for(let ot=0;ot<Qe-Ge+1;ot++)de[ot+Ge]=Ye(B,Q);const Le=new Uint16Array(65536),Oe=I(de,Le),Re=Ce(B,Q);ve(C.array,B,Q,Re,ne,he);for(let ot=0;ot<C.channels;++ot){const $e=Ue[ot];for(let st=0;st<Ue[ot].size;++st)pe(ne,$e.start+st,$e.nx,$e.size,$e.ny,$e.nx*$e.size,Oe)}Z(Le,ne,he);let Xe=0;const rt=new Uint8Array(ne.buffer.byteLength);for(let ot=0;ot<C.lines;ot++)for(let $e=0;$e<C.channels;$e++){const st=Ue[$e],at=st.nx*st.size,Ot=new Uint8Array(ne.buffer,st.end*2,at*2);rt.set(Ot,Xe),Xe+=at*2,st.end+=at}return new DataView(rt.buffer)}function we(C){const B=C.array.slice(C.offset.value,C.offset.value+C.size);typeof tx>"u"&&console.error("THREE.EXRLoader: External library fflate.min.js required.");const Q=hc(B),ne=C.lines*C.channels*C.width,de=C.type==1?new Uint16Array(ne):new Uint32Array(ne);let he=0,Ue=0;const Ge=new Array(4);for(let Qe=0;Qe<C.lines;Qe++)for(let Le=0;Le<C.channels;Le++){let Oe=0;switch(C.type){case 1:Ge[0]=he,Ge[1]=Ge[0]+C.width,he=Ge[1]+C.width;for(let Re=0;Re<C.width;++Re){const Xe=Q[Ge[0]++]<<8|Q[Ge[1]++];Oe+=Xe,de[Ue]=Oe,Ue++}break;case 2:Ge[0]=he,Ge[1]=Ge[0]+C.width,Ge[2]=Ge[1]+C.width,he=Ge[2]+C.width;for(let Re=0;Re<C.width;++Re){const Xe=Q[Ge[0]++]<<24|Q[Ge[1]++]<<16|Q[Ge[2]++]<<8;Oe+=Xe,de[Ue]=Oe,Ue++}break}}return new DataView(de.buffer)}function Pe(C){const B=C.viewer,Q={value:C.offset.value},ne=new Uint8Array(C.width*C.lines*(C.channels*C.type*2)),de={version:Ne(B,Q),unknownUncompressedSize:Ne(B,Q),unknownCompressedSize:Ne(B,Q),acCompressedSize:Ne(B,Q),dcCompressedSize:Ne(B,Q),rleCompressedSize:Ne(B,Q),rleUncompressedSize:Ne(B,Q),rleRawSize:Ne(B,Q),totalAcUncompressedCount:Ne(B,Q),totalDcUncompressedCount:Ne(B,Q),acCompression:Ne(B,Q)};if(de.version<2)throw new Error("EXRLoader.parse: "+me.compression+" version "+de.version+" is unsupported");const he=new Array;let Ue=_e(B,Q)-2;for(;Ue>0;){const $e=ie(B.buffer,Q),st=Ye(B,Q),at=st>>2&3,Ot=(st>>4)-1,Vt=new Int8Array([Ot])[0],Xt=Ye(B,Q);he.push({name:$e,index:Vt,type:Xt,compression:at}),Ue-=$e.length+3}const Ge=me.channels,Qe=new Array(C.channels);for(let $e=0;$e<C.channels;++$e){const st=Qe[$e]={},at=Ge[$e];st.name=at.name,st.compression=0,st.decoded=!1,st.type=at.pixelType,st.pLinear=at.pLinear,st.width=C.width,st.height=C.lines}const Le={idx:new Array(3)};for(let $e=0;$e<C.channels;++$e){const st=Qe[$e];for(let at=0;at<he.length;++at){const Ot=he[at];st.name==Ot.name&&(st.compression=Ot.compression,Ot.index>=0&&(Le.idx[Ot.index]=$e),st.offset=$e)}}let Oe,Re,Xe;if(de.acCompressedSize>0)switch(de.acCompression){case 0:Oe=new Uint16Array(de.totalAcUncompressedCount),ve(C.array,B,Q,de.acCompressedSize,Oe,de.totalAcUncompressedCount);break;case 1:const $e=C.array.slice(Q.value,Q.value+de.totalAcUncompressedCount),st=hc($e);Oe=new Uint16Array(st.buffer),Q.value+=de.totalAcUncompressedCount;break}if(de.dcCompressedSize>0){const $e={array:C.array,offset:Q,size:de.dcCompressedSize};Re=new Uint16Array(J($e).buffer),Q.value+=de.dcCompressedSize}if(de.rleRawSize>0){const $e=C.array.slice(Q.value,Q.value+de.rleCompressedSize),st=hc($e);Xe=Ee(st.buffer),Q.value+=de.rleCompressedSize}let rt=0;const ot=new Array(Qe.length);for(let $e=0;$e<ot.length;++$e)ot[$e]=new Array;for(let $e=0;$e<C.lines;++$e)for(let st=0;st<Qe.length;++st)ot[st].push(rt),rt+=Qe[st].width*C.type*2;Se(Le,ot,Qe,Oe,Re,ne);for(let $e=0;$e<Qe.length;++$e){const st=Qe[$e];if(!st.decoded)switch(st.compression){case 2:let at=0,Ot=0;for(let Vt=0;Vt<C.lines;++Vt){let Xt=ot[$e][at];for(let jt=0;jt<st.width;++jt){for(let Rt=0;Rt<2*st.type;++Rt)ne[Xt++]=Xe[Ot+Rt*st.width*st.height];Ot++}at++}break;default:throw new Error("EXRLoader.parse: unsupported channel compression")}}return new DataView(ne.buffer)}function ie(C,B){const Q=new Uint8Array(C);let ne=0;for(;Q[B.value+ne]!=0;)ne+=1;const de=new TextDecoder().decode(Q.slice(B.value,B.value+ne));return B.value=B.value+ne+1,de}function We(C,B,Q){const ne=new TextDecoder().decode(new Uint8Array(C).slice(B.value,B.value+Q));return B.value=B.value+Q,ne}function qe(C,B){const Q=X(C,B),ne=Ce(C,B);return[Q,ne]}function Je(C,B){const Q=Ce(C,B),ne=Ce(C,B);return[Q,ne]}function X(C,B){const Q=C.getInt32(B.value,!0);return B.value=B.value+4,Q}function Ce(C,B){const Q=C.getUint32(B.value,!0);return B.value=B.value+4,Q}function Te(C,B){const Q=C[B.value];return B.value=B.value+1,Q}function Ye(C,B){const Q=C.getUint8(B.value);return B.value=B.value+1,Q}const Ne=function(C,B){let Q;return"getBigInt64"in DataView.prototype?Q=Number(C.getBigInt64(B.value,!0)):Q=C.getUint32(B.value+4,!0)+Number(C.getUint32(B.value,!0)<<32),B.value+=8,Q};function Ze(C,B){const Q=C.getFloat32(B.value,!0);return B.value+=4,Q}function Be(C,B){return Fa.toHalfFloat(Ze(C,B))}function ce(C){const B=(C&31744)>>10,Q=C&1023;return(C>>15?-1:1)*(B?B===31?Q?NaN:1/0:Math.pow(2,B-15)*(1+Q/1024):6103515625e-14*(Q/1024))}function _e(C,B){const Q=C.getUint16(B.value,!0);return B.value+=2,Q}function pt(C,B){return ce(_e(C,B))}function At(C,B,Q,ne){const de=Q.value,he=[];for(;Q.value<de+ne-1;){const Ue=ie(B,Q),Ge=X(C,Q),Qe=Ye(C,Q);Q.value+=3;const Le=X(C,Q),Oe=X(C,Q);he.push({name:Ue,pixelType:Ge,pLinear:Qe,xSampling:Le,ySampling:Oe})}return Q.value+=1,he}function ht(C,B){const Q=Ze(C,B),ne=Ze(C,B),de=Ze(C,B),he=Ze(C,B),Ue=Ze(C,B),Ge=Ze(C,B),Qe=Ze(C,B),Le=Ze(C,B);return{redX:Q,redY:ne,greenX:de,greenY:he,blueX:Ue,blueY:Ge,whiteX:Qe,whiteY:Le}}function sn(C,B){const Q=["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"],ne=Ye(C,B);return Q[ne]}function Ut(C,B){const Q=Ce(C,B),ne=Ce(C,B),de=Ce(C,B),he=Ce(C,B);return{xMin:Q,yMin:ne,xMax:de,yMax:he}}function mt(C,B){const Q=["INCREASING_Y"],ne=Ye(C,B);return Q[ne]}function Gt(C,B){const Q=Ze(C,B),ne=Ze(C,B);return[Q,ne]}function Bn(C,B){const Q=Ze(C,B),ne=Ze(C,B),de=Ze(C,B);return[Q,ne,de]}function Ln(C,B,Q,ne,de){if(ne==="string"||ne==="stringvector"||ne==="iccProfile")return We(B,Q,de);if(ne==="chlist")return At(C,B,Q,de);if(ne==="chromaticities")return ht(C,Q);if(ne==="compression")return sn(C,Q);if(ne==="box2i")return Ut(C,Q);if(ne==="lineOrder")return mt(C,Q);if(ne==="float")return Ze(C,Q);if(ne==="v2f")return Gt(C,Q);if(ne==="v3f")return Bn(C,Q);if(ne==="int")return X(C,Q);if(ne==="rational")return qe(C,Q);if(ne==="timecode")return Je(C,Q);if(ne==="preview")return Q.value+=de,"skipped";Q.value+=de}function un(C,B,Q){const ne={};if(C.getUint32(0,!0)!=20000630)throw new Error("THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.");ne.version=C.getUint8(4);const de=C.getUint8(5);ne.spec={singleTile:!!(de&2),longName:!!(de&4),deepFormat:!!(de&8),multiPart:!!(de&16)},Q.value=8;let he=!0;for(;he;){const Ue=ie(B,Q);if(Ue==0)he=!1;else{const Ge=ie(B,Q),Qe=Ce(C,Q),Le=Ln(C,B,Q,Ge,Qe);Le===void 0?console.warn(`EXRLoader.parse: skipped unknown header attribute type '${Ge}'.`):ne[Ue]=Le}}if(de!=0)throw console.error("EXRHeader:",ne),new Error("THREE.EXRLoader: provided file is currently unsupported.");return ne}function vi(C,B,Q,ne,de){const he={size:0,viewer:B,array:Q,offset:ne,width:C.dataWindow.xMax-C.dataWindow.xMin+1,height:C.dataWindow.yMax-C.dataWindow.yMin+1,channels:C.channels.length,bytesPerLine:null,lines:null,inputSize:null,type:C.channels[0].pixelType,uncompress:null,getter:null,format:null,encoding:null};switch(C.compression){case"NO_COMPRESSION":he.lines=1,he.uncompress=D;break;case"RLE_COMPRESSION":he.lines=1,he.uncompress=U;break;case"ZIPS_COMPRESSION":he.lines=1,he.uncompress=J;break;case"ZIP_COMPRESSION":he.lines=16,he.uncompress=J;break;case"PIZ_COMPRESSION":he.lines=32,he.uncompress=be;break;case"PXR24_COMPRESSION":he.lines=16,he.uncompress=we;break;case"DWAA_COMPRESSION":he.lines=32,he.uncompress=Pe;break;case"DWAB_COMPRESSION":he.lines=256,he.uncompress=Pe;break;default:throw new Error("EXRLoader.parse: "+C.compression+" is unsupported")}if(he.scanlineBlockSize=he.lines,he.type==1)switch(de){case Dn:he.getter=pt,he.inputSize=2;break;case di:he.getter=_e,he.inputSize=2;break}else if(he.type==2)switch(de){case Dn:he.getter=Ze,he.inputSize=4;break;case di:he.getter=Be,he.inputSize=4}else throw new Error("EXRLoader.parse: unsupported pixelType "+he.type+" for "+C.compression+".");he.blockCount=(C.dataWindow.yMax+1)/he.scanlineBlockSize;for(let Ge=0;Ge<he.blockCount;Ge++)Ne(B,ne);he.outputChannels=he.channels==3?4:he.channels;const Ue=he.width*he.height*he.outputChannels;switch(de){case Dn:he.byteArray=new Float32Array(Ue),he.channels<he.outputChannels&&he.byteArray.fill(1,0,Ue);break;case di:he.byteArray=new Uint16Array(Ue),he.channels<he.outputChannels&&he.byteArray.fill(15360,0,Ue);break;default:console.error("THREE.EXRLoader: unsupported type: ",de);break}return he.bytesPerLine=he.width*he.inputSize*he.channels,he.outputChannels==4?(he.format=Hn,he.encoding=Fi):(he.format=gf,he.encoding=Fi),he}const V=new DataView(e),ue=new Uint8Array(e),xe={value:0},me=un(V,e,xe),fe=vi(me,V,ue,xe,this.type),it={value:0},ct={R:0,G:1,B:2,A:3,Y:0};for(let C=0;C<fe.height/fe.scanlineBlockSize;C++){const B=Ce(V,xe);fe.size=Ce(V,xe),fe.lines=B+fe.scanlineBlockSize>fe.height?fe.height-B:fe.scanlineBlockSize;const ne=fe.size<fe.lines*fe.bytesPerLine?fe.uncompress(fe):D(fe);xe.value+=fe.size;for(let de=0;de<fe.scanlineBlockSize;de++){const he=de+C*fe.scanlineBlockSize;if(he>=fe.height)break;for(let Ue=0;Ue<fe.channels;Ue++){const Ge=ct[me.channels[Ue].name];for(let Qe=0;Qe<fe.width;Qe++){it.value=(de*(fe.channels*fe.width)+Ue*fe.width+Qe)*fe.inputSize;const Le=(fe.height-1-he)*(fe.width*fe.outputChannels)+Qe*fe.outputChannels+Ge;fe.byteArray[Le]=fe.getter(ne,it)}}}}return{header:me,width:fe.width,height:fe.height,data:fe.byteArray,format:fe.format,encoding:fe.encoding,type:this.type}}setDataType(e){return this.type=e,this}load(e,t,n,i){function r(s,o){s.encoding=o.encoding,s.minFilter=St,s.magFilter=St,s.generateMipmaps=!1,s.flipY=!1,t&&t(s,o)}return super.load(e,r,n,i)}}class AP extends Uf{constructor(e){super(e),this.type=di}parse(e){const o=function(w,x){switch(w){case 1:console.error("THREE.RGBELoader Read Error: "+(x||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(x||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(x||""));break;default:case 4:console.error("THREE.RGBELoader: Error: "+(x||""))}return-1},d=function(w,x,S){x=x||1024;let E=w.pos,M=-1,T=0,I="",O=String.fromCharCode.apply(null,new Uint16Array(w.subarray(E,E+128)));for(;0>(M=O.indexOf(`
`))&&T<x&&E<w.byteLength;)I+=O,T+=O.length,E+=128,O+=String.fromCharCode.apply(null,new Uint16Array(w.subarray(E,E+128)));return-1<M?(w.pos+=T+M+1,I+O.slice(0,M)):!1},f=function(w){const x=/^#\?(\S+)/,S=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,b=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,E=/^\s*FORMAT=(\S+)\s*$/,M=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,T={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let I,O;if(w.pos>=w.byteLength||!(I=d(w)))return o(1,"no header found");if(!(O=I.match(x)))return o(3,"bad initial token");for(T.valid|=1,T.programtype=O[1],T.string+=I+`
`;I=d(w),I!==!1;){if(T.string+=I+`
`,I.charAt(0)==="#"){T.comments+=I+`
`;continue}if((O=I.match(S))&&(T.gamma=parseFloat(O[1])),(O=I.match(b))&&(T.exposure=parseFloat(O[1])),(O=I.match(E))&&(T.valid|=2,T.format=O[1]),(O=I.match(M))&&(T.valid|=4,T.height=parseInt(O[1],10),T.width=parseInt(O[2],10)),T.valid&2&&T.valid&4)break}return T.valid&2?T.valid&4?T:o(3,"missing image size specifier"):o(3,"missing format specifier")},p=function(w,x,S){const b=x;if(b<8||b>32767||w[0]!==2||w[1]!==2||w[2]&128)return new Uint8Array(w);if(b!==(w[2]<<8|w[3]))return o(3,"wrong scanline width");const E=new Uint8Array(4*x*S);if(!E.length)return o(4,"unable to allocate buffer space");let M=0,T=0;const I=4*b,O=new Uint8Array(4),R=new Uint8Array(I);let k=S;for(;k>0&&T<w.byteLength;){if(T+4>w.byteLength)return o(1);if(O[0]=w[T++],O[1]=w[T++],O[2]=w[T++],O[3]=w[T++],O[0]!=2||O[1]!=2||(O[2]<<8|O[3])!=b)return o(3,"bad rgbe scanline format");let P=0,F;for(;P<I&&T<w.byteLength;){F=w[T++];const Y=F>128;if(Y&&(F-=128),F===0||P+F>I)return o(3,"bad scanline data");if(Y){const _=w[T++];for(let G=0;G<F;G++)R[P++]=_}else R.set(w.subarray(T,T+F),P),P+=F,T+=F}const N=b;for(let Y=0;Y<N;Y++){let _=0;E[M]=R[Y+_],_+=b,E[M+1]=R[Y+_],_+=b,E[M+2]=R[Y+_],_+=b,E[M+3]=R[Y+_],M+=4}k--}return E},m=function(w,x,S,b){const E=w[x+3],M=Math.pow(2,E-128)/255;S[b+0]=w[x+0]*M,S[b+1]=w[x+1]*M,S[b+2]=w[x+2]*M,S[b+3]=1},g=function(w,x,S,b){const E=w[x+3],M=Math.pow(2,E-128)/255;S[b+0]=Fa.toHalfFloat(Math.min(w[x+0]*M,65504)),S[b+1]=Fa.toHalfFloat(Math.min(w[x+1]*M,65504)),S[b+2]=Fa.toHalfFloat(Math.min(w[x+2]*M,65504)),S[b+3]=Fa.toHalfFloat(1)},v=new Uint8Array(e);v.pos=0;const y=f(v);if(y!==-1){const w=y.width,x=y.height,S=p(v.subarray(v.pos),w,x);if(S!==-1){let b,E,M,T;switch(this.type){case Dn:T=S.length/4;const I=new Float32Array(T*4);for(let R=0;R<T;R++)m(S,R*4,I,R*4);b=I,M=Dn;break;case di:T=S.length/4;const O=new Uint16Array(T*4);for(let R=0;R<T;R++)g(S,R*4,O,R*4);b=O,M=di;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type);break}return{width:w,height:x,data:b,header:y.string,gamma:y.gamma,exposure:y.exposure,format:E,type:M}}}return null}setDataType(e){return this.type=e,this}load(e,t,n,i){function r(s,o){switch(s.type){case Dn:s.encoding=Fi,s.minFilter=St,s.magFilter=St,s.generateMipmaps=!1,s.flipY=!0;break;case di:s.encoding=Fi,s.minFilter=St,s.magFilter=St,s.generateMipmaps=!1,s.flipY=!0;break}t&&t(s,o)}return super.load(e,r,n,i)}}class SP extends ni{constructor(e){super(e)}load(e,t,n,i){const r=this,s=new $i(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(r.withCredentials),s.load(e,function(o){let l;try{l=JSON.parse(o)}catch{console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),l=JSON.parse(o.substring(65,o.length-2))}const c=r.parse(l);t&&t(c)},n,i)}parse(e){return new tM(e)}}class tM{constructor(e){this.type="Font",this.data=e}generateShapes(e,t=100){const n=[],i=MP(e,t,this.data);for(let r=0,s=i.length;r<s;r++)Array.prototype.push.apply(n,i[r].toShapes());return n}}function MP(a,e,t){const n=Array.from(a),i=e/t.resolution,r=(t.boundingBox.yMax-t.boundingBox.yMin+t.underlineThickness)*i,s=[];let o=0,l=0;for(let c=0;c<n.length;c++){const u=n[c];if(u===`
`)o=0,l-=r;else{const h=bP(u,i,o,l,t);o+=h.offsetX,s.push(h.path)}}return s}function bP(a,e,t,n,i){const r=i.glyphs[a]||i.glyphs["?"];if(!r){console.error('THREE.Font: character "'+a+'" does not exists in font family '+i.familyName+".");return}const s=new XS;let o,l,c,u,h,d,f,p;if(r.o){const m=r._cachedOutline||(r._cachedOutline=r.o.split(" "));for(let g=0,v=m.length;g<v;)switch(m[g++]){case"m":o=m[g++]*e+t,l=m[g++]*e+n,s.moveTo(o,l);break;case"l":o=m[g++]*e+t,l=m[g++]*e+n,s.lineTo(o,l);break;case"q":c=m[g++]*e+t,u=m[g++]*e+n,h=m[g++]*e+t,d=m[g++]*e+n,s.quadraticCurveTo(h,d,c,u);break;case"b":c=m[g++]*e+t,u=m[g++]*e+n,h=m[g++]*e+t,d=m[g++]*e+n,f=m[g++]*e+t,p=m[g++]*e+n,s.bezierCurveTo(h,d,f,p,c,u);break}}return{offsetX:r.ha*e,path:s}}tM.prototype.isFont=!0;var Ld={exports:{}};var EP=Ld.exports,nx;function TP(){return nx||(nx=1,(function(a){(function(e){var t={};t.VERSION="1.6.1";var n,i={},r=function(u,h){return function(){return h.apply(u,arguments)}},s=function(){var u=arguments,h=u[0],d,f;for(f=1;f<u.length;f++)for(d in u[f])!(d in h)&&u[f].hasOwnProperty(d)&&(h[d]=u[f][d]);return h},o=function(u,h){return{value:u,name:h}};t.TRACE=o(1,"TRACE"),t.DEBUG=o(2,"DEBUG"),t.INFO=o(3,"INFO"),t.TIME=o(4,"TIME"),t.WARN=o(5,"WARN"),t.ERROR=o(8,"ERROR"),t.OFF=o(99,"OFF");var l=function(u){this.context=u,this.setLevel(u.filterLevel),this.log=this.info};l.prototype={setLevel:function(u){u&&"value"in u&&(this.context.filterLevel=u)},getLevel:function(){return this.context.filterLevel},enabledFor:function(u){var h=this.context.filterLevel;return u.value>=h.value},trace:function(){this.invoke(t.TRACE,arguments)},debug:function(){this.invoke(t.DEBUG,arguments)},info:function(){this.invoke(t.INFO,arguments)},warn:function(){this.invoke(t.WARN,arguments)},error:function(){this.invoke(t.ERROR,arguments)},time:function(u){typeof u=="string"&&u.length>0&&this.invoke(t.TIME,[u,"start"])},timeEnd:function(u){typeof u=="string"&&u.length>0&&this.invoke(t.TIME,[u,"end"])},invoke:function(u,h){n&&this.enabledFor(u)&&n(h,s({level:u},this.context))}};var c=new l({filterLevel:t.OFF});(function(){var u=t;u.enabledFor=r(c,c.enabledFor),u.trace=r(c,c.trace),u.debug=r(c,c.debug),u.time=r(c,c.time),u.timeEnd=r(c,c.timeEnd),u.info=r(c,c.info),u.warn=r(c,c.warn),u.error=r(c,c.error),u.log=u.info})(),t.setHandler=function(u){n=u},t.setLevel=function(u){c.setLevel(u);for(var h in i)i.hasOwnProperty(h)&&i[h].setLevel(u)},t.getLevel=function(){return c.getLevel()},t.get=function(u){return i[u]||(i[u]=new l(s({name:u},c.context)))},t.createDefaultHandler=function(u){u=u||{},u.formatter=u.formatter||function(p,m){m.name&&p.unshift("["+m.name+"]")};var h={},d=function(f,p){Function.prototype.apply.call(f,console,p)};return typeof console>"u"?function(){}:function(f,p){f=Array.prototype.slice.call(f);var m=console.log,g;p.level===t.TIME?(g=(p.name?"["+p.name+"] ":"")+f[0],f[1]==="start"?console.time?console.time(g):h[g]=new Date().getTime():console.timeEnd?console.timeEnd(g):d(m,[g+": "+(new Date().getTime()-h[g])+"ms"])):(p.level===t.WARN&&console.warn?m=console.warn:p.level===t.ERROR&&console.error?m=console.error:p.level===t.INFO&&console.info?m=console.info:p.level===t.DEBUG&&console.debug?m=console.debug:p.level===t.TRACE&&console.trace&&(m=console.trace),u.formatter(f,p),d(m,f))}},t.useDefaults=function(u){t.setLevel(u&&u.defaultLevel||t.DEBUG),t.setHandler(t.createDefaultHandler(u))},t.setDefaults=t.useDefaults,a.exports?a.exports=t:(t._prevLogger=e.Logger,t.noConflict=function(){return e.Logger=t._prevLogger,t},e.Logger=t)})(EP)})(Ld)),Ld.exports}var CP=TP();const Wp=Bg(CP);var nM=typeof global=="object"&&global&&global.Object===Object&&global,IP=typeof self=="object"&&self&&self.Object===Object&&self,Ms=nM||IP||Function("return this")(),jr=Ms.Symbol,iM=Object.prototype,RP=iM.hasOwnProperty,PP=iM.toString,_l=jr?jr.toStringTag:void 0;function DP(a){var e=RP.call(a,_l),t=a[_l];try{a[_l]=void 0;var n=!0}catch{}var i=PP.call(a);return n&&(e?a[_l]=t:delete a[_l]),i}var OP=Object.prototype,BP=OP.toString;function LP(a){return BP.call(a)}var zP="[object Null]",NP="[object Undefined]",ix=jr?jr.toStringTag:void 0;function Ol(a){return a==null?a===void 0?NP:zP:ix&&ix in Object(a)?DP(a):LP(a)}function io(a){return a!=null&&typeof a=="object"}var kP="[object Symbol]";function Hv(a){return typeof a=="symbol"||io(a)&&Ol(a)==kP}function Gv(a,e){for(var t=-1,n=a==null?0:a.length,i=Array(n);++t<n;)i[t]=e(a[t],t,a);return i}var er=Array.isArray,rx=jr?jr.prototype:void 0,sx=rx?rx.toString:void 0;function rM(a){if(typeof a=="string")return a;if(er(a))return Gv(a,rM)+"";if(Hv(a))return sx?sx.call(a):"";var e=a+"";return e=="0"&&1/a==-1/0?"-0":e}function Vv(a){var e=typeof a;return a!=null&&(e=="object"||e=="function")}function jv(a){return a}var UP="[object AsyncFunction]",FP="[object Function]",HP="[object GeneratorFunction]",GP="[object Proxy]";function sM(a){if(!Vv(a))return!1;var e=Ol(a);return e==FP||e==HP||e==UP||e==GP}var Xp=Ms["__core-js_shared__"],ax=(function(){var a=/[^.]+$/.exec(Xp&&Xp.keys&&Xp.keys.IE_PROTO||"");return a?"Symbol(src)_1."+a:""})();function VP(a){return!!ax&&ax in a}var jP=Function.prototype,QP=jP.toString;function go(a){if(a!=null){try{return QP.call(a)}catch{}try{return a+""}catch{}}return""}var WP=/[\\^$.*+?()[\]{}|]/g,XP=/^\[object .+?Constructor\]$/,JP=Function.prototype,ZP=Object.prototype,KP=JP.toString,YP=ZP.hasOwnProperty,qP=RegExp("^"+KP.call(YP).replace(WP,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");function _P(a){if(!Vv(a)||VP(a))return!1;var e=sM(a)?qP:XP;return e.test(go(a))}function $P(a,e){return a?.[e]}function vo(a,e){var t=$P(a,e);return _P(t)?t:void 0}var ag=vo(Ms,"WeakMap");function eD(a,e,t){switch(t.length){case 0:return a.call(e);case 1:return a.call(e,t[0]);case 2:return a.call(e,t[0],t[1]);case 3:return a.call(e,t[0],t[1],t[2])}return a.apply(e,t)}function tD(){}var nD=800,iD=16,rD=Date.now;function sD(a){var e=0,t=0;return function(){var n=rD(),i=iD-(n-t);if(t=n,i>0){if(++e>=nD)return arguments[0]}else e=0;return a.apply(void 0,arguments)}}function aD(a){return function(){return a}}var qd=(function(){try{var a=vo(Object,"defineProperty");return a({},"",{}),a}catch{}})(),oD=qd?function(a,e){return qd(a,"toString",{configurable:!0,enumerable:!1,value:aD(e),writable:!0})}:jv,lD=sD(oD);function cD(a,e,t,n){for(var i=a.length,r=t+-1;++r<i;)if(e(a[r],r,a))return r;return-1}function uD(a){return a!==a}function hD(a,e,t){for(var n=t-1,i=a.length;++n<i;)if(a[n]===e)return n;return-1}function dD(a,e,t){return e===e?hD(a,e,t):cD(a,uD,t)}function aM(a,e){var t=a==null?0:a.length;return!!t&&dD(a,e,0)>-1}var fD=9007199254740991,pD=/^(?:0|[1-9]\d*)$/;function oM(a,e){var t=typeof a;return e=e??fD,!!e&&(t=="number"||t!="symbol"&&pD.test(a))&&a>-1&&a%1==0&&a<e}function lM(a,e,t){e=="__proto__"&&qd?qd(a,e,{configurable:!0,enumerable:!0,value:t,writable:!0}):a[e]=t}function cM(a,e){return a===e||a!==a&&e!==e}var ox=Math.max;function mD(a,e,t){return e=ox(e===void 0?a.length-1:e,0),function(){for(var n=arguments,i=-1,r=ox(n.length-e,0),s=Array(r);++i<r;)s[i]=n[e+i];i=-1;for(var o=Array(e+1);++i<e;)o[i]=n[i];return o[e]=t(s),eD(a,this,o)}}function gD(a,e){return lD(mD(a,e,jv),a+"")}var vD=9007199254740991;function Qv(a){return typeof a=="number"&&a>-1&&a%1==0&&a<=vD}function Gf(a){return a!=null&&Qv(a.length)&&!sM(a)}var yD=Object.prototype;function xD(a){var e=a&&a.constructor,t=typeof e=="function"&&e.prototype||yD;return a===t}function wD(a,e){for(var t=-1,n=Array(a);++t<a;)n[t]=e(t);return n}var AD="[object Arguments]";function lx(a){return io(a)&&Ol(a)==AD}var uM=Object.prototype,SD=uM.hasOwnProperty,MD=uM.propertyIsEnumerable,Wv=lx((function(){return arguments})())?lx:function(a){return io(a)&&SD.call(a,"callee")&&!MD.call(a,"callee")};function bD(){return!1}var hM=typeof exports=="object"&&exports&&!exports.nodeType&&exports,cx=hM&&typeof module=="object"&&module&&!module.nodeType&&module,ED=cx&&cx.exports===hM,ux=ED?Ms.Buffer:void 0,TD=ux?ux.isBuffer:void 0,og=TD||bD,CD="[object Arguments]",ID="[object Array]",RD="[object Boolean]",PD="[object Date]",DD="[object Error]",OD="[object Function]",BD="[object Map]",LD="[object Number]",zD="[object Object]",ND="[object RegExp]",kD="[object Set]",UD="[object String]",FD="[object WeakMap]",HD="[object ArrayBuffer]",GD="[object DataView]",VD="[object Float32Array]",jD="[object Float64Array]",QD="[object Int8Array]",WD="[object Int16Array]",XD="[object Int32Array]",JD="[object Uint8Array]",ZD="[object Uint8ClampedArray]",KD="[object Uint16Array]",YD="[object Uint32Array]",_t={};_t[VD]=_t[jD]=_t[QD]=_t[WD]=_t[XD]=_t[JD]=_t[ZD]=_t[KD]=_t[YD]=!0;_t[CD]=_t[ID]=_t[HD]=_t[RD]=_t[GD]=_t[PD]=_t[DD]=_t[OD]=_t[BD]=_t[LD]=_t[zD]=_t[ND]=_t[kD]=_t[UD]=_t[FD]=!1;function qD(a){return io(a)&&Qv(a.length)&&!!_t[Ol(a)]}function dM(a){return function(e){return a(e)}}var fM=typeof exports=="object"&&exports&&!exports.nodeType&&exports,bc=fM&&typeof module=="object"&&module&&!module.nodeType&&module,_D=bc&&bc.exports===fM,Jp=_D&&nM.process,hx=(function(){try{var a=bc&&bc.require&&bc.require("util").types;return a||Jp&&Jp.binding&&Jp.binding("util")}catch{}})(),dx=hx&&hx.isTypedArray,pM=dx?dM(dx):qD,$D=Object.prototype,eO=$D.hasOwnProperty;function tO(a,e){var t=er(a),n=!t&&Wv(a),i=!t&&!n&&og(a),r=!t&&!n&&!i&&pM(a),s=t||n||i||r,o=s?wD(a.length,String):[],l=o.length;for(var c in a)eO.call(a,c)&&!(s&&(c=="length"||i&&(c=="offset"||c=="parent")||r&&(c=="buffer"||c=="byteLength"||c=="byteOffset")||oM(c,l)))&&o.push(c);return o}function nO(a,e){return function(t){return a(e(t))}}var iO=nO(Object.keys,Object),rO=Object.prototype,sO=rO.hasOwnProperty;function aO(a){if(!xD(a))return iO(a);var e=[];for(var t in Object(a))sO.call(a,t)&&t!="constructor"&&e.push(t);return e}function Xv(a){return Gf(a)?tO(a):aO(a)}var oO=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,lO=/^\w*$/;function Jv(a,e){if(er(a))return!1;var t=typeof a;return t=="number"||t=="symbol"||t=="boolean"||a==null||Hv(a)?!0:lO.test(a)||!oO.test(a)||e!=null&&a in Object(e)}var mu=vo(Object,"create");function cO(){this.__data__=mu?mu(null):{},this.size=0}function uO(a){var e=this.has(a)&&delete this.__data__[a];return this.size-=e?1:0,e}var hO="__lodash_hash_undefined__",dO=Object.prototype,fO=dO.hasOwnProperty;function pO(a){var e=this.__data__;if(mu){var t=e[a];return t===hO?void 0:t}return fO.call(e,a)?e[a]:void 0}var mO=Object.prototype,gO=mO.hasOwnProperty;function vO(a){var e=this.__data__;return mu?e[a]!==void 0:gO.call(e,a)}var yO="__lodash_hash_undefined__";function xO(a,e){var t=this.__data__;return this.size+=this.has(a)?0:1,t[a]=mu&&e===void 0?yO:e,this}function ro(a){var e=-1,t=a==null?0:a.length;for(this.clear();++e<t;){var n=a[e];this.set(n[0],n[1])}}ro.prototype.clear=cO;ro.prototype.delete=uO;ro.prototype.get=pO;ro.prototype.has=vO;ro.prototype.set=xO;function wO(){this.__data__=[],this.size=0}function Vf(a,e){for(var t=a.length;t--;)if(cM(a[t][0],e))return t;return-1}var AO=Array.prototype,SO=AO.splice;function MO(a){var e=this.__data__,t=Vf(e,a);if(t<0)return!1;var n=e.length-1;return t==n?e.pop():SO.call(e,t,1),--this.size,!0}function bO(a){var e=this.__data__,t=Vf(e,a);return t<0?void 0:e[t][1]}function EO(a){return Vf(this.__data__,a)>-1}function TO(a,e){var t=this.__data__,n=Vf(t,a);return n<0?(++this.size,t.push([a,e])):t[n][1]=e,this}function bs(a){var e=-1,t=a==null?0:a.length;for(this.clear();++e<t;){var n=a[e];this.set(n[0],n[1])}}bs.prototype.clear=wO;bs.prototype.delete=MO;bs.prototype.get=bO;bs.prototype.has=EO;bs.prototype.set=TO;var gu=vo(Ms,"Map");function CO(){this.size=0,this.__data__={hash:new ro,map:new(gu||bs),string:new ro}}function IO(a){var e=typeof a;return e=="string"||e=="number"||e=="symbol"||e=="boolean"?a!=="__proto__":a===null}function jf(a,e){var t=a.__data__;return IO(e)?t[typeof e=="string"?"string":"hash"]:t.map}function RO(a){var e=jf(this,a).delete(a);return this.size-=e?1:0,e}function PO(a){return jf(this,a).get(a)}function DO(a){return jf(this,a).has(a)}function OO(a,e){var t=jf(this,a),n=t.size;return t.set(a,e),this.size+=t.size==n?0:1,this}function Es(a){var e=-1,t=a==null?0:a.length;for(this.clear();++e<t;){var n=a[e];this.set(n[0],n[1])}}Es.prototype.clear=CO;Es.prototype.delete=RO;Es.prototype.get=PO;Es.prototype.has=DO;Es.prototype.set=OO;var BO="Expected a function";function Zv(a,e){if(typeof a!="function"||e!=null&&typeof e!="function")throw new TypeError(BO);var t=function(){var n=arguments,i=e?e.apply(this,n):n[0],r=t.cache;if(r.has(i))return r.get(i);var s=a.apply(this,n);return t.cache=r.set(i,s)||r,s};return t.cache=new(Zv.Cache||Es),t}Zv.Cache=Es;var LO=500;function zO(a){var e=Zv(a,function(n){return t.size===LO&&t.clear(),n}),t=e.cache;return e}var NO=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,kO=/\\(\\)?/g,UO=zO(function(a){var e=[];return a.charCodeAt(0)===46&&e.push(""),a.replace(NO,function(t,n,i,r){e.push(i?r.replace(kO,"$1"):n||t)}),e});function FO(a){return a==null?"":rM(a)}function mM(a,e){return er(a)?a:Jv(a,e)?[a]:UO(FO(a))}function Qf(a){if(typeof a=="string"||Hv(a))return a;var e=a+"";return e=="0"&&1/a==-1/0?"-0":e}function gM(a,e){e=mM(e,a);for(var t=0,n=e.length;a!=null&&t<n;)a=a[Qf(e[t++])];return t&&t==n?a:void 0}function vM(a,e,t){var n=a==null?void 0:gM(a,e);return n===void 0?t:n}function yM(a,e){for(var t=-1,n=e.length,i=a.length;++t<n;)a[i+t]=e[t];return a}var fx=jr?jr.isConcatSpreadable:void 0;function HO(a){return er(a)||Wv(a)||!!(fx&&a&&a[fx])}function xM(a,e,t,n,i){var r=-1,s=a.length;for(t||(t=HO),i||(i=[]);++r<s;){var o=a[r];t(o)?yM(i,o):n||(i[i.length]=o)}return i}function GO(){this.__data__=new bs,this.size=0}function VO(a){var e=this.__data__,t=e.delete(a);return this.size=e.size,t}function jO(a){return this.__data__.get(a)}function QO(a){return this.__data__.has(a)}var WO=200;function XO(a,e){var t=this.__data__;if(t instanceof bs){var n=t.__data__;if(!gu||n.length<WO-1)return n.push([a,e]),this.size=++t.size,this;t=this.__data__=new Es(n)}return t.set(a,e),this.size=t.size,this}function gs(a){var e=this.__data__=new bs(a);this.size=e.size}gs.prototype.clear=GO;gs.prototype.delete=VO;gs.prototype.get=jO;gs.prototype.has=QO;gs.prototype.set=XO;function JO(a,e){for(var t=-1,n=a==null?0:a.length,i=0,r=[];++t<n;){var s=a[t];e(s,t,a)&&(r[i++]=s)}return r}function ZO(){return[]}var KO=Object.prototype,YO=KO.propertyIsEnumerable,px=Object.getOwnPropertySymbols,qO=px?function(a){return a==null?[]:(a=Object(a),JO(px(a),function(e){return YO.call(a,e)}))}:ZO;function _O(a,e,t){var n=e(a);return er(a)?n:yM(n,t(a))}function mx(a){return _O(a,Xv,qO)}var lg=vo(Ms,"DataView"),cg=vo(Ms,"Promise"),nl=vo(Ms,"Set"),gx="[object Map]",$O="[object Object]",vx="[object Promise]",yx="[object Set]",xx="[object WeakMap]",wx="[object DataView]",eB=go(lg),tB=go(gu),nB=go(cg),iB=go(nl),rB=go(ag),Qs=Ol;(lg&&Qs(new lg(new ArrayBuffer(1)))!=wx||gu&&Qs(new gu)!=gx||cg&&Qs(cg.resolve())!=vx||nl&&Qs(new nl)!=yx||ag&&Qs(new ag)!=xx)&&(Qs=function(a){var e=Ol(a),t=e==$O?a.constructor:void 0,n=t?go(t):"";if(n)switch(n){case eB:return wx;case tB:return gx;case nB:return vx;case iB:return yx;case rB:return xx}return e});var Ax=Ms.Uint8Array,sB="__lodash_hash_undefined__";function aB(a){return this.__data__.set(a,sB),this}function oB(a){return this.__data__.has(a)}function vl(a){var e=-1,t=a==null?0:a.length;for(this.__data__=new Es;++e<t;)this.add(a[e])}vl.prototype.add=vl.prototype.push=aB;vl.prototype.has=oB;function lB(a,e){for(var t=-1,n=a==null?0:a.length;++t<n;)if(e(a[t],t,a))return!0;return!1}function Kv(a,e){return a.has(e)}var cB=1,uB=2;function wM(a,e,t,n,i,r){var s=t&cB,o=a.length,l=e.length;if(o!=l&&!(s&&l>o))return!1;var c=r.get(a),u=r.get(e);if(c&&u)return c==e&&u==a;var h=-1,d=!0,f=t&uB?new vl:void 0;for(r.set(a,e),r.set(e,a);++h<o;){var p=a[h],m=e[h];if(n)var g=s?n(m,p,h,e,a,r):n(p,m,h,a,e,r);if(g!==void 0){if(g)continue;d=!1;break}if(f){if(!lB(e,function(v,y){if(!Kv(f,y)&&(p===v||i(p,v,t,n,r)))return f.push(y)})){d=!1;break}}else if(!(p===m||i(p,m,t,n,r))){d=!1;break}}return r.delete(a),r.delete(e),d}function hB(a){var e=-1,t=Array(a.size);return a.forEach(function(n,i){t[++e]=[i,n]}),t}function Yv(a){var e=-1,t=Array(a.size);return a.forEach(function(n){t[++e]=n}),t}var dB=1,fB=2,pB="[object Boolean]",mB="[object Date]",gB="[object Error]",vB="[object Map]",yB="[object Number]",xB="[object RegExp]",wB="[object Set]",AB="[object String]",SB="[object Symbol]",MB="[object ArrayBuffer]",bB="[object DataView]",Sx=jr?jr.prototype:void 0,Zp=Sx?Sx.valueOf:void 0;function EB(a,e,t,n,i,r,s){switch(t){case bB:if(a.byteLength!=e.byteLength||a.byteOffset!=e.byteOffset)return!1;a=a.buffer,e=e.buffer;case MB:return!(a.byteLength!=e.byteLength||!r(new Ax(a),new Ax(e)));case pB:case mB:case yB:return cM(+a,+e);case gB:return a.name==e.name&&a.message==e.message;case xB:case AB:return a==e+"";case vB:var o=hB;case wB:var l=n&dB;if(o||(o=Yv),a.size!=e.size&&!l)return!1;var c=s.get(a);if(c)return c==e;n|=fB,s.set(a,e);var u=wM(o(a),o(e),n,i,r,s);return s.delete(a),u;case SB:if(Zp)return Zp.call(a)==Zp.call(e)}return!1}var TB=1,CB=Object.prototype,IB=CB.hasOwnProperty;function RB(a,e,t,n,i,r){var s=t&TB,o=mx(a),l=o.length,c=mx(e),u=c.length;if(l!=u&&!s)return!1;for(var h=l;h--;){var d=o[h];if(!(s?d in e:IB.call(e,d)))return!1}var f=r.get(a),p=r.get(e);if(f&&p)return f==e&&p==a;var m=!0;r.set(a,e),r.set(e,a);for(var g=s;++h<l;){d=o[h];var v=a[d],y=e[d];if(n)var w=s?n(y,v,d,e,a,r):n(v,y,d,a,e,r);if(!(w===void 0?v===y||i(v,y,t,n,r):w)){m=!1;break}g||(g=d=="constructor")}if(m&&!g){var x=a.constructor,S=e.constructor;x!=S&&"constructor"in a&&"constructor"in e&&!(typeof x=="function"&&x instanceof x&&typeof S=="function"&&S instanceof S)&&(m=!1)}return r.delete(a),r.delete(e),m}var PB=1,Mx="[object Arguments]",bx="[object Array]",Jh="[object Object]",DB=Object.prototype,Ex=DB.hasOwnProperty;function OB(a,e,t,n,i,r){var s=er(a),o=er(e),l=s?bx:Qs(a),c=o?bx:Qs(e);l=l==Mx?Jh:l,c=c==Mx?Jh:c;var u=l==Jh,h=c==Jh,d=l==c;if(d&&og(a)){if(!og(e))return!1;s=!0,u=!1}if(d&&!u)return r||(r=new gs),s||pM(a)?wM(a,e,t,n,i,r):EB(a,e,l,t,n,i,r);if(!(t&PB)){var f=u&&Ex.call(a,"__wrapped__"),p=h&&Ex.call(e,"__wrapped__");if(f||p){var m=f?a.value():a,g=p?e.value():e;return r||(r=new gs),i(m,g,t,n,r)}}return d?(r||(r=new gs),RB(a,e,t,n,i,r)):!1}function qv(a,e,t,n,i){return a===e?!0:a==null||e==null||!io(a)&&!io(e)?a!==a&&e!==e:OB(a,e,t,n,qv,i)}var BB=1,LB=2;function zB(a,e,t,n){var i=t.length,r=i;if(a==null)return!r;for(a=Object(a);i--;){var s=t[i];if(s[2]?s[1]!==a[s[0]]:!(s[0]in a))return!1}for(;++i<r;){s=t[i];var o=s[0],l=a[o],c=s[1];if(s[2]){if(l===void 0&&!(o in a))return!1}else{var u=new gs,h;if(!(h===void 0?qv(c,l,BB|LB,n,u):h))return!1}}return!0}function AM(a){return a===a&&!Vv(a)}function NB(a){for(var e=Xv(a),t=e.length;t--;){var n=e[t],i=a[n];e[t]=[n,i,AM(i)]}return e}function SM(a,e){return function(t){return t==null?!1:t[a]===e&&(e!==void 0||a in Object(t))}}function kB(a){var e=NB(a);return e.length==1&&e[0][2]?SM(e[0][0],e[0][1]):function(t){return t===a||zB(t,a,e)}}function UB(a,e){return a!=null&&e in Object(a)}function MM(a,e,t){e=mM(e,a);for(var n=-1,i=e.length,r=!1;++n<i;){var s=Qf(e[n]);if(!(r=a!=null&&t(a,s)))break;a=a[s]}return r||++n!=i?r:(i=a==null?0:a.length,!!i&&Qv(i)&&oM(s,i)&&(er(a)||Wv(a)))}function FB(a,e){return a!=null&&MM(a,e,UB)}var HB=1,GB=2;function VB(a,e){return Jv(a)&&AM(e)?SM(Qf(a),e):function(t){var n=vM(t,a);return n===void 0&&n===e?FB(t,a):qv(e,n,HB|GB)}}function jB(a){return function(e){return e?.[a]}}function QB(a){return function(e){return gM(e,a)}}function WB(a){return Jv(a)?jB(Qf(a)):QB(a)}function Ju(a){return typeof a=="function"?a:a==null?jv:typeof a=="object"?er(a)?VB(a[0],a[1]):kB(a):WB(a)}function XB(a,e,t,n){for(var i=-1,r=a==null?0:a.length;++i<r;){var s=a[i];e(n,s,t(s),a)}return n}function JB(a){return function(e,t,n){for(var i=-1,r=Object(e),s=n(e),o=s.length;o--;){var l=s[++i];if(t(r[l],l,r)===!1)break}return e}}var ZB=JB();function bM(a,e){return a&&ZB(a,e,Xv)}function KB(a,e){return function(t,n){if(t==null)return t;if(!Gf(t))return a(t,n);for(var i=t.length,r=-1,s=Object(t);++r<i&&n(s[r],r,s)!==!1;);return t}}var EM=KB(bM);function YB(a,e,t,n){return EM(a,function(i,r,s){e(n,i,t(i),s)}),n}function qB(a,e){return function(t,n){var i=er(t)?XB:YB,r=e?e():{};return i(t,a,Ju(n),r)}}function Kp(a){return io(a)&&Gf(a)}var _B=200;function $B(a,e,t,n){var i=-1,r=aM,s=!0,o=a.length,l=[],c=e.length;if(!o)return l;t&&(e=Gv(e,dM(t))),e.length>=_B&&(r=Kv,s=!1,e=new vl(e));e:for(;++i<o;){var u=a[i],h=t==null?u:t(u);if(u=u!==0?u:0,s&&h===h){for(var d=c;d--;)if(e[d]===h)continue e;l.push(u)}else r(e,h,n)||l.push(u)}return l}function eL(a){var e=a==null?0:a.length;return e?a[e-1]:void 0}var tL=gD(function(a,e){var t=eL(e);return Kp(t)&&(t=void 0),Kp(a)?$B(a,xM(e,1,Kp,!0),Ju(t)):[]});function nL(a,e){var t=-1,n=Gf(a)?Array(a.length):[];return EM(a,function(i,r,s){n[++t]=e(i,r,s)}),n}function iL(a,e){var t=er(a)?Gv:nL;return t(a,Ju(e))}function rL(a,e){return xM(iL(a,e))}var sL=Object.prototype,aL=sL.hasOwnProperty,oL=qB(function(a,e,t){aL.call(a,t)?a[t].push(e):lM(a,t,[e])}),lL=Object.prototype,cL=lL.hasOwnProperty;function uL(a,e){return a!=null&&cL.call(a,e)}function hL(a,e){return a!=null&&MM(a,e,uL)}function dL(a,e){var t={};return e=Ju(e),bM(a,function(n,i,r){lM(t,i,e(n,i,r))}),t}var fL=1/0,pL=nl&&1/Yv(new nl([,-0]))[1]==fL?function(a){return new nl(a)}:tD,mL=200;function gL(a,e,t){var n=-1,i=aM,r=a.length,s=!0,o=[],l=o;if(r>=mL){var c=e?null:pL(a);if(c)return Yv(c);s=!1,i=Kv,l=new vl}else l=e?[]:o;e:for(;++n<r;){var u=a[n],h=e?e(u):u;if(u=u!==0?u:0,s&&h===h){for(var d=l.length;d--;)if(l[d]===h)continue e;e&&l.push(h),o.push(u)}else i(l,h,t)||(l!==o&&l.push(h),o.push(u))}return o}function vL(a,e){return a&&a.length?gL(a,Ju(e)):[]}const Pt={c:null,u:[new A,new A,new A],e:[]},Ft={c:null,u:[new A,new A,new A],e:[]},dn=[[],[],[]],xt=[[],[],[]],qt=[],Ma=new A,ba=new A,Ea=new A,Vn=new A,Tx=new A,Cx=new A,or=new Kt,Ix=new He,Zh=new ae,Rx=new ae,Px=new On;class Un{constructor(e=new A,t=new A,n=new Kt){this.center=e,this.halfSize=t,this.rotation=n}set(e,t,n){return this.center=e,this.halfSize=t,this.rotation=n,this}copy(e){return this.center.copy(e.center),this.halfSize.copy(e.halfSize),this.rotation.copy(e.rotation),this}clone(){return new this.constructor().copy(this)}getSize(e){return e.copy(this.halfSize).multiplyScalar(2)}clampPoint(e,t){const n=this.halfSize;Vn.subVectors(e,this.center),this.rotation.extractBasis(Ma,ba,Ea),t.copy(this.center);const i=It.clamp(Vn.dot(Ma),-n.x,n.x);t.add(Ma.multiplyScalar(i));const r=It.clamp(Vn.dot(ba),-n.y,n.y);t.add(ba.multiplyScalar(r));const s=It.clamp(Vn.dot(Ea),-n.z,n.z);return t.add(Ea.multiplyScalar(s)),t}containsPoint(e){return Vn.subVectors(e,this.center),this.rotation.extractBasis(Ma,ba,Ea),Math.abs(Vn.dot(Ma))<=this.halfSize.x&&Math.abs(Vn.dot(ba))<=this.halfSize.y&&Math.abs(Vn.dot(Ea))<=this.halfSize.z}intersectsBox3(e){return this.intersectsOBB(yL.fromBox3(e))}intersectsSphere(e){return this.clampPoint(e.center,Cx),Cx.distanceToSquared(e.center)<=e.radius*e.radius}intersectsOBB(e,t=Number.EPSILON){Pt.c=this.center,Pt.e[0]=this.halfSize.x,Pt.e[1]=this.halfSize.y,Pt.e[2]=this.halfSize.z,this.rotation.extractBasis(Pt.u[0],Pt.u[1],Pt.u[2]),Ft.c=e.center,Ft.e[0]=e.halfSize.x,Ft.e[1]=e.halfSize.y,Ft.e[2]=e.halfSize.z,e.rotation.extractBasis(Ft.u[0],Ft.u[1],Ft.u[2]);for(let r=0;r<3;r++)for(let s=0;s<3;s++)dn[r][s]=Pt.u[r].dot(Ft.u[s]);Vn.subVectors(Ft.c,Pt.c),qt[0]=Vn.dot(Pt.u[0]),qt[1]=Vn.dot(Pt.u[1]),qt[2]=Vn.dot(Pt.u[2]);for(let r=0;r<3;r++)for(let s=0;s<3;s++)xt[r][s]=Math.abs(dn[r][s])+t;let n,i;for(let r=0;r<3;r++)if(n=Pt.e[r],i=Ft.e[0]*xt[r][0]+Ft.e[1]*xt[r][1]+Ft.e[2]*xt[r][2],Math.abs(qt[r])>n+i)return!1;for(let r=0;r<3;r++)if(n=Pt.e[0]*xt[0][r]+Pt.e[1]*xt[1][r]+Pt.e[2]*xt[2][r],i=Ft.e[r],Math.abs(qt[0]*dn[0][r]+qt[1]*dn[1][r]+qt[2]*dn[2][r])>n+i)return!1;return n=Pt.e[1]*xt[2][0]+Pt.e[2]*xt[1][0],i=Ft.e[1]*xt[0][2]+Ft.e[2]*xt[0][1],!(Math.abs(qt[2]*dn[1][0]-qt[1]*dn[2][0])>n+i||(n=Pt.e[1]*xt[2][1]+Pt.e[2]*xt[1][1],i=Ft.e[0]*xt[0][2]+Ft.e[2]*xt[0][0],Math.abs(qt[2]*dn[1][1]-qt[1]*dn[2][1])>n+i)||(n=Pt.e[1]*xt[2][2]+Pt.e[2]*xt[1][2],i=Ft.e[0]*xt[0][1]+Ft.e[1]*xt[0][0],Math.abs(qt[2]*dn[1][2]-qt[1]*dn[2][2])>n+i)||(n=Pt.e[0]*xt[2][0]+Pt.e[2]*xt[0][0],i=Ft.e[1]*xt[1][2]+Ft.e[2]*xt[1][1],Math.abs(qt[0]*dn[2][0]-qt[2]*dn[0][0])>n+i)||(n=Pt.e[0]*xt[2][1]+Pt.e[2]*xt[0][1],i=Ft.e[0]*xt[1][2]+Ft.e[2]*xt[1][0],Math.abs(qt[0]*dn[2][1]-qt[2]*dn[0][1])>n+i)||(n=Pt.e[0]*xt[2][2]+Pt.e[2]*xt[0][2],i=Ft.e[0]*xt[1][1]+Ft.e[1]*xt[1][0],Math.abs(qt[0]*dn[2][2]-qt[2]*dn[0][2])>n+i)||(n=Pt.e[0]*xt[1][0]+Pt.e[1]*xt[0][0],i=Ft.e[1]*xt[2][2]+Ft.e[2]*xt[2][1],Math.abs(qt[1]*dn[0][0]-qt[0]*dn[1][0])>n+i)||(n=Pt.e[0]*xt[1][1]+Pt.e[1]*xt[0][1],i=Ft.e[0]*xt[2][2]+Ft.e[2]*xt[2][0],Math.abs(qt[1]*dn[0][1]-qt[0]*dn[1][1])>n+i)||(n=Pt.e[0]*xt[1][2]+Pt.e[1]*xt[0][2],i=Ft.e[0]*xt[2][1]+Ft.e[1]*xt[2][0],Math.abs(qt[1]*dn[0][2]-qt[0]*dn[1][2])>n+i))}intersectsPlane(e){this.rotation.extractBasis(Ma,ba,Ea);const t=this.halfSize.x*Math.abs(e.normal.dot(Ma))+this.halfSize.y*Math.abs(e.normal.dot(ba))+this.halfSize.z*Math.abs(e.normal.dot(Ea)),n=e.normal.dot(this.center)-e.constant;return Math.abs(n)<=t}intersectRay(e,t){return this.getSize(Tx),Ix.setFromCenterAndSize(Vn.set(0,0,0),Tx),Zh.setFromMatrix3(this.rotation),Zh.setPosition(this.center),Rx.copy(Zh).invert(),Px.copy(e).applyMatrix4(Rx),Px.intersectBox(Ix,t)?t.applyMatrix4(Zh):null}intersectsRay(e){return this.intersectRay(e,Vn)!==null}fromBox3(e){return e.getCenter(this.center),e.getSize(this.halfSize).multiplyScalar(.5),this.rotation.identity(),this}equals(e){return e.center.equals(this.center)&&e.halfSize.equals(this.halfSize)&&e.rotation.equals(this.rotation)}applyMatrix4(e){const t=e.elements;let n=Vn.set(t[0],t[1],t[2]).length();const i=Vn.set(t[4],t[5],t[6]).length(),r=Vn.set(t[8],t[9],t[10]).length();e.determinant()<0&&(n=-n),or.setFromMatrix4(e);const o=1/n,l=1/i,c=1/r;return or.elements[0]*=o,or.elements[1]*=o,or.elements[2]*=o,or.elements[3]*=l,or.elements[4]*=l,or.elements[5]*=l,or.elements[6]*=c,or.elements[7]*=c,or.elements[8]*=c,this.rotation.multiply(or),this.halfSize.x*=n,this.halfSize.y*=i,this.halfSize.z*=r,Vn.setFromMatrixPosition(e),this.center.add(Vn),this}}const yL=new Un;var Yp,Dx;function xL(){return Dx||(Dx=1,Yp=(function(){function a(t,n){var i=n.length,r,s;return i>=2?(r=n.slice(0,i/2),s=n.slice(i/2,i),e(t,a(t,r),a(t,s))):n.slice()}function e(t,n,i){for(var r=[],s=n.length,o=i.length;s>0&&o>0;)t(n[0],i[0])<=0?(r.push(n.shift()),s--):(r.push(i.shift()),o--);return s>0?r.push.apply(r,n):r.push.apply(r,i),r}return a})()),Yp}var qp,Ox;function wL(){return Ox||(Ox=1,qp=(function(){function a(e,t,n){var i,r;for(i=0,r=t.length;i<r&&!(e(t[i],n)>0);i++);return i}return a})()),qp}var _p,Bx;function AL(){if(Bx)return _p;Bx=1;var a,e;return a=xL(),e=wL(),_p=(function(){var t;t={};function n(u){return function(){return u}}function i(u){u=u||{},this.config=u,this.config.childrenPropertyName=u.childrenPropertyName||"children",this.config.modelComparatorFn=u.modelComparatorFn}function r(u,h){return h.parent=u,u.children.push(h),h}function s(u,h){this.config=u,this.model=h,this.children=[]}i.prototype.parse=function(u){var h,d,f;if(!(u instanceof Object))throw new TypeError("Model must be of type object.");if(f=new s(this.config,u),u[this.config.childrenPropertyName]instanceof Array)for(this.config.modelComparatorFn&&(u[this.config.childrenPropertyName]=a(this.config.modelComparatorFn,u[this.config.childrenPropertyName])),h=0,d=u[this.config.childrenPropertyName].length;h<d;h++)r(f,this.parse(u[this.config.childrenPropertyName][h]));return f};function o(u){return typeof u.config.modelComparatorFn=="function"}s.prototype.isRoot=function(){return this.parent===void 0},s.prototype.hasChildren=function(){return this.children.length>0};function l(u,h,d){var f;if(!(h instanceof s))throw new TypeError("Child must be of type Node.");if(h.parent=u,u.model[u.config.childrenPropertyName]instanceof Array||(u.model[u.config.childrenPropertyName]=[]),o(u))f=e(u.config.modelComparatorFn,u.model[u.config.childrenPropertyName],h.model),u.model[u.config.childrenPropertyName].splice(f,0,h.model),u.children.splice(f,0,h);else if(d===void 0)u.model[u.config.childrenPropertyName].push(h.model),u.children.push(h);else{if(d<0||d>u.children.length)throw new Error("Invalid index.");u.model[u.config.childrenPropertyName].splice(d,0,h.model),u.children.splice(d,0,h)}return h}s.prototype.addChild=function(u){return l(this,u)},s.prototype.addChildAtIndex=function(u,h){if(o(this))throw new Error("Cannot add child at index when using a comparator function.");return l(this,u,h)},s.prototype.setIndex=function(u){if(o(this))throw new Error("Cannot set node index when using a comparator function.");if(this.isRoot()){if(u===0)return this;throw new Error("Invalid index.")}if(u<0||u>=this.parent.children.length)throw new Error("Invalid index.");var h=this.parent.children.indexOf(this);return this.parent.children.splice(u,0,this.parent.children.splice(h,1)[0]),this.parent.model[this.parent.config.childrenPropertyName].splice(u,0,this.parent.model[this.parent.config.childrenPropertyName].splice(h,1)[0]),this},s.prototype.getPath=function(){var u=[];return(function h(d){u.unshift(d),d.isRoot()||h(d.parent)})(this),u},s.prototype.getIndex=function(){return this.isRoot()?0:this.parent.children.indexOf(this)};function c(){var u={};if(arguments.length===1?typeof arguments[0]=="function"?u.fn=arguments[0]:u.options=arguments[0]:arguments.length===2?typeof arguments[0]=="function"?(u.fn=arguments[0],u.ctx=arguments[1]):(u.options=arguments[0],u.fn=arguments[1]):(u.options=arguments[0],u.fn=arguments[1],u.ctx=arguments[2]),u.options=u.options||{},u.options.strategy||(u.options.strategy="pre"),!t[u.options.strategy])throw new Error("Unknown tree walk strategy. Valid strategies are 'pre' [default], 'post' and 'breadth'.");return u}return s.prototype.walk=function(){var u;u=c.apply(this,arguments),t[u.options.strategy].call(this,u.fn,u.ctx)},t.pre=function u(h,d){var f,p,m;for(m=h.call(d,this),f=0,p=this.children.length;f<p;f++){if(m===!1)return!1;m=u.call(this.children[f],h,d)}return m},t.post=function u(h,d){var f,p,m;for(f=0,p=this.children.length;f<p;f++)if(m=u.call(this.children[f],h,d),m===!1)return!1;return m=h.call(d,this),m},t.breadth=function(h,d){var f=[this];(function p(){var m,g,v;if(f.length!==0){for(v=f.shift(),m=0,g=v.children.length;m<g;m++)f.push(v.children[m]);h.call(d,v)!==!1&&p()}})()},s.prototype.all=function(){var u,h=[];return u=c.apply(this,arguments),u.fn=u.fn||n(!0),t[u.options.strategy].call(this,function(d){u.fn.call(u.ctx,d)&&h.push(d)},u.ctx),h},s.prototype.first=function(){var u,h;return u=c.apply(this,arguments),u.fn=u.fn||n(!0),t[u.options.strategy].call(this,function(d){if(u.fn.call(u.ctx,d))return h=d,!1},u.ctx),h},s.prototype.drop=function(){var u;return this.isRoot()||(u=this.parent.children.indexOf(this),this.parent.children.splice(u,1),this.parent.model[this.config.childrenPropertyName].splice(u,1),this.parent=void 0,delete this.parent),this},i})(),_p}var SL=AL();const Lx=Bg(SL);Ke.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new te(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}};Rn.line={uniforms:Hr.merge([Ke.common,Ke.fog,Ke.line]),vertexShader:`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,fragmentShader:`
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`};class _v extends gn{constructor(e){super({type:"LineMaterial",uniforms:Hr.clone(Rn.line.uniforms),vertexShader:Rn.line.vertexShader,fragmentShader:Rn.line.fragmentShader,clipping:!0}),Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(t){this.uniforms.diffuse.value=t}},worldUnits:{enumerable:!0,get:function(){return"WORLD_UNITS"in this.defines},set:function(t){t===!0?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(t){this.uniforms.linewidth.value=t}},dashed:{enumerable:!0,get:function(){return"USE_DASH"in this.defines},set(t){!!t!="USE_DASH"in this.defines&&(this.needsUpdate=!0),t===!0?this.defines.USE_DASH="":delete this.defines.USE_DASH}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(t){this.uniforms.dashScale.value=t}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(t){this.uniforms.dashSize.value=t}},dashOffset:{enumerable:!0,get:function(){return this.uniforms.dashOffset.value},set:function(t){this.uniforms.dashOffset.value=t}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(t){this.uniforms.gapSize.value=t}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(t){this.uniforms.resolution.value.copy(t)}},alphaToCoverage:{enumerable:!0,get:function(){return"USE_ALPHA_TO_COVERAGE"in this.defines},set:function(t){!!t!="USE_ALPHA_TO_COVERAGE"in this.defines&&(this.needsUpdate=!0),t===!0?(this.defines.USE_ALPHA_TO_COVERAGE="",this.extensions.derivatives=!0):(delete this.defines.USE_ALPHA_TO_COVERAGE,this.extensions.derivatives=!1)}}}),this.setValues(e)}}_v.prototype.isLineMaterial=!0;const TM=/\bvoid\s+main\s*\(\s*\)\s*{/g;function ug(a){const e=/^[ \t]*#include +<([\w\d./]+)>/gm;function t(n,i){let r=bt[i];return r?ug(r):n}return a.replace(e,t)}const Yn=[];for(let a=0;a<256;a++)Yn[a]=(a<16?"0":"")+a.toString(16);function ML(){const a=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(Yn[a&255]+Yn[a>>8&255]+Yn[a>>16&255]+Yn[a>>24&255]+"-"+Yn[e&255]+Yn[e>>8&255]+"-"+Yn[e>>16&15|64]+Yn[e>>24&255]+"-"+Yn[t&63|128]+Yn[t>>8&255]+"-"+Yn[t>>16&255]+Yn[t>>24&255]+Yn[n&255]+Yn[n>>8&255]+Yn[n>>16&255]+Yn[n>>24&255]).toUpperCase()}const Ta=Object.assign||function(){let a=arguments[0];for(let e=1,t=arguments.length;e<t;e++){let n=arguments[e];if(n)for(let i in n)Object.prototype.hasOwnProperty.call(n,i)&&(a[i]=n[i])}return a},bL=Date.now(),zx=new WeakMap,Nx=new Map;let EL=1e10;function so(a,e){const t=RL(e);let n=zx.get(a);if(n||zx.set(a,n=Object.create(null)),n[t])return new n[t];const i=`_onBeforeCompile${t}`,r=function(c,u){a.onBeforeCompile.call(this,c,u);const h=this.customProgramCacheKey()+"|"+c.vertexShader+"|"+c.fragmentShader;let d=Nx[h];if(!d){const f=TL(this,c,e,t);d=Nx[h]=f}c.vertexShader=d.vertexShader,c.fragmentShader=d.fragmentShader,Ta(c.uniforms,this.uniforms),e.timeUniform&&(c.uniforms[e.timeUniform]={get value(){return Date.now()-bL}}),this[i]&&this[i](c)},s=function(){return o(e.chained?a:a.clone())},o=function(c){const u=Object.create(c,l);return Object.defineProperty(u,"baseMaterial",{value:a}),Object.defineProperty(u,"id",{value:EL++}),u.uuid=ML(),u.uniforms=Ta({},c.uniforms,e.uniforms),u.defines=Ta({},c.defines,e.defines),u.defines[`TROIKA_DERIVED_MATERIAL_${t}`]="",u.extensions=Ta({},c.extensions,e.extensions),u._listeners=void 0,u},l={constructor:{value:s},isDerivedMaterial:{value:!0},type:{get:()=>a.type,set:c=>{a.type=c}},isDerivedFrom:{writable:!0,configurable:!0,value:function(c){const u=this.baseMaterial;return c===u||u.isDerivedMaterial&&u.isDerivedFrom(c)||!1}},customProgramCacheKey:{writable:!0,configurable:!0,value:function(){return a.customProgramCacheKey()+"|"+t}},onBeforeCompile:{get(){return r},set(c){this[i]=c}},copy:{writable:!0,configurable:!0,value:function(c){return a.copy.call(this,c),!a.isShaderMaterial&&!a.isDerivedMaterial&&(Ta(this.extensions,c.extensions),Ta(this.defines,c.defines),Ta(this.uniforms,Hr.clone(c.uniforms))),this}},clone:{writable:!0,configurable:!0,value:function(){const c=new a.constructor;return o(c).copy(this)}},getDepthMaterial:{writable:!0,configurable:!0,value:function(){let c=this._depthMaterial;return c||(c=this._depthMaterial=so(a.isDerivedMaterial?a.getDepthMaterial():new Cl({depthPacking:da}),e),c.defines.IS_DEPTH_MATERIAL="",c.uniforms=this.uniforms),c}},getDistanceMaterial:{writable:!0,configurable:!0,value:function(){let c=this._distanceMaterial;return c||(c=this._distanceMaterial=so(a.isDerivedMaterial?a.getDistanceMaterial():new ku,e),c.defines.IS_DISTANCE_MATERIAL="",c.uniforms=this.uniforms),c}},dispose:{writable:!0,configurable:!0,value(){const{_depthMaterial:c,_distanceMaterial:u}=this;c&&c.dispose(),u&&u.dispose(),a.dispose.call(this)}}};return n[t]=s,new s}function TL(a,{vertexShader:e,fragmentShader:t},n,i){let{vertexDefs:r,vertexMainIntro:s,vertexMainOutro:o,vertexTransform:l,fragmentDefs:c,fragmentMainIntro:u,fragmentMainOutro:h,fragmentColorTransform:d,customRewriter:f,timeUniform:p}=n;if(r=r||"",s=s||"",o=o||"",c=c||"",u=u||"",h=h||"",(l||f)&&(e=ug(e)),(d||f)&&(t=t.replace(/^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,`
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`),t=ug(t)),f){let m=f({vertexShader:e,fragmentShader:t});e=m.vertexShader,t=m.fragmentShader}if(d){let m=[];t=t.replace(/^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,g=>(m.push(g),"")),h=`${d}
${m.join(`
`)}
${h}`}if(p){const m=`
uniform float ${p};
`;r=m+r,c=m+c}return l&&(e=`vec3 troika_position_${i};
vec3 troika_normal_${i};
vec2 troika_uv_${i};
${e}
`,r=`${r}
void troikaVertexTransform${i}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${l}
}
`,s=`
troika_position_${i} = vec3(position);
troika_normal_${i} = vec3(normal);
troika_uv_${i} = vec2(uv);
troikaVertexTransform${i}(troika_position_${i}, troika_normal_${i}, troika_uv_${i});
${s}
`,e=e.replace(/\b(position|normal|uv)\b/g,(m,g,v,y)=>/\battribute\s+vec[23]\s+$/.test(y.substr(0,v))?g:`troika_${g}_${i}`),a.map&&a.map.channel>0||(e=e.replace(/\bMAP_UV\b/g,`troika_uv_${i}`))),e=kx(e,i,r,s,o),t=kx(t,i,c,u,h),{vertexShader:e,fragmentShader:t}}function kx(a,e,t,n,i){return(n||i||t)&&(a=a.replace(TM,`
${t}
void troikaOrigMain${e}() {`),a+=`
void main() {
  ${n}
  troikaOrigMain${e}();
  ${i}
}`),a}function CL(a,e){return a==="uniforms"?void 0:typeof e=="function"?e.toString():e}let IL=0;const Ux=new Map;function RL(a){const e=JSON.stringify(a,CL);let t=Ux.get(e);return t==null&&Ux.set(e,t=++IL),t}function PL(){var a=Object.create(null);function e(i,r){var s=i.id,o=i.name,l=i.dependencies;l===void 0&&(l=[]);var c=i.init;c===void 0&&(c=function(){});var u=i.getTransferables;if(u===void 0&&(u=null),!a[s])try{l=l.map(function(d){return d&&d.isWorkerModule&&(e(d,function(f){if(f instanceof Error)throw f}),d=a[d.id].value),d}),c=n("<"+o+">.init",c),u&&(u=n("<"+o+">.getTransferables",u));var h=null;typeof c=="function"?h=c.apply(void 0,l):console.error("worker module init function failed to rehydrate"),a[s]={id:s,value:h,getTransferables:u},r(h)}catch(d){d&&d.noLog||console.error(d),r(d)}}function t(i,r){var s,o=i.id,l=i.args;(!a[o]||typeof a[o].value!="function")&&r(new Error("Worker module "+o+": not found or its 'init' did not return a function"));try{var c=(s=a[o]).value.apply(s,l);c&&typeof c.then=="function"?c.then(u,function(h){return r(h instanceof Error?h:new Error(""+h))}):u(c)}catch(h){r(h)}function u(h){try{var d=a[o].getTransferables&&a[o].getTransferables(h);(!d||!Array.isArray(d)||!d.length)&&(d=void 0),r(h,d)}catch(f){console.error(f),r(f)}}}function n(i,r){var s=void 0;self.troikaDefine=function(l){return s=l};var o=URL.createObjectURL(new Blob(["/** "+i.replace(/\*/g,"")+` **/

troikaDefine(
`+r+`
)`],{type:"application/javascript"}));try{importScripts(o)}catch(l){console.error(l)}return URL.revokeObjectURL(o),delete self.troikaDefine,s}self.addEventListener("message",function(i){var r=i.data,s=r.messageId,o=r.action,l=r.data;try{o==="registerModule"&&e(l,function(c){c instanceof Error?postMessage({messageId:s,success:!1,error:c.message}):postMessage({messageId:s,success:!0,result:{isCallable:typeof c=="function"}})}),o==="callModule"&&t(l,function(c,u){c instanceof Error?postMessage({messageId:s,success:!1,error:c.message}):postMessage({messageId:s,success:!0,result:c},u||void 0)})}catch(c){postMessage({messageId:s,success:!1,error:c.stack})}})}function DL(a){var e=function(){for(var t=[],n=arguments.length;n--;)t[n]=arguments[n];return e._getInitResult().then(function(i){if(typeof i=="function")return i.apply(void 0,t);throw new Error("Worker module function was called but `init` did not return a callable function")})};return e._getInitResult=function(){var t=a.dependencies,n=a.init;t=Array.isArray(t)?t.map(function(r){return r&&(r=r.onMainThread||r,r._getInitResult&&(r=r._getInitResult())),r}):[];var i=Promise.all(t).then(function(r){return n.apply(null,r)});return e._getInitResult=function(){return i},i},e}var CM=function(){var a=!1;if(typeof window<"u"&&typeof window.document<"u")try{var e=new Worker(URL.createObjectURL(new Blob([""],{type:"application/javascript"})));e.terminate(),a=!0}catch(t){console.log("Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: ["+t.message+"]")}return CM=function(){return a},a},OL=0,BL=0,$p=!1,Ec=Object.create(null),Tc=Object.create(null),hg=Object.create(null);function Bl(a){if((!a||typeof a.init!="function")&&!$p)throw new Error("requires `options.init` function");var e=a.dependencies,t=a.init,n=a.getTransferables,i=a.workerId,r=DL(a);i==null&&(i="#default");var s="workerModule"+ ++OL,o=a.name||s,l=null;e=e&&e.map(function(u){return typeof u=="function"&&!u.workerModuleData&&($p=!0,u=Bl({workerId:i,name:"<"+o+"> function dependency: "+u.name,init:`function(){return (
`+zd(u)+`
)}`}),$p=!1),u&&u.workerModuleData&&(u=u.workerModuleData),u});function c(){for(var u=[],h=arguments.length;h--;)u[h]=arguments[h];if(!CM())return r.apply(void 0,u);if(!l){l=Fx(i,"registerModule",c.workerModuleData);var d=function(){l=null,Tc[i].delete(d)};(Tc[i]||(Tc[i]=new Set)).add(d)}return l.then(function(f){var p=f.isCallable;if(p)return Fx(i,"callModule",{id:s,args:u});throw new Error("Worker module function was called but `init` did not return a callable function")})}return c.workerModuleData={isWorkerModule:!0,id:s,name:o,dependencies:e,init:zd(t),getTransferables:n&&zd(n)},c.onMainThread=r,c}function LL(a){Tc[a]&&Tc[a].forEach(function(e){e()}),Ec[a]&&(Ec[a].terminate(),delete Ec[a])}function zd(a){var e=a.toString();return!/^function/.test(e)&&/^\w+\s*\(/.test(e)&&(e="function "+e),e}function zL(a){var e=Ec[a];if(!e){var t=zd(PL);e=Ec[a]=new Worker(URL.createObjectURL(new Blob(["/** Worker Module Bootstrap: "+a.replace(/\*/g,"")+` **/

;(`+t+")()"],{type:"application/javascript"}))),e.onmessage=function(n){var i=n.data,r=i.messageId,s=hg[r];if(!s)throw new Error("WorkerModule response with empty or unknown messageId");delete hg[r],s(i)}}return e}function Fx(a,e,t){return new Promise(function(n,i){var r=++BL;hg[r]=function(s){s.success?n(s.result):i(new Error("Error in worker "+e+" call: "+s.error))},zL(a).postMessage({messageId:r,action:e,data:t})})}function IM(){var a=(function(e){function t(G,j,L,H,q,$,ee,W){var le=1-ee;W.x=le*le*G+2*le*ee*L+ee*ee*q,W.y=le*le*j+2*le*ee*H+ee*ee*$}function n(G,j,L,H,q,$,ee,W,le,K){var pe=1-le;K.x=pe*pe*pe*G+3*pe*pe*le*L+3*pe*le*le*q+le*le*le*ee,K.y=pe*pe*pe*j+3*pe*pe*le*H+3*pe*le*le*$+le*le*le*W}function i(G,j){for(var L=/([MLQCZ])([^MLQCZ]*)/g,H,q,$,ee,W;H=L.exec(G);){var le=H[2].replace(/^\s*|\s*$/g,"").split(/[,\s]+/).map(function(K){return parseFloat(K)});switch(H[1]){case"M":ee=q=le[0],W=$=le[1];break;case"L":(le[0]!==ee||le[1]!==W)&&j("L",ee,W,ee=le[0],W=le[1]);break;case"Q":{j("Q",ee,W,ee=le[2],W=le[3],le[0],le[1]);break}case"C":{j("C",ee,W,ee=le[4],W=le[5],le[0],le[1],le[2],le[3]);break}case"Z":(ee!==q||W!==$)&&j("L",ee,W,q,$);break}}}function r(G,j,L){L===void 0&&(L=16);var H={x:0,y:0};i(G,function(q,$,ee,W,le,K,pe,se,ve){switch(q){case"L":j($,ee,W,le);break;case"Q":{for(var Z=$,oe=ee,Ae=1;Ae<L;Ae++)t($,ee,K,pe,W,le,Ae/(L-1),H),j(Z,oe,H.x,H.y),Z=H.x,oe=H.y;break}case"C":{for(var Ee=$,Se=ee,ke=1;ke<L;ke++)n($,ee,K,pe,se,ve,W,le,ke/(L-1),H),j(Ee,Se,H.x,H.y),Ee=H.x,Se=H.y;break}}})}var s="precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",o="precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}",l=new WeakMap,c={premultipliedAlpha:!1,preserveDrawingBuffer:!0,antialias:!1,depth:!1};function u(G,j){var L=G.getContext?G.getContext("webgl",c):G,H=l.get(L);if(!H){let pe=function(Ee){var Se=$[Ee];if(!Se&&(Se=$[Ee]=L.getExtension(Ee),!Se))throw new Error(Ee+" not supported");return Se},se=function(Ee,Se){var ke=L.createShader(Se);return L.shaderSource(ke,Ee),L.compileShader(ke),ke},ve=function(Ee,Se,ke,ye){if(!ee[Ee]){var ge={},Fe={},Me=L.createProgram();L.attachShader(Me,se(Se,L.VERTEX_SHADER)),L.attachShader(Me,se(ke,L.FRAGMENT_SHADER)),L.linkProgram(Me),ee[Ee]={program:Me,transaction:function(D){L.useProgram(Me),D({setUniform:function(J,be){for(var we=[],Pe=arguments.length-2;Pe-- >0;)we[Pe]=arguments[Pe+2];var ie=Fe[be]||(Fe[be]=L.getUniformLocation(Me,be));L["uniform"+J].apply(L,[ie].concat(we))},setAttribute:function(J,be,we,Pe,ie){var We=ge[J];We||(We=ge[J]={buf:L.createBuffer(),loc:L.getAttribLocation(Me,J),data:null}),L.bindBuffer(L.ARRAY_BUFFER,We.buf),L.vertexAttribPointer(We.loc,be,L.FLOAT,!1,0,0),L.enableVertexAttribArray(We.loc),q?L.vertexAttribDivisor(We.loc,Pe):pe("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(We.loc,Pe),ie!==We.data&&(L.bufferData(L.ARRAY_BUFFER,ie,we),We.data=ie)}})}}}ee[Ee].transaction(ye)},Z=function(Ee,Se){le++;try{L.activeTexture(L.TEXTURE0+le);var ke=W[Ee];ke||(ke=W[Ee]=L.createTexture(),L.bindTexture(L.TEXTURE_2D,ke),L.texParameteri(L.TEXTURE_2D,L.TEXTURE_MIN_FILTER,L.NEAREST),L.texParameteri(L.TEXTURE_2D,L.TEXTURE_MAG_FILTER,L.NEAREST)),L.bindTexture(L.TEXTURE_2D,ke),Se(ke,le)}finally{le--}},oe=function(Ee,Se,ke){var ye=L.createFramebuffer();K.push(ye),L.bindFramebuffer(L.FRAMEBUFFER,ye),L.activeTexture(L.TEXTURE0+Se),L.bindTexture(L.TEXTURE_2D,Ee),L.framebufferTexture2D(L.FRAMEBUFFER,L.COLOR_ATTACHMENT0,L.TEXTURE_2D,Ee,0);try{ke(ye)}finally{L.deleteFramebuffer(ye),L.bindFramebuffer(L.FRAMEBUFFER,K[--K.length-1]||null)}},Ae=function(){$={},ee={},W={},le=-1,K.length=0};var q=typeof WebGL2RenderingContext<"u"&&L instanceof WebGL2RenderingContext,$={},ee={},W={},le=-1,K=[];L.canvas.addEventListener("webglcontextlost",function(Ee){Ae(),Ee.preventDefault()},!1),l.set(L,H={gl:L,isWebGL2:q,getExtension:pe,withProgram:ve,withTexture:Z,withTextureFramebuffer:oe,handleContextLoss:Ae})}j(H)}function h(G,j,L,H,q,$,ee,W){ee===void 0&&(ee=15),W===void 0&&(W=null),u(G,function(le){var K=le.gl,pe=le.withProgram,se=le.withTexture;se("copy",function(ve,Z){K.texImage2D(K.TEXTURE_2D,0,K.RGBA,q,$,0,K.RGBA,K.UNSIGNED_BYTE,j),pe("copy",s,o,function(oe){var Ae=oe.setUniform,Ee=oe.setAttribute;Ee("aUV",2,K.STATIC_DRAW,0,new Float32Array([0,0,2,0,0,2])),Ae("1i","image",Z),K.bindFramebuffer(K.FRAMEBUFFER,W||null),K.disable(K.BLEND),K.colorMask(ee&8,ee&4,ee&2,ee&1),K.viewport(L,H,q,$),K.scissor(L,H,q,$),K.drawArrays(K.TRIANGLES,0,3)})})})}function d(G,j,L){var H=G.width,q=G.height;u(G,function($){var ee=$.gl,W=new Uint8Array(H*q*4);ee.readPixels(0,0,H,q,ee.RGBA,ee.UNSIGNED_BYTE,W),G.width=j,G.height=L,h(ee,W,0,0,H,q)})}var f=Object.freeze({__proto__:null,withWebGLContext:u,renderImageData:h,resizeWebGLCanvasWithoutClearing:d});function p(G,j,L,H,q,$){$===void 0&&($=1);var ee=new Uint8Array(G*j),W=H[2]-H[0],le=H[3]-H[1],K=[];r(L,function(Ee,Se,ke,ye){K.push({x1:Ee,y1:Se,x2:ke,y2:ye,minX:Math.min(Ee,ke),minY:Math.min(Se,ye),maxX:Math.max(Ee,ke),maxY:Math.max(Se,ye)})}),K.sort(function(Ee,Se){return Ee.maxX-Se.maxX});for(var pe=0;pe<G;pe++)for(var se=0;se<j;se++){var ve=oe(H[0]+W*(pe+.5)/G,H[1]+le*(se+.5)/j),Z=Math.pow(1-Math.abs(ve)/q,$)/2;ve<0&&(Z=1-Z),Z=Math.max(0,Math.min(255,Math.round(Z*255))),ee[se*G+pe]=Z}return ee;function oe(Ee,Se){for(var ke=1/0,ye=1/0,ge=K.length;ge--;){var Fe=K[ge];if(Fe.maxX+ye<=Ee)break;if(Ee+ye>Fe.minX&&Se-ye<Fe.maxY&&Se+ye>Fe.minY){var Me=v(Ee,Se,Fe.x1,Fe.y1,Fe.x2,Fe.y2);Me<ke&&(ke=Me,ye=Math.sqrt(ke))}}return Ae(Ee,Se)&&(ye=-ye),ye}function Ae(Ee,Se){for(var ke=0,ye=K.length;ye--;){var ge=K[ye];if(ge.maxX<=Ee)break;var Fe=ge.y1>Se!=ge.y2>Se&&Ee<(ge.x2-ge.x1)*(Se-ge.y1)/(ge.y2-ge.y1)+ge.x1;Fe&&(ke+=ge.y1<ge.y2?1:-1)}return ke!==0}}function m(G,j,L,H,q,$,ee,W,le,K){$===void 0&&($=1),W===void 0&&(W=0),le===void 0&&(le=0),K===void 0&&(K=0),g(G,j,L,H,q,$,ee,null,W,le,K)}function g(G,j,L,H,q,$,ee,W,le,K,pe){$===void 0&&($=1),le===void 0&&(le=0),K===void 0&&(K=0),pe===void 0&&(pe=0);for(var se=p(G,j,L,H,q,$),ve=new Uint8Array(se.length*4),Z=0;Z<se.length;Z++)ve[Z*4+pe]=se[Z];h(ee,ve,le,K,G,j,1<<3-pe,W)}function v(G,j,L,H,q,$){var ee=q-L,W=$-H,le=ee*ee+W*W,K=le?Math.max(0,Math.min(1,((G-L)*ee+(j-H)*W)/le)):0,pe=G-(L+K*ee),se=j-(H+K*W);return pe*pe+se*se}var y=Object.freeze({__proto__:null,generate:p,generateIntoCanvas:m,generateIntoFramebuffer:g}),w="precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",x="precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}",S="precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}",b=new Float32Array([0,0,2,0,0,2]),E=null,M=!1,T={},I=new WeakMap;function O(G){if(!M&&!F(G))throw new Error("WebGL generation not supported")}function R(G,j,L,H,q,$,ee){if($===void 0&&($=1),ee===void 0&&(ee=null),!ee&&(ee=E,!ee)){var W=typeof OffscreenCanvas=="function"?new OffscreenCanvas(1,1):typeof document<"u"?document.createElement("canvas"):null;if(!W)throw new Error("OffscreenCanvas or DOM canvas not supported");ee=E=W.getContext("webgl",{depth:!1})}O(ee);var le=new Uint8Array(G*j*4);u(ee,function(ve){var Z=ve.gl,oe=ve.withTexture,Ae=ve.withTextureFramebuffer;oe("readable",function(Ee,Se){Z.texImage2D(Z.TEXTURE_2D,0,Z.RGBA,G,j,0,Z.RGBA,Z.UNSIGNED_BYTE,null),Ae(Ee,Se,function(ke){P(G,j,L,H,q,$,Z,ke,0,0,0),Z.readPixels(0,0,G,j,Z.RGBA,Z.UNSIGNED_BYTE,le)})})});for(var K=new Uint8Array(G*j),pe=0,se=0;pe<le.length;pe+=4)K[se++]=le[pe];return K}function k(G,j,L,H,q,$,ee,W,le,K){$===void 0&&($=1),W===void 0&&(W=0),le===void 0&&(le=0),K===void 0&&(K=0),P(G,j,L,H,q,$,ee,null,W,le,K)}function P(G,j,L,H,q,$,ee,W,le,K,pe){$===void 0&&($=1),le===void 0&&(le=0),K===void 0&&(K=0),pe===void 0&&(pe=0),O(ee);var se=[];r(L,function(ve,Z,oe,Ae){se.push(ve,Z,oe,Ae)}),se=new Float32Array(se),u(ee,function(ve){var Z=ve.gl,oe=ve.isWebGL2,Ae=ve.getExtension,Ee=ve.withProgram,Se=ve.withTexture,ke=ve.withTextureFramebuffer,ye=ve.handleContextLoss;if(Se("rawDistances",function(ge,Fe){(G!==ge._lastWidth||j!==ge._lastHeight)&&Z.texImage2D(Z.TEXTURE_2D,0,Z.RGBA,ge._lastWidth=G,ge._lastHeight=j,0,Z.RGBA,Z.UNSIGNED_BYTE,null),Ee("main",w,x,function(Me){var z=Me.setAttribute,D=Me.setUniform,U=!oe&&Ae("ANGLE_instanced_arrays"),J=!oe&&Ae("EXT_blend_minmax");z("aUV",2,Z.STATIC_DRAW,0,b),z("aLineSegment",4,Z.DYNAMIC_DRAW,1,se),D.apply(void 0,["4f","uGlyphBounds"].concat(H)),D("1f","uMaxDistance",q),D("1f","uExponent",$),ke(ge,Fe,function(be){Z.enable(Z.BLEND),Z.colorMask(!0,!0,!0,!0),Z.viewport(0,0,G,j),Z.scissor(0,0,G,j),Z.blendFunc(Z.ONE,Z.ONE),Z.blendEquationSeparate(Z.FUNC_ADD,oe?Z.MAX:J.MAX_EXT),Z.clear(Z.COLOR_BUFFER_BIT),oe?Z.drawArraysInstanced(Z.TRIANGLES,0,3,se.length/4):U.drawArraysInstancedANGLE(Z.TRIANGLES,0,3,se.length/4)})}),Ee("post",s,S,function(Me){Me.setAttribute("aUV",2,Z.STATIC_DRAW,0,b),Me.setUniform("1i","tex",Fe),Z.bindFramebuffer(Z.FRAMEBUFFER,W),Z.disable(Z.BLEND),Z.colorMask(pe===0,pe===1,pe===2,pe===3),Z.viewport(le,K,G,j),Z.scissor(le,K,G,j),Z.drawArrays(Z.TRIANGLES,0,3)})}),Z.isContextLost())throw ye(),new Error("webgl context lost")})}function F(G){var j=!G||G===E?T:G.canvas||G,L=I.get(j);if(L===void 0){M=!0;var H=null;try{var q=[97,106,97,61,99,137,118,80,80,118,137,99,61,97,106,97],$=R(4,4,"M8,8L16,8L24,24L16,24Z",[0,0,32,32],24,1,G);L=$&&q.length===$.length&&$.every(function(ee,W){return ee===q[W]}),L||(H="bad trial run results",console.info(q,$))}catch(ee){L=!1,H=ee.message}H&&console.warn("WebGL SDF generation not supported:",H),M=!1,I.set(j,L)}return L}var N=Object.freeze({__proto__:null,generate:R,generateIntoCanvas:k,generateIntoFramebuffer:P,isSupported:F});function Y(G,j,L,H,q,$){q===void 0&&(q=Math.max(H[2]-H[0],H[3]-H[1])/2),$===void 0&&($=1);try{return R.apply(N,arguments)}catch(ee){return console.info("WebGL SDF generation failed, falling back to JS",ee),p.apply(y,arguments)}}function _(G,j,L,H,q,$,ee,W,le,K){q===void 0&&(q=Math.max(H[2]-H[0],H[3]-H[1])/2),$===void 0&&($=1),W===void 0&&(W=0),le===void 0&&(le=0),K===void 0&&(K=0);try{return k.apply(N,arguments)}catch(pe){return console.info("WebGL SDF generation failed, falling back to JS",pe),m.apply(y,arguments)}}return e.forEachPathCommand=i,e.generate=Y,e.generateIntoCanvas=_,e.javascript=y,e.pathToLineSegments=r,e.webgl=N,e.webglUtils=f,Object.defineProperty(e,"__esModule",{value:!0}),e})({});return a}function NL(){var a=(function(e){var t={R:"13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",EN:"1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",ES:"17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",ET:"z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",AN:"16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",CS:"18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",B:"a,3,f+2,2v,690",S:"9,2,k",WS:"c,k,4f4,1vk+a,u,1j,335",ON:"x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",BN:"0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",NSM:"lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",AL:"16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",LRO:"6ct",RLO:"6cu",LRE:"6cq",RLE:"6cr",PDF:"6cs",LRI:"6ee",RLI:"6ef",FSI:"6eg",PDI:"6eh"},n={},i={};n.L=1,i[1]="L",Object.keys(t).forEach(function(ye,ge){n[ye]=1<<ge+1,i[n[ye]]=ye}),Object.freeze(n);var r=n.LRI|n.RLI|n.FSI,s=n.L|n.R|n.AL,o=n.B|n.S|n.WS|n.ON|n.FSI|n.LRI|n.RLI|n.PDI,l=n.BN|n.RLE|n.LRE|n.RLO|n.LRO|n.PDF,c=n.S|n.WS|n.B|r|n.PDI|l,u=null;function h(){if(!u){u=new Map;var ye=function(Fe){if(t.hasOwnProperty(Fe)){var Me=0;t[Fe].split(",").forEach(function(z){var D=z.split("+"),U=D[0],J=D[1];U=parseInt(U,36),J=J?parseInt(J,36):0,u.set(Me+=U,n[Fe]);for(var be=0;be<J;be++)u.set(++Me,n[Fe])})}};for(var ge in t)ye(ge)}}function d(ye){return h(),u.get(ye.codePointAt(0))||n.L}function f(ye){return i[d(ye)]}var p={pairs:"14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",canonical:"6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"};function m(ye,ge){var Fe=36,Me=0,z=new Map,D=ge&&new Map,U;return ye.split(",").forEach(function J(be){if(be.indexOf("+")!==-1)for(var we=+be;we--;)J(U);else{U=be;var Pe=be.split(">"),ie=Pe[0],We=Pe[1];ie=String.fromCodePoint(Me+=parseInt(ie,Fe)),We=String.fromCodePoint(Me+=parseInt(We,Fe)),z.set(ie,We),ge&&D.set(We,ie)}}),{map:z,reverseMap:D}}var g,v,y;function w(){if(!g){var ye=m(p.pairs,!0),ge=ye.map,Fe=ye.reverseMap;g=ge,v=Fe,y=m(p.canonical,!1).map}}function x(ye){return w(),g.get(ye)||null}function S(ye){return w(),v.get(ye)||null}function b(ye){return w(),y.get(ye)||null}var E=n.L,M=n.R,T=n.EN,I=n.ES,O=n.ET,R=n.AN,k=n.CS,P=n.B,F=n.S,N=n.ON,Y=n.BN,_=n.NSM,G=n.AL,j=n.LRO,L=n.RLO,H=n.LRE,q=n.RLE,$=n.PDF,ee=n.LRI,W=n.RLI,le=n.FSI,K=n.PDI;function pe(ye,ge){for(var Fe=125,Me=new Uint32Array(ye.length),z=0;z<ye.length;z++)Me[z]=d(ye[z]);var D=new Map;function U(Ii,nr){var Ri=Me[Ii];Me[Ii]=nr,D.set(Ri,D.get(Ri)-1),Ri&o&&D.set(o,D.get(o)-1),D.set(nr,(D.get(nr)||0)+1),nr&o&&D.set(o,(D.get(o)||0)+1)}for(var J=new Uint8Array(ye.length),be=new Map,we=[],Pe=null,ie=0;ie<ye.length;ie++)Pe||we.push(Pe={start:ie,end:ye.length-1,level:ge==="rtl"?1:ge==="ltr"?0:I0(ie,!1)}),Me[ie]&P&&(Pe.end=ie,Pe=null);for(var We=q|H|L|j|r|K|$|P,qe=function(Ii){return Ii+(Ii&1?1:2)},Je=function(Ii){return Ii+(Ii&1?2:1)},X=0;X<we.length;X++){Pe=we[X];var Ce=[{_level:Pe.level,_override:0,_isolate:0}],Te=void 0,Ye=0,Ne=0,Ze=0;D.clear();for(var Be=Pe.start;Be<=Pe.end;Be++){var ce=Me[Be];if(Te=Ce[Ce.length-1],D.set(ce,(D.get(ce)||0)+1),ce&o&&D.set(o,(D.get(o)||0)+1),ce&We)if(ce&(q|H)){J[Be]=Te._level;var _e=(ce===q?Je:qe)(Te._level);_e<=Fe&&!Ye&&!Ne?Ce.push({_level:_e,_override:0,_isolate:0}):Ye||Ne++}else if(ce&(L|j)){J[Be]=Te._level;var pt=(ce===L?Je:qe)(Te._level);pt<=Fe&&!Ye&&!Ne?Ce.push({_level:pt,_override:ce&L?M:E,_isolate:0}):Ye||Ne++}else if(ce&r){ce&le&&(ce=I0(Be+1,!0)===1?W:ee),J[Be]=Te._level,Te._override&&U(Be,Te._override);var At=(ce===W?Je:qe)(Te._level);At<=Fe&&Ye===0&&Ne===0?(Ze++,Ce.push({_level:At,_override:0,_isolate:1,_isolInitIndex:Be})):Ye++}else if(ce&K){if(Ye>0)Ye--;else if(Ze>0){for(Ne=0;!Ce[Ce.length-1]._isolate;)Ce.pop();var ht=Ce[Ce.length-1]._isolInitIndex;ht!=null&&(be.set(ht,Be),be.set(Be,ht)),Ce.pop(),Ze--}Te=Ce[Ce.length-1],J[Be]=Te._level,Te._override&&U(Be,Te._override)}else ce&$?(Ye===0&&(Ne>0?Ne--:!Te._isolate&&Ce.length>1&&(Ce.pop(),Te=Ce[Ce.length-1])),J[Be]=Te._level):ce&P&&(J[Be]=Pe.level);else J[Be]=Te._level,Te._override&&ce!==Y&&U(Be,Te._override)}for(var sn=[],Ut=null,mt=Pe.start;mt<=Pe.end;mt++){var Gt=Me[mt];if(!(Gt&l)){var Bn=J[mt],Ln=Gt&r,un=Gt===K;Ut&&Bn===Ut._level?(Ut._end=mt,Ut._endsWithIsolInit=Ln):sn.push(Ut={_start:mt,_end:mt,_level:Bn,_startsWithPDI:un,_endsWithIsolInit:Ln})}}for(var vi=[],V=0;V<sn.length;V++){var ue=sn[V];if(!ue._startsWithPDI||ue._startsWithPDI&&!be.has(ue._start)){for(var xe=[Ut=ue],me=void 0;Ut&&Ut._endsWithIsolInit&&(me=be.get(Ut._end))!=null;)for(var fe=V+1;fe<sn.length;fe++)if(sn[fe]._start===me){xe.push(Ut=sn[fe]);break}for(var it=[],ct=0;ct<xe.length;ct++)for(var C=xe[ct],B=C._start;B<=C._end;B++)it.push(B);for(var Q=J[it[0]],ne=Pe.level,de=it[0]-1;de>=0;de--)if(!(Me[de]&l)){ne=J[de];break}var he=it[it.length-1],Ue=J[he],Ge=Pe.level;if(!(Me[he]&r)){for(var Qe=he+1;Qe<=Pe.end;Qe++)if(!(Me[Qe]&l)){Ge=J[Qe];break}}vi.push({_seqIndices:it,_sosType:Math.max(ne,Q)%2?M:E,_eosType:Math.max(Ge,Ue)%2?M:E})}}for(var Le=0;Le<vi.length;Le++){var Oe=vi[Le],Re=Oe._seqIndices,Xe=Oe._sosType,rt=Oe._eosType,ot=J[Re[0]]&1?M:E;if(D.get(_))for(var $e=0;$e<Re.length;$e++){var st=Re[$e];if(Me[st]&_){for(var at=Xe,Ot=$e-1;Ot>=0;Ot--)if(!(Me[Re[Ot]]&l)){at=Me[Re[Ot]];break}U(st,at&(r|K)?N:at)}}if(D.get(T))for(var Vt=0;Vt<Re.length;Vt++){var Xt=Re[Vt];if(Me[Xt]&T)for(var jt=Vt-1;jt>=-1;jt--){var Rt=jt===-1?Xe:Me[Re[jt]];if(Rt&s){Rt===G&&U(Xt,R);break}}}if(D.get(G))for(var hn=0;hn<Re.length;hn++){var yi=Re[hn];Me[yi]&G&&U(yi,M)}if(D.get(I)||D.get(k))for(var an=1;an<Re.length-1;an++){var Bt=Re[an];if(Me[Bt]&(I|k)){for(var Lt=0,Di=0,Kr=an-1;Kr>=0&&(Lt=Me[Re[Kr]],!!(Lt&l));Kr--);for(var Ci=an+1;Ci<Re.length&&(Di=Me[Re[Ci]],!!(Di&l));Ci++);Lt===Di&&(Me[Bt]===I?Lt===T:Lt&(T|R))&&U(Bt,Lt)}}if(D.get(T))for(var xi=0;xi<Re.length;xi++){var zb=Re[xi];if(Me[zb]&T){for(var $u=xi-1;$u>=0&&Me[Re[$u]]&(O|l);$u--)U(Re[$u],T);for(xi++;xi<Re.length&&Me[Re[xi]]&(O|l|T);xi++)Me[Re[xi]]!==T&&U(Re[xi],T)}}if(D.get(O)||D.get(I)||D.get(k))for(var Nl=0;Nl<Re.length;Nl++){var m0=Re[Nl];if(Me[m0]&(O|I|k)){U(m0,N);for(var eh=Nl-1;eh>=0&&Me[Re[eh]]&l;eh--)U(Re[eh],N);for(var th=Nl+1;th<Re.length&&Me[Re[th]]&l;th++)U(Re[th],N)}}if(D.get(T))for(var _f=0,g0=Xe;_f<Re.length;_f++){var v0=Re[_f],$f=Me[v0];$f&T?g0===E&&U(v0,E):$f&s&&(g0=$f)}if(D.get(o)){var kl=M|T|R,y0=kl|E,nh=[];{for(var wo=[],Ao=0;Ao<Re.length;Ao++)if(Me[Re[Ao]]&o){var Ul=ye[Re[Ao]],x0=void 0;if(x(Ul)!==null)if(wo.length<63)wo.push({char:Ul,seqIndex:Ao});else break;else if((x0=S(Ul))!==null)for(var Fl=wo.length-1;Fl>=0;Fl--){var ep=wo[Fl].char;if(ep===x0||ep===S(b(Ul))||x(b(ep))===Ul){nh.push([wo[Fl].seqIndex,Ao]),wo.length=Fl;break}}}nh.sort(function(Ii,nr){return Ii[0]-nr[0]})}for(var tp=0;tp<nh.length;tp++){for(var w0=nh[tp],ih=w0[0],np=w0[1],A0=!1,tr=0,ip=ih+1;ip<np;ip++){var S0=Re[ip];if(Me[S0]&y0){A0=!0;var M0=Me[S0]&kl?M:E;if(M0===ot){tr=M0;break}}}if(A0&&!tr){tr=Xe;for(var rp=ih-1;rp>=0;rp--){var b0=Re[rp];if(Me[b0]&y0){var E0=Me[b0]&kl?M:E;E0!==ot?tr=E0:tr=ot;break}}}if(tr){if(Me[Re[ih]]=Me[Re[np]]=tr,tr!==ot){for(var Hl=ih+1;Hl<Re.length;Hl++)if(!(Me[Re[Hl]]&l)){d(ye[Re[Hl]])&_&&(Me[Re[Hl]]=tr);break}}if(tr!==ot){for(var Gl=np+1;Gl<Re.length;Gl++)if(!(Me[Re[Gl]]&l)){d(ye[Re[Gl]])&_&&(Me[Re[Gl]]=tr);break}}}}for(var Is=0;Is<Re.length;Is++)if(Me[Re[Is]]&o){for(var T0=Is,sp=Is,ap=Xe,Vl=Is-1;Vl>=0;Vl--)if(Me[Re[Vl]]&l)T0=Vl;else{ap=Me[Re[Vl]]&kl?M:E;break}for(var C0=rt,jl=Is+1;jl<Re.length;jl++)if(Me[Re[jl]]&(o|l))sp=jl;else{C0=Me[Re[jl]]&kl?M:E;break}for(var op=T0;op<=sp;op++)Me[Re[op]]=ap===C0?ap:ot;Is=sp}}}for(var Oi=Pe.start;Oi<=Pe.end;Oi++){var Nb=J[Oi],rh=Me[Oi];if(Nb&1?rh&(E|T|R)&&J[Oi]++:rh&M?J[Oi]++:rh&(R|T)&&(J[Oi]+=2),rh&l&&(J[Oi]=Oi===0?Pe.level:J[Oi-1]),Oi===Pe.end||d(ye[Oi])&(F|P))for(var sh=Oi;sh>=0&&d(ye[sh])&c;sh--)J[sh]=Pe.level}}return{levels:J,paragraphs:we};function I0(Ii,nr){for(var Ri=Ii;Ri<ye.length;Ri++){var Rs=Me[Ri];if(Rs&(M|G))return 1;if(Rs&(P|E)||nr&&Rs===K)return 0;if(Rs&r){var R0=kb(Ri);Ri=R0===-1?ye.length:R0}}return 0}function kb(Ii){for(var nr=1,Ri=Ii+1;Ri<ye.length;Ri++){var Rs=Me[Ri];if(Rs&P)break;if(Rs&K){if(--nr===0)return Ri}else Rs&r&&nr++}return-1}}var se="14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1",ve;function Z(){if(!ve){var ye=m(se,!0),ge=ye.map,Fe=ye.reverseMap;Fe.forEach(function(Me,z){ge.set(z,Me)}),ve=ge}}function oe(ye){return Z(),ve.get(ye)||null}function Ae(ye,ge,Fe,Me){var z=ye.length;Fe=Math.max(0,Fe==null?0:+Fe),Me=Math.min(z-1,Me==null?z-1:+Me);for(var D=new Map,U=Fe;U<=Me;U++)if(ge[U]&1){var J=oe(ye[U]);J!==null&&D.set(U,J)}return D}function Ee(ye,ge,Fe,Me){var z=ye.length;Fe=Math.max(0,Fe==null?0:+Fe),Me=Math.min(z-1,Me==null?z-1:+Me);var D=[];return ge.paragraphs.forEach(function(U){var J=Math.max(Fe,U.start),be=Math.min(Me,U.end);if(J<be){for(var we=ge.levels.slice(J,be+1),Pe=be;Pe>=J&&d(ye[Pe])&c;Pe--)we[Pe]=U.level;for(var ie=U.level,We=1/0,qe=0;qe<we.length;qe++){var Je=we[qe];Je>ie&&(ie=Je),Je<We&&(We=Je|1)}for(var X=ie;X>=We;X--)for(var Ce=0;Ce<we.length;Ce++)if(we[Ce]>=X){for(var Te=Ce;Ce+1<we.length&&we[Ce+1]>=X;)Ce++;Ce>Te&&D.push([Te+J,Ce+J])}}}),D}function Se(ye,ge,Fe,Me){var z=ke(ye,ge,Fe,Me),D=[].concat(ye);return z.forEach(function(U,J){D[J]=(ge.levels[U]&1?oe(ye[U]):null)||ye[U]}),D.join("")}function ke(ye,ge,Fe,Me){for(var z=Ee(ye,ge,Fe,Me),D=[],U=0;U<ye.length;U++)D[U]=U;return z.forEach(function(J){for(var be=J[0],we=J[1],Pe=D.slice(be,we+1),ie=Pe.length;ie--;)D[we-ie]=Pe[ie]}),D}return e.closingToOpeningBracket=S,e.getBidiCharType=d,e.getBidiCharTypeName=f,e.getCanonicalBracket=b,e.getEmbeddingLevels=pe,e.getMirroredCharacter=oe,e.getMirroredCharactersMap=Ae,e.getReorderSegments=Ee,e.getReorderedIndices=ke,e.getReorderedString=Se,e.openingToClosingBracket=x,Object.defineProperty(e,"__esModule",{value:!0}),e})({});return a}function kL(){return typeof window>"u"&&(self.window=self),(function(a){var e={parse:function(i){var r=e._bin,s=new Uint8Array(i);if(r.readASCII(s,0,4)=="ttcf"){var o=4;r.readUshort(s,o),o+=2,r.readUshort(s,o),o+=2;var l=r.readUint(s,o);o+=4;for(var c=[],u=0;u<l;u++){var h=r.readUint(s,o);o+=4,c.push(e._readFont(s,h))}return c}return[e._readFont(s,0)]},_readFont:function(i,r){var s=e._bin,o=r;s.readFixed(i,r),r+=4;var l=s.readUshort(i,r);r+=2,s.readUshort(i,r),r+=2,s.readUshort(i,r),r+=2,s.readUshort(i,r),r+=2;for(var c=["cmap","head","hhea","maxp","hmtx","name","OS/2","post","loca","glyf","kern","CFF ","GDEF","GPOS","GSUB","SVG "],u={_data:i,_offset:o},h={},d=0;d<l;d++){var f=s.readASCII(i,r,4);r+=4,s.readUint(i,r),r+=4;var p=s.readUint(i,r);r+=4;var m=s.readUint(i,r);r+=4,h[f]={offset:p,length:m}}for(d=0;d<c.length;d++){var g=c[d];h[g]&&(u[g.trim()]=e[g.trim()].parse(i,h[g].offset,h[g].length,u))}return u},_tabOffset:function(i,r,s){for(var o=e._bin,l=o.readUshort(i,s+4),c=s+12,u=0;u<l;u++){var h=o.readASCII(i,c,4);c+=4,o.readUint(i,c),c+=4;var d=o.readUint(i,c);if(c+=4,o.readUint(i,c),c+=4,h==r)return d}return 0}};e._bin={readFixed:function(i,r){return(i[r]<<8|i[r+1])+(i[r+2]<<8|i[r+3])/65540},readF2dot14:function(i,r){return e._bin.readShort(i,r)/16384},readInt:function(i,r){return e._bin._view(i).getInt32(r)},readInt8:function(i,r){return e._bin._view(i).getInt8(r)},readShort:function(i,r){return e._bin._view(i).getInt16(r)},readUshort:function(i,r){return e._bin._view(i).getUint16(r)},readUshorts:function(i,r,s){for(var o=[],l=0;l<s;l++)o.push(e._bin.readUshort(i,r+2*l));return o},readUint:function(i,r){return e._bin._view(i).getUint32(r)},readUint64:function(i,r){return 4294967296*e._bin.readUint(i,r)+e._bin.readUint(i,r+4)},readASCII:function(i,r,s){for(var o="",l=0;l<s;l++)o+=String.fromCharCode(i[r+l]);return o},readUnicode:function(i,r,s){for(var o="",l=0;l<s;l++){var c=i[r++]<<8|i[r++];o+=String.fromCharCode(c)}return o},_tdec:typeof window<"u"&&window.TextDecoder?new window.TextDecoder:null,readUTF8:function(i,r,s){var o=e._bin._tdec;return o&&r==0&&s==i.length?o.decode(i):e._bin.readASCII(i,r,s)},readBytes:function(i,r,s){for(var o=[],l=0;l<s;l++)o.push(i[r+l]);return o},readASCIIArray:function(i,r,s){for(var o=[],l=0;l<s;l++)o.push(String.fromCharCode(i[r+l]));return o},_view:function(i){return i._dataView||(i._dataView=i.buffer?new DataView(i.buffer,i.byteOffset,i.byteLength):new DataView(new Uint8Array(i).buffer))}},e._lctf={},e._lctf.parse=function(i,r,s,o,l){var c=e._bin,u={},h=r;c.readFixed(i,r),r+=4;var d=c.readUshort(i,r);r+=2;var f=c.readUshort(i,r);r+=2;var p=c.readUshort(i,r);return r+=2,u.scriptList=e._lctf.readScriptList(i,h+d),u.featureList=e._lctf.readFeatureList(i,h+f),u.lookupList=e._lctf.readLookupList(i,h+p,l),u},e._lctf.readLookupList=function(i,r,s){var o=e._bin,l=r,c=[],u=o.readUshort(i,r);r+=2;for(var h=0;h<u;h++){var d=o.readUshort(i,r);r+=2;var f=e._lctf.readLookupTable(i,l+d,s);c.push(f)}return c},e._lctf.readLookupTable=function(i,r,s){var o=e._bin,l=r,c={tabs:[]};c.ltype=o.readUshort(i,r),r+=2,c.flag=o.readUshort(i,r),r+=2;var u=o.readUshort(i,r);r+=2;for(var h=c.ltype,d=0;d<u;d++){var f=o.readUshort(i,r);r+=2;var p=s(i,h,l+f,c);c.tabs.push(p)}return c},e._lctf.numOfOnes=function(i){for(var r=0,s=0;s<32;s++)(i>>>s&1)!=0&&r++;return r},e._lctf.readClassDef=function(i,r){var s=e._bin,o=[],l=s.readUshort(i,r);if(r+=2,l==1){var c=s.readUshort(i,r);r+=2;var u=s.readUshort(i,r);r+=2;for(var h=0;h<u;h++)o.push(c+h),o.push(c+h),o.push(s.readUshort(i,r)),r+=2}if(l==2){var d=s.readUshort(i,r);for(r+=2,h=0;h<d;h++)o.push(s.readUshort(i,r)),r+=2,o.push(s.readUshort(i,r)),r+=2,o.push(s.readUshort(i,r)),r+=2}return o},e._lctf.getInterval=function(i,r){for(var s=0;s<i.length;s+=3){var o=i[s],l=i[s+1];if(i[s+2],o<=r&&r<=l)return s}return-1},e._lctf.readCoverage=function(i,r){var s=e._bin,o={};o.fmt=s.readUshort(i,r),r+=2;var l=s.readUshort(i,r);return r+=2,o.fmt==1&&(o.tab=s.readUshorts(i,r,l)),o.fmt==2&&(o.tab=s.readUshorts(i,r,3*l)),o},e._lctf.coverageIndex=function(i,r){var s=i.tab;if(i.fmt==1)return s.indexOf(r);if(i.fmt==2){var o=e._lctf.getInterval(s,r);if(o!=-1)return s[o+2]+(r-s[o])}return-1},e._lctf.readFeatureList=function(i,r){var s=e._bin,o=r,l=[],c=s.readUshort(i,r);r+=2;for(var u=0;u<c;u++){var h=s.readASCII(i,r,4);r+=4;var d=s.readUshort(i,r);r+=2;var f=e._lctf.readFeatureTable(i,o+d);f.tag=h.trim(),l.push(f)}return l},e._lctf.readFeatureTable=function(i,r){var s=e._bin,o=r,l={},c=s.readUshort(i,r);r+=2,c>0&&(l.featureParams=o+c);var u=s.readUshort(i,r);r+=2,l.tab=[];for(var h=0;h<u;h++)l.tab.push(s.readUshort(i,r+2*h));return l},e._lctf.readScriptList=function(i,r){var s=e._bin,o=r,l={},c=s.readUshort(i,r);r+=2;for(var u=0;u<c;u++){var h=s.readASCII(i,r,4);r+=4;var d=s.readUshort(i,r);r+=2,l[h.trim()]=e._lctf.readScriptTable(i,o+d)}return l},e._lctf.readScriptTable=function(i,r){var s=e._bin,o=r,l={},c=s.readUshort(i,r);r+=2,c>0&&(l.default=e._lctf.readLangSysTable(i,o+c));var u=s.readUshort(i,r);r+=2;for(var h=0;h<u;h++){var d=s.readASCII(i,r,4);r+=4;var f=s.readUshort(i,r);r+=2,l[d.trim()]=e._lctf.readLangSysTable(i,o+f)}return l},e._lctf.readLangSysTable=function(i,r){var s=e._bin,o={};s.readUshort(i,r),r+=2,o.reqFeature=s.readUshort(i,r),r+=2;var l=s.readUshort(i,r);return r+=2,o.features=s.readUshorts(i,r,l),o},e.CFF={},e.CFF.parse=function(i,r,s){var o=e._bin;(i=new Uint8Array(i.buffer,r,s))[r=0],i[++r],i[++r],i[++r],r++;var l=[];r=e.CFF.readIndex(i,r,l);for(var c=[],u=0;u<l.length-1;u++)c.push(o.readASCII(i,r+l[u],l[u+1]-l[u]));r+=l[l.length-1];var h=[];r=e.CFF.readIndex(i,r,h);var d=[];for(u=0;u<h.length-1;u++)d.push(e.CFF.readDict(i,r+h[u],r+h[u+1]));r+=h[h.length-1];var f=d[0],p=[];r=e.CFF.readIndex(i,r,p);var m=[];for(u=0;u<p.length-1;u++)m.push(o.readASCII(i,r+p[u],p[u+1]-p[u]));if(r+=p[p.length-1],e.CFF.readSubrs(i,r,f),f.CharStrings){r=f.CharStrings,p=[],r=e.CFF.readIndex(i,r,p);var g=[];for(u=0;u<p.length-1;u++)g.push(o.readBytes(i,r+p[u],p[u+1]-p[u]));f.CharStrings=g}if(f.ROS){r=f.FDArray;var v=[];for(r=e.CFF.readIndex(i,r,v),f.FDArray=[],u=0;u<v.length-1;u++){var y=e.CFF.readDict(i,r+v[u],r+v[u+1]);e.CFF._readFDict(i,y,m),f.FDArray.push(y)}r+=v[v.length-1],r=f.FDSelect,f.FDSelect=[];var w=i[r];if(r++,w!=3)throw w;var x=o.readUshort(i,r);for(r+=2,u=0;u<x+1;u++)f.FDSelect.push(o.readUshort(i,r),i[r+2]),r+=3}return f.Encoding&&(f.Encoding=e.CFF.readEncoding(i,f.Encoding,f.CharStrings.length)),f.charset&&(f.charset=e.CFF.readCharset(i,f.charset,f.CharStrings.length)),e.CFF._readFDict(i,f,m),f},e.CFF._readFDict=function(i,r,s){var o;for(var l in r.Private&&(o=r.Private[1],r.Private=e.CFF.readDict(i,o,o+r.Private[0]),r.Private.Subrs&&e.CFF.readSubrs(i,o+r.Private.Subrs,r.Private)),r)["FamilyName","FontName","FullName","Notice","version","Copyright"].indexOf(l)!=-1&&(r[l]=s[r[l]-426+35])},e.CFF.readSubrs=function(i,r,s){var o=e._bin,l=[];r=e.CFF.readIndex(i,r,l);var c,u=l.length;c=u<1240?107:u<33900?1131:32768,s.Bias=c,s.Subrs=[];for(var h=0;h<l.length-1;h++)s.Subrs.push(o.readBytes(i,r+l[h],l[h+1]-l[h]))},e.CFF.tableSE=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,0,111,112,113,114,0,115,116,117,118,119,120,121,122,0,123,0,124,125,126,127,128,129,130,131,0,132,133,0,134,135,136,137,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,138,0,139,0,0,0,0,140,141,142,143,0,0,0,0,0,144,0,0,0,145,0,0,146,147,148,149,0,0,0,0],e.CFF.glyphByUnicode=function(i,r){for(var s=0;s<i.charset.length;s++)if(i.charset[s]==r)return s;return-1},e.CFF.glyphBySE=function(i,r){return r<0||r>255?-1:e.CFF.glyphByUnicode(i,e.CFF.tableSE[r])},e.CFF.readEncoding=function(i,r,s){e._bin;var o=[".notdef"],l=i[r];if(r++,l!=0)throw"error: unknown encoding format: "+l;var c=i[r];r++;for(var u=0;u<c;u++)o.push(i[r+u]);return o},e.CFF.readCharset=function(i,r,s){var o=e._bin,l=[".notdef"],c=i[r];if(r++,c==0)for(var u=0;u<s;u++){var h=o.readUshort(i,r);r+=2,l.push(h)}else{if(c!=1&&c!=2)throw"error: format: "+c;for(;l.length<s;){h=o.readUshort(i,r),r+=2;var d=0;for(c==1?(d=i[r],r++):(d=o.readUshort(i,r),r+=2),u=0;u<=d;u++)l.push(h),h++}}return l},e.CFF.readIndex=function(i,r,s){var o=e._bin,l=o.readUshort(i,r)+1,c=i[r+=2];if(r++,c==1)for(var u=0;u<l;u++)s.push(i[r+u]);else if(c==2)for(u=0;u<l;u++)s.push(o.readUshort(i,r+2*u));else if(c==3)for(u=0;u<l;u++)s.push(16777215&o.readUint(i,r+3*u-1));else if(l!=1)throw"unsupported offset size: "+c+", count: "+l;return(r+=l*c)-1},e.CFF.getCharString=function(i,r,s){var o=e._bin,l=i[r],c=i[r+1];i[r+2],i[r+3],i[r+4];var u=1,h=null,d=null;l<=20&&(h=l,u=1),l==12&&(h=100*l+c,u=2),21<=l&&l<=27&&(h=l,u=1),l==28&&(d=o.readShort(i,r+1),u=3),29<=l&&l<=31&&(h=l,u=1),32<=l&&l<=246&&(d=l-139,u=1),247<=l&&l<=250&&(d=256*(l-247)+c+108,u=2),251<=l&&l<=254&&(d=256*-(l-251)-c-108,u=2),l==255&&(d=o.readInt(i,r+1)/65535,u=5),s.val=d??"o"+h,s.size=u},e.CFF.readCharString=function(i,r,s){for(var o=r+s,l=e._bin,c=[];r<o;){var u=i[r],h=i[r+1];i[r+2],i[r+3],i[r+4];var d=1,f=null,p=null;u<=20&&(f=u,d=1),u==12&&(f=100*u+h,d=2),u!=19&&u!=20||(f=u,d=2),21<=u&&u<=27&&(f=u,d=1),u==28&&(p=l.readShort(i,r+1),d=3),29<=u&&u<=31&&(f=u,d=1),32<=u&&u<=246&&(p=u-139,d=1),247<=u&&u<=250&&(p=256*(u-247)+h+108,d=2),251<=u&&u<=254&&(p=256*-(u-251)-h-108,d=2),u==255&&(p=l.readInt(i,r+1)/65535,d=5),c.push(p??"o"+f),r+=d}return c},e.CFF.readDict=function(i,r,s){for(var o=e._bin,l={},c=[];r<s;){var u=i[r],h=i[r+1];i[r+2],i[r+3],i[r+4];var d=1,f=null,p=null;if(u==28&&(p=o.readShort(i,r+1),d=3),u==29&&(p=o.readInt(i,r+1),d=5),32<=u&&u<=246&&(p=u-139,d=1),247<=u&&u<=250&&(p=256*(u-247)+h+108,d=2),251<=u&&u<=254&&(p=256*-(u-251)-h-108,d=2),u==255)throw p=o.readInt(i,r+1)/65535,d=5,"unknown number";if(u==30){var m=[];for(d=1;;){var g=i[r+d];d++;var v=g>>4,y=15&g;if(v!=15&&m.push(v),y!=15&&m.push(y),y==15)break}for(var w="",x=[0,1,2,3,4,5,6,7,8,9,".","e","e-","reserved","-","endOfNumber"],S=0;S<m.length;S++)w+=x[m[S]];p=parseFloat(w)}u<=21&&(f=["version","Notice","FullName","FamilyName","Weight","FontBBox","BlueValues","OtherBlues","FamilyBlues","FamilyOtherBlues","StdHW","StdVW","escape","UniqueID","XUID","charset","Encoding","CharStrings","Private","Subrs","defaultWidthX","nominalWidthX"][u],d=1,u==12&&(f=["Copyright","isFixedPitch","ItalicAngle","UnderlinePosition","UnderlineThickness","PaintType","CharstringType","FontMatrix","StrokeWidth","BlueScale","BlueShift","BlueFuzz","StemSnapH","StemSnapV","ForceBold",0,0,"LanguageGroup","ExpansionFactor","initialRandomSeed","SyntheticBase","PostScript","BaseFontName","BaseFontBlend",0,0,0,0,0,0,"ROS","CIDFontVersion","CIDFontRevision","CIDFontType","CIDCount","UIDBase","FDArray","FDSelect","FontName"][h],d=2)),f!=null?(l[f]=c.length==1?c[0]:c,c=[]):c.push(p),r+=d}return l},e.cmap={},e.cmap.parse=function(i,r,s){i=new Uint8Array(i.buffer,r,s),r=0;var o=e._bin,l={};o.readUshort(i,r),r+=2;var c=o.readUshort(i,r);r+=2;var u=[];l.tables=[];for(var h=0;h<c;h++){var d=o.readUshort(i,r);r+=2;var f=o.readUshort(i,r);r+=2;var p=o.readUint(i,r);r+=4;var m="p"+d+"e"+f,g=u.indexOf(p);if(g==-1){var v;g=l.tables.length,u.push(p);var y=o.readUshort(i,p);y==0?v=e.cmap.parse0(i,p):y==4?v=e.cmap.parse4(i,p):y==6?v=e.cmap.parse6(i,p):y==12?v=e.cmap.parse12(i,p):console.debug("unknown format: "+y,d,f,p),l.tables.push(v)}if(l[m]!=null)throw"multiple tables for one platform+encoding";l[m]=g}return l},e.cmap.parse0=function(i,r){var s=e._bin,o={};o.format=s.readUshort(i,r),r+=2;var l=s.readUshort(i,r);r+=2,s.readUshort(i,r),r+=2,o.map=[];for(var c=0;c<l-6;c++)o.map.push(i[r+c]);return o},e.cmap.parse4=function(i,r){var s=e._bin,o=r,l={};l.format=s.readUshort(i,r),r+=2;var c=s.readUshort(i,r);r+=2,s.readUshort(i,r),r+=2;var u=s.readUshort(i,r);r+=2;var h=u/2;l.searchRange=s.readUshort(i,r),r+=2,l.entrySelector=s.readUshort(i,r),r+=2,l.rangeShift=s.readUshort(i,r),r+=2,l.endCount=s.readUshorts(i,r,h),r+=2*h,r+=2,l.startCount=s.readUshorts(i,r,h),r+=2*h,l.idDelta=[];for(var d=0;d<h;d++)l.idDelta.push(s.readShort(i,r)),r+=2;for(l.idRangeOffset=s.readUshorts(i,r,h),r+=2*h,l.glyphIdArray=[];r<o+c;)l.glyphIdArray.push(s.readUshort(i,r)),r+=2;return l},e.cmap.parse6=function(i,r){var s=e._bin,o={};o.format=s.readUshort(i,r),r+=2,s.readUshort(i,r),r+=2,s.readUshort(i,r),r+=2,o.firstCode=s.readUshort(i,r),r+=2;var l=s.readUshort(i,r);r+=2,o.glyphIdArray=[];for(var c=0;c<l;c++)o.glyphIdArray.push(s.readUshort(i,r)),r+=2;return o},e.cmap.parse12=function(i,r){var s=e._bin,o={};o.format=s.readUshort(i,r),r+=2,r+=2,s.readUint(i,r),r+=4,s.readUint(i,r),r+=4;var l=s.readUint(i,r);r+=4,o.groups=[];for(var c=0;c<l;c++){var u=r+12*c,h=s.readUint(i,u+0),d=s.readUint(i,u+4),f=s.readUint(i,u+8);o.groups.push([h,d,f])}return o},e.glyf={},e.glyf.parse=function(i,r,s,o){for(var l=[],c=0;c<o.maxp.numGlyphs;c++)l.push(null);return l},e.glyf._parseGlyf=function(i,r){var s=e._bin,o=i._data,l=e._tabOffset(o,"glyf",i._offset)+i.loca[r];if(i.loca[r]==i.loca[r+1])return null;var c={};if(c.noc=s.readShort(o,l),l+=2,c.xMin=s.readShort(o,l),l+=2,c.yMin=s.readShort(o,l),l+=2,c.xMax=s.readShort(o,l),l+=2,c.yMax=s.readShort(o,l),l+=2,c.xMin>=c.xMax||c.yMin>=c.yMax)return null;if(c.noc>0){c.endPts=[];for(var u=0;u<c.noc;u++)c.endPts.push(s.readUshort(o,l)),l+=2;var h=s.readUshort(o,l);if(l+=2,o.length-l<h)return null;c.instructions=s.readBytes(o,l,h),l+=h;var d=c.endPts[c.noc-1]+1;for(c.flags=[],u=0;u<d;u++){var f=o[l];if(l++,c.flags.push(f),(8&f)!=0){var p=o[l];l++;for(var m=0;m<p;m++)c.flags.push(f),u++}}for(c.xs=[],u=0;u<d;u++){var g=(2&c.flags[u])!=0,v=(16&c.flags[u])!=0;g?(c.xs.push(v?o[l]:-o[l]),l++):v?c.xs.push(0):(c.xs.push(s.readShort(o,l)),l+=2)}for(c.ys=[],u=0;u<d;u++)g=(4&c.flags[u])!=0,v=(32&c.flags[u])!=0,g?(c.ys.push(v?o[l]:-o[l]),l++):v?c.ys.push(0):(c.ys.push(s.readShort(o,l)),l+=2);var y=0,w=0;for(u=0;u<d;u++)y+=c.xs[u],w+=c.ys[u],c.xs[u]=y,c.ys[u]=w}else{var x;c.parts=[];do{x=s.readUshort(o,l),l+=2;var S={m:{a:1,b:0,c:0,d:1,tx:0,ty:0},p1:-1,p2:-1};if(c.parts.push(S),S.glyphIndex=s.readUshort(o,l),l+=2,1&x){var b=s.readShort(o,l);l+=2;var E=s.readShort(o,l);l+=2}else b=s.readInt8(o,l),l++,E=s.readInt8(o,l),l++;2&x?(S.m.tx=b,S.m.ty=E):(S.p1=b,S.p2=E),8&x?(S.m.a=S.m.d=s.readF2dot14(o,l),l+=2):64&x?(S.m.a=s.readF2dot14(o,l),l+=2,S.m.d=s.readF2dot14(o,l),l+=2):128&x&&(S.m.a=s.readF2dot14(o,l),l+=2,S.m.b=s.readF2dot14(o,l),l+=2,S.m.c=s.readF2dot14(o,l),l+=2,S.m.d=s.readF2dot14(o,l),l+=2)}while(32&x);if(256&x){var M=s.readUshort(o,l);for(l+=2,c.instr=[],u=0;u<M;u++)c.instr.push(o[l]),l++}}return c},e.GDEF={},e.GDEF.parse=function(i,r,s,o){var l=r;r+=4;var c=e._bin.readUshort(i,r);return{glyphClassDef:c===0?null:e._lctf.readClassDef(i,l+c)}},e.GPOS={},e.GPOS.parse=function(i,r,s,o){return e._lctf.parse(i,r,s,o,e.GPOS.subt)},e.GPOS.subt=function(i,r,s,o){var l=e._bin,c=s,u={};if(u.fmt=l.readUshort(i,s),s+=2,r==1||r==2||r==3||r==7||r==8&&u.fmt<=2){var h=l.readUshort(i,s);s+=2,u.coverage=e._lctf.readCoverage(i,h+c)}if(r==1&&u.fmt==1){var d=l.readUshort(i,s);s+=2,d!=0&&(u.pos=e.GPOS.readValueRecord(i,s,d))}else if(r==2&&u.fmt>=1&&u.fmt<=2){d=l.readUshort(i,s),s+=2;var f=l.readUshort(i,s);s+=2;var p=e._lctf.numOfOnes(d),m=e._lctf.numOfOnes(f);if(u.fmt==1){u.pairsets=[];var g=l.readUshort(i,s);s+=2;for(var v=0;v<g;v++){var y=c+l.readUshort(i,s);s+=2;var w=l.readUshort(i,y);y+=2;for(var x=[],S=0;S<w;S++){var b=l.readUshort(i,y);y+=2,d!=0&&(R=e.GPOS.readValueRecord(i,y,d),y+=2*p),f!=0&&(k=e.GPOS.readValueRecord(i,y,f),y+=2*m),x.push({gid2:b,val1:R,val2:k})}u.pairsets.push(x)}}if(u.fmt==2){var E=l.readUshort(i,s);s+=2;var M=l.readUshort(i,s);s+=2;var T=l.readUshort(i,s);s+=2;var I=l.readUshort(i,s);for(s+=2,u.classDef1=e._lctf.readClassDef(i,c+E),u.classDef2=e._lctf.readClassDef(i,c+M),u.matrix=[],v=0;v<T;v++){var O=[];for(S=0;S<I;S++){var R=null,k=null;d!=0&&(R=e.GPOS.readValueRecord(i,s,d),s+=2*p),f!=0&&(k=e.GPOS.readValueRecord(i,s,f),s+=2*m),O.push({val1:R,val2:k})}u.matrix.push(O)}}}else if(r==4&&u.fmt==1)u.markCoverage=e._lctf.readCoverage(i,l.readUshort(i,s)+c),u.baseCoverage=e._lctf.readCoverage(i,l.readUshort(i,s+2)+c),u.markClassCount=l.readUshort(i,s+4),u.markArray=e.GPOS.readMarkArray(i,l.readUshort(i,s+6)+c),u.baseArray=e.GPOS.readBaseArray(i,l.readUshort(i,s+8)+c,u.markClassCount);else if(r==6&&u.fmt==1)u.mark1Coverage=e._lctf.readCoverage(i,l.readUshort(i,s)+c),u.mark2Coverage=e._lctf.readCoverage(i,l.readUshort(i,s+2)+c),u.markClassCount=l.readUshort(i,s+4),u.mark1Array=e.GPOS.readMarkArray(i,l.readUshort(i,s+6)+c),u.mark2Array=e.GPOS.readBaseArray(i,l.readUshort(i,s+8)+c,u.markClassCount);else{if(r==9&&u.fmt==1){var P=l.readUshort(i,s);s+=2;var F=l.readUint(i,s);if(s+=4,o.ltype==9)o.ltype=P;else if(o.ltype!=P)throw"invalid extension substitution";return e.GPOS.subt(i,o.ltype,c+F)}console.debug("unsupported GPOS table LookupType",r,"format",u.fmt)}return u},e.GPOS.readValueRecord=function(i,r,s){var o=e._bin,l=[];return l.push(1&s?o.readShort(i,r):0),r+=1&s?2:0,l.push(2&s?o.readShort(i,r):0),r+=2&s?2:0,l.push(4&s?o.readShort(i,r):0),r+=4&s?2:0,l.push(8&s?o.readShort(i,r):0),r+=8&s?2:0,l},e.GPOS.readBaseArray=function(i,r,s){var o=e._bin,l=[],c=r,u=o.readUshort(i,r);r+=2;for(var h=0;h<u;h++){for(var d=[],f=0;f<s;f++)d.push(e.GPOS.readAnchorRecord(i,c+o.readUshort(i,r))),r+=2;l.push(d)}return l},e.GPOS.readMarkArray=function(i,r){var s=e._bin,o=[],l=r,c=s.readUshort(i,r);r+=2;for(var u=0;u<c;u++){var h=e.GPOS.readAnchorRecord(i,s.readUshort(i,r+2)+l);h.markClass=s.readUshort(i,r),o.push(h),r+=4}return o},e.GPOS.readAnchorRecord=function(i,r){var s=e._bin,o={};return o.fmt=s.readUshort(i,r),o.x=s.readShort(i,r+2),o.y=s.readShort(i,r+4),o},e.GSUB={},e.GSUB.parse=function(i,r,s,o){return e._lctf.parse(i,r,s,o,e.GSUB.subt)},e.GSUB.subt=function(i,r,s,o){var l=e._bin,c=s,u={};if(u.fmt=l.readUshort(i,s),s+=2,r!=1&&r!=2&&r!=4&&r!=5&&r!=6)return null;if(r==1||r==2||r==4||r==5&&u.fmt<=2||r==6&&u.fmt<=2){var h=l.readUshort(i,s);s+=2,u.coverage=e._lctf.readCoverage(i,c+h)}if(r==1&&u.fmt>=1&&u.fmt<=2){if(u.fmt==1)u.delta=l.readShort(i,s),s+=2;else if(u.fmt==2){var d=l.readUshort(i,s);s+=2,u.newg=l.readUshorts(i,s,d),s+=2*u.newg.length}}else if(r==2&&u.fmt==1){d=l.readUshort(i,s),s+=2,u.seqs=[];for(var f=0;f<d;f++){var p=l.readUshort(i,s)+c;s+=2;var m=l.readUshort(i,p);u.seqs.push(l.readUshorts(i,p+2,m))}}else if(r==4)for(u.vals=[],d=l.readUshort(i,s),s+=2,f=0;f<d;f++){var g=l.readUshort(i,s);s+=2,u.vals.push(e.GSUB.readLigatureSet(i,c+g))}else if(r==5&&u.fmt==2){if(u.fmt==2){var v=l.readUshort(i,s);s+=2,u.cDef=e._lctf.readClassDef(i,c+v),u.scset=[];var y=l.readUshort(i,s);for(s+=2,f=0;f<y;f++){var w=l.readUshort(i,s);s+=2,u.scset.push(w==0?null:e.GSUB.readSubClassSet(i,c+w))}}}else if(r==6&&u.fmt==3){if(u.fmt==3){for(f=0;f<3;f++){d=l.readUshort(i,s),s+=2;for(var x=[],S=0;S<d;S++)x.push(e._lctf.readCoverage(i,c+l.readUshort(i,s+2*S)));s+=2*d,f==0&&(u.backCvg=x),f==1&&(u.inptCvg=x),f==2&&(u.ahedCvg=x)}d=l.readUshort(i,s),s+=2,u.lookupRec=e.GSUB.readSubstLookupRecords(i,s,d)}}else{if(r==7&&u.fmt==1){var b=l.readUshort(i,s);s+=2;var E=l.readUint(i,s);if(s+=4,o.ltype==9)o.ltype=b;else if(o.ltype!=b)throw"invalid extension substitution";return e.GSUB.subt(i,o.ltype,c+E)}console.debug("unsupported GSUB table LookupType",r,"format",u.fmt)}return u},e.GSUB.readSubClassSet=function(i,r){var s=e._bin.readUshort,o=r,l=[],c=s(i,r);r+=2;for(var u=0;u<c;u++){var h=s(i,r);r+=2,l.push(e.GSUB.readSubClassRule(i,o+h))}return l},e.GSUB.readSubClassRule=function(i,r){var s=e._bin.readUshort,o={},l=s(i,r),c=s(i,r+=2);r+=2,o.input=[];for(var u=0;u<l-1;u++)o.input.push(s(i,r)),r+=2;return o.substLookupRecords=e.GSUB.readSubstLookupRecords(i,r,c),o},e.GSUB.readSubstLookupRecords=function(i,r,s){for(var o=e._bin.readUshort,l=[],c=0;c<s;c++)l.push(o(i,r),o(i,r+2)),r+=4;return l},e.GSUB.readChainSubClassSet=function(i,r){var s=e._bin,o=r,l=[],c=s.readUshort(i,r);r+=2;for(var u=0;u<c;u++){var h=s.readUshort(i,r);r+=2,l.push(e.GSUB.readChainSubClassRule(i,o+h))}return l},e.GSUB.readChainSubClassRule=function(i,r){for(var s=e._bin,o={},l=["backtrack","input","lookahead"],c=0;c<l.length;c++){var u=s.readUshort(i,r);r+=2,c==1&&u--,o[l[c]]=s.readUshorts(i,r,u),r+=2*o[l[c]].length}return u=s.readUshort(i,r),r+=2,o.subst=s.readUshorts(i,r,2*u),r+=2*o.subst.length,o},e.GSUB.readLigatureSet=function(i,r){var s=e._bin,o=r,l=[],c=s.readUshort(i,r);r+=2;for(var u=0;u<c;u++){var h=s.readUshort(i,r);r+=2,l.push(e.GSUB.readLigature(i,o+h))}return l},e.GSUB.readLigature=function(i,r){var s=e._bin,o={chain:[]};o.nglyph=s.readUshort(i,r),r+=2;var l=s.readUshort(i,r);r+=2;for(var c=0;c<l-1;c++)o.chain.push(s.readUshort(i,r)),r+=2;return o},e.head={},e.head.parse=function(i,r,s){var o=e._bin,l={};return o.readFixed(i,r),r+=4,l.fontRevision=o.readFixed(i,r),r+=4,o.readUint(i,r),r+=4,o.readUint(i,r),r+=4,l.flags=o.readUshort(i,r),r+=2,l.unitsPerEm=o.readUshort(i,r),r+=2,l.created=o.readUint64(i,r),r+=8,l.modified=o.readUint64(i,r),r+=8,l.xMin=o.readShort(i,r),r+=2,l.yMin=o.readShort(i,r),r+=2,l.xMax=o.readShort(i,r),r+=2,l.yMax=o.readShort(i,r),r+=2,l.macStyle=o.readUshort(i,r),r+=2,l.lowestRecPPEM=o.readUshort(i,r),r+=2,l.fontDirectionHint=o.readShort(i,r),r+=2,l.indexToLocFormat=o.readShort(i,r),r+=2,l.glyphDataFormat=o.readShort(i,r),r+=2,l},e.hhea={},e.hhea.parse=function(i,r,s){var o=e._bin,l={};return o.readFixed(i,r),r+=4,l.ascender=o.readShort(i,r),r+=2,l.descender=o.readShort(i,r),r+=2,l.lineGap=o.readShort(i,r),r+=2,l.advanceWidthMax=o.readUshort(i,r),r+=2,l.minLeftSideBearing=o.readShort(i,r),r+=2,l.minRightSideBearing=o.readShort(i,r),r+=2,l.xMaxExtent=o.readShort(i,r),r+=2,l.caretSlopeRise=o.readShort(i,r),r+=2,l.caretSlopeRun=o.readShort(i,r),r+=2,l.caretOffset=o.readShort(i,r),r+=2,r+=8,l.metricDataFormat=o.readShort(i,r),r+=2,l.numberOfHMetrics=o.readUshort(i,r),r+=2,l},e.hmtx={},e.hmtx.parse=function(i,r,s,o){for(var l=e._bin,c={aWidth:[],lsBearing:[]},u=0,h=0,d=0;d<o.maxp.numGlyphs;d++)d<o.hhea.numberOfHMetrics&&(u=l.readUshort(i,r),r+=2,h=l.readShort(i,r),r+=2),c.aWidth.push(u),c.lsBearing.push(h);return c},e.kern={},e.kern.parse=function(i,r,s,o){var l=e._bin,c=l.readUshort(i,r);if(r+=2,c==1)return e.kern.parseV1(i,r-2,s,o);var u=l.readUshort(i,r);r+=2;for(var h={glyph1:[],rval:[]},d=0;d<u;d++){r+=2,s=l.readUshort(i,r),r+=2;var f=l.readUshort(i,r);r+=2;var p=f>>>8;if((p&=15)!=0)throw"unknown kern table format: "+p;r=e.kern.readFormat0(i,r,h)}return h},e.kern.parseV1=function(i,r,s,o){var l=e._bin;l.readFixed(i,r),r+=4;var c=l.readUint(i,r);r+=4;for(var u={glyph1:[],rval:[]},h=0;h<c;h++){l.readUint(i,r),r+=4;var d=l.readUshort(i,r);r+=2,l.readUshort(i,r),r+=2;var f=d>>>8;if((f&=15)!=0)throw"unknown kern table format: "+f;r=e.kern.readFormat0(i,r,u)}return u},e.kern.readFormat0=function(i,r,s){var o=e._bin,l=-1,c=o.readUshort(i,r);r+=2,o.readUshort(i,r),r+=2,o.readUshort(i,r),r+=2,o.readUshort(i,r),r+=2;for(var u=0;u<c;u++){var h=o.readUshort(i,r);r+=2;var d=o.readUshort(i,r);r+=2;var f=o.readShort(i,r);r+=2,h!=l&&(s.glyph1.push(h),s.rval.push({glyph2:[],vals:[]}));var p=s.rval[s.rval.length-1];p.glyph2.push(d),p.vals.push(f),l=h}return r},e.loca={},e.loca.parse=function(i,r,s,o){var l=e._bin,c=[],u=o.head.indexToLocFormat,h=o.maxp.numGlyphs+1;if(u==0)for(var d=0;d<h;d++)c.push(l.readUshort(i,r+(d<<1))<<1);if(u==1)for(d=0;d<h;d++)c.push(l.readUint(i,r+(d<<2)));return c},e.maxp={},e.maxp.parse=function(i,r,s){var o=e._bin,l={},c=o.readUint(i,r);return r+=4,l.numGlyphs=o.readUshort(i,r),r+=2,c==65536&&(l.maxPoints=o.readUshort(i,r),r+=2,l.maxContours=o.readUshort(i,r),r+=2,l.maxCompositePoints=o.readUshort(i,r),r+=2,l.maxCompositeContours=o.readUshort(i,r),r+=2,l.maxZones=o.readUshort(i,r),r+=2,l.maxTwilightPoints=o.readUshort(i,r),r+=2,l.maxStorage=o.readUshort(i,r),r+=2,l.maxFunctionDefs=o.readUshort(i,r),r+=2,l.maxInstructionDefs=o.readUshort(i,r),r+=2,l.maxStackElements=o.readUshort(i,r),r+=2,l.maxSizeOfInstructions=o.readUshort(i,r),r+=2,l.maxComponentElements=o.readUshort(i,r),r+=2,l.maxComponentDepth=o.readUshort(i,r),r+=2),l},e.name={},e.name.parse=function(i,r,s){var o=e._bin,l={};o.readUshort(i,r),r+=2;var c=o.readUshort(i,r);r+=2,o.readUshort(i,r);for(var u,h=["copyright","fontFamily","fontSubfamily","ID","fullName","version","postScriptName","trademark","manufacturer","designer","description","urlVendor","urlDesigner","licence","licenceURL","---","typoFamilyName","typoSubfamilyName","compatibleFull","sampleText","postScriptCID","wwsFamilyName","wwsSubfamilyName","lightPalette","darkPalette"],d=r+=2,f=0;f<c;f++){var p=o.readUshort(i,r);r+=2;var m=o.readUshort(i,r);r+=2;var g=o.readUshort(i,r);r+=2;var v=o.readUshort(i,r);r+=2;var y=o.readUshort(i,r);r+=2;var w=o.readUshort(i,r);r+=2;var x,S=h[v],b=d+12*c+w;if(p==0)x=o.readUnicode(i,b,y/2);else if(p==3&&m==0)x=o.readUnicode(i,b,y/2);else if(m==0)x=o.readASCII(i,b,y);else if(m==1)x=o.readUnicode(i,b,y/2);else if(m==3)x=o.readUnicode(i,b,y/2);else{if(p!=1)throw"unknown encoding "+m+", platformID: "+p;x=o.readASCII(i,b,y),console.debug("reading unknown MAC encoding "+m+" as ASCII")}var E="p"+p+","+g.toString(16);l[E]==null&&(l[E]={}),l[E][S!==void 0?S:v]=x,l[E]._lang=g}for(var M in l)if(l[M].postScriptName!=null&&l[M]._lang==1033)return l[M];for(var M in l)if(l[M].postScriptName!=null&&l[M]._lang==0)return l[M];for(var M in l)if(l[M].postScriptName!=null&&l[M]._lang==3084)return l[M];for(var M in l)if(l[M].postScriptName!=null)return l[M];for(var M in l){u=M;break}return console.debug("returning name table with languageID "+l[u]._lang),l[u]},e["OS/2"]={},e["OS/2"].parse=function(i,r,s){var o=e._bin.readUshort(i,r);r+=2;var l={};if(o==0)e["OS/2"].version0(i,r,l);else if(o==1)e["OS/2"].version1(i,r,l);else if(o==2||o==3||o==4)e["OS/2"].version2(i,r,l);else{if(o!=5)throw"unknown OS/2 table version: "+o;e["OS/2"].version5(i,r,l)}return l},e["OS/2"].version0=function(i,r,s){var o=e._bin;return s.xAvgCharWidth=o.readShort(i,r),r+=2,s.usWeightClass=o.readUshort(i,r),r+=2,s.usWidthClass=o.readUshort(i,r),r+=2,s.fsType=o.readUshort(i,r),r+=2,s.ySubscriptXSize=o.readShort(i,r),r+=2,s.ySubscriptYSize=o.readShort(i,r),r+=2,s.ySubscriptXOffset=o.readShort(i,r),r+=2,s.ySubscriptYOffset=o.readShort(i,r),r+=2,s.ySuperscriptXSize=o.readShort(i,r),r+=2,s.ySuperscriptYSize=o.readShort(i,r),r+=2,s.ySuperscriptXOffset=o.readShort(i,r),r+=2,s.ySuperscriptYOffset=o.readShort(i,r),r+=2,s.yStrikeoutSize=o.readShort(i,r),r+=2,s.yStrikeoutPosition=o.readShort(i,r),r+=2,s.sFamilyClass=o.readShort(i,r),r+=2,s.panose=o.readBytes(i,r,10),r+=10,s.ulUnicodeRange1=o.readUint(i,r),r+=4,s.ulUnicodeRange2=o.readUint(i,r),r+=4,s.ulUnicodeRange3=o.readUint(i,r),r+=4,s.ulUnicodeRange4=o.readUint(i,r),r+=4,s.achVendID=[o.readInt8(i,r),o.readInt8(i,r+1),o.readInt8(i,r+2),o.readInt8(i,r+3)],r+=4,s.fsSelection=o.readUshort(i,r),r+=2,s.usFirstCharIndex=o.readUshort(i,r),r+=2,s.usLastCharIndex=o.readUshort(i,r),r+=2,s.sTypoAscender=o.readShort(i,r),r+=2,s.sTypoDescender=o.readShort(i,r),r+=2,s.sTypoLineGap=o.readShort(i,r),r+=2,s.usWinAscent=o.readUshort(i,r),r+=2,s.usWinDescent=o.readUshort(i,r),r+=2},e["OS/2"].version1=function(i,r,s){var o=e._bin;return r=e["OS/2"].version0(i,r,s),s.ulCodePageRange1=o.readUint(i,r),r+=4,s.ulCodePageRange2=o.readUint(i,r),r+=4},e["OS/2"].version2=function(i,r,s){var o=e._bin;return r=e["OS/2"].version1(i,r,s),s.sxHeight=o.readShort(i,r),r+=2,s.sCapHeight=o.readShort(i,r),r+=2,s.usDefault=o.readUshort(i,r),r+=2,s.usBreak=o.readUshort(i,r),r+=2,s.usMaxContext=o.readUshort(i,r),r+=2},e["OS/2"].version5=function(i,r,s){var o=e._bin;return r=e["OS/2"].version2(i,r,s),s.usLowerOpticalPointSize=o.readUshort(i,r),r+=2,s.usUpperOpticalPointSize=o.readUshort(i,r),r+=2},e.post={},e.post.parse=function(i,r,s){var o=e._bin,l={};return l.version=o.readFixed(i,r),r+=4,l.italicAngle=o.readFixed(i,r),r+=4,l.underlinePosition=o.readShort(i,r),r+=2,l.underlineThickness=o.readShort(i,r),r+=2,l},e==null&&(e={}),e.U==null&&(e.U={}),e.U.codeToGlyph=function(i,r){var s=i.cmap,o=-1;if(s.p0e4!=null?o=s.p0e4:s.p3e1!=null?o=s.p3e1:s.p1e0!=null?o=s.p1e0:s.p0e3!=null&&(o=s.p0e3),o==-1)throw"no familiar platform and encoding!";var l=s.tables[o];if(l.format==0)return r>=l.map.length?0:l.map[r];if(l.format==4){for(var c=-1,u=0;u<l.endCount.length;u++)if(r<=l.endCount[u]){c=u;break}return c==-1||l.startCount[c]>r?0:65535&(l.idRangeOffset[c]!=0?l.glyphIdArray[r-l.startCount[c]+(l.idRangeOffset[c]>>1)-(l.idRangeOffset.length-c)]:r+l.idDelta[c])}if(l.format==12){if(r>l.groups[l.groups.length-1][1])return 0;for(u=0;u<l.groups.length;u++){var h=l.groups[u];if(h[0]<=r&&r<=h[1])return h[2]+(r-h[0])}return 0}throw"unknown cmap table format "+l.format},e.U.glyphToPath=function(i,r){var s={cmds:[],crds:[]};if(i.SVG&&i.SVG.entries[r]){var o=i.SVG.entries[r];return o==null?s:(typeof o=="string"&&(o=e.SVG.toPath(o),i.SVG.entries[r]=o),o)}if(i.CFF){var l={x:0,y:0,stack:[],nStems:0,haveWidth:!1,width:i.CFF.Private?i.CFF.Private.defaultWidthX:0,open:!1},c=i.CFF,u=i.CFF.Private;if(c.ROS){for(var h=0;c.FDSelect[h+2]<=r;)h+=2;u=c.FDArray[c.FDSelect[h+1]].Private}e.U._drawCFF(i.CFF.CharStrings[r],l,c,u,s)}else i.glyf&&e.U._drawGlyf(r,i,s);return s},e.U._drawGlyf=function(i,r,s){var o=r.glyf[i];o==null&&(o=r.glyf[i]=e.glyf._parseGlyf(r,i)),o!=null&&(o.noc>-1?e.U._simpleGlyph(o,s):e.U._compoGlyph(o,r,s))},e.U._simpleGlyph=function(i,r){for(var s=0;s<i.noc;s++){for(var o=s==0?0:i.endPts[s-1]+1,l=i.endPts[s],c=o;c<=l;c++){var u=c==o?l:c-1,h=c==l?o:c+1,d=1&i.flags[c],f=1&i.flags[u],p=1&i.flags[h],m=i.xs[c],g=i.ys[c];if(c==o)if(d){if(!f){e.U.P.moveTo(r,m,g);continue}e.U.P.moveTo(r,i.xs[u],i.ys[u])}else f?e.U.P.moveTo(r,i.xs[u],i.ys[u]):e.U.P.moveTo(r,(i.xs[u]+m)/2,(i.ys[u]+g)/2);d?f&&e.U.P.lineTo(r,m,g):p?e.U.P.qcurveTo(r,m,g,i.xs[h],i.ys[h]):e.U.P.qcurveTo(r,m,g,(m+i.xs[h])/2,(g+i.ys[h])/2)}e.U.P.closePath(r)}},e.U._compoGlyph=function(i,r,s){for(var o=0;o<i.parts.length;o++){var l={cmds:[],crds:[]},c=i.parts[o];e.U._drawGlyf(c.glyphIndex,r,l);for(var u=c.m,h=0;h<l.crds.length;h+=2){var d=l.crds[h],f=l.crds[h+1];s.crds.push(d*u.a+f*u.b+u.tx),s.crds.push(d*u.c+f*u.d+u.ty)}for(h=0;h<l.cmds.length;h++)s.cmds.push(l.cmds[h])}},e.U._getGlyphClass=function(i,r){var s=e._lctf.getInterval(r,i);return s==-1?0:r[s+2]},e.U._applySubs=function(i,r,s,o){for(var l=i.length-r-1,c=0;c<s.tabs.length;c++)if(s.tabs[c]!=null){var u,h=s.tabs[c];if(!h.coverage||(u=e._lctf.coverageIndex(h.coverage,i[r]))!=-1){if(s.ltype==1)i[r],h.fmt==1?i[r]=i[r]+h.delta:i[r]=h.newg[u];else if(s.ltype==4)for(var d=h.vals[u],f=0;f<d.length;f++){var p=d[f],m=p.chain.length;if(!(m>l)){for(var g=!0,v=0,y=0;y<m;y++){for(;i[r+v+(1+y)]==-1;)v++;p.chain[y]!=i[r+v+(1+y)]&&(g=!1)}if(g){for(i[r]=p.nglyph,y=0;y<m+v;y++)i[r+y+1]=-1;break}}}else if(s.ltype==5&&h.fmt==2)for(var w=e._lctf.getInterval(h.cDef,i[r]),x=h.cDef[w+2],S=h.scset[x],b=0;b<S.length;b++){var E=S[b],M=E.input;if(!(M.length>l)){for(g=!0,y=0;y<M.length;y++){var T=e._lctf.getInterval(h.cDef,i[r+1+y]);if(w==-1&&h.cDef[T+2]!=M[y]){g=!1;break}}if(g){var I=E.substLookupRecords;for(f=0;f<I.length;f+=2)I[f],I[f+1]}}}else if(s.ltype==6&&h.fmt==3){if(!e.U._glsCovered(i,h.backCvg,r-h.backCvg.length)||!e.U._glsCovered(i,h.inptCvg,r)||!e.U._glsCovered(i,h.ahedCvg,r+h.inptCvg.length))continue;var O=h.lookupRec;for(b=0;b<O.length;b+=2){w=O[b];var R=o[O[b+1]];e.U._applySubs(i,r+w,R,o)}}}}},e.U._glsCovered=function(i,r,s){for(var o=0;o<r.length;o++)if(e._lctf.coverageIndex(r[o],i[s+o])==-1)return!1;return!0},e.U.glyphsToPath=function(i,r,s){for(var o={cmds:[],crds:[]},l=0,c=0;c<r.length;c++){var u=r[c];if(u!=-1){for(var h=c<r.length-1&&r[c+1]!=-1?r[c+1]:0,d=e.U.glyphToPath(i,u),f=0;f<d.crds.length;f+=2)o.crds.push(d.crds[f]+l),o.crds.push(d.crds[f+1]);for(s&&o.cmds.push(s),f=0;f<d.cmds.length;f++)o.cmds.push(d.cmds[f]);s&&o.cmds.push("X"),l+=i.hmtx.aWidth[u],c<r.length-1&&(l+=e.U.getPairAdjustment(i,u,h))}}return o},e.U.P={},e.U.P.moveTo=function(i,r,s){i.cmds.push("M"),i.crds.push(r,s)},e.U.P.lineTo=function(i,r,s){i.cmds.push("L"),i.crds.push(r,s)},e.U.P.curveTo=function(i,r,s,o,l,c,u){i.cmds.push("C"),i.crds.push(r,s,o,l,c,u)},e.U.P.qcurveTo=function(i,r,s,o,l){i.cmds.push("Q"),i.crds.push(r,s,o,l)},e.U.P.closePath=function(i){i.cmds.push("Z")},e.U._drawCFF=function(i,r,s,o,l){for(var c=r.stack,u=r.nStems,h=r.haveWidth,d=r.width,f=r.open,p=0,m=r.x,g=r.y,v=0,y=0,w=0,x=0,S=0,b=0,E=0,M=0,T=0,I=0,O={val:0,size:0};p<i.length;){e.CFF.getCharString(i,p,O);var R=O.val;if(p+=O.size,R=="o1"||R=="o18")c.length%2!=0&&!h&&(d=c.shift()+o.nominalWidthX),u+=c.length>>1,c.length=0,h=!0;else if(R=="o3"||R=="o23")c.length%2!=0&&!h&&(d=c.shift()+o.nominalWidthX),u+=c.length>>1,c.length=0,h=!0;else if(R=="o4")c.length>1&&!h&&(d=c.shift()+o.nominalWidthX,h=!0),f&&e.U.P.closePath(l),g+=c.pop(),e.U.P.moveTo(l,m,g),f=!0;else if(R=="o5")for(;c.length>0;)m+=c.shift(),g+=c.shift(),e.U.P.lineTo(l,m,g);else if(R=="o6"||R=="o7")for(var k=c.length,P=R=="o6",F=0;F<k;F++){var N=c.shift();P?m+=N:g+=N,P=!P,e.U.P.lineTo(l,m,g)}else if(R=="o8"||R=="o24"){k=c.length;for(var Y=0;Y+6<=k;)v=m+c.shift(),y=g+c.shift(),w=v+c.shift(),x=y+c.shift(),m=w+c.shift(),g=x+c.shift(),e.U.P.curveTo(l,v,y,w,x,m,g),Y+=6;R=="o24"&&(m+=c.shift(),g+=c.shift(),e.U.P.lineTo(l,m,g))}else{if(R=="o11")break;if(R=="o1234"||R=="o1235"||R=="o1236"||R=="o1237")R=="o1234"&&(y=g,w=(v=m+c.shift())+c.shift(),I=x=y+c.shift(),b=x,M=g,m=(E=(S=(T=w+c.shift())+c.shift())+c.shift())+c.shift(),e.U.P.curveTo(l,v,y,w,x,T,I),e.U.P.curveTo(l,S,b,E,M,m,g)),R=="o1235"&&(v=m+c.shift(),y=g+c.shift(),w=v+c.shift(),x=y+c.shift(),T=w+c.shift(),I=x+c.shift(),S=T+c.shift(),b=I+c.shift(),E=S+c.shift(),M=b+c.shift(),m=E+c.shift(),g=M+c.shift(),c.shift(),e.U.P.curveTo(l,v,y,w,x,T,I),e.U.P.curveTo(l,S,b,E,M,m,g)),R=="o1236"&&(v=m+c.shift(),y=g+c.shift(),w=v+c.shift(),I=x=y+c.shift(),b=x,E=(S=(T=w+c.shift())+c.shift())+c.shift(),M=b+c.shift(),m=E+c.shift(),e.U.P.curveTo(l,v,y,w,x,T,I),e.U.P.curveTo(l,S,b,E,M,m,g)),R=="o1237"&&(v=m+c.shift(),y=g+c.shift(),w=v+c.shift(),x=y+c.shift(),T=w+c.shift(),I=x+c.shift(),S=T+c.shift(),b=I+c.shift(),E=S+c.shift(),M=b+c.shift(),Math.abs(E-m)>Math.abs(M-g)?m=E+c.shift():g=M+c.shift(),e.U.P.curveTo(l,v,y,w,x,T,I),e.U.P.curveTo(l,S,b,E,M,m,g));else if(R=="o14"){if(c.length>0&&!h&&(d=c.shift()+s.nominalWidthX,h=!0),c.length==4){var _=c.shift(),G=c.shift(),j=c.shift(),L=c.shift(),H=e.CFF.glyphBySE(s,j),q=e.CFF.glyphBySE(s,L);e.U._drawCFF(s.CharStrings[H],r,s,o,l),r.x=_,r.y=G,e.U._drawCFF(s.CharStrings[q],r,s,o,l)}f&&(e.U.P.closePath(l),f=!1)}else if(R=="o19"||R=="o20")c.length%2!=0&&!h&&(d=c.shift()+o.nominalWidthX),u+=c.length>>1,c.length=0,h=!0,p+=u+7>>3;else if(R=="o21")c.length>2&&!h&&(d=c.shift()+o.nominalWidthX,h=!0),g+=c.pop(),m+=c.pop(),f&&e.U.P.closePath(l),e.U.P.moveTo(l,m,g),f=!0;else if(R=="o22")c.length>1&&!h&&(d=c.shift()+o.nominalWidthX,h=!0),m+=c.pop(),f&&e.U.P.closePath(l),e.U.P.moveTo(l,m,g),f=!0;else if(R=="o25"){for(;c.length>6;)m+=c.shift(),g+=c.shift(),e.U.P.lineTo(l,m,g);v=m+c.shift(),y=g+c.shift(),w=v+c.shift(),x=y+c.shift(),m=w+c.shift(),g=x+c.shift(),e.U.P.curveTo(l,v,y,w,x,m,g)}else if(R=="o26")for(c.length%2&&(m+=c.shift());c.length>0;)v=m,y=g+c.shift(),m=w=v+c.shift(),g=(x=y+c.shift())+c.shift(),e.U.P.curveTo(l,v,y,w,x,m,g);else if(R=="o27")for(c.length%2&&(g+=c.shift());c.length>0;)y=g,w=(v=m+c.shift())+c.shift(),x=y+c.shift(),m=w+c.shift(),g=x,e.U.P.curveTo(l,v,y,w,x,m,g);else if(R=="o10"||R=="o29"){var $=R=="o10"?o:s;if(c.length==0)console.debug("error: empty stack");else{var ee=c.pop(),W=$.Subrs[ee+$.Bias];r.x=m,r.y=g,r.nStems=u,r.haveWidth=h,r.width=d,r.open=f,e.U._drawCFF(W,r,s,o,l),m=r.x,g=r.y,u=r.nStems,h=r.haveWidth,d=r.width,f=r.open}}else if(R=="o30"||R=="o31"){var le=c.length,K=(Y=0,R=="o31");for(Y+=le-(k=-3&le);Y<k;)K?(y=g,w=(v=m+c.shift())+c.shift(),g=(x=y+c.shift())+c.shift(),k-Y==5?(m=w+c.shift(),Y++):m=w,K=!1):(v=m,y=g+c.shift(),w=v+c.shift(),x=y+c.shift(),m=w+c.shift(),k-Y==5?(g=x+c.shift(),Y++):g=x,K=!0),e.U.P.curveTo(l,v,y,w,x,m,g),Y+=4}else{if((R+"").charAt(0)=="o")throw console.debug("Unknown operation: "+R,i),R;c.push(R)}}}r.x=m,r.y=g,r.nStems=u,r.haveWidth=h,r.width=d,r.open=f};var t=e,n={Typr:t};return a.Typr=t,a.default=n,Object.defineProperty(a,"__esModule",{value:!0}),a})({}).Typr}function UL(){return(function(a){var e=Uint8Array,t=Uint16Array,n=Uint32Array,i=new e([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),r=new e([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),s=new e([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),o=function(R,k){for(var P=new t(31),F=0;F<31;++F)P[F]=k+=1<<R[F-1];var N=new n(P[30]);for(F=1;F<30;++F)for(var Y=P[F];Y<P[F+1];++Y)N[Y]=Y-P[F]<<5|F;return[P,N]},l=o(i,2),c=l[0],u=l[1];c[28]=258,u[258]=28;for(var h=o(r,0)[0],d=new t(32768),f=0;f<32768;++f){var p=(43690&f)>>>1|(21845&f)<<1;p=(61680&(p=(52428&p)>>>2|(13107&p)<<2))>>>4|(3855&p)<<4,d[f]=((65280&p)>>>8|(255&p)<<8)>>>1}var m=function(R,k,P){for(var F=R.length,N=0,Y=new t(k);N<F;++N)++Y[R[N]-1];var _,G=new t(k);for(N=0;N<k;++N)G[N]=G[N-1]+Y[N-1]<<1;{_=new t(1<<k);var j=15-k;for(N=0;N<F;++N)if(R[N])for(var L=N<<4|R[N],H=k-R[N],q=G[R[N]-1]++<<H,$=q|(1<<H)-1;q<=$;++q)_[d[q]>>>j]=L}return _},g=new e(288);for(f=0;f<144;++f)g[f]=8;for(f=144;f<256;++f)g[f]=9;for(f=256;f<280;++f)g[f]=7;for(f=280;f<288;++f)g[f]=8;var v=new e(32);for(f=0;f<32;++f)v[f]=5;var y=m(g,9),w=m(v,5),x=function(R){for(var k=R[0],P=1;P<R.length;++P)R[P]>k&&(k=R[P]);return k},S=function(R,k,P){var F=k/8|0;return(R[F]|R[F+1]<<8)>>(7&k)&P},b=function(R,k){var P=k/8|0;return(R[P]|R[P+1]<<8|R[P+2]<<16)>>(7&k)},E=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],M=function(R,k,P){var F=new Error(k||E[R]);if(F.code=R,Error.captureStackTrace&&Error.captureStackTrace(F,M),!P)throw F;return F},T=function(R,k,P){var F=R.length;if(!F||P&&!P.l&&F<5)return k||new e(0);var N=!k||P,Y=!P||P.i;P||(P={}),k||(k=new e(3*F));var _,G=function(Te){var Ye=k.length;if(Te>Ye){var Ne=new e(Math.max(2*Ye,Te));Ne.set(k),k=Ne}},j=P.f||0,L=P.p||0,H=P.b||0,q=P.l,$=P.d,ee=P.m,W=P.n,le=8*F;do{if(!q){P.f=j=S(R,L,1);var K=S(R,L+1,3);if(L+=3,!K){var pe=R[(Fe=((_=L)/8|0)+(7&_&&1)+4)-4]|R[Fe-3]<<8,se=Fe+pe;if(se>F){Y&&M(0);break}N&&G(H+pe),k.set(R.subarray(Fe,se),H),P.b=H+=pe,P.p=L=8*se;continue}if(K==1)q=y,$=w,ee=9,W=5;else if(K==2){var ve=S(R,L,31)+257,Z=S(R,L+10,15)+4,oe=ve+S(R,L+5,31)+1;L+=14;for(var Ae=new e(oe),Ee=new e(19),Se=0;Se<Z;++Se)Ee[s[Se]]=S(R,L+3*Se,7);L+=3*Z;var ke=x(Ee),ye=(1<<ke)-1,ge=m(Ee,ke);for(Se=0;Se<oe;){var Fe,Me=ge[S(R,L,ye)];if(L+=15&Me,(Fe=Me>>>4)<16)Ae[Se++]=Fe;else{var z=0,D=0;for(Fe==16?(D=3+S(R,L,3),L+=2,z=Ae[Se-1]):Fe==17?(D=3+S(R,L,7),L+=3):Fe==18&&(D=11+S(R,L,127),L+=7);D--;)Ae[Se++]=z}}var U=Ae.subarray(0,ve),J=Ae.subarray(ve);ee=x(U),W=x(J),q=m(U,ee),$=m(J,W)}else M(1);if(L>le){Y&&M(0);break}}N&&G(H+131072);for(var be=(1<<ee)-1,we=(1<<W)-1,Pe=L;;Pe=L){var ie=(z=q[b(R,L)&be])>>>4;if((L+=15&z)>le){Y&&M(0);break}if(z||M(2),ie<256)k[H++]=ie;else{if(ie==256){Pe=L,q=null;break}var We=ie-254;if(ie>264){var qe=i[Se=ie-257];We=S(R,L,(1<<qe)-1)+c[Se],L+=qe}var Je=$[b(R,L)&we],X=Je>>>4;if(Je||M(3),L+=15&Je,J=h[X],X>3&&(qe=r[X],J+=b(R,L)&(1<<qe)-1,L+=qe),L>le){Y&&M(0);break}N&&G(H+131072);for(var Ce=H+We;H<Ce;H+=4)k[H]=k[H-J],k[H+1]=k[H+1-J],k[H+2]=k[H+2-J],k[H+3]=k[H+3-J];H=Ce}}P.l=q,P.p=Pe,P.b=H,q&&(j=1,P.m=ee,P.d=$,P.n=W)}while(!j);return H==k.length?k:(function(Te,Ye,Ne){(Ne==null||Ne>Te.length)&&(Ne=Te.length);var Ze=new(Te instanceof t?t:Te instanceof n?n:e)(Ne-Ye);return Ze.set(Te.subarray(Ye,Ne)),Ze})(k,0,H)},I=new e(0),O=typeof TextDecoder<"u"&&new TextDecoder;try{O.decode(I,{stream:!0})}catch{}return a.convert_streams=function(R){var k=new DataView(R),P=0;function F(){var ve=k.getUint16(P);return P+=2,ve}function N(){var ve=k.getUint32(P);return P+=4,ve}function Y(ve){pe.setUint16(se,ve),se+=2}function _(ve){pe.setUint32(se,ve),se+=4}for(var G={signature:N(),flavor:N(),length:N(),numTables:F(),reserved:F(),totalSfntSize:N(),majorVersion:F(),minorVersion:F(),metaOffset:N(),metaLength:N(),metaOrigLength:N(),privOffset:N(),privLength:N()},j=0;Math.pow(2,j)<=G.numTables;)j++;j--;for(var L=16*Math.pow(2,j),H=16*G.numTables-L,q=12,$=[],ee=0;ee<G.numTables;ee++)$.push({tag:N(),offset:N(),compLength:N(),origLength:N(),origChecksum:N()}),q+=16;var W,le=new Uint8Array(12+16*$.length+$.reduce((function(ve,Z){return ve+Z.origLength+4}),0)),K=le.buffer,pe=new DataView(K),se=0;return _(G.flavor),Y(G.numTables),Y(L),Y(j),Y(H),$.forEach((function(ve){_(ve.tag),_(ve.origChecksum),_(q),_(ve.origLength),ve.outOffset=q,(q+=ve.origLength)%4!=0&&(q+=4-q%4)})),$.forEach((function(ve){var Z,oe=R.slice(ve.offset,ve.offset+ve.compLength);if(ve.compLength!=ve.origLength){var Ae=new Uint8Array(ve.origLength);Z=new Uint8Array(oe,2),T(Z,Ae)}else Ae=new Uint8Array(oe);le.set(Ae,ve.outOffset);var Ee=0;(q=ve.outOffset+ve.origLength)%4!=0&&(Ee=4-q%4),le.set(new Uint8Array(Ee).buffer,ve.outOffset+ve.origLength),W=q+Ee})),K.slice(0,W)},Object.defineProperty(a,"__esModule",{value:!0}),a})({}).convert_streams}function FL(a,e){const t={M:2,L:2,Q:4,C:6,Z:0},n={C:"18g,ca,368,1kz",D:"17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v",R:"17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6",L:"x9u,jff,a,fd,jv",T:"4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n"},i=1,r=2,s=4,o=8,l=16,c=32;let u;function h(E){if(!u){const M={R:r,L:i,D:s,C:l,U:c,T:o};u=new Map;for(let T in n){let I=0;n[T].split(",").forEach(O=>{let[R,k]=O.split("+");R=parseInt(R,36),k=k?parseInt(k,36):0,u.set(I+=R,M[T]);for(let P=k;P--;)u.set(++I,M[T])})}}return u.get(E)||c}const d=1,f=2,p=3,m=4,g=[null,"isol","init","fina","medi"];function v(E){const M=new Uint8Array(E.length);let T=c,I=d,O=-1;for(let R=0;R<E.length;R++){const k=E.codePointAt(R);let P=h(k)|0,F=d;P&o||(T&(i|s|l)?P&(r|s|l)?(F=p,(I===d||I===p)&&M[O]++):P&(i|c)&&(I===f||I===m)&&M[O]--:T&(r|c)&&(I===f||I===m)&&M[O]--,I=M[R]=F,T=P,O=R,k>65535&&R++)}return M}function y(E,M){const T=[];for(let O=0;O<M.length;O++){const R=M.codePointAt(O);R>65535&&O++,T.push(a.U.codeToGlyph(E,R))}const I=E.GSUB;if(I){const{lookupList:O,featureList:R}=I;let k;const P=/^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/,F=[];R.forEach(N=>{if(P.test(N.tag))for(let Y=0;Y<N.tab.length;Y++){if(F[N.tab[Y]])continue;F[N.tab[Y]]=!0;const _=O[N.tab[Y]],G=/^(isol|init|fina|medi)$/.test(N.tag);G&&!k&&(k=v(M));for(let j=0;j<T.length;j++)(!k||!G||g[k[j]]===N.tag)&&a.U._applySubs(T,j,_,O)}})}return T}function w(E,M){const T=new Int16Array(M.length*3);let I=0;for(;I<M.length;I++){const P=M[I];if(P===-1)continue;T[I*3+2]=E.hmtx.aWidth[P];const F=E.GPOS;if(F){const N=F.lookupList;for(let Y=0;Y<N.length;Y++){const _=N[Y];for(let G=0;G<_.tabs.length;G++){const j=_.tabs[G];if(_.ltype===1){if(a._lctf.coverageIndex(j.coverage,P)!==-1&&j.pos){k(j.pos,I);break}}else if(_.ltype===2){let L=null,H=O();if(H!==-1){const q=a._lctf.coverageIndex(j.coverage,M[H]);if(q!==-1){if(j.fmt===1){const $=j.pairsets[q];for(let ee=0;ee<$.length;ee++)$[ee].gid2===P&&(L=$[ee])}else if(j.fmt===2){const $=a.U._getGlyphClass(M[H],j.classDef1),ee=a.U._getGlyphClass(P,j.classDef2);L=j.matrix[$][ee]}if(L){L.val1&&k(L.val1,H),L.val2&&k(L.val2,I);break}}}}else if(_.ltype===4){const L=a._lctf.coverageIndex(j.markCoverage,P);if(L!==-1){const H=O(R),q=H===-1?-1:a._lctf.coverageIndex(j.baseCoverage,M[H]);if(q!==-1){const $=j.markArray[L],ee=j.baseArray[q][$.markClass];T[I*3]=ee.x-$.x+T[H*3]-T[H*3+2],T[I*3+1]=ee.y-$.y+T[H*3+1];break}}}else if(_.ltype===6){const L=a._lctf.coverageIndex(j.mark1Coverage,P);if(L!==-1){const H=O();if(H!==-1){const q=M[H];if(x(E,q)===3){const $=a._lctf.coverageIndex(j.mark2Coverage,q);if($!==-1){const ee=j.mark1Array[L],W=j.mark2Array[$][ee.markClass];T[I*3]=W.x-ee.x+T[H*3]-T[H*3+2],T[I*3+1]=W.y-ee.y+T[H*3+1];break}}}}}}}}else if(E.kern&&!E.cff){const N=O();if(N!==-1){const Y=E.kern.glyph1.indexOf(M[N]);if(Y!==-1){const _=E.kern.rval[Y].glyph2.indexOf(P);_!==-1&&(T[N*3+2]+=E.kern.rval[Y].vals[_])}}}}return T;function O(P){for(let F=I-1;F>=0;F--)if(M[F]!==-1&&(!P||P(M[F])))return F;return-1}function R(P){return x(E,P)===1}function k(P,F){for(let N=0;N<3;N++)T[F*3+N]+=P[N]||0}}function x(E,M){const T=E.GDEF&&E.GDEF.glyphClassDef;return T?a.U._getGlyphClass(M,T):0}function S(...E){for(let M=0;M<E.length;M++)if(typeof E[M]=="number")return E[M]}function b(E){const M=Object.create(null),T=E["OS/2"],I=E.hhea,O=E.head.unitsPerEm,R=S(T&&T.sTypoAscender,I&&I.ascender,O),k={unitsPerEm:O,ascender:R,descender:S(T&&T.sTypoDescender,I&&I.descender,0),capHeight:S(T&&T.sCapHeight,R),xHeight:S(T&&T.sxHeight,R),lineGap:S(T&&T.sTypoLineGap,I&&I.lineGap),supportsCodePoint(P){return a.U.codeToGlyph(E,P)>0},forEachGlyph(P,F,N,Y){let _=0;const G=1/k.unitsPerEm*F,j=y(E,P);let L=0;const H=w(E,j);return j.forEach((q,$)=>{if(q!==-1){let ee=M[q];if(!ee){const{cmds:W,crds:le}=a.U.glyphToPath(E,q);let K="",pe=0;for(let Ae=0,Ee=W.length;Ae<Ee;Ae++){const Se=t[W[Ae]];K+=W[Ae];for(let ke=1;ke<=Se;ke++)K+=(ke>1?",":"")+le[pe++]}let se,ve,Z,oe;if(le.length){se=ve=1/0,Z=oe=-1/0;for(let Ae=0,Ee=le.length;Ae<Ee;Ae+=2){let Se=le[Ae],ke=le[Ae+1];Se<se&&(se=Se),ke<ve&&(ve=ke),Se>Z&&(Z=Se),ke>oe&&(oe=ke)}}else se=Z=ve=oe=0;ee=M[q]={index:q,advanceWidth:E.hmtx.aWidth[q],xMin:se,yMin:ve,xMax:Z,yMax:oe,path:K}}Y.call(null,ee,_+H[$*3]*G,H[$*3+1]*G,L),_+=H[$*3+2]*G,N&&(_+=N*F)}L+=P.codePointAt(L)>65535?2:1}),_}};return k}return function(M){const T=new Uint8Array(M,0,4),I=a._bin.readASCII(T,0,4);if(I==="wOFF")M=e(M);else if(I==="wOF2")throw new Error("woff2 fonts not supported");return b(a.parse(M)[0])}}const HL=Bl({name:"Typr Font Parser",dependencies:[kL,UL,FL],init(a,e,t){const n=a(),i=e();return t(n,i)}});function GL(){return(function(a){var e=function(){this.buckets=new Map};e.prototype.add=function(w){var x=w>>5;this.buckets.set(x,(this.buckets.get(x)||0)|1<<(31&w))},e.prototype.has=function(w){var x=this.buckets.get(w>>5);return x!==void 0&&(x&1<<(31&w))!=0},e.prototype.serialize=function(){var w=[];return this.buckets.forEach((function(x,S){w.push((+S).toString(36)+":"+x.toString(36))})),w.join(",")},e.prototype.deserialize=function(w){var x=this;this.buckets.clear(),w.split(",").forEach((function(S){var b=S.split(":");x.buckets.set(parseInt(b[0],36),parseInt(b[1],36))}))};var t=Math.pow(2,8),n=t-1,i=~n;function r(w){var x=(function(b){return b&i})(w).toString(16),S=(function(b){return(b&i)+t-1})(w).toString(16);return"codepoint-index/plane"+(w>>16)+"/"+x+"-"+S+".json"}function s(w,x){var S=w&n,b=x.codePointAt(S/6|0);return((b=(b||48)-48)&1<<S%6)!=0}function o(w,x){var S;(S=w,S.replace(/U\+/gi,"").replace(/^,+|,+$/g,"").split(/,+/).map((function(b){return b.split("-").map((function(E){return parseInt(E.trim(),16)}))}))).forEach((function(b){var E=b[0],M=b[1];M===void 0&&(M=E),x(E,M)}))}function l(w,x){o(w,(function(S,b){for(var E=S;E<=b;E++)x(E)}))}var c={},u={},h=new WeakMap,d="https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";function f(w){var x=h.get(w);return x||(x=new e,l(w.ranges,(function(S){return x.add(S)})),h.set(w,x)),x}var p,m=new Map;function g(w,x,S){return w[x]?x:w[S]?S:(function(b){for(var E in b)return E})(w)}function v(w,x){var S=x;if(!w.includes(S)){S=1/0;for(var b=0;b<w.length;b++)Math.abs(w[b]-x)<Math.abs(S-x)&&(S=w[b])}return S}function y(w){return p||(p=new Set,l("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000",(function(x){p.add(x)}))),p.has(w)}return a.CodePointSet=e,a.clearCache=function(){c={},u={}},a.getFontsForString=function(w,x){x===void 0&&(x={});var S,b=x.lang;b===void 0&&(b=new RegExp("\\p{Script=Hangul}","u").test(S=w)?"ko":new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}","u").test(S)?"ja":"en");var E=x.category;E===void 0&&(E="sans-serif");var M=x.style;M===void 0&&(M="normal");var T=x.weight;T===void 0&&(T=400);var I=(x.dataUrl||d).replace(/\/$/g,""),O=new Map,R=new Uint8Array(w.length),k={},P={},F=new Array(w.length),N=new Map,Y=!1;function _(L){var H=m.get(L);return H||(H=fetch(I+"/"+L).then((function(q){if(!q.ok)throw new Error(q.statusText);return q.json().then((function($){if(!Array.isArray($)||$[0]!==1)throw new Error("Incorrect schema version; need 1, got "+$[0]);return $[1]}))})).catch((function(q){if(I!==d)return Y||(console.error('unicode-font-resolver: Failed loading from dataUrl "'+I+'", trying default CDN. '+q.message),Y=!0),I=d,m.delete(L),_(L);throw q})),m.set(L,H)),H}for(var G=function(L){var H=w.codePointAt(L),q=r(H);F[L]=q,c[q]||N.has(q)||N.set(q,_(q).then((function($){c[q]=$}))),H>65535&&(L++,j=L)},j=0;j<w.length;j++)G(j);return Promise.all(N.values()).then((function(){N.clear();for(var L=function(q){var $=w.codePointAt(q),ee=null,W=c[F[q]],le=void 0;for(var K in W){var pe=P[K];if(pe===void 0&&(pe=P[K]=new RegExp(K).test(b||"en")),pe){for(var se in le=K,W[K])if(s($,W[K][se])){ee=se;break}break}}if(!ee){e:for(var ve in W)if(ve!==le){for(var Z in W[ve])if(s($,W[ve][Z])){ee=Z;break e}}}ee||(console.debug("No font coverage for U+"+$.toString(16)),ee="latin"),F[q]=ee,u[ee]||N.has(ee)||N.set(ee,_("font-meta/"+ee+".json").then((function(oe){u[ee]=oe}))),$>65535&&(q++,H=q)},H=0;H<w.length;H++)L(H);return Promise.all(N.values())})).then((function(){for(var L,H=null,q=0;q<w.length;q++){var $=w.codePointAt(q);if(H&&(y($)||f(H).has($)))R[q]=R[q-1];else{H=u[F[q]];var ee=k[H.id];if(!ee){var W=H.typeforms,le=g(W,E,"sans-serif"),K=g(W[le],M,"normal"),pe=v((L=W[le])===null||L===void 0?void 0:L[K],T);ee=k[H.id]=I+"/font-files/"+H.id+"/"+le+"."+K+"."+pe+".woff"}var se=O.get(ee);se==null&&(se=O.size,O.set(ee,se)),R[q]=se}$>65535&&(q++,R[q]=R[q-1])}return{fontUrls:Array.from(O.keys()),chars:R}}))},Object.defineProperty(a,"__esModule",{value:!0}),a})({})}function VL(a,e){const t=Object.create(null),n=Object.create(null);function i(s,o){const l=c=>{console.error(`Failure loading font ${s}`,c)};try{const c=new XMLHttpRequest;c.open("get",s,!0),c.responseType="arraybuffer",c.onload=function(){if(c.status>=400)l(new Error(c.statusText));else if(c.status>0)try{const u=a(c.response);u.src=s,o(u)}catch(u){l(u)}},c.onerror=l,c.send()}catch(c){l(c)}}function r(s,o){let l=t[s];l?o(l):n[s]?n[s].push(o):(n[s]=[o],i(s,c=>{c.src=s,t[s]=c,n[s].forEach(u=>u(c)),delete n[s]}))}return function(s,o,{lang:l,fonts:c=[],style:u="normal",weight:h="normal",unicodeFontsURL:d}={}){const f=new Uint8Array(s.length),p=[];s.length||y();const m=new Map,g=[];if(u!=="italic"&&(u="normal"),typeof h!="number"&&(h=h==="bold"?700:400),c&&!Array.isArray(c)&&(c=[c]),c=c.slice().filter(x=>!x.lang||x.lang.test(l)).reverse(),c.length){let E=0;(function M(T=0){for(let I=T,O=s.length;I<O;I++){const R=s.codePointAt(I);if(E===1&&p[f[I-1]].supportsCodePoint(R)||I>0&&/\s/.test(s[I]))f[I]=f[I-1],E===2&&(g[g.length-1][1]=I);else for(let k=f[I],P=c.length;k<=P;k++)if(k===P){const F=E===2?g[g.length-1]:g[g.length]=[I,I];F[1]=I,E=2}else{f[I]=k;const{src:F,unicodeRange:N}=c[k];if(!N||w(R,N)){const Y=t[F];if(!Y){r(F,()=>{M(I)});return}if(Y.supportsCodePoint(R)){let _=m.get(Y);typeof _!="number"&&(_=p.length,p.push(Y),m.set(Y,_)),f[I]=_,E=1;break}}}R>65535&&I+1<O&&(f[I+1]=f[I],I++,E===2&&(g[g.length-1][1]=I))}v()})()}else g.push([0,s.length-1]),v();function v(){if(g.length){const x=g.map(S=>s.substring(S[0],S[1]+1)).join(`
`);e.getFontsForString(x,{lang:l||void 0,style:u,weight:h,dataUrl:d}).then(({fontUrls:S,chars:b})=>{const E=p.length;let M=0;g.forEach(I=>{for(let O=0,R=I[1]-I[0];O<=R;O++)f[I[0]+O]=b[M++]+E;M++});let T=0;S.forEach((I,O)=>{r(I,R=>{p[O+E]=R,++T===S.length&&y()})})})}else y()}function y(){o({chars:f,fonts:p})}function w(x,S){for(let b=0;b<S.length;b++){const[E,M=E]=S[b];if(E<=x&&x<=M)return!0}return!1}}}const jL=Bl({name:"FontResolver",dependencies:[VL,HL,GL],init(a,e,t){return a(e,t())}});function QL(a,e){const n=/[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/,i="[^\\S\\u00A0]",r=new RegExp(`${i}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);function s({text:p,lang:m,fonts:g,style:v,weight:y,preResolvedFonts:w,unicodeFontsURL:x},S){const b=({chars:E,fonts:M})=>{let T,I;const O=[];for(let R=0;R<E.length;R++)E[R]!==I?(I=E[R],O.push(T={start:R,end:R,fontObj:M[E[R]]})):T.end=R;S(O)};w?b(w):a(p,b,{lang:m,fonts:g,style:v,weight:y,unicodeFontsURL:x})}function o({text:p="",font:m,lang:g,sdfGlyphSize:v=64,fontSize:y=400,fontWeight:w=1,fontStyle:x="normal",letterSpacing:S=0,lineHeight:b="normal",maxWidth:E=1/0,direction:M,textAlign:T="left",textIndent:I=0,whiteSpace:O="normal",overflowWrap:R="normal",anchorX:k=0,anchorY:P=0,metricsOnly:F=!1,unicodeFontsURL:N,preResolvedFonts:Y=null,includeCaretPositions:_=!1,chunkedBoundsSize:G=8192,colorRanges:j=null},L){const H=h(),q={fontLoad:0,typesetting:0};p.indexOf("\r")>-1&&(console.info("Typesetter: got text with \\r chars; normalizing to \\n"),p=p.replace(/\r\n/g,`
`).replace(/\r/g,`
`)),y=+y,S=+S,E=+E,b=b||"normal",I=+I,s({text:p,lang:g,style:x,weight:w,fonts:typeof m=="string"?[{src:m}]:m,unicodeFontsURL:N,preResolvedFonts:Y},$=>{q.fontLoad=h()-H;const ee=isFinite(E);let W=null,le=null,K=null,pe=null,se=null,ve=null,Z=null,oe=null,Ae=0,Ee=0,Se=O!=="nowrap";const ke=new Map,ye=h();let ge=I,Fe=0,Me=new d;const z=[Me];$.forEach(we=>{const{fontObj:Pe}=we,{ascender:ie,descender:We,unitsPerEm:qe,lineGap:Je,capHeight:X,xHeight:Ce}=Pe;let Te=ke.get(Pe);if(!Te){const ce=y/qe,_e=b==="normal"?(ie-We+Je)*ce:b*y,pt=(_e-(ie-We)*ce)/2,At=Math.min(_e,(ie-We)*ce),ht=(ie+We)/2*ce+At/2;Te={index:ke.size,src:Pe.src,fontObj:Pe,fontSizeMult:ce,unitsPerEm:qe,ascender:ie*ce,descender:We*ce,capHeight:X*ce,xHeight:Ce*ce,lineHeight:_e,baseline:-pt-ie*ce,caretTop:ht,caretBottom:ht-At},ke.set(Pe,Te)}const{fontSizeMult:Ye}=Te,Ne=p.slice(we.start,we.end+1);let Ze,Be;Pe.forEachGlyph(Ne,y,S,(ce,_e,pt,At)=>{_e+=Fe,At+=we.start,Ze=_e,Be=ce;const ht=p.charAt(At),sn=ce.advanceWidth*Ye,Ut=Me.count;let mt;if("isEmpty"in ce||(ce.isWhitespace=!!ht&&new RegExp(i).test(ht),ce.canBreakAfter=!!ht&&r.test(ht),ce.isEmpty=ce.xMin===ce.xMax||ce.yMin===ce.yMax||n.test(ht)),!ce.isWhitespace&&!ce.isEmpty&&Ee++,Se&&ee&&!ce.isWhitespace&&_e+sn+ge>E&&Ut){if(Me.glyphAt(Ut-1).glyphObj.canBreakAfter)mt=new d,ge=-_e;else for(let Bn=Ut;Bn--;)if(Bn===0&&R==="break-word"){mt=new d,ge=-_e;break}else if(Me.glyphAt(Bn).glyphObj.canBreakAfter){mt=Me.splitAt(Bn+1);const Ln=mt.glyphAt(0).x;ge-=Ln;for(let un=mt.count;un--;)mt.glyphAt(un).x-=Ln;break}mt&&(Me.isSoftWrapped=!0,Me=mt,z.push(Me),Ae=E)}let Gt=Me.glyphAt(Me.count);Gt.glyphObj=ce,Gt.x=_e+ge,Gt.y=pt,Gt.width=sn,Gt.charIndex=At,Gt.fontData=Te,ht===`
`&&(Me=new d,z.push(Me),ge=-(_e+sn+S*y)+I)}),Fe=Ze+Be.advanceWidth*Ye+S*y});let D=0;z.forEach(we=>{let Pe=!0;for(let ie=we.count;ie--;){const We=we.glyphAt(ie);Pe&&!We.glyphObj.isWhitespace&&(we.width=We.x+We.width,we.width>Ae&&(Ae=we.width),Pe=!1);let{lineHeight:qe,capHeight:Je,xHeight:X,baseline:Ce}=We.fontData;qe>we.lineHeight&&(we.lineHeight=qe);const Te=Ce-we.baseline;Te<0&&(we.baseline+=Te,we.cap+=Te,we.ex+=Te),we.cap=Math.max(we.cap,we.baseline+Je),we.ex=Math.max(we.ex,we.baseline+X)}we.baseline-=D,we.cap-=D,we.ex-=D,D+=we.lineHeight});let U=0,J=0;if(k&&(typeof k=="number"?U=-k:typeof k=="string"&&(U=-Ae*(k==="left"?0:k==="center"?.5:k==="right"?1:c(k)))),P&&(typeof P=="number"?J=-P:typeof P=="string"&&(J=P==="top"?0:P==="top-baseline"?-z[0].baseline:P==="top-cap"?-z[0].cap:P==="top-ex"?-z[0].ex:P==="middle"?D/2:P==="bottom"?D:P==="bottom-baseline"?-z[z.length-1].baseline:c(P)*D)),!F){const we=e.getEmbeddingLevels(p,M);W=new Uint16Array(Ee),le=new Uint8Array(Ee),K=new Float32Array(Ee*2),pe={},Z=[1/0,1/0,-1/0,-1/0],oe=[],_&&(ve=new Float32Array(p.length*4)),j&&(se=new Uint8Array(Ee*3));let Pe=0,ie=-1,We=-1,qe,Je;if(z.forEach((X,Ce)=>{let{count:Te,width:Ye}=X;if(Te>0){let Ne=0;for(let At=Te;At--&&X.glyphAt(At).glyphObj.isWhitespace;)Ne++;let Ze=0,Be=0;if(T==="center")Ze=(Ae-Ye)/2;else if(T==="right")Ze=Ae-Ye;else if(T==="justify"&&X.isSoftWrapped){let At=0;for(let ht=Te-Ne;ht--;)X.glyphAt(ht).glyphObj.isWhitespace&&At++;Be=(Ae-Ye)/At}if(Be||Ze){let At=0;for(let ht=0;ht<Te;ht++){let sn=X.glyphAt(ht);const Ut=sn.glyphObj;sn.x+=Ze+At,Be!==0&&Ut.isWhitespace&&ht<Te-Ne&&(At+=Be,sn.width+=Be)}}const ce=e.getReorderSegments(p,we,X.glyphAt(0).charIndex,X.glyphAt(X.count-1).charIndex);for(let At=0;At<ce.length;At++){const[ht,sn]=ce[At];let Ut=1/0,mt=-1/0;for(let Gt=0;Gt<Te;Gt++)if(X.glyphAt(Gt).charIndex>=ht){let Bn=Gt,Ln=Gt;for(;Ln<Te;Ln++){let un=X.glyphAt(Ln);if(un.charIndex>sn)break;Ln<Te-Ne&&(Ut=Math.min(Ut,un.x),mt=Math.max(mt,un.x+un.width))}for(let un=Bn;un<Ln;un++){const vi=X.glyphAt(un);vi.x=mt-(vi.x+vi.width-Ut)}break}}let _e;const pt=At=>_e=At;for(let At=0;At<Te;At++){const ht=X.glyphAt(At);_e=ht.glyphObj;const sn=_e.index,Ut=we.levels[ht.charIndex]&1;if(Ut){const mt=e.getMirroredCharacter(p[ht.charIndex]);mt&&ht.fontData.fontObj.forEachGlyph(mt,0,0,pt)}if(_){const{charIndex:mt,fontData:Gt}=ht,Bn=ht.x+U,Ln=ht.x+ht.width+U;ve[mt*4]=Ut?Ln:Bn,ve[mt*4+1]=Ut?Bn:Ln,ve[mt*4+2]=X.baseline+Gt.caretBottom+J,ve[mt*4+3]=X.baseline+Gt.caretTop+J;const un=mt-ie;un>1&&u(ve,ie,un),ie=mt}if(j){const{charIndex:mt}=ht;for(;mt>We;)We++,j.hasOwnProperty(We)&&(Je=j[We])}if(!_e.isWhitespace&&!_e.isEmpty){const mt=Pe++,{fontSizeMult:Gt,src:Bn,index:Ln}=ht.fontData,un=pe[Bn]||(pe[Bn]={});un[sn]||(un[sn]={path:_e.path,pathBounds:[_e.xMin,_e.yMin,_e.xMax,_e.yMax]});const vi=ht.x+U,V=ht.y+X.baseline+J;K[mt*2]=vi,K[mt*2+1]=V;const ue=vi+_e.xMin*Gt,xe=V+_e.yMin*Gt,me=vi+_e.xMax*Gt,fe=V+_e.yMax*Gt;ue<Z[0]&&(Z[0]=ue),xe<Z[1]&&(Z[1]=xe),me>Z[2]&&(Z[2]=me),fe>Z[3]&&(Z[3]=fe),mt%G===0&&(qe={start:mt,end:mt,rect:[1/0,1/0,-1/0,-1/0]},oe.push(qe)),qe.end++;const it=qe.rect;if(ue<it[0]&&(it[0]=ue),xe<it[1]&&(it[1]=xe),me>it[2]&&(it[2]=me),fe>it[3]&&(it[3]=fe),W[mt]=sn,le[mt]=Ln,j){const ct=mt*3;se[ct]=Je>>16&255,se[ct+1]=Je>>8&255,se[ct+2]=Je&255}}}}}),ve){const X=p.length-ie;X>1&&u(ve,ie,X)}}const be=[];ke.forEach(({index:we,src:Pe,unitsPerEm:ie,ascender:We,descender:qe,lineHeight:Je,capHeight:X,xHeight:Ce})=>{be[we]={src:Pe,unitsPerEm:ie,ascender:We,descender:qe,lineHeight:Je,capHeight:X,xHeight:Ce}}),q.typesetting=h()-ye,L({glyphIds:W,glyphFontIndices:le,glyphPositions:K,glyphData:pe,fontData:be,caretPositions:ve,glyphColors:se,chunkedBounds:oe,fontSize:y,topBaseline:J+z[0].baseline,blockBounds:[U,J-D,U+Ae,J],visibleBounds:Z,timings:q})})}function l(p,m){o({...p,metricsOnly:!0},g=>{const[v,y,w,x]=g.blockBounds;m({width:w-v,height:x-y})})}function c(p){let m=p.match(/^([\d.]+)%$/),g=m?parseFloat(m[1]):NaN;return isNaN(g)?0:g/100}function u(p,m,g){const v=p[m*4],y=p[m*4+1],w=p[m*4+2],x=p[m*4+3],S=(y-v)/g;for(let b=0;b<g;b++){const E=(m+b)*4;p[E]=v+S*b,p[E+1]=v+S*(b+1),p[E+2]=w,p[E+3]=x}}function h(){return(self.performance||Date).now()}function d(){this.data=[]}const f=["glyphObj","x","y","width","charIndex","fontData"];return d.prototype={width:0,lineHeight:0,baseline:0,cap:0,ex:0,isSoftWrapped:!1,get count(){return Math.ceil(this.data.length/f.length)},glyphAt(p){let m=d.flyweight;return m.data=this.data,m.index=p,m},splitAt(p){let m=new d;return m.data=this.data.splice(p*f.length),m}},d.flyweight=f.reduce((p,m,g,v)=>(Object.defineProperty(p,m,{get(){return this.data[this.index*f.length+g]},set(y){this.data[this.index*f.length+g]=y}}),p),{data:null,index:0}),{typeset:o,measure:l}}const Ja=()=>(self.performance||Date).now(),Wf=IM();let Hx;function WL(a,e,t,n,i,r,s,o,l,c,u=!0){return u?JL(a,e,t,n,i,r,s,o,l,c).then(null,h=>(Hx||(console.warn("WebGL SDF generation failed, falling back to JS",h),Hx=!0),Vx(a,e,t,n,i,r,s,o,l,c))):Vx(a,e,t,n,i,r,s,o,l,c)}const Nd=[],XL=5;let dg=0;function RM(){const a=Ja();for(;Nd.length&&Ja()-a<XL;)Nd.shift()();dg=Nd.length?setTimeout(RM,0):0}const JL=(...a)=>new Promise((e,t)=>{Nd.push(()=>{const n=Ja();try{Wf.webgl.generateIntoCanvas(...a),e({timing:Ja()-n})}catch(i){t(i)}}),dg||(dg=setTimeout(RM,0))}),ZL=4,KL=2e3,Gx={};let YL=0;function Vx(a,e,t,n,i,r,s,o,l,c){const u="TroikaTextSDFGenerator_JS_"+YL++%ZL;let h=Gx[u];return h||(h=Gx[u]={workerModule:Bl({name:u,workerId:u,dependencies:[IM,Ja],init(d,f){const p=d().javascript.generate;return function(...m){const g=f();return{textureData:p(...m),timing:f()-g}}},getTransferables(d){return[d.textureData.buffer]}}),requests:0,idleTimer:null}),h.requests++,clearTimeout(h.idleTimer),h.workerModule(a,e,t,n,i,r).then(({textureData:d,timing:f})=>{const p=Ja(),m=new Uint8Array(d.length*4);for(let g=0;g<d.length;g++)m[g*4+c]=d[g];return Wf.webglUtils.renderImageData(s,m,o,l,a,e,1<<3-c),f+=Ja()-p,--h.requests===0&&(h.idleTimer=setTimeout(()=>{LL(u)},KL)),{timing:f}})}function qL(a){a._warm||(Wf.webgl.isSupported(a),a._warm=!0)}const _L=Wf.webglUtils.resizeWebGLCanvasWithoutClearing,dc={unicodeFontsURL:null,sdfGlyphSize:64,sdfMargin:1/16,sdfExponent:9,textureWidth:2048},$L=new Ie;function Ho(){return(self.performance||Date).now()}const jx=Object.create(null);function ez(a,e){a=nz({},a);const t=Ho(),n=[];if(a.font&&n.push({label:"user",src:iz(a.font)}),a.font=n,a.text=""+a.text,a.sdfGlyphSize=a.sdfGlyphSize||dc.sdfGlyphSize,a.unicodeFontsURL=a.unicodeFontsURL||dc.unicodeFontsURL,a.colorRanges!=null){let d={};for(let f in a.colorRanges)if(a.colorRanges.hasOwnProperty(f)){let p=a.colorRanges[f];typeof p!="number"&&(p=$L.set(p).getHex()),d[f]=p}a.colorRanges=d}Object.freeze(a);const{textureWidth:i,sdfExponent:r}=dc,{sdfGlyphSize:s}=a,o=i/s*4;let l=jx[s];if(!l){const d=document.createElement("canvas");d.width=i,d.height=s*256/o,l=jx[s]={glyphCount:0,sdfGlyphSize:s,sdfCanvas:d,sdfTexture:new bn(d,void 0,void 0,void 0,St,St),contextLost:!1,glyphsByFont:new Map},l.sdfTexture.generateMipmaps=!1,tz(l)}const{sdfTexture:c,sdfCanvas:u}=l;OM(a).then(d=>{const{glyphIds:f,glyphFontIndices:p,fontData:m,glyphPositions:g,fontSize:v,timings:y}=d,w=[],x=new Float32Array(f.length*4);let S=0,b=0;const E=Ho(),M=m.map(k=>{let P=l.glyphsByFont.get(k.src);return P||l.glyphsByFont.set(k.src,P=new Map),P});f.forEach((k,P)=>{const F=p[P],{src:N,unitsPerEm:Y}=m[F];let _=M[F].get(k);if(!_){const{path:q,pathBounds:$}=d.glyphData[N][k],ee=Math.max($[2]-$[0],$[3]-$[1])/s*(dc.sdfMargin*s+.5),W=l.glyphCount++,le=[$[0]-ee,$[1]-ee,$[2]+ee,$[3]+ee];M[F].set(k,_={path:q,atlasIndex:W,sdfViewBox:le}),w.push(_)}const{sdfViewBox:G}=_,j=g[b++],L=g[b++],H=v/Y;x[S++]=j+G[0]*H,x[S++]=L+G[1]*H,x[S++]=j+G[2]*H,x[S++]=L+G[3]*H,f[P]=_.atlasIndex}),y.quads=(y.quads||0)+(Ho()-E);const T=Ho();y.sdf={};const I=u.height,O=Math.ceil(l.glyphCount/o),R=Math.pow(2,Math.ceil(Math.log2(O*s)));R>I&&(console.info(`Increasing SDF texture size ${I}->${R}`),_L(u,i,R),c.dispose()),Promise.all(w.map(k=>PM(k,l,a.gpuAccelerateSDF).then(({timing:P})=>{y.sdf[k.atlasIndex]=P}))).then(()=>{w.length&&!l.contextLost&&(DM(l),c.needsUpdate=!0),y.sdfTotal=Ho()-T,y.total=Ho()-t,e(Object.freeze({parameters:a,sdfTexture:c,sdfGlyphSize:s,sdfExponent:r,glyphBounds:x,glyphAtlasIndices:f,glyphColors:d.glyphColors,caretPositions:d.caretPositions,chunkedBounds:d.chunkedBounds,ascender:d.ascender,descender:d.descender,lineHeight:d.lineHeight,capHeight:d.capHeight,xHeight:d.xHeight,topBaseline:d.topBaseline,blockBounds:d.blockBounds,visibleBounds:d.visibleBounds,timings:d.timings}))})}),Promise.resolve().then(()=>{l.contextLost||qL(u)})}function PM({path:a,atlasIndex:e,sdfViewBox:t},{sdfGlyphSize:n,sdfCanvas:i,contextLost:r},s){if(r)return Promise.resolve({timing:-1});const{textureWidth:o,sdfExponent:l}=dc,c=Math.max(t[2]-t[0],t[3]-t[1]),u=Math.floor(e/4),h=u%(o/n)*n,d=Math.floor(u/(o/n))*n,f=e%4;return WL(n,n,a,t,c,l,i,h,d,f,s)}function tz(a){const e=a.sdfCanvas;e.addEventListener("webglcontextlost",t=>{console.log("Context Lost",t),t.preventDefault(),a.contextLost=!0}),e.addEventListener("webglcontextrestored",t=>{console.log("Context Restored",t),a.contextLost=!1;const n=[];a.glyphsByFont.forEach(i=>{i.forEach(r=>{n.push(PM(r,a,!0))})}),Promise.all(n).then(()=>{DM(a),a.sdfTexture.needsUpdate=!0})})}function nz(a,e){for(let t in e)e.hasOwnProperty(t)&&(a[t]=e[t]);return a}let Kh;function iz(a){return Kh||(Kh=typeof document>"u"?{}:document.createElement("a")),Kh.href=a,Kh.href}function DM(a){if(typeof createImageBitmap!="function"){console.info("Safari<15: applying SDF canvas workaround");const{sdfCanvas:e,sdfTexture:t}=a,{width:n,height:i}=e,r=a.sdfCanvas.getContext("webgl");let s=t.image.data;(!s||s.length!==n*i*4)&&(s=new Uint8Array(n*i*4),t.image={width:n,height:i,data:s},t.flipY=!1,t.isDataTexture=!0),r.readPixels(0,0,n,i,r.RGBA,r.UNSIGNED_BYTE,s)}}const rz=Bl({name:"Typesetter",dependencies:[QL,jL,NL],init(a,e,t){return a(e,t())}}),OM=Bl({name:"Typesetter",dependencies:[rz],init(a){return function(e){return new Promise(t=>{a.typeset(e,t)})}},getTransferables(a){const e=[];for(let t in a)a[t]&&a[t].buffer&&e.push(a[t].buffer);return e}});OM.onMainThread;const Qx={};function sz(a){let e=Qx[a];return e||(e=Qx[a]=new Hi(1,1,a,a).translate(.5,.5,0)),e}const kd="aTroikaGlyphBounds",Cc="aTroikaGlyphIndex",az="aTroikaGlyphColor";class oz extends Qu{constructor(){super(),this.detail=1,this.curveRadius=0,this.groups=[{start:0,count:1/0,materialIndex:0},{start:0,count:1/0,materialIndex:1}],this.boundingSphere=new rn,this.boundingBox=new He}computeBoundingSphere(){}computeBoundingBox(){}set detail(e){if(e!==this._detail){this._detail=e,(typeof e!="number"||e<1)&&(e=1);let t=sz(e);["position","normal","uv"].forEach(n=>{this.attributes[n]=t.attributes[n].clone()}),this.setIndex(t.getIndex().clone())}}get detail(){return this._detail}set curveRadius(e){e!==this._curveRadius&&(this._curveRadius=e,this._updateBounds())}get curveRadius(){return this._curveRadius}updateGlyphs(e,t,n,i,r){this.updateAttributeData(kd,e,4),this.updateAttributeData(Cc,t,1),this.updateAttributeData(az,r,3),this._blockBounds=n,this._chunkedBounds=i,this.instanceCount=t.length,this._updateBounds()}_updateBounds(){const e=this._blockBounds;if(e){const{curveRadius:t,boundingBox:n}=this;if(t){const{PI:i,floor:r,min:s,max:o,sin:l,cos:c}=Math,u=i/2,h=i*2,d=Math.abs(t),f=e[0]/d,p=e[2]/d,m=r((f+u)/h)!==r((p+u)/h)?-d:s(l(f)*d,l(p)*d),g=r((f-u)/h)!==r((p-u)/h)?d:o(l(f)*d,l(p)*d),v=r((f+i)/h)!==r((p+i)/h)?d*2:o(d-c(f)*d,d-c(p)*d);n.min.set(m,e[1],t<0?-v:0),n.max.set(g,e[3],t<0?0:v)}else n.min.set(e[0],e[1],0),n.max.set(e[2],e[3],0);n.getBoundingSphere(this.boundingSphere)}}applyClipRect(e){let t=this.getAttribute(Cc).count,n=this._chunkedBounds;if(n)for(let i=n.length;i--;){t=n[i].end;let r=n[i].rect;if(r[1]<e.w&&r[3]>e.y&&r[0]<e.z&&r[2]>e.x)break}this.instanceCount=t}updateAttributeData(e,t,n){const i=this.getAttribute(e);t?i&&i.array.length===t.length?(i.array.set(t),i.needsUpdate=!0):(this.setAttribute(e,new yr(t,n)),delete this._maxInstanceCount,this.dispose()):i&&this.deleteAttribute(e)}}const lz=`
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaEdgeOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`,cz=`
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`,uz=`
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaEdgeOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`,hz=`
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;function _d(a){const e=so(a,{chained:!0,extensions:{derivatives:!0},uniforms:{uTroikaSDFTexture:{value:null},uTroikaSDFTextureSize:{value:new te},uTroikaSDFGlyphSize:{value:0},uTroikaSDFExponent:{value:0},uTroikaTotalBounds:{value:new lt(0,0,0,0)},uTroikaClipRect:{value:new lt(0,0,0,0)},uTroikaEdgeOffset:{value:0},uTroikaFillOpacity:{value:1},uTroikaPositionOffset:{value:new te},uTroikaCurveRadius:{value:0},uTroikaBlurRadius:{value:0},uTroikaStrokeWidth:{value:0},uTroikaStrokeColor:{value:new Ie},uTroikaStrokeOpacity:{value:1},uTroikaOrient:{value:new Kt},uTroikaUseGlyphColors:{value:!0},uTroikaSDFDebug:{value:!1}},vertexDefs:lz,vertexTransform:cz,fragmentDefs:uz,fragmentColorTransform:hz,customRewriter({vertexShader:t,fragmentShader:n}){let i=/\buniform\s+vec3\s+diffuse\b/;return i.test(n)&&(n=n.replace(i,"varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g,"vTroikaGlyphColor"),i.test(t)||(t=t.replace(TM,`uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`))),{vertexShader:t,fragmentShader:n}}});return e.transparent=!0,e.forceSinglePass=!0,Object.defineProperties(e,{isTroikaTextMaterial:{value:!0},shadowSide:{get(){return this.side},set(){}}}),e}const $v=new ti({color:16777215,side:yt,transparent:!0}),Wx=8421504,Xx=new ae,Yh=new A,em=new A,$l=[],dz=new A,tm="+x+y";function Jx(a){return Array.isArray(a)?a[0]:a}let BM=()=>{const a=new Ve(new Hi(1,1),$v);return BM=()=>a,a},LM=()=>{const a=new Ve(new Hi(1,1,32,1),$v);return LM=()=>a,a};const fz={type:"syncstart"},pz={type:"synccomplete"},zM=["font","fontSize","fontStyle","fontWeight","lang","letterSpacing","lineHeight","maxWidth","overflowWrap","text","direction","textAlign","textIndent","whiteSpace","anchorX","anchorY","colorRanges","sdfGlyphSize"],mz=zM.concat("material","color","depthOffset","clipRect","curveRadius","orientation","glyphGeometryDetail");class Za extends Ve{constructor(){const e=new oz;super(e,null),this.text="",this.anchorX=0,this.anchorY=0,this.curveRadius=0,this.direction="auto",this.font=null,this.unicodeFontsURL=null,this.fontSize=.1,this.fontWeight="normal",this.fontStyle="normal",this.lang=null,this.letterSpacing=0,this.lineHeight="normal",this.maxWidth=1/0,this.overflowWrap="normal",this.textAlign="left",this.textIndent=0,this.whiteSpace="normal",this.material=null,this.color=null,this.colorRanges=null,this.outlineWidth=0,this.outlineColor=0,this.outlineOpacity=1,this.outlineBlur=0,this.outlineOffsetX=0,this.outlineOffsetY=0,this.strokeWidth=0,this.strokeColor=Wx,this.strokeOpacity=1,this.fillOpacity=1,this.depthOffset=0,this.clipRect=null,this.orientation=tm,this.glyphGeometryDetail=1,this.sdfGlyphSize=null,this.gpuAccelerateSDF=!0,this.debugSDF=!1}sync(e){this._needsSync&&(this._needsSync=!1,this._isSyncing?(this._queuedSyncs||(this._queuedSyncs=[])).push(e):(this._isSyncing=!0,this.dispatchEvent(fz),ez({text:this.text,font:this.font,lang:this.lang,fontSize:this.fontSize||.1,fontWeight:this.fontWeight||"normal",fontStyle:this.fontStyle||"normal",letterSpacing:this.letterSpacing||0,lineHeight:this.lineHeight||"normal",maxWidth:this.maxWidth,direction:this.direction||"auto",textAlign:this.textAlign,textIndent:this.textIndent,whiteSpace:this.whiteSpace,overflowWrap:this.overflowWrap,anchorX:this.anchorX,anchorY:this.anchorY,colorRanges:this.colorRanges,includeCaretPositions:!0,sdfGlyphSize:this.sdfGlyphSize,gpuAccelerateSDF:this.gpuAccelerateSDF,unicodeFontsURL:this.unicodeFontsURL},t=>{this._isSyncing=!1,this._textRenderInfo=t,this.geometry.updateGlyphs(t.glyphBounds,t.glyphAtlasIndices,t.blockBounds,t.chunkedBounds,t.glyphColors);const n=this._queuedSyncs;n&&(this._queuedSyncs=null,this._needsSync=!0,this.sync(()=>{n.forEach(i=>i&&i())})),this.dispatchEvent(pz),e&&e()})))}onBeforeRender(e,t,n,i,r,s){this.sync(),r.isTroikaTextMaterial&&this._prepareForRender(r)}dispose(){this.geometry.dispose()}get textRenderInfo(){return this._textRenderInfo||null}createDerivedMaterial(e){return _d(e)}get material(){let e=this._derivedMaterial;const t=this._baseMaterial||this._defaultMaterial||(this._defaultMaterial=$v.clone());if((!e||!e.isDerivedFrom(t))&&(e=this._derivedMaterial=this.createDerivedMaterial(t),t.addEventListener("dispose",function n(){t.removeEventListener("dispose",n),e.dispose()})),this.hasOutline()){let n=e._outlineMtl;return n||(n=e._outlineMtl=Object.create(e,{id:{value:e.id+.1}}),n.isTextOutlineMaterial=!0,n.depthWrite=!1,n.map=null,e.addEventListener("dispose",function i(){e.removeEventListener("dispose",i),n.dispose()})),[n,e]}else return e}set material(e){e&&e.isTroikaTextMaterial?(this._derivedMaterial=e,this._baseMaterial=e.baseMaterial):this._baseMaterial=e}hasOutline(){return!!(this.outlineWidth||this.outlineBlur||this.outlineOffsetX||this.outlineOffsetY)}get glyphGeometryDetail(){return this.geometry.detail}set glyphGeometryDetail(e){this.geometry.detail=e}get curveRadius(){return this.geometry.curveRadius}set curveRadius(e){this.geometry.curveRadius=e}get customDepthMaterial(){return Jx(this.material).getDepthMaterial()}set customDepthMaterial(e){}get customDistanceMaterial(){return Jx(this.material).getDistanceMaterial()}set customDistanceMaterial(e){}_prepareForRender(e){const t=e.isTextOutlineMaterial,n=e.uniforms,i=this.textRenderInfo;if(i){const{sdfTexture:o,blockBounds:l}=i;n.uTroikaSDFTexture.value=o,n.uTroikaSDFTextureSize.value.set(o.image.width,o.image.height),n.uTroikaSDFGlyphSize.value=i.sdfGlyphSize,n.uTroikaSDFExponent.value=i.sdfExponent,n.uTroikaTotalBounds.value.fromArray(l),n.uTroikaUseGlyphColors.value=!t&&!!i.glyphColors;let c=0,u=0,h=0,d,f,p,m=0,g=0;if(t){let{outlineWidth:y,outlineOffsetX:w,outlineOffsetY:x,outlineBlur:S,outlineOpacity:b}=this;c=this._parsePercent(y)||0,u=Math.max(0,this._parsePercent(S)||0),d=b,m=this._parsePercent(w)||0,g=this._parsePercent(x)||0}else h=Math.max(0,this._parsePercent(this.strokeWidth)||0),h&&(p=this.strokeColor,n.uTroikaStrokeColor.value.set(p??Wx),f=this.strokeOpacity,f==null&&(f=1)),d=this.fillOpacity;n.uTroikaEdgeOffset.value=c,n.uTroikaPositionOffset.value.set(m,g),n.uTroikaBlurRadius.value=u,n.uTroikaStrokeWidth.value=h,n.uTroikaStrokeOpacity.value=f,n.uTroikaFillOpacity.value=d??1,n.uTroikaCurveRadius.value=this.curveRadius||0;let v=this.clipRect;if(v&&Array.isArray(v)&&v.length===4)n.uTroikaClipRect.value.fromArray(v);else{const y=(this.fontSize||.1)*100;n.uTroikaClipRect.value.set(l[0]-y,l[1]-y,l[2]+y,l[3]+y)}this.geometry.applyClipRect(n.uTroikaClipRect.value)}n.uTroikaSDFDebug.value=!!this.debugSDF,e.polygonOffset=!!this.depthOffset,e.polygonOffsetFactor=e.polygonOffsetUnits=this.depthOffset||0;const r=t?this.outlineColor||0:this.color;if(r==null)delete e.color;else{const o=e.hasOwnProperty("color")?e.color:e.color=new Ie;(r!==o._input||typeof r=="object")&&o.set(o._input=r)}let s=this.orientation||tm;if(s!==e._orientation){let o=n.uTroikaOrient.value;s=s.replace(/[^-+xyz]/g,"");let l=s!==tm&&s.match(/^([-+])([xyz])([-+])([xyz])$/);if(l){let[,c,u,h,d]=l;Yh.set(0,0,0)[u]=c==="-"?1:-1,em.set(0,0,0)[d]=h==="-"?-1:1,Xx.lookAt(dz,Yh.cross(em),em),o.setFromMatrix4(Xx)}else o.identity();e._orientation=s}}_parsePercent(e){if(typeof e=="string"){let t=e.match(/^(-?[\d.]+)%$/),n=t?parseFloat(t[1]):NaN;e=(isNaN(n)?0:n/100)*this.fontSize}return e}localPositionToTextCoords(e,t=new te){t.copy(e);const n=this.curveRadius;return n&&(t.x=Math.atan2(e.x,Math.abs(n)-Math.abs(e.z))*Math.abs(n)),t}worldPositionToTextCoords(e,t=new te){return Yh.copy(e),this.localPositionToTextCoords(this.worldToLocal(Yh),t)}raycast(e,t){const{textRenderInfo:n,curveRadius:i}=this;if(n){const r=n.blockBounds,s=i?LM():BM(),o=s.geometry,{position:l,uv:c}=o.attributes;for(let u=0;u<c.count;u++){let h=r[0]+c.getX(u)*(r[2]-r[0]);const d=r[1]+c.getY(u)*(r[3]-r[1]);let f=0;i&&(f=i-Math.cos(h/i)*i,h=Math.sin(h/i)*i),l.setXYZ(u,h,d,f)}o.boundingSphere=this.geometry.boundingSphere,o.boundingBox=this.geometry.boundingBox,s.matrixWorld=this.matrixWorld,s.material.side=this.material.side,$l.length=0,s.raycast(e,$l);for(let u=0;u<$l.length;u++)$l[u].object=this,t.push($l[u])}}copy(e){const t=this.geometry;return super.copy(e),this.geometry=t,mz.forEach(n=>{this[n]=e[n]}),this}clone(){return new this.constructor().copy(this)}}zM.forEach(a=>{const e="_private_"+a;Object.defineProperty(Za.prototype,a,{get(){return this[e]},set(t){t!==this[e]&&(this[e]=t,this._needsSync=!0)}})});const gz={type:"syncstart"},vz={type:"synccomplete"},$o="aTroikaTextBatchMemberIndex",fg=32,Zx=new He,Kx=new Ie;class e0 extends Za{constructor(){super(),this._members=new Map,this._dataTextures={},this._onMemberSynced=e=>{this._members.get(e.target).dirty=!0}}add(...e){for(let t=0;t<e.length;t++)e[t]instanceof Za?this.addText(e[t]):super.add(e[t]);return this}remove(...e){for(let t=0;t<e.length;t++)e[t]instanceof Za?this.removeText(e[t]):super.remove(e[t]);return this}addText(e){this._members.has(e)||(this._members.set(e,{index:-1,glyphCount:-1,dirty:!0}),e.addEventListener("synccomplete",this._onMemberSynced))}removeText(e){this._needsRepack=!0,e.removeEventListener("synccomplete",this._onMemberSynced),this._members.delete(e)}createDerivedMaterial(e){return yz(e)}updateMatrixWorld(e){super.updateMatrixWorld(e),this.updateBounds()}updateBounds(){const e=this.geometry.boundingBox.makeEmpty();this._members.forEach((t,n)=>{n.matrixAutoUpdate&&n.updateMatrix(),Zx.copy(n.geometry.boundingBox).applyMatrix4(n.matrix),e.union(Zx)}),e.getBoundingSphere(this.geometry.boundingSphere)}hasOutline(){for(let e of this._members.keys())if(e.hasOutline())return!0;return!1}_prepareForRender(e){const t=e.isTextOutlineMaterial;e.uniforms.uTroikaIsOutline.value=t;let n=this._dataTextures[t?"outline":"main"];const i=Math.pow(2,Math.ceil(Math.log2(this._members.size*fg)));if(!n||i!==n.image.data.length){n&&n.dispose();const o=Math.min(i/4,1024);n=this._dataTextures[t?"outline":"main"]=new Yi(new Float32Array(i),o,i/4/o,Hn,Dn)}const r=n.image.data,s=(o,l)=>{l!==r[o]&&(r[o]=l,n.needsUpdate=!0)};this._members.forEach(({index:o,dirty:l},c)=>{if(o>-1){const u=o*fg,h=c.matrix.elements;for(let E=0;E<16;E++)s(u+E,h[E]);c._prepareForRender(e);const{uTroikaTotalBounds:d,uTroikaClipRect:f,uTroikaPositionOffset:p,uTroikaEdgeOffset:m,uTroikaBlurRadius:g,uTroikaStrokeWidth:v,uTroikaStrokeColor:y,uTroikaStrokeOpacity:w,uTroikaFillOpacity:x,uTroikaCurveRadius:S}=e.uniforms;for(let E=0;E<4;E++)s(u+16+E,d.value.getComponent(E));for(let E=0;E<4;E++)s(u+20+E,f.value.getComponent(E));let b=t?c.outlineColor||0:c.color;b==null&&(b=this.color),b==null&&(b=this.material.color),b==null&&(b=16777215),s(u+24,Kx.set(b).getHex()),s(u+25,x.value),s(u+26,S.value),t?(s(u+28,p.value.x),s(u+29,p.value.y),s(u+30,m.value),s(u+31,g.value)):(s(u+28,v.value),s(u+29,Kx.set(y.value).getHex()),s(u+30,w.value))}}),e.setMatrixTexture(n),super._prepareForRender(e)}sync(e){let t=this._needsRepack?[]:null;this._needsRepack=!1,this._members.forEach((n,i)=>{(n.dirty||i._needsSync)&&(n.dirty=!1,(t||(t=[])).push(new Promise(r=>{i._needsSync?i.sync(r):r()})))}),t&&(this.dispatchEvent(gz),Promise.all(t).then(()=>{const{geometry:n}=this,i=n.attributes;let r=i[$o]&&i[$o].array||new Uint16Array(0),s=i[Cc]&&i[Cc].array||new Float32Array(0),o=i[kd]&&i[kd].array||new Float32Array(0),l=0;this._members.forEach((h,{textRenderInfo:d})=>{d&&(l+=d.glyphAtlasIndices.length,this._textRenderInfo=d)}),l!==r.length&&(r=nm(r,l),s=nm(s,l),o=nm(o,l*4));let c=0,u=0;this._members.forEach((h,{textRenderInfo:d})=>{if(d){const f=d.glyphAtlasIndices.length;r.fill(c,u,u+f),s.set(d.glyphAtlasIndices,u,u+f),o.set(d.glyphBounds,u*4,(u+f)*4),u+=f,h.index=c++}}),n.updateAttributeData($o,r,1),n.getAttribute($o).setUsage(Xn),n.updateAttributeData(Cc,s,1),n.updateAttributeData(kd,o,4),this.updateBounds(),this.dispatchEvent(vz),e&&e()}))}copy(e){return e instanceof e0&&(super.copy(e),this._members.forEach((t,n)=>this.removeText(n)),e._members.forEach((t,n)=>this.addText(n))),this}dispose(){super.dispose(),Object.values(this._dataTextures).forEach(e=>e.dispose())}}function nm(a,e){const t=new a.constructor(e);return t.set(a.subarray(0,e)),t}function yz(a){const e="uTroikaMatricesTexture",t="uTroikaMatricesTextureSize";let n=so(a,{chained:!0,uniforms:{[t]:{value:new te},[e]:{value:null}},vertexDefs:`
      uniform highp sampler2D ${e};
      uniform vec2 ${t};
      attribute float ${$o};

      vec4 troikaBatchTexel(float offset) {
        offset += ${$o} * ${fg.toFixed(1)} / 4.0;
        float w = ${t}.x;
        vec2 uv = (vec2(mod(offset, w), floor(offset / w)) + 0.5) / ${t};
        return texture2D(${e}, uv);
      }
    `,vertexTransform:`
      mat4 matrix = mat4(
        troikaBatchTexel(0.0),
        troikaBatchTexel(1.0),
        troikaBatchTexel(2.0),
        troikaBatchTexel(3.0)
      );
      position.xyz = (matrix * vec4(position, 1.0)).xyz;
    `});return n=_d(n),n=so(n,{chained:!0,uniforms:{uTroikaIsOutline:{value:!1}},customRewriter(i){return["uTroikaTotalBounds","uTroikaClipRect","uTroikaPositionOffset","uTroikaEdgeOffset","uTroikaBlurRadius","uTroikaStrokeWidth","uTroikaStrokeColor","uTroikaStrokeOpacity","uTroikaFillOpacity","uTroikaCurveRadius","diffuse"].forEach(s=>{i=xz(i,s)}),i},vertexDefs:`
      uniform bool uTroikaIsOutline;
      vec3 troikaFloatToColor(float v) {
        return mod(floor(vec3(v / 65536.0, v / 256.0, v)), 256.0) / 256.0;
      }
    `,vertexTransform:`
      uTroikaTotalBounds = troikaBatchTexel(4.0);
      uTroikaClipRect = troikaBatchTexel(5.0);
      
      vec4 data = troikaBatchTexel(6.0);
      diffuse = troikaFloatToColor(data.x);
      uTroikaFillOpacity = data.y;
      uTroikaCurveRadius = data.z;
      
      data = troikaBatchTexel(7.0);
      if (uTroikaIsOutline) {
        if (data == vec4(0.0)) { // degenerate if zero outline
          position = vec3(0.0);
        } else {
          uTroikaPositionOffset = data.xy;
          uTroikaEdgeOffset = data.z;
          uTroikaBlurRadius = data.w;
        }
      } else {
        uTroikaStrokeWidth = data.x;
        uTroikaStrokeColor = troikaFloatToColor(data.y);
        uTroikaStrokeOpacity = data.z;
      }
    `}),n.setMatrixTexture=i=>{n.uniforms[e].value=i,n.uniforms[t].value.set(i.image.width,i.image.height)},n}function xz({vertexShader:a,fragmentShader:e},t,n=t){const i=new RegExp(`uniform\\s+(bool|float|vec[234]|mat[34])\\s+${t}\\b`);let r,s=!1;e=e.replace(i,(l,c)=>(s=!0,`varying ${r=c} ${n}`));let o=!1;return a=a.replace(i,(l,c)=>(o=!0,`${s?"varying":""} ${r=c} ${n}`)),o||(a=`${s?"varying":""} ${r} ${n};
${a}`),{vertexShader:a,fragmentShader:e}}new Ie;function wz({vertexShader:a,fragmentShader:e},t,n=t){const i=new RegExp(`uniform\\s+(bool|float|vec[234]|mat[34])\\s+${t}\\b`);let r,s=!1;e=e.replace(i,(l,c)=>(s=!0,`varying ${r=c} ${n}`));let o=!1;return a=a.replace(i,(l,c)=>(o=!0,`${s?"varying":""} ${r=c} ${n}`)),o||(a=`${s?"varying":""} ${r} ${n};
${a}`),{vertexShader:a,fragmentShader:e}}const Yx=new He,qh=new A;class la extends Qu{constructor(){super(),this.type="LineSegmentsGeometry";const e=[-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],t=[-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],n=[0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5];this.setIndex(n),this.setAttribute("position",new je(e,3)),this.setAttribute("uv",new je(t,2))}applyMatrix4(e){const t=this.attributes.instanceStart,n=this.attributes.instanceEnd;return t!==void 0&&(t.applyMatrix4(e),n.applyMatrix4(e),t.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}setPositions(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));const n=new no(t,6,1);return this.setAttribute("instanceStart",new Wn(n,3,0)),this.setAttribute("instanceEnd",new Wn(n,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));const n=new no(t,6,1);return this.setAttribute("instanceColorStart",new Wn(n,3,0)),this.setAttribute("instanceColorEnd",new Wn(n,3,3)),this}fromWireframeGeometry(e){return this.setPositions(e.attributes.position.array),this}fromEdgesGeometry(e){return this.setPositions(e.attributes.position.array),this}fromMesh(e){return this.fromWireframeGeometry(new Lf(e.geometry)),this}fromLineSegments(e){const t=e.geometry;if(t.isGeometry){console.error("THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.");return}else t.isBufferGeometry&&this.setPositions(t.attributes.position.array);return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new He);const e=this.attributes.instanceStart,t=this.attributes.instanceEnd;e!==void 0&&t!==void 0&&(this.boundingBox.setFromBufferAttribute(e),Yx.setFromBufferAttribute(t),this.boundingBox.union(Yx))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new rn),this.boundingBox===null&&this.computeBoundingBox();const e=this.attributes.instanceStart,t=this.attributes.instanceEnd;if(e!==void 0&&t!==void 0){const n=this.boundingSphere.center;this.boundingBox.getCenter(n);let i=0;for(let r=0,s=e.count;r<s;r++)qh.fromBufferAttribute(e,r),i=Math.max(i,n.distanceToSquared(qh)),qh.fromBufferAttribute(t,r),i=Math.max(i,n.distanceToSquared(qh));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}applyMatrix(e){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(e)}}la.prototype.isLineSegmentsGeometry=!0;const qx=new A,_x=new A,Jn=new lt,Zn=new lt,Sr=new lt,im=new A,rm=new ae,ci=new Ui,$x=new A,_h=new He,$h=new rn,Mr=new lt;let Dr,pg,NM,Ka;function ew(a,e,t){return Mr.set(0,0,-e,1).applyMatrix4(a.projectionMatrix),Mr.multiplyScalar(1/Mr.w),Mr.x=Ka/t.width,Mr.y=Ka/t.height,Mr.applyMatrix4(a.projectionMatrixInverse),Mr.multiplyScalar(1/Mr.w),Math.abs(Math.max(Mr.x,Mr.y))}function Az(a,e){for(let t=0,n=pg.count;t<n;t++){ci.start.fromBufferAttribute(pg,t),ci.end.fromBufferAttribute(NM,t);const i=new A,r=new A;Dr.distanceSqToSegment(ci.start,ci.end,r,i),r.distanceTo(i)<Ka*.5&&e.push({point:r,pointOnLine:i,distance:Dr.origin.distanceTo(r),object:a,face:null,faceIndex:t,uv:null,uv2:null})}}function Sz(a,e,t){const n=e.projectionMatrix,r=a.material.resolution,s=a.matrixWorld,o=a.geometry,l=o.attributes.instanceStart,c=o.attributes.instanceEnd,u=-e.near;Dr.at(1,Sr),Sr.w=1,Sr.applyMatrix4(e.matrixWorldInverse),Sr.applyMatrix4(n),Sr.multiplyScalar(1/Sr.w),Sr.x*=r.x/2,Sr.y*=r.y/2,Sr.z=0,im.copy(Sr),rm.multiplyMatrices(e.matrixWorldInverse,s);for(let h=0,d=l.count;h<d;h++){if(Jn.fromBufferAttribute(l,h),Zn.fromBufferAttribute(c,h),Jn.w=1,Zn.w=1,Jn.applyMatrix4(rm),Zn.applyMatrix4(rm),Jn.z>u&&Zn.z>u)continue;if(Jn.z>u){const y=Jn.z-Zn.z,w=(Jn.z-u)/y;Jn.lerp(Zn,w)}else if(Zn.z>u){const y=Zn.z-Jn.z,w=(Zn.z-u)/y;Zn.lerp(Jn,w)}Jn.applyMatrix4(n),Zn.applyMatrix4(n),Jn.multiplyScalar(1/Jn.w),Zn.multiplyScalar(1/Zn.w),Jn.x*=r.x/2,Jn.y*=r.y/2,Zn.x*=r.x/2,Zn.y*=r.y/2,ci.start.copy(Jn),ci.start.z=0,ci.end.copy(Zn),ci.end.z=0;const p=ci.closestPointToPointParameter(im,!0);ci.at(p,$x);const m=It.lerp(Jn.z,Zn.z,p),g=m>=-1&&m<=1,v=im.distanceTo($x)<Ka*.5;if(g&&v){ci.start.fromBufferAttribute(l,h),ci.end.fromBufferAttribute(c,h),ci.start.applyMatrix4(s),ci.end.applyMatrix4(s);const y=new A,w=new A;Dr.distanceSqToSegment(ci.start,ci.end,w,y),t.push({point:w,pointOnLine:y,distance:Dr.origin.distanceTo(w),object:a,face:null,faceIndex:h,uv:null,uv2:null})}}}class ao extends Ve{constructor(e=new la,t=new _v({color:Math.random()*16777215})){super(e,t),this.type="LineSegments2"}computeLineDistances(){const e=this.geometry,t=e.attributes.instanceStart,n=e.attributes.instanceEnd,i=new Float32Array(2*t.count);for(let s=0,o=0,l=t.count;s<l;s++,o+=2)qx.fromBufferAttribute(t,s),_x.fromBufferAttribute(n,s),i[o]=o===0?0:i[o-1],i[o+1]=i[o]+qx.distanceTo(_x);const r=new no(i,2,1);return e.setAttribute("instanceDistanceStart",new Wn(r,1,0)),e.setAttribute("instanceDistanceEnd",new Wn(r,1,1)),this}raycast(e,t){const n=this.material.worldUnits,i=e.camera;i===null&&!n&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const r=e.params.Line2!==void 0&&e.params.Line2.threshold||0;Dr=e.ray;const s=this.matrixWorld,o=this.geometry,l=this.material;Ka=l.linewidth+r,pg=o.attributes.instanceStart,NM=o.attributes.instanceEnd,o.boundingSphere===null&&o.computeBoundingSphere(),$h.copy(o.boundingSphere).applyMatrix4(s);let c;if(n)c=Ka*.5;else{const h=Math.max(i.near,$h.distanceToPoint(Dr.origin));c=ew(i,h,l.resolution)}if($h.radius+=c,Dr.intersectsSphere($h)===!1)return;o.boundingBox===null&&o.computeBoundingBox(),_h.copy(o.boundingBox).applyMatrix4(s);let u;if(n)u=Ka*.5;else{const h=Math.max(i.near,_h.distanceToPoint(Dr.origin));u=ew(i,h,l.resolution)}_h.expandByScalar(u),Dr.intersectsBox(_h)!==!1&&(n?Az(this,t):Sz(this,i,t))}}ao.prototype.isLineSegments2=!0;for(let a=0;a<256;a++)(a<16?"0":"")+a.toString(16);const Mz=Math.PI/180;function bz(a,e,t){return(1-t)*a+t*e}function Ez(a,e,t=2){const n=a.length;let i=Tz(a,0,n,t,!0);const r=[];if(!i||i.next===i.prev)return r;let s,o,l;if(a.length>80*t){s=1/0,o=1/0;let c=-1/0,u=-1/0;for(let h=t;h<n;h+=t){const d=a[h],f=a[h+1];d<s&&(s=d),f<o&&(o=f),d>c&&(c=d),f>u&&(u=f)}l=Math.max(c-s,u-o),l=l!==0?32767/l:0}return yu(i,r,t,s,o,l,0),r}function Tz(a,e,t,n,i){let r;if(i===Uz(a,e,t,n)>0)for(let s=e;s<t;s+=n)r=tw(s/n|0,a[s],a[s+1],r);else for(let s=t-n;s>=e;s-=n)r=tw(s/n|0,a[s],a[s+1],r);return r&&Xf(r,r.next)&&(xu(r),r=r.next),r}function vu(a,e){if(!a)return a;e||(e=a);let t=a,n;do if(n=!1,!t.steiner&&(Xf(t,t.next)||Pn(t.prev,t,t.next)===0)){if(xu(t),t=e=t.prev,t===t.next)break;n=!0}else t=t.next;while(n||t!==e);return e}function yu(a,e,t,n,i,r,s){if(!a)return;!s&&r&&Dz(a,n,i,r);let o=a;for(;a.prev!==a.next;){const l=a.prev,c=a.next;if(r?Iz(a,n,i,r):Cz(a)){e.push(l.i,a.i,c.i),xu(a),a=c.next,o=c.next;continue}if(a=c,a===o){s?s===1?(a=Rz(vu(a),e),yu(a,e,t,n,i,r,2)):s===2&&Pz(a,e,t,n,i,r):yu(vu(a),e,t,n,i,r,1);break}}}function Cz(a){const e=a.prev,t=a,n=a.next;if(Pn(e,t,n)>=0)return!1;const i=e.x,r=t.x,s=n.x,o=e.y,l=t.y,c=n.y,u=Math.min(i,r,s),h=Math.min(o,l,c),d=Math.max(i,r,s),f=Math.max(o,l,c);let p=n.next;for(;p!==e;){if(p.x>=u&&p.x<=d&&p.y>=h&&p.y<=f&&fc(i,o,r,l,s,c,p.x,p.y)&&Pn(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}function Iz(a,e,t,n){const i=a.prev,r=a,s=a.next;if(Pn(i,r,s)>=0)return!1;const o=i.x,l=r.x,c=s.x,u=i.y,h=r.y,d=s.y,f=Math.min(o,l,c),p=Math.min(u,h,d),m=Math.max(o,l,c),g=Math.max(u,h,d),v=mg(f,p,e,t,n),y=mg(m,g,e,t,n);let w=a.prevZ,x=a.nextZ;for(;w&&w.z>=v&&x&&x.z<=y;){if(w.x>=f&&w.x<=m&&w.y>=p&&w.y<=g&&w!==i&&w!==s&&fc(o,u,l,h,c,d,w.x,w.y)&&Pn(w.prev,w,w.next)>=0||(w=w.prevZ,x.x>=f&&x.x<=m&&x.y>=p&&x.y<=g&&x!==i&&x!==s&&fc(o,u,l,h,c,d,x.x,x.y)&&Pn(x.prev,x,x.next)>=0))return!1;x=x.nextZ}for(;w&&w.z>=v;){if(w.x>=f&&w.x<=m&&w.y>=p&&w.y<=g&&w!==i&&w!==s&&fc(o,u,l,h,c,d,w.x,w.y)&&Pn(w.prev,w,w.next)>=0)return!1;w=w.prevZ}for(;x&&x.z<=y;){if(x.x>=f&&x.x<=m&&x.y>=p&&x.y<=g&&x!==i&&x!==s&&fc(o,u,l,h,c,d,x.x,x.y)&&Pn(x.prev,x,x.next)>=0)return!1;x=x.nextZ}return!0}function Rz(a,e){let t=a;do{const n=t.prev,i=t.next.next;!Xf(n,i)&&kM(n,t,t.next,i)&&$d(n,i)&&$d(i,n)&&(e.push(n.i,t.i,i.i),xu(t),xu(t.next),t=a=i),t=t.next}while(t!==a);return vu(t)}function Pz(a,e,t,n,i,r){let s=a;do{let o=s.next.next;for(;o!==s.prev;){if(s.i!==o.i&&Lz(s,o)){let l=kz(s,o);s=vu(s,s.next),l=vu(l,l.next),yu(s,e,t,n,i,r,0),yu(l,e,t,n,i,r,0);return}o=o.next}s=s.next}while(s!==a)}function Dz(a,e,t,n){let i=a;do i.z===0&&(i.z=mg(i.x,i.y,e,t,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==a);i.prevZ.nextZ=null,i.prevZ=null,Oz(i)}function Oz(a){let e,t=1;do{let n=a,i;a=null;let r=null;for(e=0;n;){e++;let s=n,o=0;for(let c=0;c<t&&(o++,s=s.nextZ,!!s);c++);let l=t;for(;o>0||l>0&&s;)o!==0&&(l===0||!s||n.z<=s.z)?(i=n,n=n.nextZ,o--):(i=s,s=s.nextZ,l--),r?r.nextZ=i:a=i,i.prevZ=r,r=i;n=s}r.nextZ=null,t*=2}while(e>1);return a}function mg(a,e,t,n,i){return a=(a-t)*i|0,e=(e-n)*i|0,a=(a|a<<8)&16711935,a=(a|a<<4)&252645135,a=(a|a<<2)&858993459,a=(a|a<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,a|e<<1}function Bz(a,e,t,n,i,r,s,o){return(i-s)*(e-o)>=(a-s)*(r-o)&&(a-s)*(n-o)>=(t-s)*(e-o)&&(t-s)*(r-o)>=(i-s)*(n-o)}function fc(a,e,t,n,i,r,s,o){return!(a===s&&e===o)&&Bz(a,e,t,n,i,r,s,o)}function Lz(a,e){return a.next.i!==e.i&&a.prev.i!==e.i&&!zz(a,e)&&($d(a,e)&&$d(e,a)&&Nz(a,e)&&(Pn(a.prev,a,e.prev)||Pn(a,e.prev,e))||Xf(a,e)&&Pn(a.prev,a,a.next)>0&&Pn(e.prev,e,e.next)>0)}function Pn(a,e,t){return(e.y-a.y)*(t.x-e.x)-(e.x-a.x)*(t.y-e.y)}function Xf(a,e){return a.x===e.x&&a.y===e.y}function kM(a,e,t,n){const i=td(Pn(a,e,t)),r=td(Pn(a,e,n)),s=td(Pn(t,n,a)),o=td(Pn(t,n,e));return!!(i!==r&&s!==o||i===0&&ed(a,t,e)||r===0&&ed(a,n,e)||s===0&&ed(t,a,n)||o===0&&ed(t,e,n))}function ed(a,e,t){return e.x<=Math.max(a.x,t.x)&&e.x>=Math.min(a.x,t.x)&&e.y<=Math.max(a.y,t.y)&&e.y>=Math.min(a.y,t.y)}function td(a){return a>0?1:a<0?-1:0}function zz(a,e){let t=a;do{if(t.i!==a.i&&t.next.i!==a.i&&t.i!==e.i&&t.next.i!==e.i&&kM(t,t.next,a,e))return!0;t=t.next}while(t!==a);return!1}function $d(a,e){return Pn(a.prev,a,a.next)<0?Pn(a,e,a.next)>=0&&Pn(a,a.prev,e)>=0:Pn(a,e,a.prev)<0||Pn(a,a.next,e)<0}function Nz(a,e){let t=a,n=!1;const i=(a.x+e.x)/2,r=(a.y+e.y)/2;do t.y>r!=t.next.y>r&&t.next.y!==t.y&&i<(t.next.x-t.x)*(r-t.y)/(t.next.y-t.y)+t.x&&(n=!n),t=t.next;while(t!==a);return n}function kz(a,e){const t=gg(a.i,a.x,a.y),n=gg(e.i,e.x,e.y),i=a.next,r=e.prev;return a.next=e,e.prev=a,t.next=i,i.prev=t,n.next=t,t.prev=n,r.next=n,n.prev=r,n}function tw(a,e,t,n){const i=gg(a,e,t);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function xu(a){a.next.prev=a.prev,a.prev.next=a.next,a.prevZ&&(a.prevZ.nextZ=a.nextZ),a.nextZ&&(a.nextZ.prevZ=a.prevZ)}function gg(a,e,t){return{i:a,x:e,y:t,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}function Uz(a,e,t,n){let i=0;for(let r=e,s=t-n;r<t;r+=n)i+=(a[s]-a[r])*(a[r+1]+a[s+1]),s=r;return i}const t0=0,Fz=1,Hz=2,nw=2,sm=1.25,iw=1,Ud=32,vg=65535,Gz=Math.pow(2,-24);class nd{constructor(){}}function dr(a,e,t){return t.min.x=e[a],t.min.y=e[a+1],t.min.z=e[a+2],t.max.x=e[a+3],t.max.y=e[a+4],t.max.z=e[a+5],t}function rw(a){let e=-1,t=-1/0;for(let n=0;n<3;n++){const i=a[n+3]-a[n];i>t&&(t=i,e=n)}return e}function sw(a,e){e.set(a)}function aw(a,e,t){let n,i;for(let r=0;r<3;r++){const s=r+3;n=a[r],i=e[r],t[r]=n<i?n:i,n=a[s],i=e[s],t[s]=n>i?n:i}}function id(a,e,t){for(let n=0;n<3;n++){const i=e[a+2*n],r=e[a+2*n+1],s=i-r,o=i+r;s<t[n]&&(t[n]=s),o>t[n+3]&&(t[n+3]=o)}}function ec(a){const e=a[3]-a[0],t=a[4]-a[1],n=a[5]-a[2];return 2*(e*t+t*n+n*e)}function Vz(a,e){if(!a.index){const t=a.attributes.position.count,n=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let i;t>65535?i=new Uint32Array(new n(4*t)):i=new Uint16Array(new n(2*t)),a.setIndex(new wt(i,1));for(let r=0;r<t;r++)i[r]=r}}function jz(a){if(!a.groups||!a.groups.length)return[{offset:0,count:a.index.count/3}];const e=[],t=new Set;for(const i of a.groups)t.add(i.start),t.add(i.start+i.count);const n=Array.from(t.values()).sort((i,r)=>i-r);for(let i=0;i<n.length-1;i++){const r=n[i],s=n[i+1];e.push({offset:r/3,count:(s-r)/3})}return e}function am(a,e,t,n,i=null){let r=1/0,s=1/0,o=1/0,l=-1/0,c=-1/0,u=-1/0,h=1/0,d=1/0,f=1/0,p=-1/0,m=-1/0,g=-1/0;const v=i!==null;for(let y=e*6,w=(e+t)*6;y<w;y+=6){const x=a[y+0],S=a[y+1],b=x-S,E=x+S;b<r&&(r=b),E>l&&(l=E),v&&x<h&&(h=x),v&&x>p&&(p=x);const M=a[y+2],T=a[y+3],I=M-T,O=M+T;I<s&&(s=I),O>c&&(c=O),v&&M<d&&(d=M),v&&M>m&&(m=M);const R=a[y+4],k=a[y+5],P=R-k,F=R+k;P<o&&(o=P),F>u&&(u=F),v&&R<f&&(f=R),v&&R>g&&(g=R)}n[0]=r,n[1]=s,n[2]=o,n[3]=l,n[4]=c,n[5]=u,v&&(i[0]=h,i[1]=d,i[2]=f,i[3]=p,i[4]=m,i[5]=g)}function Qz(a,e,t,n){let i=1/0,r=1/0,s=1/0,o=-1/0,l=-1/0,c=-1/0;for(let u=e*6,h=(e+t)*6;u<h;u+=6){const d=a[u+0];d<i&&(i=d),d>o&&(o=d);const f=a[u+2];f<r&&(r=f),f>l&&(l=f);const p=a[u+4];p<s&&(s=p),p>c&&(c=p)}n[0]=i,n[1]=r,n[2]=s,n[3]=o,n[4]=l,n[5]=c}function Wz(a,e,t,n,i){let r=t,s=t+n-1;const o=i.pos,l=i.axis*2;for(;;){for(;r<=s&&e[r*6+l]<o;)r++;for(;r<=s&&e[s*6+l]>=o;)s--;if(r<s){for(let c=0;c<3;c++){let u=a[r*3+c];a[r*3+c]=a[s*3+c],a[s*3+c]=u;let h=e[r*6+c*2+0];e[r*6+c*2+0]=e[s*6+c*2+0],e[s*6+c*2+0]=h;let d=e[r*6+c*2+1];e[r*6+c*2+1]=e[s*6+c*2+1],e[s*6+c*2+1]=d}r++,s--}else return r}}const hs=32,Xz=(a,e)=>a.candidate-e.candidate,Fs=new Array(hs).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),rd=new Float32Array(6);function Jz(a,e,t,n,i,r){let s=-1,o=0;if(r===t0)s=rw(e),s!==-1&&(o=(e[s]+e[s+3])/2);else if(r===Fz)s=rw(a),s!==-1&&(o=Zz(t,n,i,s));else if(r===Hz){const l=ec(a);let c=sm*i;const u=n*6,h=(n+i)*6;for(let d=0;d<3;d++){const f=e[d],g=(e[d+3]-f)/hs;if(i<hs/4){const v=[...Fs];v.length=i;let y=0;for(let x=u;x<h;x+=6,y++){const S=v[y];S.candidate=t[x+2*d],S.count=0;const{bounds:b,leftCacheBounds:E,rightCacheBounds:M}=S;for(let T=0;T<3;T++)M[T]=1/0,M[T+3]=-1/0,E[T]=1/0,E[T+3]=-1/0,b[T]=1/0,b[T+3]=-1/0;id(x,t,b)}v.sort(Xz);let w=i;for(let x=0;x<w;x++){const S=v[x];for(;x+1<w&&v[x+1].candidate===S.candidate;)v.splice(x+1,1),w--}for(let x=u;x<h;x+=6){const S=t[x+2*d];for(let b=0;b<w;b++){const E=v[b];S>=E.candidate?id(x,t,E.rightCacheBounds):(id(x,t,E.leftCacheBounds),E.count++)}}for(let x=0;x<w;x++){const S=v[x],b=S.count,E=i-S.count,M=S.leftCacheBounds,T=S.rightCacheBounds;let I=0;b!==0&&(I=ec(M)/l);let O=0;E!==0&&(O=ec(T)/l);const R=iw+sm*(I*b+O*E);R<c&&(s=d,c=R,o=S.candidate)}}else{for(let w=0;w<hs;w++){const x=Fs[w];x.count=0,x.candidate=f+g+w*g;const S=x.bounds;for(let b=0;b<3;b++)S[b]=1/0,S[b+3]=-1/0}for(let w=u;w<h;w+=6){let b=~~((t[w+2*d]-f)/g);b>=hs&&(b=hs-1);const E=Fs[b];E.count++,id(w,t,E.bounds)}const v=Fs[hs-1];sw(v.bounds,v.rightCacheBounds);for(let w=hs-2;w>=0;w--){const x=Fs[w],S=Fs[w+1];aw(x.bounds,S.rightCacheBounds,x.rightCacheBounds)}let y=0;for(let w=0;w<hs-1;w++){const x=Fs[w],S=x.count,b=x.bounds,M=Fs[w+1].rightCacheBounds;S!==0&&(y===0?sw(b,rd):aw(b,rd,rd)),y+=S;let T=0,I=0;y!==0&&(T=ec(rd)/l);const O=i-y;O!==0&&(I=ec(M)/l);const R=iw+sm*(T*y+I*O);R<c&&(s=d,c=R,o=x.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:s,pos:o}}function Zz(a,e,t,n){let i=0;for(let r=e,s=e+t;r<s;r++)i+=a[r*6+n*2];return i/t}function Kz(a,e){const t=a.attributes.position,n=a.index.array,i=n.length/3,r=new Float32Array(i*6),s=t.normalized,o=t.array,l=t.offset||0;let c=3;t.isInterleavedBufferAttribute&&(c=t.data.stride);const u=["getX","getY","getZ"];for(let h=0;h<i;h++){const d=h*3,f=h*6;let p,m,g;s?(p=n[d+0],m=n[d+1],g=n[d+2]):(p=n[d+0]*c+l,m=n[d+1]*c+l,g=n[d+2]*c+l);for(let v=0;v<3;v++){let y,w,x;s?(y=t[u[v]](p),w=t[u[v]](m),x=t[u[v]](g)):(y=o[p+v],w=o[m+v],x=o[g+v]);let S=y;w<S&&(S=w),x<S&&(S=x);let b=y;w>b&&(b=w),x>b&&(b=x);const E=(b-S)/2,M=v*2;r[f+M+0]=S+E,r[f+M+1]=E+(Math.abs(S)+E)*Gz,S<e[v]&&(e[v]=S),b>e[v+3]&&(e[v+3]=b)}}return r}function Yz(a,e){function t(v){d&&d(v/f)}function n(v,y,w,x=null,S=0){if(!p&&S>=l&&(p=!0,c&&(console.warn(`MeshBVH: Max depth of ${l} reached when generating BVH. Consider increasing maxDepth.`),console.warn(a))),w<=u||S>=l)return t(y+w),v.offset=y,v.count=w,v;const b=Jz(v.boundingData,x,s,y,w,h);if(b.axis===-1)return t(y+w),v.offset=y,v.count=w,v;const E=Wz(o,s,y,w,b);if(E===y||E===y+w)t(y+w),v.offset=y,v.count=w;else{v.splitAxis=b.axis;const M=new nd,T=y,I=E-y;v.left=M,M.boundingData=new Float32Array(6),am(s,T,I,M.boundingData,r),n(M,T,I,r,S+1);const O=new nd,R=E,k=w-I;v.right=O,O.boundingData=new Float32Array(6),am(s,R,k,O.boundingData,r),n(O,R,k,r,S+1)}return v}Vz(a,e);const i=new Float32Array(6),r=new Float32Array(6),s=Kz(a,i),o=a.index.array,l=e.maxDepth,c=e.verbose,u=e.maxLeafTris,h=e.strategy,d=e.onProgress,f=a.index.count/3;let p=!1;const m=[],g=jz(a);if(g.length===1){const v=g[0],y=new nd;y.boundingData=i,Qz(s,v.offset,v.count,r),n(y,v.offset,v.count,r),m.push(y)}else for(let v of g){const y=new nd;y.boundingData=new Float32Array(6),am(s,v.offset,v.count,y.boundingData,r),n(y,v.offset,v.count,r),m.push(y)}return m}function qz(a,e){const t=Yz(a,e);let n,i,r;const s=[],o=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let u=0;u<t.length;u++){const h=t[u];let d=l(h);const f=new o(Ud*d);n=new Float32Array(f),i=new Uint32Array(f),r=new Uint16Array(f),c(0,h),s.push(f)}return s;function l(u){return u.count?1:1+l(u.left)+l(u.right)}function c(u,h){const d=u/4,f=u/2,p=!!h.count,m=h.boundingData;for(let g=0;g<6;g++)n[d+g]=m[g];if(p){const g=h.offset,v=h.count;return i[d+6]=g,r[f+14]=v,r[f+15]=vg,u+Ud}else{const g=h.left,v=h.right,y=h.splitAxis;let w;if(w=c(u+Ud,g),w/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return i[d+6]=w/4,w=c(w,v),i[d+7]=y,w}}}class As{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(e,t){let n=1/0,i=-1/0;for(let r=0,s=e.length;r<s;r++){const l=e[r][t];n=l<n?l:n,i=l>i?l:i}this.min=n,this.max=i}setFromPoints(e,t){let n=1/0,i=-1/0;for(let r=0,s=t.length;r<s;r++){const o=t[r],l=e.dot(o);n=l<n?l:n,i=l>i?l:i}this.min=n,this.max=i}isSeparated(e){return this.min>e.max||e.min>this.max}}As.prototype.setFromBox=(function(){const a=new A;return function(t,n){const i=n.min,r=n.max;let s=1/0,o=-1/0;for(let l=0;l<=1;l++)for(let c=0;c<=1;c++)for(let u=0;u<=1;u++){a.x=i.x*l+r.x*(1-l),a.y=i.y*c+r.y*(1-c),a.z=i.z*u+r.z*(1-u);const h=t.dot(a);s=Math.min(h,s),o=Math.max(h,o)}this.min=s,this.max=o}})();const _z=(function(){const a=new A,e=new A,t=new A;return function(i,r,s){const o=i.start,l=a,c=r.start,u=e;t.subVectors(o,c),a.subVectors(i.end,i.start),e.subVectors(r.end,r.start);const h=t.dot(u),d=u.dot(l),f=u.dot(u),p=t.dot(l),g=l.dot(l)*f-d*d;let v,y;g!==0?v=(h*d-p*f)/g:v=0,y=(h+v*d)/f,s.x=v,s.y=y}})(),n0=(function(){const a=new te,e=new A,t=new A;return function(i,r,s,o){_z(i,r,a);let l=a.x,c=a.y;if(l>=0&&l<=1&&c>=0&&c<=1){i.at(l,s),r.at(c,o);return}else if(l>=0&&l<=1){c<0?r.at(0,o):r.at(1,o),i.closestPointToPoint(o,!0,s);return}else if(c>=0&&c<=1){l<0?i.at(0,s):i.at(1,s),r.closestPointToPoint(s,!0,o);return}else{let u;l<0?u=i.start:u=i.end;let h;c<0?h=r.start:h=r.end;const d=e,f=t;if(i.closestPointToPoint(h,!0,e),r.closestPointToPoint(u,!0,t),d.distanceToSquared(h)<=f.distanceToSquared(u)){s.copy(d),o.copy(h);return}else{s.copy(u),o.copy(f);return}}}})(),$z=(function(){const a=new A,e=new A,t=new kt,n=new Ui;return function(r,s){const{radius:o,center:l}=r,{a:c,b:u,c:h}=s;if(n.start=c,n.end=u,n.closestPointToPoint(l,!0,a).distanceTo(l)<=o||(n.start=c,n.end=h,n.closestPointToPoint(l,!0,a).distanceTo(l)<=o)||(n.start=u,n.end=h,n.closestPointToPoint(l,!0,a).distanceTo(l)<=o))return!0;const m=s.getPlane(t);if(Math.abs(m.distanceToPoint(l))<=o){const v=m.projectPoint(l,e);if(s.containsPoint(v))return!0}return!1}})(),e2=1e-15;function Go(a){return Math.abs(a)<e2}class Qr extends Ht{constructor(...e){super(...e),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new A),this.satBounds=new Array(4).fill().map(()=>new As),this.points=[this.a,this.b,this.c],this.sphere=new rn,this.plane=new kt,this.needsUpdate=!0}intersectsSphere(e){return $z(e,this)}update(){const e=this.a,t=this.b,n=this.c,i=this.points,r=this.satAxes,s=this.satBounds,o=r[0],l=s[0];this.getNormal(o),l.setFromPoints(o,i);const c=r[1],u=s[1];c.subVectors(e,t),u.setFromPoints(c,i);const h=r[2],d=s[2];h.subVectors(t,n),d.setFromPoints(h,i);const f=r[3],p=s[3];f.subVectors(n,e),p.setFromPoints(f,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,e),this.needsUpdate=!1}}Qr.prototype.closestPointToSegment=(function(){const a=new A,e=new A,t=new Ui;return function(i,r=null,s=null){const{start:o,end:l}=i,c=this.points;let u,h=1/0;for(let d=0;d<3;d++){const f=(d+1)%3;t.start.copy(c[d]),t.end.copy(c[f]),n0(t,i,a,e),u=a.distanceToSquared(e),u<h&&(h=u,r&&r.copy(a),s&&s.copy(e))}return this.closestPointToPoint(o,a),u=o.distanceToSquared(a),u<h&&(h=u,r&&r.copy(a),s&&s.copy(o)),this.closestPointToPoint(l,a),u=l.distanceToSquared(a),u<h&&(h=u,r&&r.copy(a),s&&s.copy(l)),Math.sqrt(h)}})();Qr.prototype.intersectsTriangle=(function(){const a=new Qr,e=new Array(3),t=new Array(3),n=new As,i=new As,r=new A,s=new A,o=new A,l=new A,c=new Ui,u=new Ui,h=new Ui;return function(f,p=null){this.needsUpdate&&this.update(),f.isExtendedTriangle?f.needsUpdate&&f.update():(a.copy(f),a.update(),f=a);const m=this.plane,g=f.plane;if(Math.abs(m.normal.dot(g.normal))>1-1e-10){const v=this.satBounds,y=this.satAxes;t[0]=f.a,t[1]=f.b,t[2]=f.c;for(let S=0;S<4;S++){const b=v[S],E=y[S];if(n.setFromPoints(E,t),b.isSeparated(n))return!1}const w=f.satBounds,x=f.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let S=0;S<4;S++){const b=w[S],E=x[S];if(n.setFromPoints(E,e),b.isSeparated(n))return!1}for(let S=0;S<4;S++){const b=y[S];for(let E=0;E<4;E++){const M=x[E];if(r.crossVectors(b,M),n.setFromPoints(r,e),i.setFromPoints(r,t),n.isSeparated(i))return!1}}return p&&(console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),p.start.set(0,0,0),p.end.set(0,0,0)),!0}else{const v=this.points;let y=!1,w=0;for(let k=0;k<3;k++){const P=v[k],F=v[(k+1)%3];c.start.copy(P),c.end.copy(F),c.delta(s);const N=y?u.start:u.end,Y=Go(g.distanceToPoint(P));if(Go(g.normal.dot(s))&&Y){u.copy(c),w=2;break}if((g.intersectLine(c,N)||Y)&&!Go(N.distanceTo(F))){if(w++,y)break;y=!0}}if(w===1&&this.containsPoint(u.end))return p&&(p.start.copy(u.end),p.end.copy(u.end)),!0;if(w!==2)return!1;const x=f.points;let S=!1,b=0;for(let k=0;k<3;k++){const P=x[k],F=x[(k+1)%3];c.start.copy(P),c.end.copy(F),c.delta(o);const N=S?h.start:h.end,Y=Go(m.distanceToPoint(P));if(Go(m.normal.dot(o))&&Y){h.copy(c),b=2;break}if((m.intersectLine(c,N)||Y)&&!Go(N.distanceTo(F))){if(b++,S)break;S=!0}}if(b===1&&this.containsPoint(h.end))return p&&(p.start.copy(h.end),p.end.copy(h.end)),!0;if(b!==2)return!1;if(u.delta(s),h.delta(o),s.dot(o)<0){let k=h.start;h.start=h.end,h.end=k}const E=u.start.dot(s),M=u.end.dot(s),T=h.start.dot(s),I=h.end.dot(s),O=M<T,R=E<I;return E!==I&&T!==M&&O===R?!1:(p&&(l.subVectors(u.start,h.start),l.dot(s)>0?p.start.copy(u.start):p.start.copy(h.start),l.subVectors(u.end,h.end),l.dot(s)<0?p.end.copy(u.end):p.end.copy(h.end)),!0)}}})();Qr.prototype.distanceToPoint=(function(){const a=new A;return function(t){return this.closestPointToPoint(t,a),t.distanceTo(a)}})();Qr.prototype.distanceToTriangle=(function(){const a=new A,e=new A,t=["a","b","c"],n=new Ui,i=new Ui;return function(s,o=null,l=null){const c=o||l?n:null;if(this.intersectsTriangle(s,c))return(o||l)&&(o&&c.getCenter(o),l&&c.getCenter(l)),0;let u=1/0;for(let h=0;h<3;h++){let d;const f=t[h],p=s[f];this.closestPointToPoint(p,a),d=p.distanceToSquared(a),d<u&&(u=d,o&&o.copy(a),l&&l.copy(p));const m=this[f];s.closestPointToPoint(m,a),d=m.distanceToSquared(a),d<u&&(u=d,o&&o.copy(m),l&&l.copy(a))}for(let h=0;h<3;h++){const d=t[h],f=t[(h+1)%3];n.set(this[d],this[f]);for(let p=0;p<3;p++){const m=t[p],g=t[(p+1)%3];i.set(s[m],s[g]),n0(n,i,a,e);const v=a.distanceToSquared(e);v<u&&(u=v,o&&o.copy(a),l&&l.copy(e))}}return Math.sqrt(u)}})();class Wr{constructor(e,t,n){this.isOrientedBox=!0,this.min=new A,this.max=new A,this.matrix=new ae,this.invMatrix=new ae,this.points=new Array(8).fill().map(()=>new A),this.satAxes=new Array(3).fill().map(()=>new A),this.satBounds=new Array(3).fill().map(()=>new As),this.alignedSatBounds=new Array(3).fill().map(()=>new As),this.needsUpdate=!1,e&&this.min.copy(e),t&&this.max.copy(t),n&&this.matrix.copy(n)}set(e,t,n){this.min.copy(e),this.max.copy(t),this.matrix.copy(n),this.needsUpdate=!0}copy(e){this.min.copy(e.min),this.max.copy(e.max),this.matrix.copy(e.matrix),this.needsUpdate=!0}}Wr.prototype.update=(function(){return function(){const e=this.matrix,t=this.min,n=this.max,i=this.points;for(let c=0;c<=1;c++)for(let u=0;u<=1;u++)for(let h=0;h<=1;h++){const d=1*c|2*u|4*h,f=i[d];f.x=c?n.x:t.x,f.y=u?n.y:t.y,f.z=h?n.z:t.z,f.applyMatrix4(e)}const r=this.satBounds,s=this.satAxes,o=i[0];for(let c=0;c<3;c++){const u=s[c],h=r[c],d=1<<c,f=i[d];u.subVectors(o,f),h.setFromPoints(u,i)}const l=this.alignedSatBounds;l[0].setFromPointsField(i,"x"),l[1].setFromPointsField(i,"y"),l[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}})();Wr.prototype.intersectsBox=(function(){const a=new As;return function(t){this.needsUpdate&&this.update();const n=t.min,i=t.max,r=this.satBounds,s=this.satAxes,o=this.alignedSatBounds;if(a.min=n.x,a.max=i.x,o[0].isSeparated(a)||(a.min=n.y,a.max=i.y,o[1].isSeparated(a))||(a.min=n.z,a.max=i.z,o[2].isSeparated(a)))return!1;for(let l=0;l<3;l++){const c=s[l],u=r[l];if(a.setFromBox(c,t),u.isSeparated(a))return!1}return!0}})();Wr.prototype.intersectsTriangle=(function(){const a=new Qr,e=new Array(3),t=new As,n=new As,i=new A;return function(s){this.needsUpdate&&this.update(),s.isExtendedTriangle?s.needsUpdate&&s.update():(a.copy(s),a.update(),s=a);const o=this.satBounds,l=this.satAxes;e[0]=s.a,e[1]=s.b,e[2]=s.c;for(let d=0;d<3;d++){const f=o[d],p=l[d];if(t.setFromPoints(p,e),f.isSeparated(t))return!1}const c=s.satBounds,u=s.satAxes,h=this.points;for(let d=0;d<3;d++){const f=c[d],p=u[d];if(t.setFromPoints(p,h),f.isSeparated(t))return!1}for(let d=0;d<3;d++){const f=l[d];for(let p=0;p<4;p++){const m=u[p];if(i.crossVectors(f,m),t.setFromPoints(i,e),n.setFromPoints(i,h),t.isSeparated(n))return!1}}return!0}})();Wr.prototype.closestPointToPoint=(function(){return function(e,t){return this.needsUpdate&&this.update(),t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}})();Wr.prototype.distanceToPoint=(function(){const a=new A;return function(t){return this.closestPointToPoint(t,a),t.distanceTo(a)}})();Wr.prototype.distanceToBox=(function(){const a=["x","y","z"],e=new Array(12).fill().map(()=>new Ui),t=new Array(12).fill().map(()=>new Ui),n=new A,i=new A;return function(s,o=0,l=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(s))return(l||c)&&(s.getCenter(i),this.closestPointToPoint(i,n),s.closestPointToPoint(n,i),l&&l.copy(n),c&&c.copy(i)),0;const u=o*o,h=s.min,d=s.max,f=this.points;let p=1/0;for(let g=0;g<8;g++){const v=f[g];i.copy(v).clamp(h,d);const y=v.distanceToSquared(i);if(y<p&&(p=y,l&&l.copy(v),c&&c.copy(i),y<u))return Math.sqrt(y)}let m=0;for(let g=0;g<3;g++)for(let v=0;v<=1;v++)for(let y=0;y<=1;y++){const w=(g+1)%3,x=(g+2)%3,S=v<<w|y<<x,b=1<<g|v<<w|y<<x,E=f[S],M=f[b];e[m].set(E,M);const I=a[g],O=a[w],R=a[x],k=t[m],P=k.start,F=k.end;P[I]=h[I],P[O]=v?h[O]:d[O],P[R]=y?h[R]:d[O],F[I]=d[I],F[O]=v?h[O]:d[O],F[R]=y?h[R]:d[O],m++}for(let g=0;g<=1;g++)for(let v=0;v<=1;v++)for(let y=0;y<=1;y++){i.x=g?d.x:h.x,i.y=v?d.y:h.y,i.z=y?d.z:h.z,this.closestPointToPoint(i,n);const w=i.distanceToSquared(n);if(w<p&&(p=w,l&&l.copy(n),c&&c.copy(i),w<u))return Math.sqrt(w)}for(let g=0;g<12;g++){const v=e[g];for(let y=0;y<12;y++){const w=t[y];n0(v,w,n,i);const x=n.distanceToSquared(i);if(x<p&&(p=x,l&&l.copy(n),c&&c.copy(i),x<u))return Math.sqrt(x)}}return Math.sqrt(p)}})();const sd=new A,ad=new A,od=new A,ow=new te,lw=new te,cw=new te,uw=new A;function t2(a,e,t,n,i,r){let s;return r===pi?s=a.intersectTriangle(n,t,e,!0,i):s=a.intersectTriangle(e,t,n,r!==yt,i),s===null?null:{distance:a.origin.distanceTo(i),point:i.clone()}}function n2(a,e,t,n,i,r,s){sd.fromBufferAttribute(e,n),ad.fromBufferAttribute(e,i),od.fromBufferAttribute(e,r);const o=t2(a,sd,ad,od,uw,s);if(o){t&&(ow.fromBufferAttribute(t,n),lw.fromBufferAttribute(t,i),cw.fromBufferAttribute(t,r),o.uv=Ht.getUV(uw,sd,ad,od,ow,lw,cw,new te));const l={a:n,b:i,c:r,normal:new A,materialIndex:0};Ht.getNormal(sd,ad,od,l.normal),o.face=l,o.faceIndex=n}return o}function UM(a,e,t,n,i){const r=n*3,s=a.index.getX(r),o=a.index.getX(r+1),l=a.index.getX(r+2),c=n2(t,a.attributes.position,a.attributes.uv,s,o,l,e);return c?(c.faceIndex=n,i&&i.push(c),c):null}function i2(a,e,t,n,i,r){for(let s=n,o=n+i;s<o;s++)UM(a,e,t,s,r)}function r2(a,e,t,n,i){let r=1/0,s=null;for(let o=n,l=n+i;o<l;o++){const c=UM(a,e,t,o);c&&c.distance<r&&(s=c,r=c.distance)}return s}function Pr(a,e,t,n){const i=a.a,r=a.b,s=a.c;let o=e,l=e+1,c=e+2;t&&(o=t.getX(e),l=t.getX(e+1),c=t.getX(e+2)),i.x=n.getX(o),i.y=n.getY(o),i.z=n.getZ(o),r.x=n.getX(l),r.y=n.getY(l),r.z=n.getZ(l),s.x=n.getX(c),s.y=n.getY(c),s.z=n.getZ(c)}function hw(a,e,t,n,i,r,s){const o=t.index,l=t.attributes.position;for(let c=a,u=e+a;c<u;c++)if(Pr(s,c*3,o,l),s.needsUpdate=!0,n(s,c,i,r))return!0;return!1}class FM{constructor(e){this._getNewPrimitive=e,this._primitives=[]}getPrimitive(){const e=this._primitives;return e.length===0?this._getNewPrimitive():e.pop()}releasePrimitive(e){this._primitives.push(e)}}function Ws(a,e){return e[a+15]===65535}function il(a,e){return e[a+6]}function wu(a,e){return e[a+14]}function Au(a){return a+8}function Su(a,e){return e[a+6]}function s2(a,e){return e[a+7]}const el=new He,ef=new A,a2=["x","y","z"];function yg(a,e,t,n,i){let r=a*2,s=Ll,o=ta,l=na;if(Ws(r,o)){const u=il(a,l),h=wu(r,o);i2(e,t,n,u,h,i)}else{const u=Au(a);tf(u,s,n,ef)&&yg(u,e,t,n,i);const h=Su(a,l);tf(h,s,n,ef)&&yg(h,e,t,n,i)}}function xg(a,e,t,n){let i=a*2,r=Ll,s=ta,o=na;if(Ws(i,s)){const c=il(a,o),u=wu(i,s);return r2(e,t,n,c,u)}else{const c=s2(a,o),u=a2[c],d=n.direction[u]>=0;let f,p;d?(f=Au(a),p=Su(a,o)):(f=Su(a,o),p=Au(a));const g=tf(f,r,n,ef)?xg(f,e,t,n):null;if(g){const w=g.point[u];if(d?w<=r[p+c]:w>=r[p+c+3])return g}const y=tf(p,r,n,ef)?xg(p,e,t,n):null;return g&&y?g.distance<=y.distance?g:y:g||y||null}}const o2=(function(){let a,e;const t=[],n=new FM(()=>new He);return function(...s){a=n.getPrimitive(),e=n.getPrimitive(),t.push(a,e);const o=i(...s);n.releasePrimitive(a),n.releasePrimitive(e),t.pop(),t.pop();const l=t.length;return l>0&&(e=t[l-1],a=t[l-2]),o};function i(r,s,o,l,c=null,u=0,h=0){function d(w){let x=w*2,S=ta,b=na;for(;!Ws(x,S);)w=Au(w),x=w*2;return il(w,b)}function f(w){let x=w*2,S=ta,b=na;for(;!Ws(x,S);)w=Su(w,b),x=w*2;return il(w,b)+wu(x,S)}let p=r*2,m=Ll,g=ta,v=na;if(Ws(p,g)){const w=il(r,v),x=wu(p,g);return dr(r,m,a),l(w,x,!1,h,u+r,a)}else{const w=Au(r),x=Su(r,v);let S=w,b=x,E,M,T,I;if(c&&(T=a,I=e,dr(S,m,T),dr(b,m,I),E=c(T),M=c(I),M<E)){S=x,b=w;const Y=E;E=M,M=Y,T=I}T||(T=a,dr(S,m,T));const O=Ws(S*2,g),R=o(T,O,E,h+1,u+S);let k;if(R===nw){const Y=d(S),G=f(S)-Y;k=l(Y,G,!0,h+1,u+S,T)}else k=R&&i(S,s,o,l,c,u,h+1);if(k)return!0;I=e,dr(b,m,I);const P=Ws(b*2,g),F=o(I,P,M,h+1,u+b);let N;if(F===nw){const Y=d(b),G=f(b)-Y;N=l(Y,G,!0,h+1,u+b,I)}else N=F&&i(b,s,o,l,c,u,h+1);return!!N}}})(),l2=(function(){const a=new Qr,e=new Qr,t=new ae,n=new Wr,i=new Wr;return function r(s,o,l,c,u=null){let h=s*2,d=Ll,f=ta,p=na;if(u===null&&(l.boundingBox||l.computeBoundingBox(),n.set(l.boundingBox.min,l.boundingBox.max,c),u=n),Ws(h,f)){const g=o,v=g.index,y=g.attributes.position,w=l.index,x=l.attributes.position,S=il(s,p),b=wu(h,f);if(t.copy(c).invert(),l.boundsTree)return dr(s,d,i),i.matrix.copy(t),i.needsUpdate=!0,l.boundsTree.shapecast({intersectsBounds:M=>i.intersectsBox(M),intersectsTriangle:M=>{M.a.applyMatrix4(c),M.b.applyMatrix4(c),M.c.applyMatrix4(c),M.needsUpdate=!0;for(let T=S*3,I=(b+S)*3;T<I;T+=3)if(Pr(e,T,v,y),e.needsUpdate=!0,M.intersectsTriangle(e))return!0;return!1}});for(let E=S*3,M=b+S*3;E<M;E+=3){Pr(a,E,v,y),a.a.applyMatrix4(t),a.b.applyMatrix4(t),a.c.applyMatrix4(t),a.needsUpdate=!0;for(let T=0,I=w.count;T<I;T+=3)if(Pr(e,T,w,x),e.needsUpdate=!0,a.intersectsTriangle(e))return!0}}else{const g=s+8,v=p[s+6];return dr(g,d,el),!!(u.intersectsBox(el)&&r(g,o,l,c,u)||(dr(v,d,el),u.intersectsBox(el)&&r(v,o,l,c,u)))}}})();function tf(a,e,t,n){return dr(a,e,el),t.intersectBox(el,n)}const wg=[];let Fd,Ll,ta,na;function pc(a){Fd&&wg.push(Fd),Fd=a,Ll=new Float32Array(a),ta=new Uint16Array(a),na=new Uint32Array(a)}function ld(){Fd=null,Ll=null,ta=null,na=null,wg.length&&pc(wg.pop())}const om=Symbol("skip tree generation"),lm=new He,cm=new He,Vo=new ae,Ca=new Wr,tc=new Wr,nc=new A,cd=new A,c2=new A,u2=new A,h2=new A,dw=new He,br=new FM(()=>new Qr);class rl{static serialize(e,t={}){if(t.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),rl.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});t={cloneBuffers:!0,...t};const n=e.geometry,i=e._roots,r=n.getIndex();let s;return t.cloneBuffers?s={roots:i.map(o=>o.slice()),index:r.array.slice()}:s={roots:i,index:r.array},s}static deserialize(e,t,n={}){if(typeof n=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),rl.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});n={setIndex:!0,...n};const{index:i,roots:r}=e,s=new rl(t,{...n,[om]:!0});if(s._roots=r,n.setIndex){const o=t.getIndex();if(o===null){const l=new wt(e.index,1,!1);t.setIndex(l)}else o.array!==i&&(o.array.set(i),o.needsUpdate=!0)}return s}constructor(e,t={}){if(e.isBufferGeometry){if(e.index&&e.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({strategy:t0,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[om]:!1},t),t.useSharedArrayBuffer&&typeof SharedArrayBuffer>"u")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,t[om]||(this._roots=qz(e,t),!e.boundingBox&&t.setBoundingBox&&(e.boundingBox=this.getBoundingBox(new He))),this.geometry=e}refit(e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=this.geometry,n=t.index.array,i=t.attributes.position;let r,s,o,l,c=0;const u=this._roots;for(let d=0,f=u.length;d<f;d++)r=u[d],s=new Uint32Array(r),o=new Uint16Array(r),l=new Float32Array(r),h(0,c),c+=r.byteLength;function h(d,f,p=!1){const m=d*2;if(o[m+15]===vg){const v=s[d+6],y=o[m+14];let w=1/0,x=1/0,S=1/0,b=-1/0,E=-1/0,M=-1/0;for(let T=3*v,I=3*(v+y);T<I;T++){const O=n[T],R=i.getX(O),k=i.getY(O),P=i.getZ(O);R<w&&(w=R),R>b&&(b=R),k<x&&(x=k),k>E&&(E=k),P<S&&(S=P),P>M&&(M=P)}return l[d+0]!==w||l[d+1]!==x||l[d+2]!==S||l[d+3]!==b||l[d+4]!==E||l[d+5]!==M?(l[d+0]=w,l[d+1]=x,l[d+2]=S,l[d+3]=b,l[d+4]=E,l[d+5]=M,!0):!1}else{const v=d+8,y=s[d+6],w=v+f,x=y+f;let S=p,b=!1,E=!1;e?S||(b=e.has(w),E=e.has(x),S=!b&&!E):(b=!0,E=!0);const M=S||b,T=S||E;let I=!1;M&&(I=h(v,f,S));let O=!1;T&&(O=h(y,f,S));const R=I||O;if(R)for(let k=0;k<3;k++){const P=v+k,F=y+k,N=l[P],Y=l[P+3],_=l[F],G=l[F+3];l[d+k]=N<_?N:_,l[d+k+3]=Y>G?Y:G}return R}}}traverse(e,t=0){const n=this._roots[t],i=new Uint32Array(n),r=new Uint16Array(n);s(0);function s(o,l=0){const c=o*2,u=r[c+15]===vg;if(u){const h=i[o+6],d=r[c+14];e(l,u,new Float32Array(n,o*4,6),h,d)}else{const h=o+Ud/4,d=i[o+6],f=i[o+7];e(l,u,new Float32Array(n,o*4,6),f)||(s(h,l+1),s(d,l+1))}}}raycast(e,t=An){const n=this._roots,i=this.geometry,r=[],s=t.isMaterial,o=Array.isArray(t),l=i.groups,c=s?t.side:t;for(let u=0,h=n.length;u<h;u++){const d=o?t[l[u].materialIndex].side:c,f=r.length;if(pc(n[u]),yg(0,i,d,e,r),ld(),o){const p=l[u].materialIndex;for(let m=f,g=r.length;m<g;m++)r[m].face.materialIndex=p}}return r}raycastFirst(e,t=An){const n=this._roots,i=this.geometry,r=t.isMaterial,s=Array.isArray(t);let o=null;const l=i.groups,c=r?t.side:t;for(let u=0,h=n.length;u<h;u++){const d=s?t[l[u].materialIndex].side:c;pc(n[u]);const f=xg(0,i,d,e);ld(),f!=null&&(o==null||f.distance<o.distance)&&(o=f,s&&(f.face.materialIndex=l[u].materialIndex))}return o}intersectsGeometry(e,t){const n=this.geometry;let i=!1;for(const r of this._roots)if(pc(r),i=l2(0,n,e,t),ld(),i)break;return i}shapecast(e,t,n){const i=this.geometry;if(e instanceof Function){if(t){const d=t;t=(f,p,m,g)=>{const v=p*3;return d(f,v,v+1,v+2,m,g)}}e={boundsTraverseOrder:n,intersectsBounds:e,intersectsTriangle:t,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const r=br.getPrimitive();let{boundsTraverseOrder:s,intersectsBounds:o,intersectsRange:l,intersectsTriangle:c}=e;if(l&&c){const d=l;l=(f,p,m,g,v)=>d(f,p,m,g,v)?!0:hw(f,p,i,c,m,g,r)}else l||(c?l=(d,f,p,m)=>hw(d,f,i,c,p,m,r):l=(d,f,p)=>p);let u=!1,h=0;for(const d of this._roots){if(pc(d),u=o2(0,i,o,l,s,h),ld(),u)break;h+=d.byteLength}return br.releasePrimitive(r),u}bvhcast(e,t,n){let{intersectsRanges:i,intersectsTriangles:r}=n;const s=this.geometry.index,o=this.geometry.attributes.position,l=e.geometry.index,c=e.geometry.attributes.position;Vo.copy(t).invert();const u=br.getPrimitive(),h=br.getPrimitive();if(r){let f=function(p,m,g,v,y,w,x,S){for(let b=g,E=g+v;b<E;b++){Pr(h,b*3,l,c),h.a.applyMatrix4(t),h.b.applyMatrix4(t),h.c.applyMatrix4(t),h.needsUpdate=!0;for(let M=p,T=p+m;M<T;M++)if(Pr(u,M*3,s,o),u.needsUpdate=!0,r(u,h,M,b,y,w,x,S))return!0}return!1};if(i){const p=i;i=function(m,g,v,y,w,x,S,b){return p(m,g,v,y,w,x,S,b)?!0:f(m,g,v,y,w,x,S,b)}}else i=f}e.getBoundingBox(cm),cm.applyMatrix4(t);const d=this.shapecast({intersectsBounds:f=>cm.intersectsBox(f),intersectsRange:(f,p,m,g,v,y)=>(lm.copy(y),lm.applyMatrix4(Vo),e.shapecast({intersectsBounds:w=>lm.intersectsBox(w),intersectsRange:(w,x,S,b,E)=>i(f,p,w,x,g,v,b,E)}))});return br.releasePrimitive(u),br.releasePrimitive(h),d}intersectsBox(e,t){return Ca.set(e.min,e.max,t),Ca.needsUpdate=!0,this.shapecast({intersectsBounds:n=>Ca.intersectsBox(n),intersectsTriangle:n=>Ca.intersectsTriangle(n)})}intersectsSphere(e){return this.shapecast({intersectsBounds:t=>e.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(e)})}closestPointToGeometry(e,t,n={},i={},r=0,s=1/0){e.boundingBox||e.computeBoundingBox(),Ca.set(e.boundingBox.min,e.boundingBox.max,t),Ca.needsUpdate=!0;const o=this.geometry,l=o.attributes.position,c=o.index,u=e.attributes.position,h=e.index,d=br.getPrimitive(),f=br.getPrimitive();let p=cd,m=c2,g=null,v=null;i&&(g=u2,v=h2);let y=1/0,w=null,x=null;return Vo.copy(t).invert(),tc.matrix.copy(Vo),this.shapecast({boundsTraverseOrder:S=>Ca.distanceToBox(S),intersectsBounds:(S,b,E)=>E<y&&E<s?(b&&(tc.min.copy(S.min),tc.max.copy(S.max),tc.needsUpdate=!0),!0):!1,intersectsRange:(S,b)=>{if(e.boundsTree)return e.boundsTree.shapecast({boundsTraverseOrder:E=>tc.distanceToBox(E),intersectsBounds:(E,M,T)=>T<y&&T<s,intersectsRange:(E,M)=>{for(let T=E*3,I=(E+M)*3;T<I;T+=3){Pr(f,T,h,u),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let O=S*3,R=(S+b)*3;O<R;O+=3){Pr(d,O,c,l),d.needsUpdate=!0;const k=d.distanceToTriangle(f,p,g);if(k<y&&(m.copy(p),v&&v.copy(g),y=k,w=O/3,x=T/3),k<r)return!0}}}});{const E=h?h.count:u.count;for(let M=0,T=E;M<T;M+=3){Pr(f,M,h,u),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let I=S*3,O=(S+b)*3;I<O;I+=3){Pr(d,I,c,l),d.needsUpdate=!0;const R=d.distanceToTriangle(f,p,g);if(R<y&&(m.copy(p),v&&v.copy(g),y=R,w=I/3,x=M/3),R<r)return!0}}}}}),br.releasePrimitive(d),br.releasePrimitive(f),y===1/0?null:(n.point?n.point.copy(m):n.point=m.clone(),n.distance=y,n.faceIndex=w,i&&(i.point?i.point.copy(v):i.point=v.clone(),i.point.applyMatrix4(Vo),m.applyMatrix4(Vo),i.distance=m.sub(i.point).length(),i.faceIndex=x),n)}closestPointToPoint(e,t={},n=0,i=1/0){const r=n*n,s=i*i;let o=1/0,l=null;if(this.shapecast({boundsTraverseOrder:u=>(nc.copy(e).clamp(u.min,u.max),nc.distanceToSquared(e)),intersectsBounds:(u,h,d)=>d<o&&d<s,intersectsTriangle:(u,h)=>{u.closestPointToPoint(e,nc);const d=e.distanceToSquared(nc);return d<o&&(cd.copy(nc),o=d,l=h),d<r}}),o===1/0)return null;const c=Math.sqrt(o);return t.point?t.point.copy(cd):t.point=cd.clone(),t.distance=c,t.faceIndex=l,t}getBoundingBox(e){return e.makeEmpty(),this._roots.forEach(n=>{dr(0,new Float32Array(n),dw),e.union(dw)}),e}}const fw=new He;class d2 extends gt{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(e,t,n=10,i=0){super(),this.material=t,this.geometry=new nt,this.name="MeshBVHRootVisualizer",this.depth=n,this.displayParents=!1,this.mesh=e,this.displayEdges=!0,this._group=i}raycast(){}update(){const e=this.geometry,t=this.mesh.geometry.boundsTree,n=this._group;if(e.dispose(),this.visible=!1,t){const i=this.depth-1,r=this.displayParents;let s=0;t.traverse((d,f)=>{if(d===i||f)return s++,!0;r&&s++},n);let o=0;const l=new Float32Array(24*s);t.traverse((d,f,p)=>{const m=d===i||f;if(m||r){dr(0,p,fw);const{min:g,max:v}=fw;for(let y=-1;y<=1;y+=2){const w=y<0?g.x:v.x;for(let x=-1;x<=1;x+=2){const S=x<0?g.y:v.y;for(let b=-1;b<=1;b+=2){const E=b<0?g.z:v.z;l[o+0]=w,l[o+1]=S,l[o+2]=E,o+=3}}}return m}},n);let c,u;this.displayEdges?u=new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):u=new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),l.length>65535?c=new Uint32Array(u.length*s):c=new Uint16Array(u.length*s);const h=u.length;for(let d=0;d<s;d++){const f=d*8,p=d*h;for(let m=0;m<h;m++)c[p+m]=f+u[m]}e.setIndex(new wt(c,1,!1)),e.setAttribute("position",new wt(l,3,!1)),this.visible=!0}}}class i0 extends fi{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(e){this.edgeMaterial.opacity=e,this.meshMaterial.opacity=e}constructor(e,t=10){super(),this.name="MeshBVHVisualizer",this.depth=t,this.mesh=e,this.displayParents=!1,this.displayEdges=!0,this._roots=[];const n=new mn({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),i=new ti({color:65416,transparent:!0,opacity:.3,depthWrite:!1});i.color=n.color,this.edgeMaterial=n,this.meshMaterial=i,this.update()}update(){const e=this.mesh.geometry.boundsTree,t=e?e._roots.length:0;for(;this._roots.length>t;){const n=this._roots.pop();n.geometry.dispose(),this.remove(n)}for(let n=0;n<t;n++){if(n>=this._roots.length){const r=new d2(this.mesh,this.edgeMaterial,this.depth,n);this.add(r),this._roots.push(r)}const i=this._roots[n];i.depth=this.depth,i.mesh=this.mesh,i.displayParents=this.displayParents,i.displayEdges=this.displayEdges,i.material=this.displayEdges?this.edgeMaterial:this.meshMaterial,i.update()}}updateMatrixWorld(...e){this.position.copy(this.mesh.position),this.rotation.copy(this.mesh.rotation),this.scale.copy(this.mesh.scale),super.updateMatrixWorld(...e)}copy(e){this.depth=e.depth,this.mesh=e.mesh}clone(){return new i0(this.mesh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const e=this.children;for(let t=0,n=e.length;t<n;t++)e[t].geometry.dispose()}}const yo={Model:"Model",Object:"Object",ModelFolder:"ModelFolder",AllModels:"all-models"};class f2{type=yo.AllModels;toString(){return"all"}}class HM{type;modelId;versionId;constructor(e,t){this.type=yo.Model,this.modelId=e.toLowerCase(),this.versionId=t?.toLowerCase()}toString(){return(this.versionId?`${this.modelId}@${this.versionId}`:this.modelId).toLowerCase()}}class p2 extends HM{versionId;constructor(e,t){super(e,t),this.versionId=t?.toLowerCase()}toJSON(){return this.toString()}}class m2{type;objectId;constructor(e){this.type=yo.Object,this.objectId=e.toLowerCase()}toString(){return this.objectId.toLowerCase()}}class g2{type;folderName;constructor(e){this.type=yo.ModelFolder,this.folderName=e}toString(){return"$"+this.folderName}}const v2=a=>{if(a==="all")return new f2;if(a.includes("@")){const[e,t]=a.split("@");return new p2(e,t)}else return a.startsWith("$")?new g2(a.substring(1)):a.length===32?new m2(a):new HM(a)};function y2(a){if(!a?.length)return[];const e=a.split(",").filter(n=>n.trim().length).sort(),t=[];for(const n of e){const i=v2(n);i&&t.push(i)}return vL(t,n=>n.toString())}const x2=a=>a.type===yo.AllModels,w2=a=>a.type===yo.Model,A2=a=>a.type===yo.Object,Er=Object.freeze({Stream:{Owner:"stream:owner",Contributor:"stream:contributor",Reviewer:"stream:reviewer"},Workspace:{Admin:"workspace:admin",Member:"workspace:member",Guest:"workspace:guest"},Server:{Admin:"server:admin",User:"server:user",Guest:"server:guest",ArchivedUser:"server:archived-user"}});Object.freeze({Stream:{[Er.Stream.Owner]:{title:"Owner",description:"Can edit project, including settings, collaborators and all models",weight:1e3},[Er.Stream.Contributor]:{title:"Can edit",description:"Can publish and load models from connectors and view and comment in the web viewer",weight:500},[Er.Stream.Reviewer]:{title:"Can view",description:"Can view and comment on models in the web viewer",weight:100}},Server:{[Er.Server.Admin]:{title:"Admin",description:"Can edit server, including settings, users and all projects",weight:1e3},[Er.Server.User]:{title:"User",description:"Can create and own projects",weight:100},[Er.Server.Guest]:{title:"Guest",description:"Can contribute to projects they're invited to",weight:50},[Er.Server.ArchivedUser]:{title:"Archived",description:"Can no longer access server",weight:10}},Workspace:{[Er.Workspace.Admin]:{title:"Admin",description:"Can edit workspace, including settings, members and all projects",weight:1e3},[Er.Workspace.Member]:{title:"Member",description:"Can create and own projects",weight:100},[Er.Workspace.Guest]:{title:"Guest",description:"Can contribute to projects they're invited to",weight:50}}});const S2=Object.freeze({Streams:{Read:"streams:read",Write:"streams:write"},Profile:{Read:"profile:read",Write:"profile:write",Email:"profile:email",Delete:"profile:delete"},Users:{Read:"users:read",Email:"users:email",Invite:"users:invite"},Server:{Stats:"server:stats",Setup:"server:setup"},Tokens:{Read:"tokens:read",Write:"tokens:write"},Apps:{Read:"apps:read",Write:"apps:write"},Automate:{ReportResults:"automate:report-results"},AutomateFunctions:{Read:"automate-functions:read",Write:"automate-functions:write"},Workspaces:{Create:"workspace:create",Read:"workspace:read",Update:"workspace:update",Delete:"workspace:delete"},Gatekeeper:{WorkspaceBilling:"workspace:billing"}});rL(S2,a=>Object.values(a));const M2={second:1,minute:60,hour:3600,day:1440*60,week:10080*60,month:672*60*60},Zu=dL(M2,a=>a*1e3);function um(a,e){let t=a[0],n=a[1],i=a[2],r=a[3];t=ii(t,n,i,r,e[0],7,-680876936),r=ii(r,t,n,i,e[1],12,-389564586),i=ii(i,r,t,n,e[2],17,606105819),n=ii(n,i,r,t,e[3],22,-1044525330),t=ii(t,n,i,r,e[4],7,-176418897),r=ii(r,t,n,i,e[5],12,1200080426),i=ii(i,r,t,n,e[6],17,-1473231341),n=ii(n,i,r,t,e[7],22,-45705983),t=ii(t,n,i,r,e[8],7,1770035416),r=ii(r,t,n,i,e[9],12,-1958414417),i=ii(i,r,t,n,e[10],17,-42063),n=ii(n,i,r,t,e[11],22,-1990404162),t=ii(t,n,i,r,e[12],7,1804603682),r=ii(r,t,n,i,e[13],12,-40341101),i=ii(i,r,t,n,e[14],17,-1502002290),n=ii(n,i,r,t,e[15],22,1236535329),t=ri(t,n,i,r,e[1],5,-165796510),r=ri(r,t,n,i,e[6],9,-1069501632),i=ri(i,r,t,n,e[11],14,643717713),n=ri(n,i,r,t,e[0],20,-373897302),t=ri(t,n,i,r,e[5],5,-701558691),r=ri(r,t,n,i,e[10],9,38016083),i=ri(i,r,t,n,e[15],14,-660478335),n=ri(n,i,r,t,e[4],20,-405537848),t=ri(t,n,i,r,e[9],5,568446438),r=ri(r,t,n,i,e[14],9,-1019803690),i=ri(i,r,t,n,e[3],14,-187363961),n=ri(n,i,r,t,e[8],20,1163531501),t=ri(t,n,i,r,e[13],5,-1444681467),r=ri(r,t,n,i,e[2],9,-51403784),i=ri(i,r,t,n,e[7],14,1735328473),n=ri(n,i,r,t,e[12],20,-1926607734),t=si(t,n,i,r,e[5],4,-378558),r=si(r,t,n,i,e[8],11,-2022574463),i=si(i,r,t,n,e[11],16,1839030562),n=si(n,i,r,t,e[14],23,-35309556),t=si(t,n,i,r,e[1],4,-1530992060),r=si(r,t,n,i,e[4],11,1272893353),i=si(i,r,t,n,e[7],16,-155497632),n=si(n,i,r,t,e[10],23,-1094730640),t=si(t,n,i,r,e[13],4,681279174),r=si(r,t,n,i,e[0],11,-358537222),i=si(i,r,t,n,e[3],16,-722521979),n=si(n,i,r,t,e[6],23,76029189),t=si(t,n,i,r,e[9],4,-640364487),r=si(r,t,n,i,e[12],11,-421815835),i=si(i,r,t,n,e[15],16,530742520),n=si(n,i,r,t,e[2],23,-995338651),t=ai(t,n,i,r,e[0],6,-198630844),r=ai(r,t,n,i,e[7],10,1126891415),i=ai(i,r,t,n,e[14],15,-1416354905),n=ai(n,i,r,t,e[5],21,-57434055),t=ai(t,n,i,r,e[12],6,1700485571),r=ai(r,t,n,i,e[3],10,-1894986606),i=ai(i,r,t,n,e[10],15,-1051523),n=ai(n,i,r,t,e[1],21,-2054922799),t=ai(t,n,i,r,e[8],6,1873313359),r=ai(r,t,n,i,e[15],10,-30611744),i=ai(i,r,t,n,e[6],15,-1560198380),n=ai(n,i,r,t,e[13],21,1309151649),t=ai(t,n,i,r,e[4],6,-145523070),r=ai(r,t,n,i,e[11],10,-1120210379),i=ai(i,r,t,n,e[2],15,718787259),n=ai(n,i,r,t,e[9],21,-343485551),a[0]=fs(t,a[0]),a[1]=fs(n,a[1]),a[2]=fs(i,a[2]),a[3]=fs(r,a[3])}function Jf(a,e,t,n,i,r){return e=fs(fs(e,a),fs(n,r)),fs(e<<i|e>>>32-i,t)}function ii(a,e,t,n,i,r,s){return Jf(e&t|~e&n,a,e,i,r,s)}function ri(a,e,t,n,i,r,s){return Jf(e&n|t&~n,a,e,i,r,s)}function si(a,e,t,n,i,r,s){return Jf(e^t^n,a,e,i,r,s)}function ai(a,e,t,n,i,r,s){return Jf(t^(e|~n),a,e,i,r,s)}function b2(a){const e=a.length,t=[1732584193,-271733879,-1732584194,271733878];let n;for(n=64;n<=a.length;n+=64)um(t,E2(a.substring(n-64,n)));a=a.substring(n-64);const i=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(n=0;n<a.length;n++)i[n>>2]|=a.charCodeAt(n)<<(n%4<<3);if(i[n>>2]|=128<<(n%4<<3),n>55)for(um(t,i),n=0;n<16;n++)i[n]=0;return i[14]=e*8,um(t,i),t}function E2(a){const e=[];let t;for(t=0;t<64;t+=4)e[t>>2]=a.charCodeAt(t)+(a.charCodeAt(t+1)<<8)+(a.charCodeAt(t+2)<<16)+(a.charCodeAt(t+3)<<24);return e}const pw="0123456789abcdef".split("");function T2(a){let e="",t=0;for(;t<4;t++)e+=pw[a>>t*8+4&15]+pw[a>>t*8&15];return e}function C2(a){for(let e=0;e<a.length;e++)a[e]=T2(a[e]);return a.join("")}let fs=(a,e)=>a+e&4294967295;function I2(a){return C2(b2(a))}I2("hello")!=="5d41402abc4b2a76b9719d911017c592"&&(fs=(a,e)=>{const t=(a&65535)+(e&65535);return(a>>16)+(e>>16)+(t>>16)<<16|t&65535});function R2(){try{const a="___localStorageAvailabilityTest",e=globalThis.localStorage;return e.setItem(a,a),e.getItem(a),e.removeItem(a),!0}catch{return!1}}R2();var mw;(function(a){a.Windows="win",a.Mac="mac",a.Linux="linux",a.Android="android",a.iOS="ios",a.Other="other"})(mw||(mw={}));function P2(){if(!globalThis||!globalThis.navigator||!("userAgent"in globalThis.navigator))return!1;const a=globalThis.navigator.userAgent;return/^((?!chrome|android).)*safari/i.test(a)}var Mi;(function(a){a[a.PERPENDICULAR=0]="PERPENDICULAR",a[a.POINTTOPOINT=1]="POINTTOPOINT",a[a.AREA=2]="AREA",a[a.POINT=3]="POINT"})(Mi||(Mi={}));Object.freeze({visible:!0,type:Mi.POINTTOPOINT,vertexSnap:!1,units:"m",precision:2});var hm={exports:{}},dm,gw;function D2(){return gw||(gw=1,dm=[{value:"#B0171F",name:"indian red"},{value:"#DC143C",css:!0,name:"crimson"},{value:"#FFB6C1",css:!0,name:"lightpink"},{value:"#FFAEB9",name:"lightpink 1"},{value:"#EEA2AD",name:"lightpink 2"},{value:"#CD8C95",name:"lightpink 3"},{value:"#8B5F65",name:"lightpink 4"},{value:"#FFC0CB",css:!0,name:"pink"},{value:"#FFB5C5",name:"pink 1"},{value:"#EEA9B8",name:"pink 2"},{value:"#CD919E",name:"pink 3"},{value:"#8B636C",name:"pink 4"},{value:"#DB7093",css:!0,name:"palevioletred"},{value:"#FF82AB",name:"palevioletred 1"},{value:"#EE799F",name:"palevioletred 2"},{value:"#CD6889",name:"palevioletred 3"},{value:"#8B475D",name:"palevioletred 4"},{value:"#FFF0F5",name:"lavenderblush 1"},{value:"#FFF0F5",css:!0,name:"lavenderblush"},{value:"#EEE0E5",name:"lavenderblush 2"},{value:"#CDC1C5",name:"lavenderblush 3"},{value:"#8B8386",name:"lavenderblush 4"},{value:"#FF3E96",name:"violetred 1"},{value:"#EE3A8C",name:"violetred 2"},{value:"#CD3278",name:"violetred 3"},{value:"#8B2252",name:"violetred 4"},{value:"#FF69B4",css:!0,name:"hotpink"},{value:"#FF6EB4",name:"hotpink 1"},{value:"#EE6AA7",name:"hotpink 2"},{value:"#CD6090",name:"hotpink 3"},{value:"#8B3A62",name:"hotpink 4"},{value:"#872657",name:"raspberry"},{value:"#FF1493",name:"deeppink 1"},{value:"#FF1493",css:!0,name:"deeppink"},{value:"#EE1289",name:"deeppink 2"},{value:"#CD1076",name:"deeppink 3"},{value:"#8B0A50",name:"deeppink 4"},{value:"#FF34B3",name:"maroon 1"},{value:"#EE30A7",name:"maroon 2"},{value:"#CD2990",name:"maroon 3"},{value:"#8B1C62",name:"maroon 4"},{value:"#C71585",css:!0,name:"mediumvioletred"},{value:"#D02090",name:"violetred"},{value:"#DA70D6",css:!0,name:"orchid"},{value:"#FF83FA",name:"orchid 1"},{value:"#EE7AE9",name:"orchid 2"},{value:"#CD69C9",name:"orchid 3"},{value:"#8B4789",name:"orchid 4"},{value:"#D8BFD8",css:!0,name:"thistle"},{value:"#FFE1FF",name:"thistle 1"},{value:"#EED2EE",name:"thistle 2"},{value:"#CDB5CD",name:"thistle 3"},{value:"#8B7B8B",name:"thistle 4"},{value:"#FFBBFF",name:"plum 1"},{value:"#EEAEEE",name:"plum 2"},{value:"#CD96CD",name:"plum 3"},{value:"#8B668B",name:"plum 4"},{value:"#DDA0DD",css:!0,name:"plum"},{value:"#EE82EE",css:!0,name:"violet"},{value:"#FF00FF",vga:!0,name:"magenta"},{value:"#FF00FF",vga:!0,css:!0,name:"fuchsia"},{value:"#EE00EE",name:"magenta 2"},{value:"#CD00CD",name:"magenta 3"},{value:"#8B008B",name:"magenta 4"},{value:"#8B008B",css:!0,name:"darkmagenta"},{value:"#800080",vga:!0,css:!0,name:"purple"},{value:"#BA55D3",css:!0,name:"mediumorchid"},{value:"#E066FF",name:"mediumorchid 1"},{value:"#D15FEE",name:"mediumorchid 2"},{value:"#B452CD",name:"mediumorchid 3"},{value:"#7A378B",name:"mediumorchid 4"},{value:"#9400D3",css:!0,name:"darkviolet"},{value:"#9932CC",css:!0,name:"darkorchid"},{value:"#BF3EFF",name:"darkorchid 1"},{value:"#B23AEE",name:"darkorchid 2"},{value:"#9A32CD",name:"darkorchid 3"},{value:"#68228B",name:"darkorchid 4"},{value:"#4B0082",css:!0,name:"indigo"},{value:"#8A2BE2",css:!0,name:"blueviolet"},{value:"#9B30FF",name:"purple 1"},{value:"#912CEE",name:"purple 2"},{value:"#7D26CD",name:"purple 3"},{value:"#551A8B",name:"purple 4"},{value:"#9370DB",css:!0,name:"mediumpurple"},{value:"#AB82FF",name:"mediumpurple 1"},{value:"#9F79EE",name:"mediumpurple 2"},{value:"#8968CD",name:"mediumpurple 3"},{value:"#5D478B",name:"mediumpurple 4"},{value:"#483D8B",css:!0,name:"darkslateblue"},{value:"#8470FF",name:"lightslateblue"},{value:"#7B68EE",css:!0,name:"mediumslateblue"},{value:"#6A5ACD",css:!0,name:"slateblue"},{value:"#836FFF",name:"slateblue 1"},{value:"#7A67EE",name:"slateblue 2"},{value:"#6959CD",name:"slateblue 3"},{value:"#473C8B",name:"slateblue 4"},{value:"#F8F8FF",css:!0,name:"ghostwhite"},{value:"#E6E6FA",css:!0,name:"lavender"},{value:"#0000FF",vga:!0,css:!0,name:"blue"},{value:"#0000EE",name:"blue 2"},{value:"#0000CD",name:"blue 3"},{value:"#0000CD",css:!0,name:"mediumblue"},{value:"#00008B",name:"blue 4"},{value:"#00008B",css:!0,name:"darkblue"},{value:"#000080",vga:!0,css:!0,name:"navy"},{value:"#191970",css:!0,name:"midnightblue"},{value:"#3D59AB",name:"cobalt"},{value:"#4169E1",css:!0,name:"royalblue"},{value:"#4876FF",name:"royalblue 1"},{value:"#436EEE",name:"royalblue 2"},{value:"#3A5FCD",name:"royalblue 3"},{value:"#27408B",name:"royalblue 4"},{value:"#6495ED",css:!0,name:"cornflowerblue"},{value:"#B0C4DE",css:!0,name:"lightsteelblue"},{value:"#CAE1FF",name:"lightsteelblue 1"},{value:"#BCD2EE",name:"lightsteelblue 2"},{value:"#A2B5CD",name:"lightsteelblue 3"},{value:"#6E7B8B",name:"lightsteelblue 4"},{value:"#778899",css:!0,name:"lightslategray"},{value:"#708090",css:!0,name:"slategray"},{value:"#C6E2FF",name:"slategray 1"},{value:"#B9D3EE",name:"slategray 2"},{value:"#9FB6CD",name:"slategray 3"},{value:"#6C7B8B",name:"slategray 4"},{value:"#1E90FF",name:"dodgerblue 1"},{value:"#1E90FF",css:!0,name:"dodgerblue"},{value:"#1C86EE",name:"dodgerblue 2"},{value:"#1874CD",name:"dodgerblue 3"},{value:"#104E8B",name:"dodgerblue 4"},{value:"#F0F8FF",css:!0,name:"aliceblue"},{value:"#4682B4",css:!0,name:"steelblue"},{value:"#63B8FF",name:"steelblue 1"},{value:"#5CACEE",name:"steelblue 2"},{value:"#4F94CD",name:"steelblue 3"},{value:"#36648B",name:"steelblue 4"},{value:"#87CEFA",css:!0,name:"lightskyblue"},{value:"#B0E2FF",name:"lightskyblue 1"},{value:"#A4D3EE",name:"lightskyblue 2"},{value:"#8DB6CD",name:"lightskyblue 3"},{value:"#607B8B",name:"lightskyblue 4"},{value:"#87CEFF",name:"skyblue 1"},{value:"#7EC0EE",name:"skyblue 2"},{value:"#6CA6CD",name:"skyblue 3"},{value:"#4A708B",name:"skyblue 4"},{value:"#87CEEB",css:!0,name:"skyblue"},{value:"#00BFFF",name:"deepskyblue 1"},{value:"#00BFFF",css:!0,name:"deepskyblue"},{value:"#00B2EE",name:"deepskyblue 2"},{value:"#009ACD",name:"deepskyblue 3"},{value:"#00688B",name:"deepskyblue 4"},{value:"#33A1C9",name:"peacock"},{value:"#ADD8E6",css:!0,name:"lightblue"},{value:"#BFEFFF",name:"lightblue 1"},{value:"#B2DFEE",name:"lightblue 2"},{value:"#9AC0CD",name:"lightblue 3"},{value:"#68838B",name:"lightblue 4"},{value:"#B0E0E6",css:!0,name:"powderblue"},{value:"#98F5FF",name:"cadetblue 1"},{value:"#8EE5EE",name:"cadetblue 2"},{value:"#7AC5CD",name:"cadetblue 3"},{value:"#53868B",name:"cadetblue 4"},{value:"#00F5FF",name:"turquoise 1"},{value:"#00E5EE",name:"turquoise 2"},{value:"#00C5CD",name:"turquoise 3"},{value:"#00868B",name:"turquoise 4"},{value:"#5F9EA0",css:!0,name:"cadetblue"},{value:"#00CED1",css:!0,name:"darkturquoise"},{value:"#F0FFFF",name:"azure 1"},{value:"#F0FFFF",css:!0,name:"azure"},{value:"#E0EEEE",name:"azure 2"},{value:"#C1CDCD",name:"azure 3"},{value:"#838B8B",name:"azure 4"},{value:"#E0FFFF",name:"lightcyan 1"},{value:"#E0FFFF",css:!0,name:"lightcyan"},{value:"#D1EEEE",name:"lightcyan 2"},{value:"#B4CDCD",name:"lightcyan 3"},{value:"#7A8B8B",name:"lightcyan 4"},{value:"#BBFFFF",name:"paleturquoise 1"},{value:"#AEEEEE",name:"paleturquoise 2"},{value:"#AEEEEE",css:!0,name:"paleturquoise"},{value:"#96CDCD",name:"paleturquoise 3"},{value:"#668B8B",name:"paleturquoise 4"},{value:"#2F4F4F",css:!0,name:"darkslategray"},{value:"#97FFFF",name:"darkslategray 1"},{value:"#8DEEEE",name:"darkslategray 2"},{value:"#79CDCD",name:"darkslategray 3"},{value:"#528B8B",name:"darkslategray 4"},{value:"#00FFFF",name:"cyan"},{value:"#00FFFF",css:!0,name:"aqua"},{value:"#00EEEE",name:"cyan 2"},{value:"#00CDCD",name:"cyan 3"},{value:"#008B8B",name:"cyan 4"},{value:"#008B8B",css:!0,name:"darkcyan"},{value:"#008080",vga:!0,css:!0,name:"teal"},{value:"#48D1CC",css:!0,name:"mediumturquoise"},{value:"#20B2AA",css:!0,name:"lightseagreen"},{value:"#03A89E",name:"manganeseblue"},{value:"#40E0D0",css:!0,name:"turquoise"},{value:"#808A87",name:"coldgrey"},{value:"#00C78C",name:"turquoiseblue"},{value:"#7FFFD4",name:"aquamarine 1"},{value:"#7FFFD4",css:!0,name:"aquamarine"},{value:"#76EEC6",name:"aquamarine 2"},{value:"#66CDAA",name:"aquamarine 3"},{value:"#66CDAA",css:!0,name:"mediumaquamarine"},{value:"#458B74",name:"aquamarine 4"},{value:"#00FA9A",css:!0,name:"mediumspringgreen"},{value:"#F5FFFA",css:!0,name:"mintcream"},{value:"#00FF7F",css:!0,name:"springgreen"},{value:"#00EE76",name:"springgreen 1"},{value:"#00CD66",name:"springgreen 2"},{value:"#008B45",name:"springgreen 3"},{value:"#3CB371",css:!0,name:"mediumseagreen"},{value:"#54FF9F",name:"seagreen 1"},{value:"#4EEE94",name:"seagreen 2"},{value:"#43CD80",name:"seagreen 3"},{value:"#2E8B57",name:"seagreen 4"},{value:"#2E8B57",css:!0,name:"seagreen"},{value:"#00C957",name:"emeraldgreen"},{value:"#BDFCC9",name:"mint"},{value:"#3D9140",name:"cobaltgreen"},{value:"#F0FFF0",name:"honeydew 1"},{value:"#F0FFF0",css:!0,name:"honeydew"},{value:"#E0EEE0",name:"honeydew 2"},{value:"#C1CDC1",name:"honeydew 3"},{value:"#838B83",name:"honeydew 4"},{value:"#8FBC8F",css:!0,name:"darkseagreen"},{value:"#C1FFC1",name:"darkseagreen 1"},{value:"#B4EEB4",name:"darkseagreen 2"},{value:"#9BCD9B",name:"darkseagreen 3"},{value:"#698B69",name:"darkseagreen 4"},{value:"#98FB98",css:!0,name:"palegreen"},{value:"#9AFF9A",name:"palegreen 1"},{value:"#90EE90",name:"palegreen 2"},{value:"#90EE90",css:!0,name:"lightgreen"},{value:"#7CCD7C",name:"palegreen 3"},{value:"#548B54",name:"palegreen 4"},{value:"#32CD32",css:!0,name:"limegreen"},{value:"#228B22",css:!0,name:"forestgreen"},{value:"#00FF00",vga:!0,name:"green 1"},{value:"#00FF00",vga:!0,css:!0,name:"lime"},{value:"#00EE00",name:"green 2"},{value:"#00CD00",name:"green 3"},{value:"#008B00",name:"green 4"},{value:"#008000",vga:!0,css:!0,name:"green"},{value:"#006400",css:!0,name:"darkgreen"},{value:"#308014",name:"sapgreen"},{value:"#7CFC00",css:!0,name:"lawngreen"},{value:"#7FFF00",name:"chartreuse 1"},{value:"#7FFF00",css:!0,name:"chartreuse"},{value:"#76EE00",name:"chartreuse 2"},{value:"#66CD00",name:"chartreuse 3"},{value:"#458B00",name:"chartreuse 4"},{value:"#ADFF2F",css:!0,name:"greenyellow"},{value:"#CAFF70",name:"darkolivegreen 1"},{value:"#BCEE68",name:"darkolivegreen 2"},{value:"#A2CD5A",name:"darkolivegreen 3"},{value:"#6E8B3D",name:"darkolivegreen 4"},{value:"#556B2F",css:!0,name:"darkolivegreen"},{value:"#6B8E23",css:!0,name:"olivedrab"},{value:"#C0FF3E",name:"olivedrab 1"},{value:"#B3EE3A",name:"olivedrab 2"},{value:"#9ACD32",name:"olivedrab 3"},{value:"#9ACD32",css:!0,name:"yellowgreen"},{value:"#698B22",name:"olivedrab 4"},{value:"#FFFFF0",name:"ivory 1"},{value:"#FFFFF0",css:!0,name:"ivory"},{value:"#EEEEE0",name:"ivory 2"},{value:"#CDCDC1",name:"ivory 3"},{value:"#8B8B83",name:"ivory 4"},{value:"#F5F5DC",css:!0,name:"beige"},{value:"#FFFFE0",name:"lightyellow 1"},{value:"#FFFFE0",css:!0,name:"lightyellow"},{value:"#EEEED1",name:"lightyellow 2"},{value:"#CDCDB4",name:"lightyellow 3"},{value:"#8B8B7A",name:"lightyellow 4"},{value:"#FAFAD2",css:!0,name:"lightgoldenrodyellow"},{value:"#FFFF00",vga:!0,name:"yellow 1"},{value:"#FFFF00",vga:!0,css:!0,name:"yellow"},{value:"#EEEE00",name:"yellow 2"},{value:"#CDCD00",name:"yellow 3"},{value:"#8B8B00",name:"yellow 4"},{value:"#808069",name:"warmgrey"},{value:"#808000",vga:!0,css:!0,name:"olive"},{value:"#BDB76B",css:!0,name:"darkkhaki"},{value:"#FFF68F",name:"khaki 1"},{value:"#EEE685",name:"khaki 2"},{value:"#CDC673",name:"khaki 3"},{value:"#8B864E",name:"khaki 4"},{value:"#F0E68C",css:!0,name:"khaki"},{value:"#EEE8AA",css:!0,name:"palegoldenrod"},{value:"#FFFACD",name:"lemonchiffon 1"},{value:"#FFFACD",css:!0,name:"lemonchiffon"},{value:"#EEE9BF",name:"lemonchiffon 2"},{value:"#CDC9A5",name:"lemonchiffon 3"},{value:"#8B8970",name:"lemonchiffon 4"},{value:"#FFEC8B",name:"lightgoldenrod 1"},{value:"#EEDC82",name:"lightgoldenrod 2"},{value:"#CDBE70",name:"lightgoldenrod 3"},{value:"#8B814C",name:"lightgoldenrod 4"},{value:"#E3CF57",name:"banana"},{value:"#FFD700",name:"gold 1"},{value:"#FFD700",css:!0,name:"gold"},{value:"#EEC900",name:"gold 2"},{value:"#CDAD00",name:"gold 3"},{value:"#8B7500",name:"gold 4"},{value:"#FFF8DC",name:"cornsilk 1"},{value:"#FFF8DC",css:!0,name:"cornsilk"},{value:"#EEE8CD",name:"cornsilk 2"},{value:"#CDC8B1",name:"cornsilk 3"},{value:"#8B8878",name:"cornsilk 4"},{value:"#DAA520",css:!0,name:"goldenrod"},{value:"#FFC125",name:"goldenrod 1"},{value:"#EEB422",name:"goldenrod 2"},{value:"#CD9B1D",name:"goldenrod 3"},{value:"#8B6914",name:"goldenrod 4"},{value:"#B8860B",css:!0,name:"darkgoldenrod"},{value:"#FFB90F",name:"darkgoldenrod 1"},{value:"#EEAD0E",name:"darkgoldenrod 2"},{value:"#CD950C",name:"darkgoldenrod 3"},{value:"#8B6508",name:"darkgoldenrod 4"},{value:"#FFA500",name:"orange 1"},{value:"#FF8000",css:!0,name:"orange"},{value:"#EE9A00",name:"orange 2"},{value:"#CD8500",name:"orange 3"},{value:"#8B5A00",name:"orange 4"},{value:"#FFFAF0",css:!0,name:"floralwhite"},{value:"#FDF5E6",css:!0,name:"oldlace"},{value:"#F5DEB3",css:!0,name:"wheat"},{value:"#FFE7BA",name:"wheat 1"},{value:"#EED8AE",name:"wheat 2"},{value:"#CDBA96",name:"wheat 3"},{value:"#8B7E66",name:"wheat 4"},{value:"#FFE4B5",css:!0,name:"moccasin"},{value:"#FFEFD5",css:!0,name:"papayawhip"},{value:"#FFEBCD",css:!0,name:"blanchedalmond"},{value:"#FFDEAD",name:"navajowhite 1"},{value:"#FFDEAD",css:!0,name:"navajowhite"},{value:"#EECFA1",name:"navajowhite 2"},{value:"#CDB38B",name:"navajowhite 3"},{value:"#8B795E",name:"navajowhite 4"},{value:"#FCE6C9",name:"eggshell"},{value:"#D2B48C",css:!0,name:"tan"},{value:"#9C661F",name:"brick"},{value:"#FF9912",name:"cadmiumyellow"},{value:"#FAEBD7",css:!0,name:"antiquewhite"},{value:"#FFEFDB",name:"antiquewhite 1"},{value:"#EEDFCC",name:"antiquewhite 2"},{value:"#CDC0B0",name:"antiquewhite 3"},{value:"#8B8378",name:"antiquewhite 4"},{value:"#DEB887",css:!0,name:"burlywood"},{value:"#FFD39B",name:"burlywood 1"},{value:"#EEC591",name:"burlywood 2"},{value:"#CDAA7D",name:"burlywood 3"},{value:"#8B7355",name:"burlywood 4"},{value:"#FFE4C4",name:"bisque 1"},{value:"#FFE4C4",css:!0,name:"bisque"},{value:"#EED5B7",name:"bisque 2"},{value:"#CDB79E",name:"bisque 3"},{value:"#8B7D6B",name:"bisque 4"},{value:"#E3A869",name:"melon"},{value:"#ED9121",name:"carrot"},{value:"#FF8C00",css:!0,name:"darkorange"},{value:"#FF7F00",name:"darkorange 1"},{value:"#EE7600",name:"darkorange 2"},{value:"#CD6600",name:"darkorange 3"},{value:"#8B4500",name:"darkorange 4"},{value:"#FFA54F",name:"tan 1"},{value:"#EE9A49",name:"tan 2"},{value:"#CD853F",name:"tan 3"},{value:"#CD853F",css:!0,name:"peru"},{value:"#8B5A2B",name:"tan 4"},{value:"#FAF0E6",css:!0,name:"linen"},{value:"#FFDAB9",name:"peachpuff 1"},{value:"#FFDAB9",css:!0,name:"peachpuff"},{value:"#EECBAD",name:"peachpuff 2"},{value:"#CDAF95",name:"peachpuff 3"},{value:"#8B7765",name:"peachpuff 4"},{value:"#FFF5EE",name:"seashell 1"},{value:"#FFF5EE",css:!0,name:"seashell"},{value:"#EEE5DE",name:"seashell 2"},{value:"#CDC5BF",name:"seashell 3"},{value:"#8B8682",name:"seashell 4"},{value:"#F4A460",css:!0,name:"sandybrown"},{value:"#C76114",name:"rawsienna"},{value:"#D2691E",css:!0,name:"chocolate"},{value:"#FF7F24",name:"chocolate 1"},{value:"#EE7621",name:"chocolate 2"},{value:"#CD661D",name:"chocolate 3"},{value:"#8B4513",name:"chocolate 4"},{value:"#8B4513",css:!0,name:"saddlebrown"},{value:"#292421",name:"ivoryblack"},{value:"#FF7D40",name:"flesh"},{value:"#FF6103",name:"cadmiumorange"},{value:"#8A360F",name:"burntsienna"},{value:"#A0522D",css:!0,name:"sienna"},{value:"#FF8247",name:"sienna 1"},{value:"#EE7942",name:"sienna 2"},{value:"#CD6839",name:"sienna 3"},{value:"#8B4726",name:"sienna 4"},{value:"#FFA07A",name:"lightsalmon 1"},{value:"#FFA07A",css:!0,name:"lightsalmon"},{value:"#EE9572",name:"lightsalmon 2"},{value:"#CD8162",name:"lightsalmon 3"},{value:"#8B5742",name:"lightsalmon 4"},{value:"#FF7F50",css:!0,name:"coral"},{value:"#FF4500",name:"orangered 1"},{value:"#FF4500",css:!0,name:"orangered"},{value:"#EE4000",name:"orangered 2"},{value:"#CD3700",name:"orangered 3"},{value:"#8B2500",name:"orangered 4"},{value:"#5E2612",name:"sepia"},{value:"#E9967A",css:!0,name:"darksalmon"},{value:"#FF8C69",name:"salmon 1"},{value:"#EE8262",name:"salmon 2"},{value:"#CD7054",name:"salmon 3"},{value:"#8B4C39",name:"salmon 4"},{value:"#FF7256",name:"coral 1"},{value:"#EE6A50",name:"coral 2"},{value:"#CD5B45",name:"coral 3"},{value:"#8B3E2F",name:"coral 4"},{value:"#8A3324",name:"burntumber"},{value:"#FF6347",name:"tomato 1"},{value:"#FF6347",css:!0,name:"tomato"},{value:"#EE5C42",name:"tomato 2"},{value:"#CD4F39",name:"tomato 3"},{value:"#8B3626",name:"tomato 4"},{value:"#FA8072",css:!0,name:"salmon"},{value:"#FFE4E1",name:"mistyrose 1"},{value:"#FFE4E1",css:!0,name:"mistyrose"},{value:"#EED5D2",name:"mistyrose 2"},{value:"#CDB7B5",name:"mistyrose 3"},{value:"#8B7D7B",name:"mistyrose 4"},{value:"#FFFAFA",name:"snow 1"},{value:"#FFFAFA",css:!0,name:"snow"},{value:"#EEE9E9",name:"snow 2"},{value:"#CDC9C9",name:"snow 3"},{value:"#8B8989",name:"snow 4"},{value:"#BC8F8F",css:!0,name:"rosybrown"},{value:"#FFC1C1",name:"rosybrown 1"},{value:"#EEB4B4",name:"rosybrown 2"},{value:"#CD9B9B",name:"rosybrown 3"},{value:"#8B6969",name:"rosybrown 4"},{value:"#F08080",css:!0,name:"lightcoral"},{value:"#CD5C5C",css:!0,name:"indianred"},{value:"#FF6A6A",name:"indianred 1"},{value:"#EE6363",name:"indianred 2"},{value:"#8B3A3A",name:"indianred 4"},{value:"#CD5555",name:"indianred 3"},{value:"#A52A2A",css:!0,name:"brown"},{value:"#FF4040",name:"brown 1"},{value:"#EE3B3B",name:"brown 2"},{value:"#CD3333",name:"brown 3"},{value:"#8B2323",name:"brown 4"},{value:"#B22222",css:!0,name:"firebrick"},{value:"#FF3030",name:"firebrick 1"},{value:"#EE2C2C",name:"firebrick 2"},{value:"#CD2626",name:"firebrick 3"},{value:"#8B1A1A",name:"firebrick 4"},{value:"#FF0000",vga:!0,name:"red 1"},{value:"#FF0000",vga:!0,css:!0,name:"red"},{value:"#EE0000",name:"red 2"},{value:"#CD0000",name:"red 3"},{value:"#8B0000",name:"red 4"},{value:"#8B0000",css:!0,name:"darkred"},{value:"#800000",vga:!0,css:!0,name:"maroon"},{value:"#8E388E",name:"sgi beet"},{value:"#7171C6",name:"sgi slateblue"},{value:"#7D9EC0",name:"sgi lightblue"},{value:"#388E8E",name:"sgi teal"},{value:"#71C671",name:"sgi chartreuse"},{value:"#8E8E38",name:"sgi olivedrab"},{value:"#C5C1AA",name:"sgi brightgray"},{value:"#C67171",name:"sgi salmon"},{value:"#555555",name:"sgi darkgray"},{value:"#1E1E1E",name:"sgi gray 12"},{value:"#282828",name:"sgi gray 16"},{value:"#515151",name:"sgi gray 32"},{value:"#5B5B5B",name:"sgi gray 36"},{value:"#848484",name:"sgi gray 52"},{value:"#8E8E8E",name:"sgi gray 56"},{value:"#AAAAAA",name:"sgi lightgray"},{value:"#B7B7B7",name:"sgi gray 72"},{value:"#C1C1C1",name:"sgi gray 76"},{value:"#EAEAEA",name:"sgi gray 92"},{value:"#F4F4F4",name:"sgi gray 96"},{value:"#FFFFFF",vga:!0,css:!0,name:"white"},{value:"#F5F5F5",name:"white smoke"},{value:"#F5F5F5",name:"gray 96"},{value:"#DCDCDC",css:!0,name:"gainsboro"},{value:"#D3D3D3",css:!0,name:"lightgrey"},{value:"#C0C0C0",vga:!0,css:!0,name:"silver"},{value:"#A9A9A9",css:!0,name:"darkgray"},{value:"#808080",vga:!0,css:!0,name:"gray"},{value:"#696969",css:!0,name:"dimgray"},{value:"#696969",name:"gray 42"},{value:"#000000",vga:!0,css:!0,name:"black"},{value:"#FCFCFC",name:"gray 99"},{value:"#FAFAFA",name:"gray 98"},{value:"#F7F7F7",name:"gray 97"},{value:"#F2F2F2",name:"gray 95"},{value:"#F0F0F0",name:"gray 94"},{value:"#EDEDED",name:"gray 93"},{value:"#EBEBEB",name:"gray 92"},{value:"#E8E8E8",name:"gray 91"},{value:"#E5E5E5",name:"gray 90"},{value:"#E3E3E3",name:"gray 89"},{value:"#E0E0E0",name:"gray 88"},{value:"#DEDEDE",name:"gray 87"},{value:"#DBDBDB",name:"gray 86"},{value:"#D9D9D9",name:"gray 85"},{value:"#D6D6D6",name:"gray 84"},{value:"#D4D4D4",name:"gray 83"},{value:"#D1D1D1",name:"gray 82"},{value:"#CFCFCF",name:"gray 81"},{value:"#CCCCCC",name:"gray 80"},{value:"#C9C9C9",name:"gray 79"},{value:"#C7C7C7",name:"gray 78"},{value:"#C4C4C4",name:"gray 77"},{value:"#C2C2C2",name:"gray 76"},{value:"#BFBFBF",name:"gray 75"},{value:"#BDBDBD",name:"gray 74"},{value:"#BABABA",name:"gray 73"},{value:"#B8B8B8",name:"gray 72"},{value:"#B5B5B5",name:"gray 71"},{value:"#B3B3B3",name:"gray 70"},{value:"#B0B0B0",name:"gray 69"},{value:"#ADADAD",name:"gray 68"},{value:"#ABABAB",name:"gray 67"},{value:"#A8A8A8",name:"gray 66"},{value:"#A6A6A6",name:"gray 65"},{value:"#A3A3A3",name:"gray 64"},{value:"#A1A1A1",name:"gray 63"},{value:"#9E9E9E",name:"gray 62"},{value:"#9C9C9C",name:"gray 61"},{value:"#999999",name:"gray 60"},{value:"#969696",name:"gray 59"},{value:"#949494",name:"gray 58"},{value:"#919191",name:"gray 57"},{value:"#8F8F8F",name:"gray 56"},{value:"#8C8C8C",name:"gray 55"},{value:"#8A8A8A",name:"gray 54"},{value:"#878787",name:"gray 53"},{value:"#858585",name:"gray 52"},{value:"#828282",name:"gray 51"},{value:"#7F7F7F",name:"gray 50"},{value:"#7D7D7D",name:"gray 49"},{value:"#7A7A7A",name:"gray 48"},{value:"#787878",name:"gray 47"},{value:"#757575",name:"gray 46"},{value:"#737373",name:"gray 45"},{value:"#707070",name:"gray 44"},{value:"#6E6E6E",name:"gray 43"},{value:"#666666",name:"gray 40"},{value:"#636363",name:"gray 39"},{value:"#616161",name:"gray 38"},{value:"#5E5E5E",name:"gray 37"},{value:"#5C5C5C",name:"gray 36"},{value:"#595959",name:"gray 35"},{value:"#575757",name:"gray 34"},{value:"#545454",name:"gray 33"},{value:"#525252",name:"gray 32"},{value:"#4F4F4F",name:"gray 31"},{value:"#4D4D4D",name:"gray 30"},{value:"#4A4A4A",name:"gray 29"},{value:"#474747",name:"gray 28"},{value:"#454545",name:"gray 27"},{value:"#424242",name:"gray 26"},{value:"#404040",name:"gray 25"},{value:"#3D3D3D",name:"gray 24"},{value:"#3B3B3B",name:"gray 23"},{value:"#383838",name:"gray 22"},{value:"#363636",name:"gray 21"},{value:"#333333",name:"gray 20"},{value:"#303030",name:"gray 19"},{value:"#2E2E2E",name:"gray 18"},{value:"#2B2B2B",name:"gray 17"},{value:"#292929",name:"gray 16"},{value:"#262626",name:"gray 15"},{value:"#242424",name:"gray 14"},{value:"#212121",name:"gray 13"},{value:"#1F1F1F",name:"gray 12"},{value:"#1C1C1C",name:"gray 11"},{value:"#1A1A1A",name:"gray 10"},{value:"#171717",name:"gray 9"},{value:"#141414",name:"gray 8"},{value:"#121212",name:"gray 7"},{value:"#0F0F0F",name:"gray 6"},{value:"#0D0D0D",name:"gray 5"},{value:"#0A0A0A",name:"gray 4"},{value:"#080808",name:"gray 3"},{value:"#050505",name:"gray 2"},{value:"#030303",name:"gray 1"},{value:"#F5F5F5",css:!0,name:"whitesmoke"}]),dm}var vw;function O2(){return vw||(vw=1,(function(a){var e=D2(),t=e.filter(function(i){return!!i.css}),n=e.filter(function(i){return!!i.vga});a.exports=function(i){var r=a.exports.get(i);return r&&r.value},a.exports.get=function(i){return i=i||"",i=i.trim().toLowerCase(),e.filter(function(r){return r.name.toLowerCase()===i}).pop()},a.exports.all=a.exports.get.all=function(){return e},a.exports.get.css=function(i){return i?(i=i||"",i=i.trim().toLowerCase(),t.filter(function(r){return r.name.toLowerCase()===i}).pop()):t},a.exports.get.vga=function(i){return i?(i=i||"",i=i.trim().toLowerCase(),n.filter(function(r){return r.name.toLowerCase()===i}).pop()):n}})(hm)),hm.exports}var fm,yw;function B2(){if(yw)return fm;yw=1;var a="[object Symbol]",e=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,t="\\ud800-\\udfff",n="\\u0300-\\u036f\\ufe20-\\ufe23",i="\\u20d0-\\u20f0",r="\\u2700-\\u27bf",s="a-z\\xdf-\\xf6\\xf8-\\xff",o="\\xac\\xb1\\xd7\\xf7",l="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",c="\\u2000-\\u206f",u=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",h="A-Z\\xc0-\\xd6\\xd8-\\xde",d="\\ufe0e\\ufe0f",f=o+l+c+u,p="[']",m="["+f+"]",g="["+n+i+"]",v="\\d+",y="["+r+"]",w="["+s+"]",x="[^"+t+f+v+r+s+h+"]",S="\\ud83c[\\udffb-\\udfff]",b="(?:"+g+"|"+S+")",E="[^"+t+"]",M="(?:\\ud83c[\\udde6-\\uddff]){2}",T="[\\ud800-\\udbff][\\udc00-\\udfff]",I="["+h+"]",O="\\u200d",R="(?:"+w+"|"+x+")",k="(?:"+I+"|"+x+")",P="(?:"+p+"(?:d|ll|m|re|s|t|ve))?",F="(?:"+p+"(?:D|LL|M|RE|S|T|VE))?",N=b+"?",Y="["+d+"]?",_="(?:"+O+"(?:"+[E,M,T].join("|")+")"+Y+N+")*",G=Y+N+_,j="(?:"+[y,M,T].join("|")+")"+G,L=RegExp([I+"?"+w+"+"+P+"(?="+[m,I,"$"].join("|")+")",k+"+"+F+"(?="+[m,I+R,"$"].join("|")+")",I+"?"+R+"+"+P,I+"+"+F,v,j].join("|"),"g"),H=/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,q=typeof Zi=="object"&&Zi&&Zi.Object===Object&&Zi,$=typeof self=="object"&&self&&self.Object===Object&&self,ee=q||$||Function("return this")();function W(ge){return ge.match(e)||[]}function le(ge){return H.test(ge)}function K(ge){return ge.match(L)||[]}var pe=Object.prototype,se=pe.toString,ve=ee.Symbol,Z=ve?ve.prototype:void 0,oe=Z?Z.toString:void 0;function Ae(ge){if(typeof ge=="string")return ge;if(Se(ge))return oe?oe.call(ge):"";var Fe=ge+"";return Fe=="0"&&1/ge==-1/0?"-0":Fe}function Ee(ge){return!!ge&&typeof ge=="object"}function Se(ge){return typeof ge=="symbol"||Ee(ge)&&se.call(ge)==a}function ke(ge){return ge==null?"":Ae(ge)}function ye(ge,Fe,Me){return ge=ke(ge),Fe=Me?void 0:Fe,Fe===void 0?le(ge)?K(ge):W(ge):ge.match(Fe)||[]}return fm=ye,fm}var pm,xw;function L2(){if(xw)return pm;xw=1;var a="[object Symbol]",e=/^\s+/,t="\\ud800-\\udfff",n="\\u0300-\\u036f\\ufe20-\\ufe23",i="\\u20d0-\\u20f0",r="\\ufe0e\\ufe0f",s="["+t+"]",o="["+n+i+"]",l="\\ud83c[\\udffb-\\udfff]",c="(?:"+o+"|"+l+")",u="[^"+t+"]",h="(?:\\ud83c[\\udde6-\\uddff]){2}",d="[\\ud800-\\udbff][\\udc00-\\udfff]",f="\\u200d",p=c+"?",m="["+r+"]?",g="(?:"+f+"(?:"+[u,h,d].join("|")+")"+m+p+")*",v=m+p+g,y="(?:"+[u+o+"?",o,h,d,s].join("|")+")",w=RegExp(l+"(?="+l+")|"+y+v,"g"),x=RegExp("["+f+t+n+i+r+"]"),S=typeof Zi=="object"&&Zi&&Zi.Object===Object&&Zi,b=typeof self=="object"&&self&&self.Object===Object&&self,E=S||b||Function("return this")();function M(K){return K.split("")}function T(K,pe,se,ve){for(var Z=K.length,oe=se+-1;++oe<Z;)if(pe(K[oe],oe,K))return oe;return-1}function I(K,pe,se){if(pe!==pe)return T(K,O,se);for(var ve=se-1,Z=K.length;++ve<Z;)if(K[ve]===pe)return ve;return-1}function O(K){return K!==K}function R(K,pe){for(var se=-1,ve=K.length;++se<ve&&I(pe,K[se],0)>-1;);return se}function k(K){return x.test(K)}function P(K){return k(K)?F(K):M(K)}function F(K){return K.match(w)||[]}var N=Object.prototype,Y=N.toString,_=E.Symbol,G=_?_.prototype:void 0,j=G?G.toString:void 0;function L(K,pe,se){var ve=-1,Z=K.length;pe<0&&(pe=-pe>Z?0:Z+pe),se=se>Z?Z:se,se<0&&(se+=Z),Z=pe>se?0:se-pe>>>0,pe>>>=0;for(var oe=Array(Z);++ve<Z;)oe[ve]=K[ve+pe];return oe}function H(K){if(typeof K=="string")return K;if(ee(K))return j?j.call(K):"";var pe=K+"";return pe=="0"&&1/K==-1/0?"-0":pe}function q(K,pe,se){var ve=K.length;return se=se===void 0?ve:se,!pe&&se>=ve?K:L(K,pe,se)}function $(K){return!!K&&typeof K=="object"}function ee(K){return typeof K=="symbol"||$(K)&&Y.call(K)==a}function W(K){return K==null?"":H(K)}function le(K,pe,se){if(K=W(K),K&&(se||pe===void 0))return K.replace(e,"");if(!K||!(pe=H(pe)))return K;var ve=P(K),Z=R(ve,P(pe));return q(ve,Z).join("")}return pm=le,pm}var mm,ww;function z2(){if(ww)return mm;ww=1;var a=1/0,e=9007199254740991,t=17976931348623157e292,n=NaN,i="[object Symbol]",r=/^\s+|\s+$/g,s=/^[-+]0x[0-9a-f]+$/i,o=/^0b[01]+$/i,l=/^0o[0-7]+$/i,c="\\ud800-\\udfff",u="\\u0300-\\u036f\\ufe20-\\ufe23",h="\\u20d0-\\u20f0",d="\\ufe0e\\ufe0f",f="["+c+"]",p="["+u+h+"]",m="\\ud83c[\\udffb-\\udfff]",g="(?:"+p+"|"+m+")",v="[^"+c+"]",y="(?:\\ud83c[\\udde6-\\uddff]){2}",w="[\\ud800-\\udbff][\\udc00-\\udfff]",x="\\u200d",S=g+"?",b="["+d+"]?",E="(?:"+x+"(?:"+[v,y,w].join("|")+")"+b+S+")*",M=b+S+E,T="(?:"+[v+p+"?",p,y,w,f].join("|")+")",I=RegExp(m+"(?="+m+")|"+T+M,"g"),O=RegExp("["+x+c+u+h+d+"]"),R=parseInt,k=typeof Zi=="object"&&Zi&&Zi.Object===Object&&Zi,P=typeof self=="object"&&self&&self.Object===Object&&self,F=k||P||Function("return this")(),N=_("length");function Y(U){return U.split("")}function _(U){return function(J){return J?.[U]}}function G(U){return O.test(U)}function j(U){return G(U)?H(U):N(U)}function L(U){return G(U)?q(U):Y(U)}function H(U){for(var J=I.lastIndex=0;I.test(U);)J++;return J}function q(U){return U.match(I)||[]}var $=Object.prototype,ee=$.toString,W=F.Symbol,le=Math.ceil,K=Math.floor,pe=W?W.prototype:void 0,se=pe?pe.toString:void 0;function ve(U,J){var be="";if(!U||J<1||J>e)return be;do J%2&&(be+=U),J=K(J/2),J&&(U+=U);while(J);return be}function Z(U,J,be){var we=-1,Pe=U.length;J<0&&(J=-J>Pe?0:Pe+J),be=be>Pe?Pe:be,be<0&&(be+=Pe),Pe=J>be?0:be-J>>>0,J>>>=0;for(var ie=Array(Pe);++we<Pe;)ie[we]=U[we+J];return ie}function oe(U){if(typeof U=="string")return U;if(ye(U))return se?se.call(U):"";var J=U+"";return J=="0"&&1/U==-a?"-0":J}function Ae(U,J,be){var we=U.length;return be=be===void 0?we:be,!J&&be>=we?U:Z(U,J,be)}function Ee(U,J){J=J===void 0?" ":oe(J);var be=J.length;if(be<2)return be?ve(J,U):J;var we=ve(J,le(U/j(J)));return G(J)?Ae(L(we),0,U).join(""):we.slice(0,U)}function Se(U){var J=typeof U;return!!U&&(J=="object"||J=="function")}function ke(U){return!!U&&typeof U=="object"}function ye(U){return typeof U=="symbol"||ke(U)&&ee.call(U)==i}function ge(U){if(!U)return U===0?U:0;if(U=Me(U),U===a||U===-a){var J=U<0?-1:1;return J*t}return U===U?U:0}function Fe(U){var J=ge(U),be=J%1;return J===J?be?J-be:J:0}function Me(U){if(typeof U=="number")return U;if(ye(U))return n;if(Se(U)){var J=typeof U.valueOf=="function"?U.valueOf():U;U=Se(J)?J+"":J}if(typeof U!="string")return U===0?U:+U;U=U.replace(r,"");var be=o.test(U);return be||l.test(U)?R(U.slice(2),be?2:8):s.test(U)?n:+U}function z(U){return U==null?"":oe(U)}function D(U,J,be){U=z(U),J=Fe(J);var we=J?j(U):0;return J&&we<J?U+Ee(J-we,be):U}return mm=D,mm}var gm,Aw;function N2(){return Aw||(Aw=1,gm=(a,e,t,n)=>{const i=(a+(n||"")).toString().includes("%");if(typeof a=="string"?[a,e,t,n]=a.match(/(0?\.?\d{1,3})%?\b/g).map(Number):n!==void 0&&(n=parseFloat(n)),typeof a!="number"||typeof e!="number"||typeof t!="number"||a>255||e>255||t>255)throw new TypeError("Expected three numbers below 256");if(typeof n=="number"){if(!i&&n>=0&&n<=1)n=Math.round(255*n);else if(i&&n>=0&&n<=100)n=Math.round(255*n/100);else throw new TypeError(`Expected alpha value (${n}) as a fraction or percentage`);n=(n|256).toString(16).slice(1)}else n="";return(t|e<<8|a<<16|1<<24).toString(16).slice(1)+n}),gm}var vm,Sw;function k2(){if(Sw)return vm;Sw=1;const a="a-f\\d",e=`#?[${a}]{3}[${a}]?`,t=`#?[${a}]{6}([${a}]{2})?`,n=new RegExp(`[^#${a}]`,"gi"),i=new RegExp(`^${e}$|^${t}$`,"i");return vm=(r,s={})=>{if(typeof r!="string"||n.test(r)||!i.test(r))throw new TypeError("Expected a valid hex string");r=r.replace(/^#/,"");let o=1;r.length===8&&(o=Number.parseInt(r.slice(6,8),16)/255,r=r.slice(0,6)),r.length===4&&(o=Number.parseInt(r.slice(3,4).repeat(2),16)/255,r=r.slice(0,3)),r.length===3&&(r=r[0]+r[0]+r[1]+r[1]+r[2]+r[2]);const l=Number.parseInt(r,16),c=l>>16,u=l>>8&255,h=l&255,d=typeof s.alpha=="number"?s.alpha:o;if(s.format==="array")return[c,u,h,d];if(s.format==="css"){const f=d===1?"":` / ${Number((d*100).toFixed(2))}%`;return`rgb(${c} ${u} ${h}${f})`}return{red:c,green:u,blue:h,alpha:d}},vm}var ym,Mw;function U2(){if(Mw)return ym;Mw=1;var a=O2(),e=B2(),t=L2(),n=z2(),i=N2(),r=k2();const s=.75,o=.25,l=16777215,c=49979693;ym=function(f){return"#"+d(String(JSON.stringify(f)))};function u(f){var p=e(f),m=[];return p.forEach(function(g){var v=a(g);v&&m.push(r(t(v,"#"),{format:"array"}))}),m}function h(f){var p=[0,0,0];return f.forEach(function(m){for(var g=0;g<3;g++)p[g]+=m[g]}),[p[0]/f.length,p[1]/f.length,p[2]/f.length]}function d(f){var p,m=u(f);m.length>0&&(p=h(m));var g=1,v=0,y=1;if(f.length>0)for(var w=0;w<f.length;w++)f[w].charCodeAt(0)>v&&(v=f[w].charCodeAt(0)),y=parseInt(l/v),g=(g+f[w].charCodeAt(0)*y*c)%l;var x=(g*f.length%l).toString(16);x=n(x,6,x);var S=r(x,{format:"array"});return p?i(o*S[0]+s*p[0],o*S[1]+s*p[1],o*S[2]+s*p[2]):x}return ym}var F2=U2();const H2=Bg(F2);class G2{#e;#t;constructor(e,t){this.#e=e,this.#t=t}async disposeAsync(){await this.#e.disposeAsync(),await this.#t.disposeAsync()}add(e){this.#e.add(e),this.#t.add(e)}values(){throw new Error("Not implemented")}}class V2{#e=[];#t=[];#i=!1;add(e){this.#t.length>0?this.#t.shift()(e):this.#e.push(e)}async*consume(){for(;!this.#i||this.#t.length>0||this.#e.length>0;)this.#e.length>0?yield this.#e.shift():yield await new Promise(e=>this.#t.push(e))}disposeAsync(){return this.#i=!0,Promise.resolve()}}function j2(a){return a!==null&&typeof a=="object"&&"id"in a&&typeof a.id=="string"}function GM(a,e){const t=[];for(let n=0;n<e;n++){const i=a.next();if(i.done)break;t.push(i.value)}return t}var ia;(function(a){a.DEBUG="debug",a.USE_CACHE="useCache"})(ia||(ia={}));const bw={[ia.DEBUG]:"false",[ia.USE_CACHE]:"true"};function Hd(a,e=!0){return typeof window<"u"&&typeof window.document<"u"?new URLSearchParams(window.location.search).get(a)??(e?bw[a]:void 0):e?bw[a]:void 0}function Q2(a,e,t=0){if(e.length===0)return 0;const n=a.length-e.length;for(let i=t;i<=n;i++){let r=!0;for(let s=0;s<e.length;s++)if(a[i+s]!==e[s]){r=!1;break}if(r)return i}return-1}class W2{promise;resolve;reject;id;constructor(e){this.id=e,this.promise=new Promise((t,n)=>{this.resolve=t,this.reject=n})}getId(){return this.id}getPromise(){return this.promise}found(e){this.resolve(e)}}class X2{item;expiresAt;constructor(e,t){this.item=e,this.expiresAt=t}isExpired(e){return e>this.expiresAt}setAccess(e,t){this.expiresAt=e+t}getItem(){return this.item}done(e){return!!this.isExpired(e)}}class J2{isGathered=new Map;references=new Map;cache=new Map;options;logger;disposed=!1;currentSize=0;timer;constructor(e,t){this.options=e,this.logger=t,this.resetGlobalTimer()}add(e,t,n){if(this.disposed)throw new Error("MemoryCache is disposed");this.currentSize+=e.size||0,this.cache.set(e.baseId,new X2(e,(n||this.now())+this.options.ttlms)),this.isGathered.has(e.baseId)||(this.isGathered.set(e.baseId,!0),this.scanForReferences(e.base,t))}get(e){if(this.disposed)throw new Error("MemoryCache is disposed");const t=this.cache.get(e);if(t)return t.setAccess(this.now(),this.options.ttlms),t.getItem()}scanForReferences(e,t){const n=i=>{if(!(i===null||typeof i!="object")){if(Array.isArray(i)){for(const r of i)n(r);return}for(const r in i)if(Object.prototype.hasOwnProperty.call(i,r)){if(r==="referencedId"){const s=i.referencedId;typeof s=="string"&&(this.references.set(s,(this.references.get(s)||0)+1),this.cache.has(s)||t(s))}n(i[r])}}};n(e)}resetGlobalTimer(){const e=()=>{this.cleanCache(),this.timer=setTimeout(e,this.options.ttlms)};this.timer=setTimeout(e,this.options.ttlms)}now(){return Date.now()}cleanCache(e){const t=this.options.maxSizeInMb*1024*1024;if(this.currentSize<t){this.logger(`cache size (${this.currentSize} < ${t}) is ok, no need to clean`);return}const n=e||this.now();let i=0;const r=performance.now();for(const s of Array.from(this.cache.values()).filter(o=>o.isExpired(n)).sort((o,l)=>this.compareMaybeBasesByReferences(o.getItem().baseId,l.getItem().baseId)))if(s.done(n)){const o=s.getItem().baseId;if((this.references.get(o)||0)>0)continue;if(this.currentSize-=s.getItem().size||0,this.cache.delete(o),i++,this.currentSize<t)break}this.logger(`cleaned cache: cleaned ${i}, cached ${this.cache.size}, time ${performance.now()-r}`)}compareMaybeBasesByReferences(e,t){const n=this.references.get(e),i=this.references.get(t);return n===void 0&&i===void 0?0:n===void 0?-1:i===void 0?1:n-i}dispose(){this.disposed||(this.disposed=!0,this.timer&&(clearTimeout(this.timer),this.timer=void 0),this.cache.clear(),this.isGathered.clear(),this.references.clear())}}class Z2{items;constructor(e){this.items=e}defer(e){const t=this.items.get(e.id);return t?[Promise.resolve(t),!0]:[Promise.reject(new Error("Not found in cache: "+e.id)),!1]}undefer(){}dispose(){}}class K2{outstanding=new Map;logger;disposed=!1;cache;constructor(e,t){this.logger=e,this.cache=t||new J2({maxSizeInMb:500,ttlms:5e3},e)}defer(e){if(this.disposed)throw new Error("DefermentManager is disposed");const t=this.cache.get(e.id);if(t)return[Promise.resolve(t.base),!0];const n=this.outstanding.get(e.id);if(n)return[n.getPromise(),!0];const i=new W2(e.id);return this.outstanding.set(e.id,i),[i.getPromise(),!1]}undefer(e,t){if(this.disposed)throw new Error("DefermentManager is disposed");const n=e.base;if(!n){this.logger("undefer called with no base",e);return}this.cache.add(e,r=>{this.outstanding.has(r)||t(r)});const i=this.outstanding.get(e.baseId);i&&(i.found(n),this.outstanding.delete(e.baseId))}dispose(){this.disposed||(this.disposed=!0,this.logger("cleared deferments, left",this.outstanding.size),this.outstanding.clear(),this.cache.dispose())}}class Y2{#e;#t=void 0;#i="speckle-cache";#n="cache";constructor(e){this.#e=e}async init(){if(!this.#t)return await this.#a(),this.#r()}async#r(){const e=this.#e.indexedDB??indexedDB;return new Promise((t,n)=>{const i=e.open(this.#i,1);i.onerror=()=>{console.warn(`Failed to open database: ${this.#i}, deleting and trying again`);const r=e.deleteDatabase(this.#i);r.onsuccess=()=>{this.#r().then(t).catch(n)},r.onerror=()=>{n(`Failed to delete and reopen database: ${this.#i}`)}},i.onupgradeneeded=r=>{const s=r.target.result;s.objectStoreNames.contains(this.#n)&&s.deleteObjectStore(this.#n),s.createObjectStore(this.#n,{keyPath:"baseId"})},i.onsuccess=r=>{this.#t=r.target.result,t()}})}#s(){if(!this.#t)throw new Error("Database not initialized. Call init() first.");return this.#t}async#a(){if(!P2()||!this.#e.indexedDB?.databases)return Promise.resolve();let e;return new Promise(t=>{const n=()=>this.#e.indexedDB?.databases().finally(t);e=setInterval(()=>{n()},100),n()}).finally(()=>clearInterval(e))}async putAll(e){return await this.init(),new Promise((t,n)=>{try{const i=this.#s().transaction(this.#n,"readwrite",{durability:"relaxed"}),r=i.objectStore(this.#n);i.onerror=()=>{n(`Transaction error: ${i.error}`)},i.oncomplete=()=>{t()},e.forEach(s=>r.put(s))}catch(i){n(i)}})}async getAll(e){return await this.init(),new Promise((t,n)=>{if(e.length===0)return t([]);try{const r=this.#s().transaction(this.#n,"readonly",{durability:"relaxed"}).objectStore(this.#n),s=[];for(const o of e)s.push(new Promise((l,c)=>{const u=r.get(o);u.onerror=()=>c(`Request error for id ${o}: ${u.error}`),u.onsuccess=()=>l(u.result)}));Promise.all(s).then(o=>{t(o)}).catch(n)}catch(i){n(i)}})}dispose(){this.#t&&(this.#t.close(),this.#t=void 0)}}class Ew{items;constructor(e){this.items=e?.items||new Map}getAll(e){const t=[];for(const n of e){const i=this.items.get(n);i?t.push({baseId:n,base:i}):t.push(void 0)}return Promise.resolve(t)}putAll(e){for(const t of e){if(!t.baseId||!t.base)throw new Error("Item must have a baseId and base");this.items.set(t.baseId,t.base)}return Promise.resolve()}dispose(){this.items.clear()}}class q2{#e;#t;#i;constructor(e,t){this.#t=e,this.#e=t}initialize(e){this.#i=e.results}downloadSingle(){const e=this.#e.get(this.#t);return e?Promise.resolve({baseId:this.#t,base:e}):Promise.reject(new Error("Method not implemented."))}disposeAsync(){return Promise.resolve()}add(e){const t=this.#e.get(e);if(t){this.#i?.add({baseId:e,base:t});return}throw new Error("Method not implemented.")}}class _2{_map;_order;constructor(){this._map=new Map,this._order=[]}enqueue(e,t){return this._map.has(e)?!1:(this._map.set(e,t),this._order.push(e),!0)}enqueueAll(e,t){let n=0;for(let i=0;i<e.length;i++)this._map.has(e[i])||(this._map.set(e[i],t[i]),this._order.push(e[i]),n++);return n}get(e){return this._map.get(e)}has(e){return this._map.has(e)}get size(){return this._order.length}spliceValues(e,t){const n=this._order.splice(e,t),i=[];for(const r of n){const s=this._map.get(r);s!==void 0&&(i.push(s),this._map.delete(r))}return i}}const $2=100;class r0{#e=new _2;#t;#i;#n=null;#r=!1;#s=!1;#a=!1;#o;#l(){return typeof window<"u"?window.setTimeout.bind(window):typeof global<"u"?global.setTimeout:setTimeout}#c(){return typeof window<"u"?window.clearTimeout.bind(window):typeof global<"u"?global.clearTimeout:clearTimeout}constructor(e){this.#t=e.batchSize,this.#i=e.processFunction,this.#o=e.maxWaitTime}async disposeAsync(){if(!this.#s){for(this.#s=!0,this.#n&&(this.#c()(this.#n),this.#n=null);this.#r;)await new Promise(e=>this.#l()(e,$2));this.#e.size>0&&await this.flush()}}add(e,t){this.#s||this.#a||(this.#e.enqueue(e,t),this.#u())}addAll(e,t){this.#s||this.#a||(this.#e.enqueueAll(e,t),this.#u())}#u(){this.#s||(this.#e.size>=this.#t?this.flush():(this.#n&&this.#c()(this.#n),this.#n=this.#l()(()=>this.flush(),this.#o)))}async flush(){if(this.#n&&(this.#c()(this.#n),this.#n=null),!(this.#a||this.#r||this.#e.size===0)){this.#r=!0;try{const e=this.#h(this.#t);await this.#i(e)}catch(e){console.error("Batch processing failed:",e),this.#a=!0}finally{this.#r=!1}this.#u()}}get(e){return this.#e.get(e)}count(){return this.#e.size}isDisposed(){return this.#s}isErrored(){return this.#a}#h(e){return this.#e.spliceValues(0,Math.min(e,this.#e.size))}}class eN extends Error{static defaultMessage="Unexpected error occurred";constructor(e){e||=new.target.defaultMessage,super(e)}}class jo extends eN{static defaultMessage="Object loader encountered a runtime problem!"}const tN=2*1024*1024*1024-1024*1024;class nN{#e;#t;#i;#n;#r;#s;#a;#o;#l;#c=new TextDecoder("utf-8",{fatal:!0});#u=0;#h=[];#d=[];constructor(e){if(this.#n=e,this.#o=e.logger,this.#r=e.fetch??((...n)=>globalThis.fetch(...n)),this.#i={},e.headers)for(const n of e.headers.entries())this.#i[n[0]]=n[1];this.#i.Accept="text/plain",this.#n.token&&(this.#i.Authorization=`Bearer ${this.#n.token}`),this.#t=`${this.#n.serverUrl}/api/v2/projects/${this.#n.streamId}/object-stream/`,this.#e=`${this.#n.serverUrl}/objects/${this.#n.streamId}/${this.#n.objectId}/single`;const t=new TextEncoder;e.objectTypeMask&&(this.#h.push(...e.objectTypeMask),this.#d.push(...e.objectTypeMask.map(n=>t.encode(n))))}initialize(e){const{results:t,total:n,maxDownloadBatchWait:i}=e;this.#s=t,this.#a=n,this.#l=new r0({batchSize:15e3,maxWaitTime:i??1e3,processFunction:r=>this.downloadBatch({batch:r,url:this.#t,headers:this.#i})})}add(e){this.#l?.add(e,e)}decodeChunk(e){this.#u+e.byteLength>tN&&(this.#c=new TextDecoder("utf-8",{fatal:!0}),this.#u=0);const t=this.#c.decode(e);return this.#u+=e.byteLength,t}async disposeAsync(){await this.#l?.disposeAsync()}async downloadBatch(e){const{batch:t,url:n,headers:i}=e,r=performance.now();this.#o(`Downloading batch of ${t.length} items...`);const s=this.#n.attributeMask,o=new Set(t),l=await this.#r(n,{method:"POST",headers:{...i,"Content-Type":"application/json"},body:JSON.stringify({objectIds:t,attributeMask:s})});if(this.#p(l),!l.body)throw new Error("ReadableStream not supported or response has no body.");const c=l.body.getReader();let u=new Uint8Array(0),h=0;for(;;){const{done:d,value:f}=await c.read();if(d)break;u=await this.#m(u,f,o,async()=>{h++,h%1e3===0&&await new Promise(p=>setTimeout(p,100))})}if(o.size>0)throw new Error("Items requested were not downloaded: "+GM(o.values(),10).join(","));h+=o.size,h>=this.#a&&await this.#s?.disposeAsync(),this.#o(`Downloaded batch of ${t.length} items in ${performance.now()-r}ms`)}async#m(e,t,n,i){const r=this.#x(e,t);let s=0;for(let o=0;o<r.length;o++)if(r[o]===10){const l=r.subarray(s,o),c=this.#g(l);s=o+1,await i(),n.delete(c.baseId),this.#s?.add(c)}return r.subarray(s)}#g(e){for(let t=0;t<e.length;t++)if(e[t]===9){const n=this.decodeChunk(e.subarray(0,t)),i=e.subarray(t+1);if(!this.#y(i))return{baseId:n,base:void 0};const r=this.decodeChunk(i),s=this.#f(n,r);return s.size=i.length,s}throw new jo("Invalid line format in response: "+this.decodeChunk(e))}#f(e,t){let n;try{n=JSON.parse(t)}catch(i){throw new Error(`Error parsing object ${e}: ${i.message}`)}if(j2(n))return{baseId:e,base:n};throw new jo(`${e} is not a base`)}#v(e){for(const t of this.#h)if(e.includes(t))return!1;return!0}#y(e){for(const t of this.#d)if(Q2(e,t)!==-1)return!1;return!0}#x(e,t){const n=new Uint8Array(e.length+t.length);return n.set(e,0),n.set(t,e.length),n}async downloadSingle(){const e=await this.#r(this.#e,{headers:this.#i});this.#p(e);const t=await e.text();if(!this.#v(t))throw new jo("Invalid base object");const n=this.#f(this.#n.objectId,t);if(!n.base)throw new jo("Invalid base object");return n.size=0,n}#p(e){if(!e.ok)throw[401,403].includes(e.status)?new jo("You do not have access!"):new jo(`Failed to fetch objects: ${e.status} ${e.statusText})`)}}class yl{static createFromObjects(e){const t=e[0],n=new Map;return e.forEach(r=>{n.set(r.id,r)}),new Tw({rootId:t.id,deferments:new Z2(n),database:new Ew({items:n}),downloader:new q2(t.id,n)})}static createFromJSON(e){const t=JSON.parse(e);return this.createFromObjects(t)}static createFromUrl(e){const t=yl.getLogger(e.options?.logger);let n;(e.options?.debug===!0||Hd(ia.DEBUG)==="true")&&this.logger("Using DEBUG mode for ObjectLoader2Factory");const i=e.options?.useCache??!0,s=Hd(ia.USE_CACHE)!=="false";i&&s?n=new Y2({indexedDB:e.options?.indexedDB,keyRange:e.options?.keyRange}):(n=new Ew({items:new Map}),this.logger("Disabled persistent caching for ObjectLoader2.  Using MemoryDatabase"));const o=t||(()=>{});return new Tw({rootId:e.objectId,deferments:new K2(o),downloader:new nN({serverUrl:e.serverUrl,streamId:e.streamId,objectId:e.objectId,token:e.token,headers:e.headers,fetch:e.options?.fetch,attributeMask:e.attributeMask,objectTypeMask:e.objectTypeMask,logger:o}),database:n,logger:o})}static getLogger(e){return Hd(ia.DEBUG)==="true"?e||this.logger:e}static logger=(e,...t)=>{console.log(`[debug] ${e}`,...t)}}class iN{#e;#t;#i;#n;#r;#s;#a;constructor(e,t,n,i){this.#e=e,this.#t=t,this.#i=n,this.#n=i}initializeQueue(e,t){this.#s=e,this.#a=t}getObject(e){const[t,n]=this.#t.defer({id:e.id});return n||this.requestItem(e.id),t}#o(){this.#r||(this.#r=new r0({batchSize:this.#n.maxCacheReadSize,maxWaitTime:this.#n.maxCacheBatchReadWait,processFunction:this.#l}))}requestItem(e){this.#o(),this.#r?.get(e)||this.#r?.add(e,e)}requestAll(e){this.#o(),this.#r?.addAll(e,e)}#l=async e=>{const t=performance.now(),n=await this.#e.getAll(e);for(let i=0;i<n.length;i++){const r=n[i];r?(this.#s?.add(r),this.#t.undefer(r,s=>this.requestItem(s))):this.#a?.add(e[i])}this.#i(`readBatch: batch ${e.length}, time ${performance.now()-t} ms left ${this.#r?.count()}`)};disposeAsync(){return this.#r?.disposeAsync()||Promise.resolve()}}class rN{#e;#t;#i;#n;#r;#s;#a=!1;constructor(e,t,n,i,r){this.#t=e,this.#s=i,this.#r=t,this.#i=n,this.#n=r}add(e){this.#e||(this.#e=new r0({batchSize:this.#s.maxCacheWriteSize,maxWaitTime:this.#s.maxCacheBatchWriteWait,processFunction:async t=>{await this.writeAll(t)}})),this.#e.add(e.baseId,e),this.#i.undefer(e,this.#n)}async writeAll(e){const t=performance.now();await this.#t.putAll(e),this.#r(`writeBatch: wrote ${e.length}, time ${performance.now()-t} ms left ${this.#e?.count()}`)}async disposeAsync(){this.#a=!0,await this.#e?.disposeAsync()}get isDisposed(){return this.#a}}const sN=100,aN=100;class Tw{#e;#t;#i;#n;#r;#s;#a;#o;#l=void 0;#c=!1;constructor(e){this.#e=e.rootId,this.#t=e.logger||(()=>{}),this.#t("ObjectLoader2 initialized with rootId:",this.#e);const t={logger:this.#t,maxCacheReadSize:1e4,maxCacheWriteSize:1e4,maxWriteQueueSize:4e4,maxCacheBatchWriteWait:100,maxCacheBatchReadWait:100};this.#o=new V2,this.#i=e.database,this.#a=e.deferments,this.#n=e.downloader,this.#r=new iN(this.#i,this.#a,this.#t,t),this.#r.initializeQueue(this.#o,this.#n),this.#s=new rN(this.#i,this.#t,this.#a,t,n=>{this.#r.requestItem(n)})}async disposeAsync(){await Promise.all([this.#o.disposeAsync(),this.#n.disposeAsync(),this.#s.disposeAsync(),this.#r.disposeAsync()]),this.#a.dispose()}async getRootObject(){return this.#l||(this.#l=(await this.#i.getAll([this.#e]))[0],this.#l?this.#c=!0:this.#l=await this.#n.downloadSingle()),this.#l}async getObject(e){return await this.#r.getObject({id:e.id})}async getTotalObjectCount(){const e=await this.getRootObject();return Object.keys(e?.base?.__closure||{}).length+1}async*getObjectIterator(){const e=await this.getRootObject();if(e?.base===void 0){this.#t("No root object found!");return}if(!e.base.__closure){yield e.base;return}const t=Object.entries(e.base.__closure??[]).sort((s,o)=>o[1]-s[1]);this.#t("calculated closures: ",!GM(t.values(),sN).every(s=>s[1]===aN));const n=t.map(s=>s[0]),i=n.length+1;this.#n.initialize({results:new G2(this.#o,this.#s),total:i}),this.#o.add(e),this.#r.requestAll(n);let r=0;for await(const s of this.#o.consume())if(yield s.base,r++,r>=i)break;this.#c||(await this.#i.putAll([e]),this.#c=!0)}static createFromObjects(e){return yl.createFromObjects(e)}static createFromJSON(e){return yl.createFromJSON(e)}}const oN=/^[og]\s*(.+)?/,lN=/^mtllib /,cN=/^usemtl /,uN=/^usemap /,Cw=new A,xm=new A,Iw=new A,Rw=new A,ji=new A,ud=new Ie;function hN(){const a={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(e,t){if(this.object&&this.object.fromDeclaration===!1){this.object.name=e,this.object.fromDeclaration=t!==!1;return}const n=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:t!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(i,r){const s=this._finalize(!1);s&&(s.inherited||s.groupCount<=0)&&this.materials.splice(s.index,1);const o={index:this.materials.length,name:i||"",mtllib:Array.isArray(r)&&r.length>0?r[r.length-1]:"",smooth:s!==void 0?s.smooth:this.smooth,groupStart:s!==void 0?s.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(l){const c={index:typeof l=="number"?l:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return c.clone=this.clone.bind(c),c}};return this.materials.push(o),o},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(i){const r=this.currentMaterial();if(r&&r.groupEnd===-1&&(r.groupEnd=this.geometry.vertices.length/3,r.groupCount=r.groupEnd-r.groupStart,r.inherited=!1),i&&this.materials.length>1)for(let s=this.materials.length-1;s>=0;s--)this.materials[s].groupCount<=0&&this.materials.splice(s,1);return i&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),r}},n&&n.name&&typeof n.clone=="function"){const i=n.clone(0);i.inherited=!0,this.object.materials.push(i)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(e,t){const n=parseInt(e,10);return(n>=0?n-1:n+t/3)*3},parseNormalIndex:function(e,t){const n=parseInt(e,10);return(n>=0?n-1:n+t/3)*3},parseUVIndex:function(e,t){const n=parseInt(e,10);return(n>=0?n-1:n+t/2)*2},addVertex:function(e,t,n){const i=this.vertices,r=this.object.geometry.vertices;r.push(i[e+0],i[e+1],i[e+2]),r.push(i[t+0],i[t+1],i[t+2]),r.push(i[n+0],i[n+1],i[n+2])},addVertexPoint:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addVertexLine:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addNormal:function(e,t,n){const i=this.normals,r=this.object.geometry.normals;r.push(i[e+0],i[e+1],i[e+2]),r.push(i[t+0],i[t+1],i[t+2]),r.push(i[n+0],i[n+1],i[n+2])},addFaceNormal:function(e,t,n){const i=this.vertices,r=this.object.geometry.normals;Cw.fromArray(i,e),xm.fromArray(i,t),Iw.fromArray(i,n),ji.subVectors(Iw,xm),Rw.subVectors(Cw,xm),ji.cross(Rw),ji.normalize(),r.push(ji.x,ji.y,ji.z),r.push(ji.x,ji.y,ji.z),r.push(ji.x,ji.y,ji.z)},addColor:function(e,t,n){const i=this.colors,r=this.object.geometry.colors;i[e]!==void 0&&r.push(i[e+0],i[e+1],i[e+2]),i[t]!==void 0&&r.push(i[t+0],i[t+1],i[t+2]),i[n]!==void 0&&r.push(i[n+0],i[n+1],i[n+2])},addUV:function(e,t,n){const i=this.uvs,r=this.object.geometry.uvs;r.push(i[e+0],i[e+1]),r.push(i[t+0],i[t+1]),r.push(i[n+0],i[n+1])},addDefaultUV:function(){const e=this.object.geometry.uvs;e.push(0,0),e.push(0,0),e.push(0,0)},addUVLine:function(e){const t=this.uvs;this.object.geometry.uvs.push(t[e+0],t[e+1])},addFace:function(e,t,n,i,r,s,o,l,c){const u=this.vertices.length;let h=this.parseVertexIndex(e,u),d=this.parseVertexIndex(t,u),f=this.parseVertexIndex(n,u);if(this.addVertex(h,d,f),this.addColor(h,d,f),o!==void 0&&o!==""){const p=this.normals.length;h=this.parseNormalIndex(o,p),d=this.parseNormalIndex(l,p),f=this.parseNormalIndex(c,p),this.addNormal(h,d,f)}else this.addFaceNormal(h,d,f);if(i!==void 0&&i!==""){const p=this.uvs.length;h=this.parseUVIndex(i,p),d=this.parseUVIndex(r,p),f=this.parseUVIndex(s,p),this.addUV(h,d,f),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(e){this.object.geometry.type="Points";const t=this.vertices.length;for(let n=0,i=e.length;n<i;n++){const r=this.parseVertexIndex(e[n],t);this.addVertexPoint(r),this.addColor(r)}},addLineGeometry:function(e,t){this.object.geometry.type="Line";const n=this.vertices.length,i=this.uvs.length;for(let r=0,s=e.length;r<s;r++)this.addVertexLine(this.parseVertexIndex(e[r],n));for(let r=0,s=t.length;r<s;r++)this.addUVLine(this.parseUVIndex(t[r],i))}};return a.startObject("",!1),a}class dN extends ni{constructor(e){super(e),this.materials=null}load(e,t,n,i){const r=this,s=new $i(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(e,function(o){try{t(r.parse(o))}catch(l){i?i(l):console.error(l),r.manager.itemError(e)}},n,i)}setMaterials(e){return this.materials=e,this}parse(e){const t=new hN;e.indexOf(`\r
`)!==-1&&(e=e.replace(/\r\n/g,`
`)),e.indexOf(`\\
`)!==-1&&(e=e.replace(/\\\n/g,""));const n=e.split(`
`);let i="",r="",s=0,o=[];const l=typeof"".trimLeft=="function";for(let h=0,d=n.length;h<d;h++)if(i=n[h],i=l?i.trimLeft():i.trim(),s=i.length,s!==0&&(r=i.charAt(0),r!=="#"))if(r==="v"){const f=i.split(/\s+/);switch(f[0]){case"v":t.vertices.push(parseFloat(f[1]),parseFloat(f[2]),parseFloat(f[3])),f.length>=7?(ud.setRGB(parseFloat(f[4]),parseFloat(f[5]),parseFloat(f[6])).convertSRGBToLinear(),t.colors.push(ud.r,ud.g,ud.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(f[1]),parseFloat(f[2]),parseFloat(f[3]));break;case"vt":t.uvs.push(parseFloat(f[1]),parseFloat(f[2]));break}}else if(r==="f"){const p=i.slice(1).trim().split(/\s+/),m=[];for(let v=0,y=p.length;v<y;v++){const w=p[v];if(w.length>0){const x=w.split("/");m.push(x)}}const g=m[0];for(let v=1,y=m.length-1;v<y;v++){const w=m[v],x=m[v+1];t.addFace(g[0],w[0],x[0],g[1],w[1],x[1],g[2],w[2],x[2])}}else if(r==="l"){const f=i.substring(1).trim().split(" ");let p=[];const m=[];if(i.indexOf("/")===-1)p=f;else for(let g=0,v=f.length;g<v;g++){const y=f[g].split("/");y[0]!==""&&p.push(y[0]),y[1]!==""&&m.push(y[1])}t.addLineGeometry(p,m)}else if(r==="p"){const p=i.slice(1).trim().split(" ");t.addPointGeometry(p)}else if((o=oN.exec(i))!==null){const f=(" "+o[0].slice(1).trim()).slice(1);t.startObject(f)}else if(cN.test(i))t.object.startMaterial(i.substring(7).trim(),t.materialLibraries);else if(lN.test(i))t.materialLibraries.push(i.substring(7).trim());else if(uN.test(i))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(r==="s"){if(o=i.split(" "),o.length>1){const p=o[1].trim().toLowerCase();t.object.smooth=p!=="0"&&p!=="off"}else t.object.smooth=!0;const f=t.object.currentMaterial();f&&(f.smooth=t.object.smooth)}else{if(i==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+i+'"')}t.finalize();const c=new fi;if(c.materialLibraries=[].concat(t.materialLibraries),!(t.objects.length===1&&t.objects[0].geometry.vertices.length===0)===!0)for(let h=0,d=t.objects.length;h<d;h++){const f=t.objects[h],p=f.geometry,m=f.materials,g=p.type==="Line",v=p.type==="Points";let y=!1;if(p.vertices.length===0)continue;const w=new nt;w.setAttribute("position",new je(p.vertices,3)),p.normals.length>0&&w.setAttribute("normal",new je(p.normals,3)),p.colors.length>0&&(y=!0,w.setAttribute("color",new je(p.colors,3))),p.hasUVIndices===!0&&w.setAttribute("uv",new je(p.uvs,2));const x=[];for(let b=0,E=m.length;b<E;b++){const M=m[b],T=M.name+"_"+M.smooth+"_"+y;let I=t.materials[T];if(this.materials!==null){if(I=this.materials.create(M.name),g&&I&&!(I instanceof mn)){const O=new mn;cn.prototype.copy.call(O,I),O.color.copy(I.color),I=O}else if(v&&I&&!(I instanceof Ki)){const O=new Ki({size:10,sizeAttenuation:!1});cn.prototype.copy.call(O,I),O.color.copy(I.color),O.map=I.map,I=O}}I===void 0&&(g?I=new mn:v?I=new Ki({size:1,sizeAttenuation:!1}):I=new zf,I.name=M.name,I.flatShading=!M.smooth,I.vertexColors=y,t.materials[T]=I),x.push(I)}let S;if(x.length>1){for(let b=0,E=m.length;b<E;b++){const M=m[b];w.addGroup(M.groupStart,M.groupCount,b)}g?S=new gi(w,x):v?S=new ms(w,x):S=new Ve(w,x)}else g?S=new gi(w,x[0]):v?S=new ms(w,x[0]):S=new Ve(w,x[0]);S.name=f.name,c.add(S)}else if(t.vertices.length>0){const h=new Ki({size:1,sizeAttenuation:!1}),d=new nt;d.setAttribute("position",new je(t.vertices,3)),t.colors.length>0&&t.colors[0]!==void 0&&(d.setAttribute("color",new je(t.colors,3)),h.vertexColors=!0);const f=new ms(d,h);c.add(f)}return c}}function fN(a,e=1e-4){e=Math.max(e,Number.EPSILON);const t={},n=a.getIndex(),i=a.getAttribute("position"),r=n?n.count:i.count;let s=0;const o=Object.keys(a.attributes),l={},c={},u=[],h=["getX","getY","getZ","getW"];for(let m=0,g=o.length;m<g;m++){const v=o[m];l[v]=[];const y=a.morphAttributes[v];y&&(c[v]=new Array(y.length).fill().map(()=>[]))}const d=Math.log10(1/e),f=Math.pow(10,d);for(let m=0;m<r;m++){const g=n?n.getX(m):m;let v="";for(let y=0,w=o.length;y<w;y++){const x=o[y],S=a.getAttribute(x),b=S.itemSize;for(let E=0;E<b;E++)v+=`${~~(S[h[E]](g)*f)},`}if(v in t)u.push(t[v]);else{for(let y=0,w=o.length;y<w;y++){const x=o[y],S=a.getAttribute(x),b=a.morphAttributes[x],E=S.itemSize,M=l[x],T=c[x];for(let I=0;I<E;I++){const O=h[I];if(M.push(S[O](g)),b)for(let R=0,k=b.length;R<k;R++)T[R].push(b[R][O](g))}}t[v]=s,u.push(s),s++}}const p=a.clone();for(let m=0,g=o.length;m<g;m++){const v=o[m],y=a.getAttribute(v),w=new y.array.constructor(l[v]),x=new wt(w,y.itemSize,y.normalized);if(p.setAttribute(v,x),v in c)for(let S=0;S<c[v].length;S++){const b=a.morphAttributes[v][S],E=new b.array.constructor(c[v][S]),M=new wt(E,b.itemSize,b.normalized);p.morphAttributes[v][S]=M}}return p.setIndex(u),p}const pN=new ki(-1,1,1,-1,0,1),s0=new nt;s0.setAttribute("position",new je([-1,3,0,-1,-1,0,3,-1,0],3));s0.setAttribute("uv",new je([0,2,0,0,2,0],2));class zl{constructor(e){this._mesh=new Ve(s0,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,pN)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}class Pw{constructor(e=Math){this.grad3=[[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]],this.grad4=[[0,1,1,1],[0,1,1,-1],[0,1,-1,1],[0,1,-1,-1],[0,-1,1,1],[0,-1,1,-1],[0,-1,-1,1],[0,-1,-1,-1],[1,0,1,1],[1,0,1,-1],[1,0,-1,1],[1,0,-1,-1],[-1,0,1,1],[-1,0,1,-1],[-1,0,-1,1],[-1,0,-1,-1],[1,1,0,1],[1,1,0,-1],[1,-1,0,1],[1,-1,0,-1],[-1,1,0,1],[-1,1,0,-1],[-1,-1,0,1],[-1,-1,0,-1],[1,1,1,0],[1,1,-1,0],[1,-1,1,0],[1,-1,-1,0],[-1,1,1,0],[-1,1,-1,0],[-1,-1,1,0],[-1,-1,-1,0]],this.p=[];for(let t=0;t<256;t++)this.p[t]=Math.floor(e.random()*256);this.perm=[];for(let t=0;t<512;t++)this.perm[t]=this.p[t&255];this.simplex=[[0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0],[0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0],[1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0],[2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]]}dot(e,t,n){return e[0]*t+e[1]*n}dot3(e,t,n,i){return e[0]*t+e[1]*n+e[2]*i}dot4(e,t,n,i,r){return e[0]*t+e[1]*n+e[2]*i+e[3]*r}noise(e,t){let n,i,r;const s=.5*(Math.sqrt(3)-1),o=(e+t)*s,l=Math.floor(e+o),c=Math.floor(t+o),u=(3-Math.sqrt(3))/6,h=(l+c)*u,d=l-h,f=c-h,p=e-d,m=t-f;let g,v;p>m?(g=1,v=0):(g=0,v=1);const y=p-g+u,w=m-v+u,x=p-1+2*u,S=m-1+2*u,b=l&255,E=c&255,M=this.perm[b+this.perm[E]]%12,T=this.perm[b+g+this.perm[E+v]]%12,I=this.perm[b+1+this.perm[E+1]]%12;let O=.5-p*p-m*m;O<0?n=0:(O*=O,n=O*O*this.dot(this.grad3[M],p,m));let R=.5-y*y-w*w;R<0?i=0:(R*=R,i=R*R*this.dot(this.grad3[T],y,w));let k=.5-x*x-S*S;return k<0?r=0:(k*=k,r=k*k*this.dot(this.grad3[I],x,S)),70*(n+i+r)}noise3d(e,t,n){let i,r,s,o;const c=(e+t+n)*.3333333333333333,u=Math.floor(e+c),h=Math.floor(t+c),d=Math.floor(n+c),f=1/6,p=(u+h+d)*f,m=u-p,g=h-p,v=d-p,y=e-m,w=t-g,x=n-v;let S,b,E,M,T,I;y>=w?w>=x?(S=1,b=0,E=0,M=1,T=1,I=0):y>=x?(S=1,b=0,E=0,M=1,T=0,I=1):(S=0,b=0,E=1,M=1,T=0,I=1):w<x?(S=0,b=0,E=1,M=0,T=1,I=1):y<x?(S=0,b=1,E=0,M=0,T=1,I=1):(S=0,b=1,E=0,M=1,T=1,I=0);const O=y-S+f,R=w-b+f,k=x-E+f,P=y-M+2*f,F=w-T+2*f,N=x-I+2*f,Y=y-1+3*f,_=w-1+3*f,G=x-1+3*f,j=u&255,L=h&255,H=d&255,q=this.perm[j+this.perm[L+this.perm[H]]]%12,$=this.perm[j+S+this.perm[L+b+this.perm[H+E]]]%12,ee=this.perm[j+M+this.perm[L+T+this.perm[H+I]]]%12,W=this.perm[j+1+this.perm[L+1+this.perm[H+1]]]%12;let le=.6-y*y-w*w-x*x;le<0?i=0:(le*=le,i=le*le*this.dot3(this.grad3[q],y,w,x));let K=.6-O*O-R*R-k*k;K<0?r=0:(K*=K,r=K*K*this.dot3(this.grad3[$],O,R,k));let pe=.6-P*P-F*F-N*N;pe<0?s=0:(pe*=pe,s=pe*pe*this.dot3(this.grad3[ee],P,F,N));let se=.6-Y*Y-_*_-G*G;return se<0?o=0:(se*=se,o=se*se*this.dot3(this.grad3[W],Y,_,G)),32*(i+r+s+o)}noise4d(e,t,n,i){const r=this.grad4,s=this.simplex,o=this.perm,l=(Math.sqrt(5)-1)/4,c=(5-Math.sqrt(5))/20;let u,h,d,f,p;const m=(e+t+n+i)*l,g=Math.floor(e+m),v=Math.floor(t+m),y=Math.floor(n+m),w=Math.floor(i+m),x=(g+v+y+w)*c,S=g-x,b=v-x,E=y-x,M=w-x,T=e-S,I=t-b,O=n-E,R=i-M,k=T>I?32:0,P=T>O?16:0,F=I>O?8:0,N=T>R?4:0,Y=I>R?2:0,_=O>R?1:0,G=k+P+F+N+Y+_,j=s[G][0]>=3?1:0,L=s[G][1]>=3?1:0,H=s[G][2]>=3?1:0,q=s[G][3]>=3?1:0,$=s[G][0]>=2?1:0,ee=s[G][1]>=2?1:0,W=s[G][2]>=2?1:0,le=s[G][3]>=2?1:0,K=s[G][0]>=1?1:0,pe=s[G][1]>=1?1:0,se=s[G][2]>=1?1:0,ve=s[G][3]>=1?1:0,Z=T-j+c,oe=I-L+c,Ae=O-H+c,Ee=R-q+c,Se=T-$+2*c,ke=I-ee+2*c,ye=O-W+2*c,ge=R-le+2*c,Fe=T-K+3*c,Me=I-pe+3*c,z=O-se+3*c,D=R-ve+3*c,U=T-1+4*c,J=I-1+4*c,be=O-1+4*c,we=R-1+4*c,Pe=g&255,ie=v&255,We=y&255,qe=w&255,Je=o[Pe+o[ie+o[We+o[qe]]]]%32,X=o[Pe+j+o[ie+L+o[We+H+o[qe+q]]]]%32,Ce=o[Pe+$+o[ie+ee+o[We+W+o[qe+le]]]]%32,Te=o[Pe+K+o[ie+pe+o[We+se+o[qe+ve]]]]%32,Ye=o[Pe+1+o[ie+1+o[We+1+o[qe+1]]]]%32;let Ne=.6-T*T-I*I-O*O-R*R;Ne<0?u=0:(Ne*=Ne,u=Ne*Ne*this.dot4(r[Je],T,I,O,R));let Ze=.6-Z*Z-oe*oe-Ae*Ae-Ee*Ee;Ze<0?h=0:(Ze*=Ze,h=Ze*Ze*this.dot4(r[X],Z,oe,Ae,Ee));let Be=.6-Se*Se-ke*ke-ye*ye-ge*ge;Be<0?d=0:(Be*=Be,d=Be*Be*this.dot4(r[Ce],Se,ke,ye,ge));let ce=.6-Fe*Fe-Me*Me-z*z-D*D;ce<0?f=0:(ce*=ce,f=ce*ce*this.dot4(r[Te],Fe,Me,z,D));let _e=.6-U*U-J*J-be*be-we*we;return _e<0?p=0:(_e*=_e,p=_e*_e*this.dot4(r[Ye],U,J,be,we)),27*(u+h+d+f+p)}}const Gd={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`},Hs={defines:{KERNEL_RADIUS:4,DEPTH_PACKING:1,PERSPECTIVE_CAMERA:1},uniforms:{tDiffuse:{value:null},size:{value:new te(512,512)},sampleUvOffsets:{value:[new te(0,0)]},sampleWeights:{value:[1]},tDepth:{value:null},cameraNear:{value:10},cameraFar:{value:1e3},depthCutoff:{value:10}},vertexShader:`

		#include <common>

		uniform vec2 size;

		varying vec2 vUv;
		varying vec2 vInvSize;

		void main() {
			vUv = uv;
			vInvSize = 1.0 / size;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`,fragmentShader:`

		#include <common>
		#include <packing>

		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform float depthCutoff;

		uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];
		uniform float sampleWeights[ KERNEL_RADIUS + 1 ];

		varying vec2 vUv;
		varying vec2 vInvSize;

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		void main() {
			float depth = getDepth( vUv );
			if( depth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = -getViewZ( depth );
			bool rBreak = false, lBreak = false;

			float weightSum = sampleWeights[0];
			vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;

			for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {

				float sampleWeight = sampleWeights[i];
				vec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;

				vec2 sampleUv = vUv + sampleUvOffset;
				float viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;

				if( ! rBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

				sampleUv = vUv - sampleUvOffset;
				viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;

				if( ! lBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

			}

			gl_FragColor = diffuseSum / weightSum;
		}`},nf={createSampleWeights:function(a,e){const t=[];for(let n=0;n<=a;n++)t.push(mN(n,e));return t},createSampleOffsets:function(a,e){const t=[];for(let n=0;n<=a;n++)t.push(e.clone().multiplyScalar(n));return t},configure:function(a,e,t,n){a.defines.KERNEL_RADIUS=e,a.uniforms.sampleUvOffsets.value=nf.createSampleOffsets(e,n),a.uniforms.sampleWeights.value=nf.createSampleWeights(e,t),a.needsUpdate=!0}};function mN(a,e){return Math.exp(-(a*a)/(2*(e*e)))/(Math.sqrt(2*Math.PI)*e)}class gN{constructor(e=[],t=(n,i)=>n<i?-1:n>i?1:0){if(this.data=e,this.length=this.data.length,this.compare=t,this.length>0)for(let n=(this.length>>1)-1;n>=0;n--)this._down(n)}push(e){this.data.push(e),this._up(this.length++)}pop(){if(this.length===0)return;const e=this.data[0],t=this.data.pop();return--this.length>0&&(this.data[0]=t,this._down(0)),e}peek(){return this.data[0]}_up(e){const{data:t,compare:n}=this,i=t[e];for(;e>0;){const r=e-1>>1,s=t[r];if(n(i,s)>=0)break;t[e]=s,e=r}t[e]=i}_down(e){const{data:t,compare:n}=this,i=this.length>>1,r=t[e];for(;e<i;){let s=(e<<1)+1;const o=s+1;if(o<this.length&&n(t[o],t[s])<0&&(s=o),n(t[s],r)>=0)break;t[e]=t[s],e=s}t[e]=r}}function vN(a,e=1,t=!1){let n=1/0,i=1/0,r=-1/0,s=-1/0;for(const[v,y]of a[0])v<n&&(n=v),y<i&&(i=y),v>r&&(r=v),y>s&&(s=y);const o=r-n,l=s-i,c=Math.max(e,Math.min(o,l));if(c===e){const v=[n,i];return v.distance=0,v}const u=new gN([],(v,y)=>y.max-v.max);let h=xN(a);const d=new rf(n+o/2,i+l/2,0,a);d.d>h.d&&(h=d);let f=2;function p(v,y,w){const x=new rf(v,y,w,a);f++,x.max>h.d+e&&u.push(x),x.d>h.d&&(h=x,t&&console.log(`found best ${Math.round(1e4*x.d)/1e4} after ${f} probes`))}let m=c/2;for(let v=n;v<r;v+=c)for(let y=i;y<s;y+=c)p(v+m,y+m,m);for(;u.length;){const{max:v,x:y,y:w,h:x}=u.pop();if(v-h.d<=e)break;m=x/2,p(y-m,w-m,m),p(y+m,w-m,m),p(y-m,w+m,m),p(y+m,w+m,m)}t&&console.log(`num probes: ${f}
best distance: ${h.d}`);const g=[h.x,h.y];return g.distance=h.d,g}function rf(a,e,t,n){this.x=a,this.y=e,this.h=t,this.d=yN(a,e,n),this.max=this.d+this.h*Math.SQRT2}function yN(a,e,t){let n=!1,i=1/0;for(const r of t)for(let s=0,o=r.length,l=o-1;s<o;l=s++){const c=r[s],u=r[l];c[1]>e!=u[1]>e&&a<(u[0]-c[0])*(e-c[1])/(u[1]-c[1])+c[0]&&(n=!n),i=Math.min(i,wN(a,e,c,u))}return i===0?0:(n?1:-1)*Math.sqrt(i)}function xN(a){let e=0,t=0,n=0;const i=a[0];for(let s=0,o=i.length,l=o-1;s<o;l=s++){const c=i[s],u=i[l],h=c[0]*u[1]-u[0]*c[1];t+=(c[0]+u[0])*h,n+=(c[1]+u[1])*h,e+=h*3}const r=new rf(t/e,n/e,0,a);return e===0||r.d<0?new rf(i[0][0],i[0][1],0,a):r}function wN(a,e,t,n){let i=t[0],r=t[1],s=n[0]-i,o=n[1]-r;if(s!==0||o!==0){const l=((a-i)*s+(e-r)*o)/(s*s+o*o);l>1?(i=n[0],r=n[1]):l>0&&(i+=s*l,r+=o*l)}return s=a-i,o=e-r,s*s+o*o}var Ic=function(){var a=0,e=document.createElement("div");e.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",e.addEventListener("click",function(u){u.preventDefault(),n(++a%e.children.length)},!1);function t(u){return e.appendChild(u.dom),u}function n(u){for(var h=0;h<e.children.length;h++)e.children[h].style.display=h===u?"block":"none";a=u}var i=(performance||Date).now(),r=i,s=0,o=t(new Ic.Panel("FPS","#0ff","#002")),l=t(new Ic.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var c=t(new Ic.Panel("MB","#f08","#201"));return n(0),{REVISION:16,dom:e,addPanel:t,showPanel:n,begin:function(){i=(performance||Date).now()},end:function(){s++;var u=(performance||Date).now();if(l.update(u-i,200),u>=r+1e3&&(o.update(s*1e3/(u-r),100),r=u,s=0,c)){var h=performance.memory;c.update(h.usedJSHeapSize/1048576,h.jsHeapSizeLimit/1048576)}return u},update:function(){i=this.end()},domElement:e,setMode:n}};Ic.Panel=function(a,e,t){var n=1/0,i=0,r=Math.round,s=r(window.devicePixelRatio||1),o=80*s,l=48*s,c=3*s,u=2*s,h=3*s,d=15*s,f=74*s,p=30*s,m=document.createElement("canvas");m.width=o,m.height=l,m.style.cssText="width:80px;height:48px";var g=m.getContext("2d");return g.font="bold "+9*s+"px Helvetica,Arial,sans-serif",g.textBaseline="top",g.fillStyle=t,g.fillRect(0,0,o,l),g.fillStyle=e,g.fillText(a,c,u),g.fillRect(h,d,f,p),g.fillStyle=t,g.globalAlpha=.9,g.fillRect(h,d,f,p),{dom:m,update:function(v,y){n=Math.min(n,v),i=Math.max(i,v),g.fillStyle=t,g.globalAlpha=1,g.fillRect(0,0,o,d),g.fillStyle=e,g.fillText(r(v)+" "+a+" ("+r(n)+"-"+r(i)+")",c,u),g.drawImage(m,h+s,d,f-s,p,h,d,f-s,p),g.fillRect(h+f-s,d,s,p),g.fillStyle=t,g.globalAlpha=.9,g.fillRect(h+f-s,d,s,r((1-v/y)*p))}}};class Ku{constructor(){this._events={}}on(e,t){this._events[e]||(this._events[e]=[]),this._events[e].push(t)}removeListener(e,t){this._events[e]&&(this._events[e]=this._events[e].filter((n=>n!==t)))}emit(e,...t){this._events[e]&&this._events[e].forEach((n=>{n(...t)}))}dispose(){this._events={}}}var gr;(function(a){a.TEXTURE_8BPP="png",a.TEXTURE_HDR="hdr",a.TEXTURE_EXR="exr",a.FONT_JSON="font-json"})(gr||(gr={}));const a0={showStats:!1,verbose:!1,environmentSrc:{id:"defaultHDRI",src:"data:image/png;base64,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Q+OARAQ8PARAS8OARAP8OASAQ8OAQAO8P8R8N8O8P/ATgEgEvDwEQEPDgEQEfDgEQEvDgEQD/D/EPDgEgEfDwEQEvDvEvD/EPDvEPDgEgEfDgEQEPDwEgDwEgDvEPEAEgEfDwEgD/DwEAEPDgEgEfDwEfjvEfEvD/DvEfDwEQEvDvEfEAEgEPDQEgD/DwEvjwEQD/DwEQD/DvEPEAEQEfD/D/DwEQEfDvEPEAEQEfDwEQEAEgEfEPDwEgD/EAEgEPD/D/D/wE4BAA8BIBH5IBABEBDxDxLw8BIA/xABIBHw8BIBDw/xDw8BIBHw8BEBHw8BL4/xLw4BIBDw/xHw/xLw4BD47xDw8BIBHw/xLw8BEBDw4BABDw8BIBLw8BEBHxIBH47xHw/xDw4BIBABIBDxDw4BEA/w8BIBDw8BIBHw8BIBIBIA7xDw8BIBHxABIA/w8BEBLw/xHxDxHw8BIBHxIBL4/xHxDxHxABIBHxHxLw4BIBDw8BEBLw/xDw/xHw/xLxABIBLw/xDxEBD5DxD5IBHxIBIBDxEBL48BIBHw/8BQASAR8R8Q8PASAS8Q8Q8Q8R8S8R8PASAQ8QASAS8Q8S/AUPDwEgEPEQEgEvEAEgEPEQEvkPEfDwEgEfEQEgEvEvEvEAEgEPEAEAEQEQEAEgEQEQEAEQEgEgEAEgEAEkjgEAEQEQDwEAEPDwEgDwEkjgDwDwEPEgEQEADwDwEvEPwFABABLxIBEBDxHxLxEBAA8BIBABIBHxABL48BEBIBIBABEBDxEBIBIBEBDxIBFJEA8BDxABABHw8BIBEBEA8BABHw8BAA4BIBEBABLw4BIBABEBABIBIBEA8BIBABIBEBABABIBABEBEBABABIBHxABEBABIBEBLxIA8BEBLxEBEBLxDxHw8BIBHxABL5EBABLxDxEBIBDxEBHxHxEBABLxEBIBEBHxIBDxEBABIBHxEBLxIBEBEBIBLxEBIBIBABIBHxH8BR/A0QEfEvEQEvEQEvEfEPEQEgEAEQEQEgEvEgEfwFIBABIBHxEBH5H5IBHxIBH8HR8RASAR8Q8QAQAS8Q8RASAQARAQASASARARARASARASASAS8S8RASAR8S8S8QASAR8PARAQ8RAS8SAS/AUgEfUkgEgEgEgEgEgEgEgEfEvEgEfEvEvkvEfwFIBD8BSAQAQ+Q/AUgEgEvEkkvkvEvEfEvEPkgEQEgEgEgEPwFIBIBHxEBIBLxIBIBDxEBIBIBLxH8DSAR8S/AUvkfwlIBABIBL5EBL5LxLxDxL8FS/A0gEvwFD5IBIBLxL8DSASAS8RARAS8QARAS+SASAS+SARAS/AUgEgEPEkgEkkkgEkgEfUvEUke0kUkUkku0QEUkvkfUgEQEu0gEkAEkfwBHxEBIBFIBJJIBJJJFIBL1LtIBFJFL1IBEBIBIBHxJFEBFFHxFJLtLtJIBH8BR7SS8SSS7SS7SASAR+SAR7SQSS+R/AEe0Ue0gEvEkfEkUkUkgEgEvEe0Uu0vwBL1JLtLtL8CSS9SS/AEO0kkkgEkkkgEkvUku0vwFLtJLtHtLxJL8DSQASS/A0u0QEku0kvwZL8BS9SAS7RRRSQASASASSSSSARSASASSR7SAQRSS8SARSS/AEfwBJHtJIBJJJJJL1LtJJL1JFIBJL1LtJL1IBJIBIBJJL8AS/AUUu0gEfwFJJIBJL5L5JJLxJEBL1LxHtLxJJL8AS8R8S/AEkke0kfwBJLxL1JJJLxLxLtLtLxL5H8FS/AUkvEvwBHtIBL5LxL8BSASS7SSS9S/BEvwNHxJL1IBL8BRS9SAR+S+S8S/CEgEvEgEvwNJJL1L1L8BS9S/AUvEvwJL8AS7R8RAS7SSR9S/EkvEvkvwBIBIBL8ES7S/AUvUvxRLtLtLxL8DS9SAS8S/A0vUfEkvEvEku0vwBL8AS9S7SASSARS/AEfkku0vwJIBJJL5IBJFL5L8CSSAS/CEvwFJL1JL8ESSSS+S/AEu0u0vwZL8HSASAS/AUu0gEvxFHxL1LtIBL8MS/DEvwZH1L8AS/AEvwBL8AS/CUvwdL8DS9S/AkvyxLtIBABL8JS9R/AEvEQEvkgEu0vkvwBIBH8BS/E0u0ku0gEkgEvEQEfw9JLtL8CSS/DUQEvwhH8JS/EEu0vwFL85S/BEv1JL8ES7S/GUvxJL8fS/DkvxVL8cS8S/AEvwlIBL8HSS/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9OE////////6h////0N////QT/5J/+R//k3/5F/eSv3kf95P/eRv3kv95I/eTv3kT85L/OSPzk785H/OS/zkn85P/ORvzkz85J/OT/zkj85M/OSvzlD85G/GTPxkn8ZP/GSPxkz8ZK/GUvxkj8ZN/GSvxlH8ZJ/GTfxkv8ZQ/GR/xk38ZK/GUPxkn8ZN/GS/xk/8ZJ/GTfxkv85K/GTvxkv8ZS/GSPwk38JL/CUPwkr8JO/CTPwlH8JJ/CTfwkv8JS/CSvwk78JM/GSPwk38JL/GSvwk78JM/CUvwkr8JO/CS/xkv8JO/CTPwlL8JJ/CTvwkz8JS/CS/wk78JM/GSvwk78JM/GS/wk/8JN/GSvwk/8JM/GS/wk/8JN/CUvwkr8JP/CTPxkz8JQ/CTfxkn8BP/ATPwFL8BL/AT/wE38BS/ASvwE/8BN/CTPwE/8BN/AUvwEr8BO/ATfwkz8BP/ATfwkv8BP/ATPwkz8BP/ATfwkr8BQ/ATfwkz8BO/ATvwFL8BL/AT/wE38JM/AUPwE/8JL/AT/wE38BS/ATPwE/8BO/CS/wFD8BN/CTPwFD8BO/CSvwE/8BN/CTPwE/8BN/AUvwEz8BP/ATfwk38BR/ATvwkv8BQ/ATfwkz8BQ/ATvwkz8BS/ATvwk38BP/ATvwFL8BL/AUfwE78JM/AUfwE/8JM/AUPwE78JN/AUPwE78JL/AUfwE78JN/AUPwE78JM/AUfwE78JN/AUPwE78JM8R8O8S8M8S8Q8S8M8P8O8S8O8S8P/ATPEvDvwE3xDw/8BM8Q8O/ATvEfD/wEvxDw78BN8R8P/ATfD/DvwE3xDxD8BM8R8O/ATfEvDvwE3w/w78BO8P8P/ATPEPDvEvDfEPD/wE38BP8S8O8S8Q/ATPEvDvwE3xDw/8BN8S8P/ATvEvEPwEzxHw78BO8R8Q/ATfEPDvwE78BQ8S8M8S8P/ATvwE/8BN8Q8P/ATvEPEfEvDPEfD/wE78BQ/ATfEvD/EvDvEPEfwEzxLw/8BO8S8Q/ATvEvD/wE7xLxD8BM8S8O/AT/EfEPwE3xLxD8BP/AUfwE7xHxD8BQ8S8P/ATfwE/8BP8S8Q/ATfEvEPwE78BP/ATvwFD8BP/AUfwE3xLw/8BO8R8P/ATvEvD/wE/xHxD8BN8R8P/ATvwFH8BN/AT/EvDvEvEfwE78BQ/ATvEfEPwE78BP/AT/EvEPwE4BAA/w8BEA/w4BABDw8BIBLw0BABHw8BIBLw4BIBDw/xDw4BIBDw8BL44BABHw7w/w4BIBABIA/xDw4BIA/w8BABLw4BIBDw4BIBHw7xDw8BEBLw0BIBHw8BEA/w/xDxD8BOARAQ8PASAQ8P8Q8PARAP8OAS+P8R8PASAP8P8S8OAQAQ8OAS+PASAQ8P/ATgEgEPDvEvDwEQEPEAEQD/D/EPDwEvjgEgEfDwEfjwEgEvEAEgEvEPEvEAEgEvDgEgEfEfEvDgEgEfEfEfD/EvEPEvDwEgEPDwEQEfDvD/D/EvD/EPD/EfDgEQD/DwEgEvDvEvEAEgEvD/wE/xLw8BIA/xABIBLw/w/xDxHw/xL5IBDw4BIBD8BS8PASAQ8R8S8P8Q8QARAQ8QASAS8P8R8OARAS8QASAS8P8S8S8S8PARAQ8P/AUgEgEPEAEQEvD/EfEAEgEfD/EvD/EfDvEvEPEfEPEfwFLw4BEBHxDxLxHxHxDxHw/xLxD8BPASAS8QASAS8P8R8Q8S8P/BUvEQEQEvEfwFHxLxHxLw8BL5EBIBLw/xLxL8BP8Q8QAS+PASAR8R8Q8R8S8RAS+QASAQ8QASAQ8Q/AUfwFLxHxABH4/xHw8BL4/xEBIBDxIBIA/8BPAS+PAQAQ8OASARASAPASAQ8QAQAS8P8R8QARAQ8SAQASASAR+SAQASAQ8RAQAQASAQAQAQ8RARAS8R+SAQARAQASAPAQ8RAPAQAS8PAQASASAQASASASAS+RAQ8SASASASAR8SARASASASASASARAQ8SAQAQ+RAPASAQASAQARAQ8RARAS8QAQ8RAS8R8SAR+RASAS8P8QARASARAQASASASAS8SAR8SARAP8RASASAQ8SAQARASAQAQASARAPARARASAS/AUAEQEfEPEvEQEgEQEgEQEfkfkvEQEfkgEvwFHxEA/xEBABL5L8BR+SASARAR/DT/EvwFLxL8BSASASAQAP/A0QEfEQEgEfEvwFEBEBLxLxLxIBIBLxEBH8BQAR8R8Q/AUfkPkgEgEQEvkvD/EPEAEPEgEgEgEQEvkvwNHxIBHxEBLxIBABIBL5IBL8DSARAS+R8Q+SAS8S/AUvwFD8HSAR/AUvkfEvEfwVIBD8FS8RAS+S8S8S8SAS8SAS/AUgEQEvwNH8DS8S+Q8SASAR+S8SASAR+RAR+SAS8S8R8S8S8S8S/AUvEvEvwNEBIBIBH8BS8R+SAS8S8QS8Q9SAS8SS8Q7S7RS/AEgEvwBIBIBIBIBIBL5JEBHtIBIBJLxIBJLxJJL8ESRR8S/BEgEkfUvEAEu0fwRIBL8AQ+S7R7S7SASASS7SS/AEvkgEgEgEkvUe0u0fkgEUvEvwdIBJIBJJJL8AS9SSAR8S+S8S9SAS9SARS+SASSARS7S9S8S7SASS/AUkfwZLtIBJLxL8AS7S7SS/AkvwpL8CSASAS/AUvEvwVIBLxIBJLxJLxIBH8CS8S8S7S8S9S/AEfwpEBIBJH8GS/AEgEu0kvUvEvUfkvEvEvwRL8DS9S7R/EUvwJL1LtL8BS7S/B0kUUgEkvwJIBFIBLtH8BS8S/AEvwZL8ESASS9S/AkvEUvw1JL8CS/AkvEku0u0vwBEBLtIBL5L8JSAS/BEkUvwJL8BS9S/CUkQEvwJLtIBL8BS+S+S/AUu0kkvUu0kvwNIBIBIBL8AS7S/Dku0vkvEku0vwxLxEBFIBL8AS/AkvEgEvUgEkgEkvEvwNLtL1IBLtL8DS9SSASAS+S/B0u0u0vkvwVL8BSS8S/OEvwZLtL8RR9S/Ikvx1L9AS/WkvwBL8QS/E0u0vzBL1L86S/EUvzZL80S/UUvwhL92S/Gkvw9L9HS/BUvy1L8ES+S/DUvwJLtLxL8KS/TkvwlL8DS/Z0vx5L/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////vBABRhxyCCCCSSSSjTTTjTjjjTjz0UEEkfEvUkg0GEH1NkcDPZS47Fde4mEw+fb0rZ85Lv0T4f7sbMlCU8r5TQVw0rb87n4EzKrm8MjR2HaD5CrwVw093flLnyBxA/nKjImuPH+5NBXuHuZ7kufocQ+IFQLeanr/kmQVpitmfOa79E6LKnRwFvJx6/5TJlcNPcz8S679ASkLGlQlDU9Q/OwVww93Pnd+QOCPSrCQanqL5TQV7p7vylz9DbFeQXRSkho9Re4mQVpvlLn6NZyQW9GZpx4i+SZBWm+UufoLqHqQW0oyk89v5hBWmK2Z8cV5+jSKlA3pHaPneI/lNDFUCtmfOZ+iTHRA3oxE5x4jz53Ve/K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S/AT/wkz8BS/AUPwlD8BQ/AT/wkz8BP/ATvwk38BR/AT/wk38JP/CTvwFL8BO/CTPwlD8JO/CUPwk38BR/AT/wk78BR/AT/wk38JP/CT/wFL8BQ/CTvwFH8BP/CTvwlL8JM/CUPwk/8BR/AUPwk78BS/ATvwk/8BS/AUfwk38BR/AUPwk78BR/AUvwk/8JP/CT/wFL8BS/CTfwk/8JP/AUfwFH8JN/AUfwFD8JQ/CUPwk78BS/AUfwk/8JS/CTvwFL8BQ/CT/wFH8RN/AUPwFL8BS/ATvwFL8BS8S8Q/ATfEvEfwE/8BR/ATvwFL8BQ/AUvwE38BR8S8Q/AUfwE/8BQ/AT/wk7xLxH8BP/AUfwE78BQ/AUPEvwU7xLxD8BR8S8Q/AT/wFH8BR/AUvwE7xLw/8BR/AUvwE/8BR/AT/wFD8BO8S8S/AUfEvEvwE78BQ/AT/EvEPwE78BR/AUfwk/8BS/CUvwE78BS/AUfwFD8BP8S8R/AUvwk78BS/AUPwFL8BP/AUfwFD8BS/ATvwFL8BS/CT/wFL8BS/AUvwE/8BS/AUfEvEfwFDxL8FS/AUvwE/8BS/AUPwk/8BS/AUvwFL8BP/AUvwFH8JP/AUvwFL8JO/CT/EvEvwFL8JR/AUvwFD8JQ/CUPwlL8JO8S8Q/AT/EvEfwE7xLw/xLxHxL8FP/AUPwFDxLxH8BR8R8RAR+Q8S8R/AUAEgEfwVL8BSAS+Q/CUgEvkfEfEPEvEvwFL8BS/AT/EvEPwFLxHxHxLw8BH5L8BS/CT/wNIBL8BS8R/AT/wFH8BS8S/BUPEvwVEBL8HP/AUgEvkvwFLxLxLxL8NSASAR8Q8S/BUvwFL8BQ/AUvwFEBL5L8BQ/CUfwFL8BR8S8R/AUvEvwFL8FS/AUvEvwVD8BS/EUfEvwVD8JS/AUvwVL8FS/AUfwFEBIBLxL8BQ/CUfwlL8JS8S/BUPwFLxL8HS+S/BUvwFLxH8RS8S8S/AUfwlL8RR/AUvEvEfwFL8JQ/AUgEvkvxVLxIBL1L8CS/BUvkgEgEgEvwNL5IBIBH8FSAS+RAS+S/AUvxFEBL5D5LxL5LxH8HS8SAR+S8SAS8R8Q8R/AUQEfwdLxL8FR/CUvw9L5L8HS/A0vwVL8NS/B0vkQEgEvEvEvkgEvEvwFL8BS/AUfwNL8LSAS/D0gEgEfxVLxL8LS/BUvwVL8PS/A0vEvxNLxL8BS/CUvEvytL8XS/DUvwdL5H8HS/A0gEvwNIBL8TS8S8R/K0vxtLxL8TS/AUgEvzlL8FS8S8S8S/BUvwVLxL8HS/H0vwxL8uSASAS8SS/AEvEvEvwFL8lSASASASAR/A0vxZL1L8RS/GEvxBL8PS8S/DUvEvwJIBL8DS9SS/DkvwdIBL5IBL8AS/AkvUkgEvwlL8NS/X0gEvwJL8jS7S8S/AEvxRL8XSS/CkvwBL8ES/CUvwtL8gS/IkvxlL8+S/A0vwJLxJL8DSAS7S7S8S/HUvwRL8VS+S/GUvwRL8KS/B0vylL///GUgEv5lL8IS/TUvyJHxL88S/VEvxxL/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////3kT////////qG////Qz///9A//kj/5G/+TP/kX95J/eRv3k395G/eSv3kj95O/eRfzkr85I/OT/zkf85L/OSfzlD85H/OS/zkn85P/OSPzkz85K/OUPzkj8ZM/GSvzkn8ZM/GSvzkn8ZN/GSvzkr8ZN/GS/zkn8ZN/GS/xlL8ZK/GTfxkz8ZS/GSvxk38ZL/OS/xk78ZM/OSfwk78JM/GS/wk78JM/GSvwk78JM/GS/wk78JM/GSvwk78JM/GTPwk/8JN/GS/wk78JM/GTPwk/8JN/GSvwk/8JN/CUvwkz8JP/CTfxkv8JR/CTfxk38JP/CTfxkv8JQ/CTfxkz8JS/CTvxkz8JR/CTvxk38JQ/CTvxkv8BS/ATvwk38BQ/ATvwkz8BS/ATvwk78BR/ATvwkz8BS/AT/wk78BR/ATvwkz8BR/ATvwk78BS/AUvwkv8BS/AT/wk78BS/AT/wk38BS/AT/wk78BR/AUPwkz8BR/AUPwk78BS/AT/wFL8BN/AUPwE/8JO/AUvwFD8JM/AUvwFH8JO/AUvwE78JO/AUPwE/8JP/CUvwk38JP/CTvwFL8BQ/CTvwFL8BQ/CTvwFL8BP/CTPwFL8BR/CTvwFL8RO/AUvwFD8JQ/GTfwFL8BR/CT/wFH8BQ/CTvwFL8BS/CT/wlD8JN8S8Q/ATvEfEPwE7xLxL8BQ8R8R/ATfEvEfwFDxH8FP8S8S/AT/wFHxLw3xLxH8BP/BUvD/EvEvwFL8BQ/ATvEfEPwE/8JP/AUvwE/8BR/ATvEvEfwE/8BS/AT/EvEvwFDxL8FP/AUvwFD8JP/AUPwFH8JO8S/BUPEvEPwE/8BQ/AT/wFL8BO8R8Q/AT/wFL8BP/AUvwFDxLxL8BO8S/BUPwFL8BO/AUvwFDxL8FP8R/BT/EfEvwFD8JQ/AUvwE78BS/AUfwFL8BO/AUvwFLxL8FP/AUvwFH8BS/AT/wFL8BQ/CTvEvEvwE/xLxL8BO8S8S/CUvwE7xLxD8BQ/CUPwFL8RQ8S8R/AUvwk/8BS/AUPwk7xL8FQ8S/BT/xFL8BO/CUPEvEfEfEPwFLxLxHxLxH8BQ/AUPwFD8BS/AT/wFL8BQ/AUvEvDvwE/8BQ/AUfwFLxHxL8BP8S8S/AUfEfEvwFD8BS/AT/EvEAEvkPwFL8BS8S8Q/AUfwFD8BQ/A0vkvwk/8JS/A0vkfwFL8BS/A0vkfwVLxD8JQ/AUvEvEgEgEvEvwE/xL8FS/CUfwFHxLxDxLxL8BQ8S8QAS+SAS/CUvkfwFD8FS8Q8S8R8S/AUvEvwE/8BR/AT/EvEvEvD/wlHxL8FS8R8Q/CUPwFL8FS8R8S/BUfEvwVH8BR/AUvEfEvwFD8BS/AUvwFHxLxLxL8JS8R8S8Q/CUPwlL8BS/BUvEgEvkPxFL8RQAS/GUgEvEPwFLxH8FS8S8S/AUQEvkvwFLxIBL8LR/AEj/wlIBD8BSAS8Q/FUvwVH8BR8RAS/A0QEvkvwFL8BS/CUgEvkvwtH5IBHxL8HS/C0vwFIBL5HxIBL5L5L8DSASASAS/DUvwtL5L8JS/AUvwNL8jSAS/BUvwtL8JS/CUvEvwdL8BS/B0vwlL5IBH8NS/AUvwVLxL80S/GkgEvEvwVL8DS/EUvEvxFL8ZS/AUvxFL8XSAR/C0vwlIBL8VS/EUvwVL8NS/NkvwNLtIBH8AS/DEkvwxL8AS/G0vw9JIBL5L8FS/FUvEvxVHtL8QS7S/DEvyBL8RSAS/BEvwpL8cSAS/AUgEkvwBJL8ES/IEvwpL8IS/C0vwVL8GS8S/Ekvku0gEvxdL8ES/CEvUkkvwdJIBJL8HS/AUu0vwNL5L8DS9S/AEvwRL8TS/F0vwJIBL8ISS/D0vw1IBL8bS7S/AUkvw9L8ASS/Akfx9L8KS8S9S/AUu0vEvwRL8BS/CEvwlL5L1L8RS/H0v/ZL8cS//////cS/Ikv/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////xEQAUYcccggggkkoow0044000489EBFFDxIBLxLxJJIAF0IuFksDqC0KOQEze2WrYtzSxbNl7swvTJdLGGGZ11ZpuRfVgAsyKlAexGc3MPG0AkBTQg9aEMbmsYyf9JE7dj4Lsm2qzZRVKwbGxhSE703vWJiqB2mX+M4WrZIwi7v/GgCkCRA5Ko0hTEzI0yr4HBy7sJqR0C0X6kkoakHYtedoV7yEvN3bKk0WA3eW+kaCkUl9L0SXIXXdgKbDh8BEAfVjnSxWRWEhNc/Tpavh/LOsiY7Os9VKLKqoewEiYWQIQM0adJ0HskSzHYqvFSxCz/TKsS9jGsI4ZY8XmwWVe28OmohxK4V5xYpJIwSu1XdiYdyRAGGj/RLWSSOEznXdjptYCWbzelOnCWq0ERNl3aNS0NAhG6Ke4GN076lapjq4xm7sF1JzQTspZGDpQxZennPXLdXe0ic+rhU2zVUrycmhGKnIz98TdBFDyEoy7hWLAKTAYvBPAB8gCBEA0dWKiQAicA9IRpTy9VQwXABdgB/C9jCNzgkFrCaqthF3DCWWHcPWTImuGElLAIiBlIQwAFUA1l81KtItCi+Kky51q0rVkVWAdsMnHg3Am1fqyhCXgi9xep9WALyABMAaoDXCmQYThDIEAhSWb8WxP1lH0XXZFFmai6AMGBo6FTxaSExBZdxpL1eABXA0dSqAdEhSRAm31eibwBhANHRqwhFsEZMQWXb5sBzgNYHsAAoPQwEgegtloEa3MhZDif0q8vzEXCtWi+tNgGUQqAS4E5NGHDgxXZsWXiwA4CeFIGuA040lwnBHGDmXdgGmBhUCGAJuADCHUucIygPABIYBGyhDKHyGLEwkgBSgB9CZ7Wl2Ki/MziJ1guU8R8ic4YSyxp9Mkic4YSywAORIF6gAAYfDwYDyJuUCoxY+tNrszNYJ2b5mcq5mhytCAyw1fXmxHoo76DFX8PIA5OUGUj0VhgAzRc7dtSq0t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",type:gr.TEXTURE_EXR}};var Cn;(function(a){a.ObjectClicked="object-clicked",a.ObjectDoubleClicked="object-doubleclicked",a.LoadComplete="load-complete",a.UnloadComplete="unload-complete",a.UnloadAllComplete="unload-all-complete",a.FilteringStateSet="filtering-state-set",a.LightConfigUpdated="light-config-updated"})(Cn||(Cn={}));const VM={enabled:!0,castShadow:!0,intensity:5,color:16777215,elevation:1.33,azimuth:.75,radius:0,indirectLightIntensity:1.2,shadowcatcher:!0};var re,Qt,zr;(function(a){a[a.STREAM_CONTENT_MESH=10]="STREAM_CONTENT_MESH",a[a.STREAM_CONTENT_LINE=11]="STREAM_CONTENT_LINE",a[a.STREAM_CONTENT_POINT=12]="STREAM_CONTENT_POINT",a[a.STREAM_CONTENT_TEXT=13]="STREAM_CONTENT_TEXT",a[a.STREAM_CONTENT_POINT_CLOUD=14]="STREAM_CONTENT_POINT_CLOUD",a[a.NONE=0]="NONE",a[a.STREAM_CONTENT=1]="STREAM_CONTENT",a[a.PROPS=2]="PROPS",a[a.SHADOWCATCHER=3]="SHADOWCATCHER",a[a.OVERLAY=4]="OVERLAY",a[a.MEASUREMENTS=5]="MEASUREMENTS"})(re||(re={})),(function(a){a[a.RENDER=1]="RENDER",a[a.SHADOWS=2]="SHADOWS",a[a.CLIPPING_PLANES=4]="CLIPPING_PLANES",a[a.RENDER_RESET=8]="RENDER_RESET"})(Qt||(Qt={})),(function(a){a[a.NONE=0]="NONE",a[a.OVERLAY=1]="OVERLAY",a[a.OUTLINE_ONLY=2]="OUTLINE_ONLY"})(zr||(zr={}));class AN extends Kd{constructor(e){super(e)}compileProperEquirectShader(e){this._equirectMaterial=new gn({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},rotationMatrix:{value:e}},vertexShader:`
          precision mediump float;
          precision mediump int;
          attribute float faceIndex;
          varying vec3 vOutputDirection;
          // RH coordinate system; PMREM face-indexing convention
          vec3 getDirection( vec2 uv, float face ) {
            uv = 2.0 * uv - 1.0;
            vec3 direction = vec3( uv, 1.0 );
            if ( face == 0.0 ) {
              direction = direction.zyx; // ( 1, v, u ) pos x
            } else if ( face == 1.0 ) {
              direction = direction.xzy;
              direction.xz *= -1.0; // ( -u, 1, -v ) pos y
            } else if ( face == 2.0 ) {
              direction.x *= -1.0; // ( -u, v, 1 ) pos z
            } else if ( face == 3.0 ) {
              direction = direction.zyx;
              direction.xz *= -1.0; // ( -1, v, -u ) neg x
            } else if ( face == 4.0 ) {
              direction = direction.xzy;
              direction.xy *= -1.0; // ( -u, -1, v ) neg y
            } else if ( face == 5.0 ) {
              direction.z *= -1.0; // ( u, v, -1 ) neg z
            }
            return direction;
          }
          void main() {
            vOutputDirection = getDirection( uv, faceIndex );
            gl_Position = vec4( position, 1.0 );
          }
        `,fragmentShader:`
          precision mediump float;
          precision mediump int;
          varying vec3 vOutputDirection;
          uniform sampler2D envMap;
          uniform mat4 rotationMatrix;
          #include <common>
          void main() {

            vec3 outputDirection = normalize( vOutputDirection );
            outputDirection = normalize((rotationMatrix * vec4(vOutputDirection, 0.)).xyz);
            vec2 uv = equirectUv( outputDirection );
            gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );
          }
        `,blending:Mn,depthTest:!1,depthWrite:!1}),this._compileMaterial(this._equirectMaterial)}}const De=hL(Wp,"warn")?Wp:vM(Wp,"default");class jn{static getLoader(e,t){if(t===void 0&&(t=e.split(".").pop()),!Object.values(gr).includes(t))return De.warn(`Asset ${e} could not be loaded. Unknown type`),null;switch(t){case gr.TEXTURE_EXR:return new wP;case gr.TEXTURE_HDR:return new AP;case gr.TEXTURE_8BPP:return new Ev;default:return null}}static hdriToPMREM(e,t){const n=new AN(e),i=new ae().makeRotationFromEuler(new mi(.5*-Math.PI,0,.5*-Math.PI));n.compileProperEquirectShader(i);const r=n.fromEquirectangular(t);return n.dispose(),r.texture}static getEnvironment(e,t){return this._cache[e.id]?Promise.resolve(jn.hdriToPMREM(t,this._cache[e.id])):new Promise(((n,i)=>{const r=jn.getLoader(e.src,e.type);r?r.load(e.src,(s=>{this._cache[e.id]=s,n(jn.hdriToPMREM(t,s))}),void 0,(s=>{i(new Error(`Loading asset ${e.id} failed ${s.message}`))})):i(new Error(`Loading asset ${e.id} failed`))}))}static getTexture(e){return this._cache[e.id]?Promise.resolve(this._cache[e.id]):new Promise(((t,n)=>{if(e.src.includes("data:image")){const i=new Image;i.src=e.src,i.onload=()=>{const r=new bn(i);r.needsUpdate=!0,this._cache[e.id]=r,t(r)},i.onerror=r=>{n(new Error(`Loading asset ${e.id} failed with ${r.toString()}`))}}else{const i=jn.getLoader(e.src,e.type);i?i.load(e.src,(r=>{this._cache[e.id]=r,t(this._cache[e.id])}),void 0,(r=>{n(new Error(`Loading asset ${e.id} failed ${r.message}`))})):n(new Error(`Loading asset ${e.id} failed`))}}))}static getFont(e){let t=null;return t=e.src?e.src:e,this._cache[t]?Promise.resolve(this._cache[t]):new Promise(((n,i)=>{new SP().load(t,(r=>{n(r)}),void 0,(r=>{i(new Error(`Loading asset ${t} failed ${r.message}`))}))}))}static async getTextureData(e){const t=await jn.getTexture(e),n=document.createElement("canvas");n.width=t.image.width,n.height=t.image.height;const i=n.getContext("2d");if(!i)throw new Error("Fatal! 2d context could not be retrieved.");i.drawImage(t.image,0,0);const r=i.getImageData(0,0,n.width,n.height);return Promise.resolve(r)}static generateGradientRampTexture(e,t,n){}static generateDiscreetRampTexture(e){const t=e.length,n=new Uint8Array(4*(1*t));for(let r=0;r<e.length;r++){const s=4*r,o=new Ie(e[r]);o.convertSRGBToLinear(),n[s]=Math.floor(255*o.r),n[s+1]=Math.floor(255*o.g),n[s+2]=Math.floor(255*o.b),n[s+3]=255}const i=new Yi(n,t,1);return i.needsUpdate=!0,i}}jn._cache={};class jM{constructor(){this.lastPauseTime=0,this.needsWait=!1}tick(e){performance.now()-this.lastPauseTime>e&&(this.needsWait=!0)}async wait(e){this.lastPauseTime=performance.now(),await new Promise((t=>setTimeout(t,e))),this.needsWait=!1}}const Qi=new ae,ns=new ae,Qo=new ae;class ca{constructor(){this.boxes=new Array,this.worldBox=new He,this.VecBuff=new A,this.BoxBuff0=new He,this.BoxBuff1=new He,this._worldOrigin=new A}get worldSize(){this.worldBox.getCenter(this._worldOrigin);const e=new A().subVectors(this.worldBox.max,this.worldBox.min);return{x:e.x,y:e.y,z:e.z}}get worldOrigin(){return this._worldOrigin}expandWorld(e){this.boxes.push(e),this.updateWorld()}reduceWorld(e){this.boxes.splice(this.boxes.indexOf(e),1),this.updateWorld()}updateWorld(){this.worldBox.makeEmpty();for(let e=0;e<this.boxes.length;e++)this.worldBox.union(this.boxes[e])}resetWorld(){this.worldBox.makeEmpty(),this.boxes.length=0}getRelativeOffset(e=.001){if(this.worldBox.isEmpty())return e;Qi.identity(),Qi.makeScale(1+e,1+e,1+e);const t=this.VecBuff.set(.5*this.worldSize.x,.5*this.worldSize.y,.5*this.worldSize.z);this.BoxBuff0.min.set(0,0,0),this.BoxBuff0.max.set(0,0,0),this.BoxBuff1.min.set(0,0,0),this.BoxBuff1.max.set(0,0,0);const n=this.BoxBuff0.expandByVector(t);return this.BoxBuff1.copy(n).applyMatrix4(Qi).max.distanceTo(n.max)}getRelativeOffsetBox(e,t=.001){if(this.worldBox.isEmpty())return e;const n=e.getCenter(new A);ns.makeTranslation(n.x,n.y,n.z),Qo.copy(ns).invert(),Qi.identity(),Qi.makeScale(1+t,1+t,1+t);const i=new He().copy(e);return i.applyMatrix4(Qo),i.applyMatrix4(Qi),i.applyMatrix4(ns),i}static expandBoxRelative(e,t=.001){return e.isEmpty()?e:e instanceof He?ca.expandBox3Relative(e,t):ca.expandOBBRelative(e,t)}static expandBox3Relative(e,t){const n=e.getCenter(new A),i=e.getSize(new A);ns.makeTranslation(n.x,n.y,n.z),Qo.copy(ns).invert(),Qi.identity(),Qi.makeScale(1+t,1+t,1+t);const r=new He().copy(e);return i.x===0&&(r.min.x+=.5*-t,r.max.x+=.5*t),i.y===0&&(r.min.y+=.5*-t,r.max.y+=.5*t),i.z===0&&(r.min.z+=.5*-t,r.max.z+=.5*t),r.applyMatrix4(Qo),r.applyMatrix4(Qi),r.applyMatrix4(ns),r}static expandOBBRelative(e,t){const n=e.center,i=e.getSize(new A);ns.makeTranslation(n.x,n.y,n.z),Qo.copy(ns).invert(),Qi.identity(),Qi.makeScale(1+t,1+t,1+t);const r=new Un().copy(e);return i.x===0&&(r.halfSize.x+=.5*t),i.y===0&&(r.halfSize.y+=.5*t),i.z===0&&(r.halfSize.z+=.5*t),r.applyMatrix4(Qo),r.applyMatrix4(Qi),r.applyMatrix4(ns),r}}var ze;(function(a){a[a.MESH=0]="MESH",a[a.LINE=1]="LINE",a[a.POINT=2]="POINT",a[a.POINT_CLOUD=3]="POINT_CLOUD",a[a.TEXT=4]="TEXT"})(ze||(ze={}));const Fn={offset:0,count:0},en={offset:0,count:1/0},qn=16;let SN=0;const QM=()=>++SN;function Dw(a){return a&&(a.geometryType===ze.MESH||a.geometryType===ze.TEXT)}function o0(a){return a.offset===Fn.offset&&a.count===Fn.count}class Ow{toJSON(){return{}}}class Ia{constructor(){this._stencilOutline=zr.NONE,this.needsCopy=!1}get speckleUserData(){return this.userData}set speckleUserData(e){this.userData=e}get speckleDefines(){return this.defines}set speckleDefines(e){this.defines=e}get vertexProgram(){return""}get fragmentProgram(){return""}get uniformsDef(){return{empty:"empty"}}get baseUniforms(){return{emptyBase:{value:"emptyBase"}}}set stencilOutline(e){this._stencilOutline=e;const t=this;t.stencilWrite=e!==zr.NONE,t.stencilWrite&&(t.stencilWriteMask=255,t.stencilRef=0,t.stencilFunc=Bu,t.stencilZFail=$s,t.stencilZPass=$s,t.stencilFail=$s,e===zr.OUTLINE_ONLY&&(t.colorWrite=!1,t.depthWrite=!1,t.stencilWrite=!0))}set pointSize(e){this.size=e}init(e=[]){this.speckleUserData=new Ow,this.setUniforms(this.uniformsDef),this.setDefines(e),this.onBeforeCompile=this.onCompile}setUniforms(e){for(const t in e)this.speckleUserData[t]={value:e[t]};this.uniforms=Hr.merge([this.baseUniforms,this.speckleUserData])}setDefines(e=[]){if(e){this.speckleDefines={};for(let t=0;t<e.length;t++)this.speckleDefines[e[t]]=" "}}copyUniforms(e){for(const t in e.userData)this.speckleUserData[t]!==void 0&&(this.speckleUserData[t].value=e.userData[t].value)}bindUniforms(){if(this._internalUniforms)for(const e in this.uniformsDef)this._internalUniforms.uniforms[e]=this.speckleUserData[e]}copyFrom(e){this.speckleUserData=new Ow,this.setUniforms(this.uniformsDef),this.copyUniforms(e),this.bindUniforms(),Object.assign(this.speckleDefines,e.defines),e.needsCopy&&(this.needsCopy=e.needsCopy)}onCompile(e){this._internalUniforms=e,this.bindUniforms(),e.vertexShader=this.vertexProgram,e.fragmentShader=this.fragmentProgram}fastCopy(e,t){t.alphaTest=e.alphaTest,t.alphaToCoverage=e.alphaToCoverage,t.blendDst=e.blendDst,t.blendDstAlpha=e.blendDstAlpha,t.blendEquation=e.blendEquation,t.blendEquationAlpha=e.blendEquationAlpha,t.blending=e.blending,t.blendSrc=e.blendSrc,t.blendSrcAlpha=e.blendSrcAlpha,t.clipIntersection=e.clipIntersection,t.clippingPlanes=e.clippingPlanes,t.clipShadows=e.clipShadows,t.colorWrite=e.colorWrite,Object.assign(t.defines,e.defines),t.depthFunc=e.depthFunc,t.depthTest=e.depthTest,t.depthWrite=e.depthWrite,t.stencilWrite=e.stencilWrite,t.stencilFunc=e.stencilFunc,t.stencilRef=e.stencilRef,t.stencilWriteMask=e.stencilWriteMask,t.stencilFuncMask=e.stencilFuncMask,t.stencilFail=e.stencilFail,t.stencilZFail=e.stencilZFail,t.stencilZPass=e.stencilZPass,t.opacity=e.opacity,t.polygonOffset=e.polygonOffset,t.polygonOffsetFactor=e.polygonOffsetFactor,t.polygonOffsetUnits=e.polygonOffsetUnits,t.premultipliedAlpha=e.premultipliedAlpha,t.dithering=e.dithering,t.side=e.side,t.shadowSide=e.shadowSide,t.toneMapped=e.toneMapped,t.transparent=e.transparent,t.vertexColors=e.vertexColors,t.visible=e.visible}setMaterialOptions(e){this.stencilOutline=e.stencilOutlines||zr.NONE,this.pointSize=e.pointSize||1}}class WM extends Vu{}class XM extends ti{}class JM extends Cl{}class ZM extends Nf{}class KM extends _v{}class YM extends Ki{}function Ra(a,e){e.forEach((t=>{Object.getOwnPropertyNames(t.prototype).forEach((n=>{Object.defineProperty(a.prototype,n,Object.getOwnPropertyDescriptor(t.prototype,n)||Object.create(null))}))}))}Ra(WM,[Ia]),Ra(XM,[Ia]),Ra(JM,[Ia]),Ra(ZM,[Ia]),Ra(class extends kf{},[Ia]),Ra(KM,[Ia]),Ra(YM,[Ia]);class Or extends KM{get vertexProgram(){return`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;
		uniform float pixelThreshold;

		varying float vAlpha;

		#define SEARCH_STEPS 10

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec4 instanceColorStart;
		attribute vec4 instanceColorEnd;
		// varying vec3 debugColor;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;
			varying float correctedLineWidth;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

        #ifdef USE_RTE
			attribute vec3 instanceStartLow;
			attribute vec3 instanceEndLow;
            uniform vec3 uViewer_high;
            uniform vec3 uViewer_low;
        #endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		float screenSpaceDistance(vec4 p0, vec4 p1) {
			p0 = projectionMatrix * p0;
			p0 /= p0.w;
			p1 = projectionMatrix * p1;
			p1 /= p1.w;
			return length(p1.xy - p0.xy);
		}

		highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
			/* 
			Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
			Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
			*/
			highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
			highp vec3 e = t1 - position_low.xyz;
			/** This is redunant, but necessary as a workaround for Apple platforms */
			highp float x = position_high.x - relativeTo_high.x;
			highp float y = position_high.y - relativeTo_high.y;
			highp float z = position_high.z - relativeTo_high.z;
			highp vec3 v = vec3(x, y, z);
			/** End of redundant part */
			highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
			highp vec3 highDifference = t1 + t2;
			highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
			
			highp vec3 position = highDifference.xyz + lowDifference.xyz;
			return vec4(position, 1.);
		}

		void main() {
			if(instanceColorStart.w == 0.) {
				gl_Position = vec4(0.);
				return;
			}
			
			vAlpha = instanceColorStart.w;

            vec3 computedPosition = position;
			#ifdef USE_COLOR

				vColor.xyz = ( computedPosition.y < 0.5 ) ? instanceColorStart.xyz : instanceColorEnd.xyz;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( computedPosition.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
            #ifdef USE_RTE
			/** Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl */
				// vec3 t1 = instanceStartLow.xyz - uViewer_low;
				// vec3 e = t1 - instanceStartLow.xyz;
				// vec3 t2 = ((-uViewer_low - e) + (instanceStartLow.xyz - (t1 - e))) + instanceStart.xyz - uViewer_high;
				// vec3 highDifference = t1 + t2;
				// vec3 lowDifference = t2 - (highDifference - t1);
				// vec4 start = modelViewMatrix * vec4(highDifference.xyz + lowDifference.xyz , 1.);
				vec4 start = modelViewMatrix * computeRelativePosition(instanceStartLow.xyz, instanceStart.xyz, uViewer_low, uViewer_high);
				
				// t1 = instanceEndLow.xyz - uViewer_low;
				// e = t1 - instanceEndLow.xyz;
				// t2 = ((-uViewer_low - e) + (instanceEndLow.xyz - (t1 - e))) + instanceEnd.xyz - uViewer_high;
				// highDifference = t1 + t2;
				// lowDifference = t2 - (highDifference - t1);
				// vec4 end = modelViewMatrix * vec4(highDifference.xyz + lowDifference.xyz , 1.);
				vec4 end = modelViewMatrix * computeRelativePosition(instanceEndLow.xyz, instanceEnd.xyz, uViewer_low, uViewer_high);
            #else
                vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
                vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );
            #endif

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( computedPosition.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( computedPosition.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( computedPosition.y > 1.0 || computedPosition.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// debugColor = vec3(0., 0., 1.);
				correctedLineWidth = linewidth;
				vec3 cOffset = offset;
				
				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( computedPosition.y < 0.5 ) ? start : end;

				/*
				Not great, not terrible
				*/
				float pixelSize = length(vec2(pixelThreshold/resolution.x + pixelThreshold/resolution.y));
				float offsetStep = linewidth;
				float d = screenSpaceDistance(worldPos, worldPos + vec4(cOffset * offsetStep, 0.));
				/* We're trying to start off with a step closer to the initial difference between SS distance and the pixel size we want
				*/
				// offsetStep += pixelSize - d;
				vec3 move = offset;
				
				for(int i = 0; i < SEARCH_STEPS; i++){
					move = cOffset * offsetStep;
					d = screenSpaceDistance(worldPos, worldPos + vec4(move, 0.));
					if(d > pixelSize) {
						correctedLineWidth = offsetStep;
						break;
					}
					offsetStep += offsetStep;
				}

				worldPos.xyz += move;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( computedPosition.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( computedPosition.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( computedPosition.y < 0.0 ) {

					offset += - dir;

				} else if ( computedPosition.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( computedPosition.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( computedPosition.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`}get fragmentProgram(){return`
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;
		varying float vAlpha;
		// varying vec3 debugColor;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;
			varying float correctedLineWidth;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha;
			#ifdef UNIFORM_OPACITY
				alpha = opacity;
			#else
				alpha = vAlpha;
			#endif


			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / correctedLineWidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			// #include <color_fragment> COMMENTED CHUNK
			#if defined( USE_COLOR_ALPHA )
				diffuseColor *= vColor;
			#elif defined( USE_COLOR )
				diffuseColor.rgb = vColor;
			#endif

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`}get baseUniforms(){return Rn.line.uniforms}get uniformsDef(){return{uViewer_high:new A,uViewer_low:new A,pixelThreshold:0}}set pixelThreshold(e){this.userData.pixelThreshold.value=e,this.needsUpdate=!0}constructor(e,t=[]){super(e),this.init(t)}customProgramCacheKey(){return this.constructor.name}copy(e){return super.copy(e),this.copyFrom(e),this}fastCopy(e,t){super.fastCopy(e,t);const n=e;t.color.copy(n.color),t.userData.pixelThreshold.value=e.userData.pixelThreshold.value}onBeforeRender(e,t,n,i,r){this.defines&&this.defines.USE_RTE&&(r.modelViewMatrix.copy(e.RTEBuffers.rteViewModelMatrix),this.userData.uViewer_low.value.copy(e.RTEBuffers.viewerLow),this.userData.uViewer_high.value.copy(e.RTEBuffers.viewerHigh)),e.getDrawingBufferSize(this.resolution),this.needsUpdate=!0}}class hi extends WM{get vertexProgram(){return`
#define STANDARD
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
    uniform mat4 rteShadowMatrix;
    uniform vec3 uShadowViewer_high;
    uniform vec3 uShadowViewer_low;
#endif

#ifdef TRANSFORM_STORAGE
    attribute float objIndex;
    #if TRANSFORM_STORAGE == 0
        #if __VERSION__ == 300
            #define TRANSFORM_STRIDE 4
        #else
            #define TRANSFORM_STRIDE 4.
        #endif
        uniform sampler2D tTransforms;
        uniform float objCount;
    #elif TRANSFORM_STORAGE == 1
        uniform mat4 uTransforms[OBJ_COUNT];
    #endif
#endif

varying vec3 vViewPosition;

#ifdef USE_TRANSMISSION

    varying vec3 vWorldPosition;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef TRANSFORM_STORAGE
    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){
        #if TRANSFORM_STORAGE == 0
            #if __VERSION__ == 300
                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); 
                vec4 v0 = texelFetch( tTransforms, uv, 0 );
                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);
                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);
                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #else
                float size = objCount * TRANSFORM_STRIDE;
                vec2 cUv = vec2(0.5/size, 0.5);
                vec2 dUv = vec2(1./size, 0.);
                
                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);
                vec4 v0 = texture2D( tTransforms, uv);
                vec4 v1 = texture2D( tTransforms, uv + dUv);
                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);
                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #endif
        #elif TRANSFORM_STORAGE == 1
            mat4 tMatrix = uTransforms[int(objIndex)];
            quaternion = tMatrix[0];
            pivotLow = vec4(tMatrix[1].xyz, 1.);
            pivotHigh = vec4(tMatrix[2].xyz, 1.);
            translation = vec4(tMatrix[3].xyz, 1.);
            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);
        #endif
    }


    highp vec3 rotate_vertex_position(highp vec3 position, highp vec4 quat)
    {   
        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);
    }

    /** Another workaround for Apple's stupid compiler */
    vec4 safeMul(vec4 a, vec4 b) {
        // Prevents constant folding and optimization
        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);
    }

    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)
    {
        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */
        /** The code below will not produce correct results in intel IrisXE integrated GPUs. 
         *  The geometry will turn mangled, albeit stable
         *  I can't know for sure what is going on, but rotating the difference seems to 
         *  force the result into a lower precision?
         */
        // highp vec4 position = v0 - v1;
        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);

        /** Subtracting the rotated vectors works. */
        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;

        /** An alternate workaround is
         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));
           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);

           However I'm not such a fan of the (1. + 1e-7) part
         */
    }
#endif

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }
#endif


void main() {

    #include <uv_vertex>
    #include <uv2_vertex>
    #include <color_vertex>
    #include <morphcolor_vertex>
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    // #include <defaultnormal_vertex> // COMMENTED CHUNK
    vec3 transformedNormal = objectNormal;
    #ifdef USE_INSTANCING

        // this is in lieu of a per-instance normal-matrix
        // shear transforms in the instance matrix are not supported
        mat3 m = mat3( instanceMatrix );
        transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
        transformedNormal = m * transformedNormal;
        
        /* If we have negative scaling, we flip the normal */
        float signDet = sign(dot(m[0], cross(m[1], m[2])));
        // Optional fallback: treat 0 as +1
        signDet = signDet + (1.0 - abs(signDet));
        transformedNormal *= signDet;
    #endif
    transformedNormal = normalMatrix * transformedNormal;
    #ifdef FLIP_SIDED
        transformedNormal = - transformedNormal;
    #endif
    #ifdef USE_TANGENT
        vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
        #ifdef FLIP_SIDED
            transformedTangent = - transformedTangent;
        #endif
    #endif
    #include <normal_vertex>

    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    //#include <project_vertex> // EDITED CHUNK
    
    #ifdef TRANSFORM_STORAGE
        highp vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;
        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);
    #endif
    #ifdef USE_RTE
        vec4 position_lowT = vec4(position_low, 1.);
        vec4 position_highT = vec4(position, 1.);
        const vec3 ZERO3 = vec3(0., 0., 0.);

        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);
        #ifdef TRANSFORM_STORAGE
            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;
        #endif
    #endif

    #ifdef USE_RTE
        vec4 mvPosition = rteLocalPosition;
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
        #ifdef TRANSFORM_STORAGE
            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif
    #endif
    
    mvPosition = modelViewMatrix * mvPosition;

    gl_Position = projectionMatrix * mvPosition;


    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>

    vViewPosition = - mvPosition.xyz;

    #include <worldpos_vertex>
    // #include <shadowmap_vertex> COMMENTED CHUNK!!!
    #ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
        highp vec4 shadowPosition = vec4(transformed, 1.0);
        mat4 shadowMatrix = directionalShadowMatrix[ i ];

        #ifdef USE_RTE
            shadowPosition = computeRelativePosition(position_low.xyz, position.xyz, uShadowViewer_low, uShadowViewer_high);
            shadowMatrix = rteShadowMatrix;
            #ifdef TRANSFORM_STORAGE
                highp vec4 rtePivotShadow = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uShadowViewer_low, uShadowViewer_high);
                shadowPosition.xyz = rotate_scaled_vertex_position_delta(shadowPosition, rtePivotShadow, tScale, tQuaternion) + rtePivotShadow.xyz + tTranslation.xyz;
            #endif
            #ifdef USE_INSTANCING
                vec4 rtePivotShadow = computeRelativePosition(ZERO3, ZERO3, uShadowViewer_low, uShadowViewer_high);
                shadowPosition.xyz = (mat3(instanceMatrix) * (shadowPosition - rtePivotShadow).xyz) + rtePivotShadow.xyz + instanceMatrix[3].xyz;
            #endif
        #else
            #ifdef TRANSFORM_STORAGE
                shadowPosition.xyz = rotate_vertex_position(shadowPosition.xyz * tScale.xyz, tQuaternion) + tTranslation.xyz;
            #endif
            #ifdef USE_INSTANCING
                shadowPosition = instanceMatrix * shadowPosition;
            #endif
        #endif
        shadowWorldPosition = modelMatrix * shadowPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
        vDirectionalShadowCoord[ i ] = shadowMatrix * shadowWorldPosition;
	}
    
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	/*
	#if NUM_RECT_AREA_LIGHTS > 0
		// TODO (abelnation): update vAreaShadowCoord with area light info
	#endif
	*/
    #endif

    #include <fog_vertex>

#ifdef USE_TRANSMISSION

    vWorldPosition = worldPosition.xyz;

#endif
}
`}get fragmentProgram(){return`
#define STANDARD

#ifdef PHYSICAL
    #define IOR
    #define SPECULAR
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef IOR
    uniform float ior;
#endif

#ifdef SPECULAR
    uniform float specularIntensity;
    uniform vec3 specularColor;

    #ifdef USE_SPECULARINTENSITYMAP
        uniform sampler2D specularIntensityMap;
    #endif

    #ifdef USE_SPECULARCOLORMAP
        uniform sampler2D specularColorMap;
    #endif
#endif

#ifdef USE_CLEARCOAT
    uniform float clearcoat;
    uniform float clearcoatRoughness;
#endif

#ifdef USE_SHEEN
    uniform vec3 sheenColor;
    uniform float sheenRoughness;

    #ifdef USE_SHEENCOLORMAP
        uniform sampler2D sheenColorMap;
    #endif

    #ifdef USE_SHEENROUGHNESSMAP
        uniform sampler2D sheenRoughnessMap;
    #endif
#endif

varying vec3 vViewPosition;
/** We're disabling color grading for now until we want to properly offer it to the users */
//#define CUSTOM_TONEMAPPING 

#ifdef CUSTOM_TONEMAPPING

	uniform float contrast;
	uniform float saturation;
	uniform float whitescale;
	vec3 EvalLogContrastFunc(vec3 col, float eps, float logMidpoint, float contrastFactor)
	{
		vec3 x = max(vec3(0.), col);
		vec3 logX = log2(x+vec3(eps));
		vec3 adjX = vec3(logMidpoint) + (logX - vec3(logMidpoint)) * contrastFactor;
		vec3 ret = max(vec3(0.0), exp2(adjX) - vec3(eps));
		return ret;
	}

	vec3 evalSaturation(vec3 rgbVal, float saturationFactor){
		vec3 lumaWeights = vec3(.25,.50,.25);
		vec3 grey = vec3(dot(lumaWeights,rgbVal));
		return grey + saturationFactor*(rgbVal-grey);
	}

	vec3 evalExposure(vec3 rgbVal, float exposureFactor){
		return rgbVal * exp2(exposureFactor);
	}

	vec3 filmicTonemap(vec3 x) {
		float A = 0.15;
		float B = 0.50;
		float C = 0.10;
		float D = 0.20;
		float E = 0.02;
		float F = 0.30;
		float W = 11.2;
		return ((x*(A*x+C*B)+D*E) / (x*(A*x+B)+D*F))- E / F;
	}


	vec3 applyFilmicToneMap( vec3 color) 
	{
		color = 2.0 * filmicTonemap( color);
		vec3 whiteScale = 1.0 / filmicTonemap(vec3(11.2));
		color *= whiteScale;
		return color;
	}

	vec3 postProcess(in vec3 _color, float exposureFactor, float contrastFactor, float saturationFactor){
		vec3 color = _color;

		// color.rgb *= exposureFactor;
		color.rgb = evalSaturation(color.rgb, saturationFactor);
		color = EvalLogContrastFunc(color, 0.0001, 0.18, contrastFactor);
		color.rgb = ACESFilmicToneMapping( color );//applyFilmicToneMap(color.rgb);
		return color;
	}
#endif

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>


void main() {

    #include <clipping_planes_fragment>

    vec4 diffuseColor = vec4( diffuse, opacity );
    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
    vec3 totalEmissiveRadiance = emissive;

    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <color_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <roughnessmap_fragment>
    #include <metalnessmap_fragment>
    #include <normal_fragment_begin>
    #include <normal_fragment_maps>
    #include <clearcoat_normal_fragment_begin>
    #include <clearcoat_normal_fragment_maps>
    #include <emissivemap_fragment>

    // accumulation
    #include <lights_physical_fragment>
    #include <lights_fragment_begin>
    #include <lights_fragment_maps>
    #include <lights_fragment_end>

    // modulation
    #include <aomap_fragment>

    vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
    vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

    #include <transmission_fragment>

    vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

    #ifdef USE_SHEEN

        // Sheen energy compensation approximation calculation can be found at the end of
        // https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
        float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );

        outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;

    #endif

    #ifdef USE_CLEARCOAT

        float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );

        vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );

        outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;

    #endif

    // #include <output_fragment> COMMENTED CHUNK
    #ifdef OPAQUE
        diffuseColor.a = 1.0;
    #endif

    // https://github.com/mrdoob/three.js/pull/22425
    #ifdef USE_TRANSMISSION
        diffuseColor.a *= transmissionAlpha + 0.1;
    #endif

    gl_FragColor = vec4( outgoingLight, diffuseColor.a );
    // #include <tonemapping_fragment> // COMMENTED OUT
    #ifdef TONE_MAPPING
		#ifdef CUSTOM_TONEMAPPING
			gl_FragColor.rgb = postProcess(gl_FragColor.rgb, toneMappingExposure, contrast, saturation);
		#else
            
			gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
		#endif
	#endif
    #include <encodings_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>
    #include <dithering_fragment>

}
`}get baseUniforms(){return Rn.standard.uniforms}get uniformsDef(){return{uViewer_high:new A,uViewer_low:new A,rteShadowMatrix:new ae,uShadowViewer_high:new A,uShadowViewer_low:new A,uTransforms:[new ae],tTransforms:null,objCount:1}}constructor(e,t=[]){super(e),this.init(t)}customProgramCacheKey(){return this.constructor.name}copy(e){return super.copy(e),this.copyFrom(e),e instanceof hi&&(this.originalRoughness=e.originalRoughness,this.artificialRoughness=e.artificialRoughness),this}fastCopy(e,t){super.fastCopy(e,t);const n=t,i=e;n.color.copy(i.color),n.roughness=i.roughness,n.metalness=i.metalness,n.emissive.copy(i.emissive),n.emissiveIntensity=i.emissiveIntensity,n.envMap=i.envMap,n.envMapIntensity=i.envMapIntensity,n.originalRoughness=i.originalRoughness,n.artificialRoughness=i.artificialRoughness}updateArtificialRoughness(e){if(e&&(this.originalRoughness===void 0&&(this.originalRoughness=this.roughness),this.artificialRoughness=e),this.originalRoughness===void 0||this.artificialRoughness===void 0)return;const t=e!==void 0?Math.min(this.originalRoughness,this.artificialRoughness):this.originalRoughness;this.roughness=t,this.needsCopy=!0}onBeforeRender(e,t,n,i,r){this.defines&&this.defines.USE_RTE&&(r.modelViewMatrix.copy(e.RTEBuffers.rteViewModelMatrix),this.userData.uViewer_low.value.copy(e.RTEBuffers.viewerLow),this.userData.uViewer_high.value.copy(e.RTEBuffers.viewerHigh),this.userData.rteShadowMatrix.value.copy(e.RTEBuffers.rteShadowMatrix),this.userData.uShadowViewer_low.value.copy(e.RTEBuffers.shadowViewerLow),this.userData.uShadowViewer_high.value.copy(e.RTEBuffers.shadowViewerHigh),this.needsUpdate=!0)}}const qM=`
uniform float size;
uniform float scale;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
#endif

highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
    /* 
    Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
    Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
    */
    highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
    highp vec3 e = t1 - position_low.xyz;
    /** This is redunant, but necessary as a workaround for Apple platforms */
    highp float x = position_high.x - relativeTo_high.x;
    highp float y = position_high.y - relativeTo_high.y;
    highp float z = position_high.z - relativeTo_high.z;
    highp vec3 v = vec3(x, y, z);
    /** End of redundant part */
    highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
    highp vec3 highDifference = t1 + t2;
    highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
    
    highp vec3 position = highDifference.xyz + lowDifference.xyz;
    return vec4(position, 1.);
}

#ifdef USE_GRADIENT_RAMP
    attribute float gradientIndex;
    varying float vGradientIndex;
#endif

void main() {

	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	// #include <project_vertex> COMMENTED CHUNK
	#ifdef USE_RTE
        vec4 mvPosition = computeRelativePosition(position_low.xyz, position.xyz, uViewer_low, uViewer_high);
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
    #endif
    
    #ifdef USE_INSTANCING

        mvPosition = instanceMatrix * mvPosition;

    #endif
    mvPosition = modelViewMatrix * mvPosition;

    #ifdef USE_GRADIENT_RAMP
        vGradientIndex = gradientIndex;
    #endif

    gl_Position = projectionMatrix * mvPosition;

	gl_PointSize = size;

	#ifdef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );

	#endif

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>

}
`,_M=`
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

#ifdef USE_GRADIENT_RAMP
	varying float vGradientIndex;
	uniform sampler2D gradientRamp;
#endif

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );

	#ifdef USE_GRADIENT_RAMP
		vec4 diffuseColor = vec4( texture2D(gradientRamp, vec2(vGradientIndex, 0.)).rgb, opacity );
	#else
		vec4 diffuseColor = vec4( diffuse, opacity );
	#endif

	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`;class fr extends YM{get vertexProgram(){return qM}get fragmentProgram(){return _M}get baseUniforms(){return Rn.points.uniforms}get uniformsDef(){return{uViewer_high:new A,uViewer_low:new A}}constructor(e,t=[]){super(e),this.init(t)}customProgramCacheKey(){return this.constructor.name}copy(e){return super.copy(e),this.copyFrom(e),this}fastCopy(e,t){super.fastCopy(e,t);const n=t,i=e;n.color.copy(i.color),n.size=i.size,n.sizeAttenuation=i.sizeAttenuation}onBeforeRender(e,t,n,i,r){this.defines&&this.defines.USE_RTE&&(r.modelViewMatrix.copy(e.RTEBuffers.rteViewModelMatrix),this.userData.uViewer_low.value.copy(e.RTEBuffers.viewerLow),this.userData.uViewer_high.value.copy(e.RTEBuffers.viewerHigh),this.needsUpdate=!0)}}class Ha extends hi{get vertexProgram(){return`
#define STANDARD
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
    uniform mat4 rteShadowMatrix;
    uniform vec3 uShadowViewer_high;
    uniform vec3 uShadowViewer_low;
#endif

#ifdef TRANSFORM_STORAGE
    attribute float objIndex;

    #if TRANSFORM_STORAGE == 0
        #if __VERSION__ == 300
            #define TRANSFORM_STRIDE 4
        #else
            #define TRANSFORM_STRIDE 4.
        #endif
        uniform sampler2D tTransforms;
        uniform float objCount;
    #elif TRANSFORM_STORAGE == 1
        uniform mat4 uTransforms[OBJ_COUNT];
    #endif
#endif

varying vec3 vViewPosition;

#ifdef USE_TRANSMISSION

    varying vec3 vWorldPosition;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef TRANSFORM_STORAGE
    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){
        #if TRANSFORM_STORAGE == 0
            #if __VERSION__ == 300
                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); 
                vec4 v0 = texelFetch( tTransforms, uv, 0 );
                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);
                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);
                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #else
                float size = objCount * TRANSFORM_STRIDE;
                vec2 cUv = vec2(0.5/size, 0.5);
                vec2 dUv = vec2(1./size, 0.);
                
                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);
                vec4 v0 = texture2D( tTransforms, uv);
                vec4 v1 = texture2D( tTransforms, uv + dUv);
                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);
                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #endif
        #elif TRANSFORM_STORAGE == 1
            mat4 tMatrix = uTransforms[int(objIndex)];
            quaternion = tMatrix[0];
            pivotLow = vec4(tMatrix[1].xyz, 1.);
            pivotHigh = vec4(tMatrix[2].xyz, 1.);
            translation = vec4(tMatrix[3].xyz, 1.);
            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);
        #endif
    }

    vec3 rotate_vertex_position(vec3 position, vec4 quat)
    { 
        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);
    }

    /** Another workaround for Apple's stupid compiler */
    vec4 safeMul(vec4 a, vec4 b) {
        // Prevents constant folding and optimization
        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);
    }

    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)
    {
        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */
        /** The code below will not produce correct results in intel IrisXE integrated GPUs. 
         *  The geometry will turn mangled, albeit stable
         *  I can't know for sure what is going on, but rotating the difference seems to 
         *  force the result into a lower precision?
         */
        // highp vec4 position = v0 - v1;
        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);

        /** Subtracting the rotated vectors works. */
        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;

        /** An alternate workaround is
         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));
           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);

           However I'm not such a fan of the (1. + 1e-7) part
         */
    }

#endif

attribute float gradientIndex;
varying float vGradientIndex;

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }
#endif

void main() {

    #include <uv_vertex>
    #include <uv2_vertex>
    #include <color_vertex>
    #include <morphcolor_vertex>
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    // #include <defaultnormal_vertex> // COMMENTED CHUNK
    vec3 transformedNormal = objectNormal;
    #ifdef USE_INSTANCING

        // this is in lieu of a per-instance normal-matrix
        // shear transforms in the instance matrix are not supported
        mat3 m = mat3( instanceMatrix );
        transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
        transformedNormal = m * transformedNormal;
        
        /* If we have negative scaling, we flip the normal */
        float signDet = sign(dot(m[0], cross(m[1], m[2])));
        // Optional fallback: treat 0 as +1
        signDet = signDet + (1.0 - abs(signDet));
        transformedNormal *= signDet;
    #endif
    transformedNormal = normalMatrix * transformedNormal;
    #ifdef FLIP_SIDED
        transformedNormal = - transformedNormal;
    #endif
    #ifdef USE_TANGENT
        vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
        #ifdef FLIP_SIDED
            transformedTangent = - transformedTangent;
        #endif
    #endif
    #include <normal_vertex>

    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    //#include <project_vertex> // EDITED CHUNK
    #ifdef TRANSFORM_STORAGE
        vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;
        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);
    #endif
    #ifdef USE_RTE
        vec4 position_lowT = vec4(position_low, 1.);
        vec4 position_highT = vec4(position, 1.);
        const vec3 ZERO3 = vec3(0., 0., 0.);

        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);
        #ifdef TRANSFORM_STORAGE
            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;
        #endif
    #endif

    #ifdef USE_RTE
        vec4 mvPosition = rteLocalPosition;
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
        #ifdef TRANSFORM_STORAGE
            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif
    #endif


    mvPosition = modelViewMatrix * mvPosition;

    vGradientIndex = gradientIndex;
    gl_Position = projectionMatrix * mvPosition;

    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>

    vViewPosition = - mvPosition.xyz;

    #include <worldpos_vertex>
    // #include <shadowmap_vertex>// EDITED CHUNK
    #ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
        highp vec4 shadowPosition = vec4(transformed, 1.0);
        mat4 shadowMatrix = directionalShadowMatrix[ i ];

        #ifdef USE_RTE
            shadowPosition = computeRelativePosition(position_low.xyz, position.xyz, uShadowViewer_low, uShadowViewer_high);
            shadowMatrix = rteShadowMatrix;
            #ifdef TRANSFORM_STORAGE
                highp vec4 rtePivotShadow = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uShadowViewer_low, uShadowViewer_high);
                shadowPosition.xyz = rotate_scaled_vertex_position_delta(shadowPosition, rtePivotShadow, tScale, tQuaternion) + rtePivotShadow.xyz + tTranslation.xyz;
            #endif
            #ifdef USE_INSTANCING
                vec4 rtePivotShadow = computeRelativePosition(ZERO3, ZERO3, uShadowViewer_low, uShadowViewer_high);
                shadowPosition.xyz = (mat3(instanceMatrix) * (shadowPosition - rtePivotShadow).xyz) + rtePivotShadow.xyz + instanceMatrix[3].xyz;
            #endif
        #else
            #ifdef TRANSFORM_STORAGE
                shadowPosition.xyz = rotate_vertex_position(shadowPosition.xyz * tScale.xyz, tQuaternion) + tTranslation.xyz;
            #endif
            #ifdef USE_INSTANCING
                shadowPosition = instanceMatrix * shadowPosition;
            #endif
        #endif
        shadowWorldPosition = modelMatrix * shadowPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
        vDirectionalShadowCoord[ i ] = shadowMatrix * shadowWorldPosition;
    
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	/*
	#if NUM_RECT_AREA_LIGHTS > 0
		// TODO (abelnation): update vAreaShadowCoord with area light info
	#endif
	*/
    #endif
    #include <fog_vertex>

#ifdef USE_TRANSMISSION

    vWorldPosition = worldPosition.xyz;

#endif
}
`}get fragmentProgram(){return`
#define STANDARD

#ifdef PHYSICAL
    #define IOR
    #define SPECULAR
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef IOR
    uniform float ior;
#endif

#ifdef SPECULAR
    uniform float specularIntensity;
    uniform vec3 specularColor;

    #ifdef USE_SPECULARINTENSITYMAP
        uniform sampler2D specularIntensityMap;
    #endif

    #ifdef USE_SPECULARCOLORMAP
        uniform sampler2D specularColorMap;
    #endif
#endif

#ifdef USE_CLEARCOAT
    uniform float clearcoat;
    uniform float clearcoatRoughness;
#endif

#ifdef USE_SHEEN
    uniform vec3 sheenColor;
    uniform float sheenRoughness;

    #ifdef USE_SHEENCOLORMAP
        uniform sampler2D sheenColorMap;
    #endif

    #ifdef USE_SHEENROUGHNESSMAP
        uniform sampler2D sheenRoughnessMap;
    #endif
#endif

varying vec3 vViewPosition;

varying float vGradientIndex;
uniform sampler2D gradientRamp;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

    #include <clipping_planes_fragment>

    vec4 diffuseColor = vec4( texture2D(gradientRamp, vec2(vGradientIndex, 0.)).rgb, opacity );
    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
    vec3 totalEmissiveRadiance = emissive;

    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <color_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <roughnessmap_fragment>
    #include <metalnessmap_fragment>
    #include <normal_fragment_begin>
    #include <normal_fragment_maps>
    #include <clearcoat_normal_fragment_begin>
    #include <clearcoat_normal_fragment_maps>
    #include <emissivemap_fragment>

    // accumulation
    #include <lights_physical_fragment>
    #include <lights_fragment_begin>
    #include <lights_fragment_maps>
    #include <lights_fragment_end>

    // modulation
    #include <aomap_fragment>

    vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
    vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

    #include <transmission_fragment>

    vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

    #ifdef USE_SHEEN

        // Sheen energy compensation approximation calculation can be found at the end of
        // https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
        float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );

        outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;

    #endif

    #ifdef USE_CLEARCOAT

        float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );

        vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );

        outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;

    #endif

    #include <output_fragment>
    #include <tonemapping_fragment>
    #include <encodings_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>
    #include <dithering_fragment>
}
`}get uniformsDef(){return{...super.uniformsDef,gradientRamp:null}}constructor(e,t=[]){super(e,t)}setGradientTexture(e){this.userData.gradientRamp.value=e,this.userData.gradientRamp.value.generateMipmaps=!1,this.userData.gradientRamp.value.minFilter=Dt,this.userData.gradientRamp.value.magFilter=Dt,this.needsUpdate=!0}}const tt={Millimeters:"mm",Centimeters:"cm",Meters:"m",Kilometers:"km",Inches:"in",Feet:"ft",Yards:"yd",Miles:"mi"};function xn(a,e=tt.Meters){switch(a=Bw(a),e=Bw(e),a){case tt.Millimeters:switch(e){case tt.Centimeters:return .1;case tt.Meters:return .001;case tt.Kilometers:return 1e-6;case tt.Inches:return .0393701;case tt.Feet:return .00328084;case tt.Yards:return .00109361;case tt.Miles:return 621371e-12}break;case tt.Centimeters:switch(e){case tt.Millimeters:return 10;case tt.Meters:return .01;case tt.Kilometers:return 1e-5;case tt.Inches:return .393701;case tt.Feet:return .0328084;case tt.Yards:return .0109361;case tt.Miles:return 621371e-11}break;case tt.Meters:switch(e){case tt.Millimeters:return 1e3;case tt.Centimeters:return 100;case tt.Kilometers:return .001;case tt.Inches:return 39.3701;case tt.Feet:return 3.28084;case tt.Yards:return 1.09361;case tt.Miles:return 621371e-9}break;case tt.Kilometers:switch(e){case tt.Millimeters:return 1e6;case tt.Centimeters:return 1e5;case tt.Meters:return 1e3;case tt.Inches:return 39370.1;case tt.Feet:return 3280.84;case tt.Yards:return 1093.61;case tt.Miles:return .621371}break;case tt.Inches:switch(e){case tt.Millimeters:return 25.4;case tt.Centimeters:return 2.54;case tt.Meters:return .0254;case tt.Kilometers:return 254e-7;case tt.Feet:return .0833333;case tt.Yards:return .027777694;case tt.Miles:return 157828e-10}break;case tt.Feet:switch(e){case tt.Millimeters:return 304.8;case tt.Centimeters:return 30.48;case tt.Meters:return .3048;case tt.Kilometers:return 3048e-7;case tt.Inches:return 12;case tt.Yards:return .333332328;case tt.Miles:return 189394e-9}break;case tt.Miles:switch(e){case tt.Millimeters:return 1609e3;case tt.Centimeters:return 160934;case tt.Meters:return 1609.34;case tt.Kilometers:return 1.60934;case tt.Inches:return 63360;case tt.Feet:return 5280;case tt.Yards:return 1759.99469184}}return 1}function Bw(a){if(!a)return tt.Meters;switch(a.toLowerCase()){case"mm":case"mil":case"millimeters":case"millimetres":return tt.Millimeters;case"cm":case"centimetre":case"centimeter":case"centimetres":case"centimeters":return tt.Centimeters;case"m":case"meter":case"metre":case"meters":case"metres":default:return tt.Meters;case"inches":case"inch":case"in":return tt.Inches;case"feet":case"foot":case"ft":return tt.Feet;case"yard":case"yards":case"yd":return tt.Yards;case"miles":case"mile":case"mi":return tt.Miles;case"km":case"kilometers":return tt.Kilometers}}const Lw=new ae,wm=new te,MN=new te,bN=new te;class Ar extends XM{get vertexProgram(){return`
#include <common>
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
#endif

#ifdef TRANSFORM_STORAGE
    attribute float objIndex;

    #if TRANSFORM_STORAGE == 0
        #if __VERSION__ == 300
            #define TRANSFORM_STRIDE 4
        #else
            #define TRANSFORM_STRIDE 4.
        #endif
        uniform sampler2D tTransforms;
        uniform float objCount;
    #elif TRANSFORM_STORAGE == 1
        uniform mat4 uTransforms[OBJ_COUNT];
    #endif
#endif

#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }   
#endif

#ifdef TRANSFORM_STORAGE
    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){
        #if TRANSFORM_STORAGE == 0
            #if __VERSION__ == 300
                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); 
                vec4 v0 = texelFetch( tTransforms, uv, 0 );
                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);
                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);
                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #else
                float size = objCount * TRANSFORM_STRIDE;
                vec2 cUv = vec2(0.5/size, 0.5);
                vec2 dUv = vec2(1./size, 0.);
                
                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);
                vec4 v0 = texture2D( tTransforms, uv);
                vec4 v1 = texture2D( tTransforms, uv + dUv);
                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);
                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #endif
        #elif TRANSFORM_STORAGE == 1
            mat4 tMatrix = uTransforms[int(objIndex)];
            quaternion = tMatrix[0];
            pivotLow = vec4(tMatrix[1].xyz, 1.);
            pivotHigh = vec4(tMatrix[2].xyz, 1.);
            translation = vec4(tMatrix[3].xyz, 1.);
            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);
        #endif
    }

    vec3 rotate_vertex_position(vec3 position, vec4 quat)
    { 
        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);
    }

    /** Another workaround for Apple's stupid compiler */
    vec4 safeMul(vec4 a, vec4 b) {
        // Prevents constant folding and optimization
        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);
    }

    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)
    {
        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */
        /** The code below will not produce correct results in intel IrisXE integrated GPUs. 
         *  The geometry will turn mangled, albeit stable
         *  I can't know for sure what is going on, but rotating the difference seems to 
         *  force the result into a lower precision?
         */
        // highp vec4 position = v0 - v1;
        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);

        /** Subtracting the rotated vectors works. */
        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;

        /** An alternate workaround is
         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));
           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);

           However I'm not such a fan of the (1. + 1e-7) part
         */
    }

#endif

#if defined(BILLBOARD) || defined(BILLBOARD_SCREEN)
    uniform mat4 invProjection;
#endif

#ifdef BILLBOARD_SCREEN
    uniform vec4 billboardPixelOffsetSize;
#endif

void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
        // #include <defaultnormal_vertex> // COMMENTED CHUNK
        vec3 transformedNormal = objectNormal;
        #ifdef USE_INSTANCING

            // this is in lieu of a per-instance normal-matrix
            // shear transforms in the instance matrix are not supported
            mat3 m = mat3( instanceMatrix );
            transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
            transformedNormal = m * transformedNormal;
            
            /* If we have negative scaling, we flip the normal */
            float signDet = sign(dot(m[0], cross(m[1], m[2])));
            // Optional fallback: treat 0 as +1
            signDet = signDet + (1.0 - abs(signDet));
            transformedNormal *= signDet;
        #endif
        transformedNormal = normalMatrix * transformedNormal;
        #ifdef FLIP_SIDED
            transformedNormal = - transformedNormal;
        #endif
        #ifdef USE_TANGENT
            vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
            #ifdef FLIP_SIDED
                transformedTangent = - transformedTangent;
            #endif
        #endif
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	// #include <project_vertex> COMMENTED CHUNK
    #ifdef TRANSFORM_STORAGE
        vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;
        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);
    #endif
    #ifdef USE_RTE
        vec4 position_lowT = vec4(position_low, 1.);
        vec4 position_highT = vec4(position, 1.);
        const vec3 ZERO3 = vec3(0., 0., 0.);

        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);
        #ifdef TRANSFORM_STORAGE
            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;
        #endif
    #endif

    #ifdef USE_RTE
        vec4 mvPosition = rteLocalPosition;
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
        #ifdef TRANSFORM_STORAGE
            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif
    #endif
    
    mvPosition = modelViewMatrix * mvPosition;
    
    #if defined(BILLBOARD)
        float div = 1.;
        gl_Position = projectionMatrix * (viewMatrix * vec4(modelMatrix[3].xyz, 1.0) + vec4(position.x, position.y, 0., 0.0));
    #elif defined(BILLBOARD_SCREEN)
        gl_Position = projectionMatrix * (viewMatrix * vec4(modelMatrix[3].xyz, 1.0));
        float div = gl_Position.w;
        gl_Position /= gl_Position.w;
        gl_Position.xy += position.xy * billboardPixelOffsetSize.zw * 2. + billboardPixelOffsetSize.xy * 2.;
    #else
        gl_Position = projectionMatrix * mvPosition;
    #endif


	#include <logdepthbuf_vertex>
	// #include <clipping_planes_vertex> COMMENTED CHUNK
    #if NUM_CLIPPING_PLANES > 0
        #if defined(BILLBOARD) || defined(BILLBOARD_SCREEN)
            vec4 movelViewProjection = gl_Position * div;
            vClipPosition = - (invProjection * movelViewProjection).xyz;
        #else
	        vClipPosition = - mvPosition.xyz;
        #endif
    #endif
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`}get fragmentProgram(){return`
uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	// modulation
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	// #include <output_fragment> COMMENTED CHUNK
	#ifdef OPAQUE
		diffuseColor.a = 1.0;
	#endif

	// https://github.com/mrdoob/three.js/pull/22425
	#ifdef USE_TRANSMISSION
		diffuseColor.a *= transmissionAlpha + 0.1;
	#endif

	gl_FragColor = vec4( outgoingLight * diffuseColor.a, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`}get baseUniforms(){return Rn.basic.uniforms}get uniformsDef(){return{uViewer_high:new A,uViewer_low:new A,uTransforms:[new ae],tTransforms:null,objCount:1,invProjection:new ae,billboardPixelOffsetSize:new lt}}get billboardPixelSize(){return this._billboardPixelSize}set billboardPixelSize(e){this._billboardPixelSize.copy(e)}get billboardPixeOffset(){return this._billboardPixelOffset}set billboardPixelOffset(e){this._billboardPixelOffset.copy(e)}constructor(e,t=[]){super(e),this._billboardPixelSize=new te,this._billboardPixelOffset=new te,this.init(t)}customProgramCacheKey(){return this.constructor.name}copy(e){return super.copy(e),this.copyFrom(e),this}fastCopy(e,t){super.fastCopy(e,t);const n=e;t.color.copy(n.color),t.userData.billboardPixelOffsetSize.value.copy(e.userData.billboardPixelOffsetSize.value)}setBillboarding(e){this.defines||(this.defines={}),delete this.defines.BILLBOARD_SCREEN,delete this.defines.BILLBOARD,e&&(e==="world"&&(this.defines.BILLBOARD=" "),e==="screen"&&(this.defines.BILLBOARD_SCREEN=" "))}onBeforeRender(e,t,n,i,r){if(this.defines&&(this.defines.BILLBOARD||this.defines.BILLBOARD_SCREEN)&&(Lw.copy(n.projectionMatrix).invert(),this.userData.invProjection.value.copy(Lw),this.needsUpdate=!0),this.defines&&this.defines.BILLBOARD_SCREEN){e.getDrawingBufferSize(wm);const s=MN.set(this._billboardPixelOffset.x,this._billboardPixelOffset.y),o=bN.set(this._billboardPixelSize.x,this._billboardPixelSize.y);s.divide(wm),o.divide(wm),this.userData.billboardPixelOffsetSize.value.set(s.x,s.y,o.x,o.y),this.needsUpdate=!0}this.defines&&this.defines.USE_RTE&&(r.modelViewMatrix.copy(e.RTEBuffers.rteViewModelMatrix),this.userData.uViewer_low.value.copy(e.RTEBuffers.viewerLow),this.userData.uViewer_high.value.copy(e.RTEBuffers.viewerHigh),this.needsUpdate=!0)}}class Ya extends Ar{get vertexProgram(){return`
#include <common>
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
#endif

#ifdef TRANSFORM_STORAGE
    attribute float objIndex;

    #if TRANSFORM_STORAGE == 0
        #if __VERSION__ == 300
            #define TRANSFORM_STRIDE 4
        #else
            #define TRANSFORM_STRIDE 4.
        #endif
        uniform sampler2D tTransforms;
        uniform float objCount;
    #elif TRANSFORM_STORAGE == 1
        uniform mat4 uTransforms[OBJ_COUNT];
    #endif
#endif

#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef TRANSFORM_STORAGE
    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){
        #if TRANSFORM_STORAGE == 0
            #if __VERSION__ == 300
                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); 
                vec4 v0 = texelFetch( tTransforms, uv, 0 );
                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);
                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);
                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #else
                float size = objCount * TRANSFORM_STRIDE;
                vec2 cUv = vec2(0.5/size, 0.5);
                vec2 dUv = vec2(1./size, 0.);
                
                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);
                vec4 v0 = texture2D( tTransforms, uv);
                vec4 v1 = texture2D( tTransforms, uv + dUv);
                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);
                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #endif
        #elif TRANSFORM_STORAGE == 1
            mat4 tMatrix = uTransforms[int(objIndex)];
            quaternion = tMatrix[0];
            pivotLow = vec4(tMatrix[1].xyz, 1.);
            pivotHigh = vec4(tMatrix[2].xyz, 1.);
            translation = vec4(tMatrix[3].xyz, 1.);
            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);
        #endif
    }

    vec3 rotate_vertex_position(vec3 position, vec4 quat)
    { 
        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);
    }

   /** Another workaround for Apple's stupid compiler */
    vec4 safeMul(vec4 a, vec4 b) {
        // Prevents constant folding and optimization
        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);
    }

    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)
    {
        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */
        /** The code below will not produce correct results in intel IrisXE integrated GPUs. 
         *  The geometry will turn mangled, albeit stable
         *  I can't know for sure what is going on, but rotating the difference seems to 
         *  force the result into a lower precision?
         */
        // highp vec4 position = v0 - v1;
        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);

        /** Subtracting the rotated vectors works. */
        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;

        /** An alternate workaround is
         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));
           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);

           However I'm not such a fan of the (1. + 1e-7) part
         */
    }
#endif

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }
#endif

void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
        // #include <defaultnormal_vertex> // COMMENTED CHUNK
        vec3 transformedNormal = objectNormal;
        #ifdef USE_INSTANCING

            // this is in lieu of a per-instance normal-matrix
            // shear transforms in the instance matrix are not supported
            mat3 m = mat3( instanceMatrix );
            transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
            transformedNormal = m * transformedNormal;
            
            /* If we have negative scaling, we flip the normal */
            float signDet = sign(dot(m[0], cross(m[1], m[2])));
            // Optional fallback: treat 0 as +1
            signDet = signDet + (1.0 - abs(signDet));
            transformedNormal *= signDet;
        #endif
        transformedNormal = normalMatrix * transformedNormal;
        #ifdef FLIP_SIDED
            transformedNormal = - transformedNormal;
        #endif
        #ifdef USE_TANGENT
            vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
            #ifdef FLIP_SIDED
                transformedTangent = - transformedTangent;
            #endif
        #endif
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	// #include <project_vertex> COMMENTED CHUNK
    #ifdef TRANSFORM_STORAGE
        vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;
        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);
    #endif
    #ifdef USE_RTE
        vec4 position_lowT = vec4(position_low, 1.);
        vec4 position_highT = vec4(position, 1.);
        const vec3 ZERO3 = vec3(0., 0., 0.);

        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);
        #ifdef TRANSFORM_STORAGE
            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;
        #endif
    #endif

    #ifdef USE_RTE
        vec4 mvPosition = rteLocalPosition;
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
        #ifdef TRANSFORM_STORAGE
            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif
    #endif
    
    mvPosition = modelViewMatrix * mvPosition;

    gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`}get fragmentProgram(){return`
uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
    // We're disabling alpha testing because we need to use it for shadow rejection. Three.js gave me no choice
	// #include <alphatest_fragment> 
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	// modulation
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`}constructor(e,t=[]){super(e,t)}}class vr extends Ar{get vertexProgram(){return`
#include <common>
#ifdef USE_RTE
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
#endif

#if defined(BILLBOARD) || defined(BILLBOARD_SCREEN)
    uniform mat4 invProjection;
#endif

#ifdef BILLBOARD_SCREEN
    uniform vec4 billboardPixelOffsetSize;
#endif



#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }
#endif


#ifdef BATCHED_TEXT
    varying float vGradientIndex;
#endif

void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
        // #include <defaultnormal_vertex> // COMMENTED CHUNK
        vec3 transformedNormal = objectNormal;
        #ifdef USE_INSTANCING

            // this is in lieu of a per-instance normal-matrix
            // shear transforms in the instance matrix are not supported
            mat3 m = mat3( instanceMatrix );
            transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
            transformedNormal = m * transformedNormal;
            
            /* If we have negative scaling, we flip the normal */
            float signDet = sign(dot(m[0], cross(m[1], m[2])));
            // Optional fallback: treat 0 as +1
            signDet = signDet + (1.0 - abs(signDet));
            transformedNormal *= signDet;
        #endif
        transformedNormal = normalMatrix * transformedNormal;
        #ifdef FLIP_SIDED
            transformedNormal = - transformedNormal;
        #endif
        #ifdef USE_TANGENT
            vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
            #ifdef FLIP_SIDED
                transformedTangent = - transformedTangent;
            #endif
        #endif
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>

    vec4 mvPosition;
    mat4 matrix;

    #ifdef BATCHED_TEXT
        matrix = mat4(
            troikaBatchTexel(0.0), 
            troikaBatchTexel(1.0), 
            troikaBatchTexel(2.0), 
            troikaBatchTexel(3.0)
        );
    #else
        matrix = modelMatrix;
    #endif

    #ifdef USE_RTE
        /* We store the high part normally as the translation component */
        vec3 translationHigh = matrix[3].xyz;
        /** We store the low part of the translation in row4 ofthe matrix */
        vec3 translationLow = vec3(matrix[0][3], matrix[1][3], matrix[2][3]);
        highp vec4 rteTranslation = computeRelativePosition(translationLow, translationHigh, uViewer_low, uViewer_high);
        #if defined(BILLBOARD)
            mvPosition = (modelViewMatrix * rteTranslation + vec4(position.x, position.y, 0., 0.0));
        #else
             mvPosition = vec4(mat3(matrix) * transformed + rteTranslation.xyz, 1.);
             mvPosition = modelViewMatrix * mvPosition;
        #endif
    #else
        #if defined(BILLBOARD) || defined(BILLBOARD_SCREEN)
            vec3 billboardPosition = matrix[3].xyz;
            #if defined(BILLBOARD_SCREEN)
                mvPosition = projectionMatrix * (viewMatrix * vec4(billboardPosition, 1.0));
                float div = mvPosition.w;
                mvPosition /= mvPosition.w;
                // Pixel values are computed like so
                // windowX = ((ndc.x + 1) / 2) * width;
                // windowY = ((ndc.y + 1) / 2) * height;
                // That's why we multiply by 2.
                mvPosition.xy += position.xy * billboardPixelOffsetSize.zw * 2. + billboardPixelOffsetSize.xy * 2.;
                /** Back to view space for convenience */
                mvPosition *= div;
                mvPosition = invProjection * mvPosition;
            #else
                mvPosition = (viewMatrix * vec4(billboardPosition, 1.) + vec4(position.x, position.y, 0., 0.0));
            #endif
        #else
             mvPosition = viewMatrix * matrix * vec4(transformed, 1.);
        #endif
    #endif

    #ifdef BATCHED_TEXT
        vGradientIndex = troikaBatchTexel(6.).w;
    #endif

    gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex> 
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`}get fragmentProgram(){return`
uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

#ifdef BATCHED_TEXT
	uniform sampler2D gradientRamp;
	varying float vGradientIndex;
#endif

void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor_RGB = vec4(diffuse, opacity);
	vec4 diffuseColor = diffuseColor_RGB;
	#ifdef BATCHED_TEXT
		vec4 diffuseColor_Tex = vec4( texture2D(gradientRamp, vec2(vGradientIndex, 0.)).rgb, opacity );
		diffuseColor = mix(diffuseColor_RGB, diffuseColor_Tex, float(vGradientIndex > 0.));
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	// modulation
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`}get uniformsDef(){return{...super.uniformsDef,gradientRamp:null}}customProgramCacheKey(){return this.constructor.name}copyCustomUniforms(e){for(const t in this.userData)e.uniforms[t]=this.userData[t]}getDerivedMaterial(){const e=_d(this);return this.copyCustomUniforms(e),e}getDerivedBatchedMaterial(){var e;const t="uTroikaMatricesTexture",n="uTroikaMatricesTextureSize",i="aTroikaTextBatchMemberIndex";let r=so(this,{chained:!0,uniforms:{[n]:{value:new te},[t]:{value:null}},vertexDefs:`
      uniform highp sampler2D ${t};
      uniform vec2 ${n};
      attribute float ${i};

      vec4 troikaBatchTexel(float offset) {
        offset += ${i} * ${32 .toFixed(1)} / 4.0;
        float w = ${n}.x;
        vec2 uv = (vec2(mod(offset, w), floor(offset / w)) + 0.5) / ${n};
        return texture2D(${t}, uv);
      }
    `,vertexTransform:`
      /** We don't need this. We're transforming ourselves in our shader to allow for RTE*/
      // mat4 matrix = mat4(
      //   troikaBatchTexel(0.0),
      //   troikaBatchTexel(1.0),
      //   troikaBatchTexel(2.0),
      //   troikaBatchTexel(3.0)
      // );
      // position.xyz = (matrix * vec4(position, 1.0)).xyz;
    `});return r=_d(r),r=so(r,{chained:!0,uniforms:{uTroikaIsOutline:{value:!1}},customRewriter:s=>(["uTroikaTotalBounds","uTroikaClipRect","uTroikaPositionOffset","uTroikaEdgeOffset","uTroikaBlurRadius","uTroikaStrokeWidth","uTroikaStrokeColor","uTroikaStrokeOpacity","uTroikaFillOpacity","uTroikaCurveRadius","diffuse"].forEach((o=>{s=wz(s,o)})),s),vertexDefs:`
      uniform bool uTroikaIsOutline;
      vec3 troikaFloatToColor(float v) {
        return mod(floor(vec3(v / 65536.0, v / 256.0, v)), 256.0) / 256.0;
      }
    `,vertexTransform:`
      uTroikaTotalBounds = troikaBatchTexel(4.0);
      uTroikaClipRect = troikaBatchTexel(5.0);
      
      vec4 data = troikaBatchTexel(6.0);
      diffuse = troikaFloatToColor(data.x);
      uTroikaFillOpacity = data.y;
      uTroikaCurveRadius = data.z;
      
      data = troikaBatchTexel(7.0);
      if (uTroikaIsOutline) {
        if (data == vec4(0.0)) { // degenerate if zero outline
          position = vec3(0.0);
        } else {
          uTroikaPositionOffset = data.xy;
          uTroikaEdgeOffset = data.z;
          uTroikaBlurRadius = data.w;
        }
      } else {
        uTroikaStrokeWidth = data.x;
        uTroikaStrokeColor = troikaFloatToColor(data.y);
        uTroikaStrokeOpacity = data.z;
      }
    `}),r.setMatrixTexture=s=>{r.uniforms[t].value=s,r.uniforms[n].value.set(s.image.width,s.image.height)},this.copyCustomUniforms(r),((e=r.defines)!==null&&e!==void 0?e:r.defines={}).BATCHED_TEXT=" ",r}fastCopy(e,t){super.fastCopy(e,t),t.userData.gradientRamp.value=e.userData.gradientRamp.value}setGradientTexture(e){this.userData.gradientRamp.value=e,this.userData.gradientRamp.value.generateMipmaps=!1,this.userData.gradientRamp.value.minFilter=Dt,this.userData.gradientRamp.value.magFilter=Dt,this.needsUpdate=!0}}class Ag extends fr{get vertexProgram(){return qM}get fragmentProgram(){return _M}get uniformsDef(){return{...super.uniformsDef,gradientRamp:null}}constructor(e,t=["USE_GRADIENT_RAMP"]){super(e,t)}setGradientTexture(e){this.userData.gradientRamp.value=e,this.userData.gradientRamp.value.generateMipmaps=!1,this.userData.gradientRamp.value.minFilter=Dt,this.userData.gradientRamp.value.magFilter=Dt,this.needsUpdate=!0}fastCopy(e,t){super.fastCopy(e,t),t.userData.gradientRamp.value=e.userData.gradientRamp.value}}class Sg extends vr{constructor(){super(...arguments),this.gradientIndexMap={}}updateGradientIndexMap(e,t){this.gradientIndexMap[e]=t}}class $M{constructor(e){this.chunks=e,this.updateOffsets()}get length(){if(this.chunks.length===0)return 0;const e=this.chunks[this.chunks.length-1];return this.offsets[this.offsets.length-1]+e.length}get(e){if(this.chunks.length===1)return this.chunks[0][e];const t=this.findChunkIndex(e),n=e-this.offsets[t];return this.chunks[t][n]}set(e,t){if(this.chunks.length===1)return void(this.chunks[0][e]=t);const n=this.findChunkIndex(e),i=e-this.offsets[n];this.chunks[n][i]=t}findChunkIndex(e){let t=0,n=this.offsets.length-1;for(;t<=n;){const i=t+n>>1,r=this.offsets[i],s=i+1<this.offsets.length?this.offsets[i+1]:this.length;if(e>=r&&e<s)return i;e<r?n=i-1:t=i+1}throw new RangeError("Index out of bounds")}updateOffsets(){this.offsets=[];let e=0;for(const t of this.chunks)this.offsets.push(e),e+=t.length}}class Zt extends $M{constructor(e){super(e&&e.map((t=>t.data))),this.chunkArray=e}slice(){const e=[];return this.chunkArray.forEach((t=>{const n=new Array(t.data.length);for(let i=0;i<t.data.length;i++)n[i]=t.data[i];e.push({data:n,id:It.generateUUID(),references:1})})),new Zt(e)}copyToBuffer(e,t){let n=0;this.chunkArray.forEach((i=>{e.set(i.data,t+n),n+=i.data.length}))}computeBox3(){const e=new He,t=new A;let n=[];for(let i=0;i<this.chunks.length;i++){const r=this.chunks[i];let s=0;if(n.length>0){for(;n.length<3&&s<r.length;)n.push(r[s++]);n.length===3&&(t.set(n[0],n[1],n[2]),e.expandByPoint(t),n=[])}const o=Math.floor((r.length-s)/3);for(let l=0;l<o;l++){const c=r[s++],u=r[s++],h=r[s++];t.set(c,u,h),e.expandByPoint(t)}for(;s<r.length;)n.push(r[s++])}return n.length!==0&&console.warn("Virtual position buffer ended with incomplete vec3 data"),e}getFlatArray(e){if(!(this.flatArray&&this.flatArray instanceof e)){this.flatArray=new e(this.length);let t=0;this.chunks.forEach((n=>{this.flatArray.set(n,t),t+=n.length}))}return this.flatArray}getFloat32Array(){return this.getFlatArray(Float32Array)}getFloat64Array(){return this.getFlatArray(Float64Array)}getInt16Array(){return this.getFlatArray(Int16Array)}getInt32Array(){return this.getFlatArray(Int32Array)}getUint16Array(){return this.getFlatArray(Uint16Array)}getUint32Array(){return this.getFlatArray(Uint32Array)}}var Et;const ic={id:"defaultGradient",src:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAABCAIAAAAn2YEhAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAHoSURBVDhPTZRRdoMwDAQx9//seaEzI5sXpwFptVqvMOm6/t7retd1Le8XAdF6+SMEYr03l2fF4GJprcfixl4+tyklG6ZvxeAKWGxBQsKDk9FIdD+pDUFiak9IDQEWMAM4dczEZmWSDOXPBuAQ1OCLYI4bc0S0bbnlFOR6Vgo2WwgraIvgbh8L2ZNxRH5T7QWKyKz9E7kNnUE+KTA3Oz6O3YIOkop+4juHoh1H+m3slByVm9vgOCOoXr7HvBJSjLdJRUHuSrbse+jDiZOPPt/jZIv8WPJeW+JVzYj2CIHc9GaEjmc/OhF3C+neQoBgW/KKZx2VuyxFKqDBNwfqA8NXa7p0781GBT6TPkSOozQPMPer4sBqTrvZUZgqSKP5oaCXXirJdZ4jqyRbtyE8amCkLLkzW9qik7Fx9mWE9pHEh9vMHsIawZSPcxut2DcDyjzeKinisypDwQoKnLU5WVLz7pGO/nbrIhC2MMOaGrj8PRLmfKpSJcT4NZn5wFgbKbVlCzia76HbQZMAjP72IyX94v189i7Ewfa2wcdMTfGOqekE2i/O9LZRi/T8qwFuuvknA3kW/YnLTMVO22OwUXg0OZ1IAdeqcEjXffH2jjEqNmSvRZbF43BLuUPsYsk5XPu3NqD3WKzr/QfN+6p+JpC7ZQAAAABJRU5ErkJggg==",type:gr.TEXTURE_8BPP};var ei,et;(function(a){a[a.GHOST=0]="GHOST",a[a.GRADIENT=1]="GRADIENT",a[a.COLORED=2]="COLORED",a[a.HIDDEN=3]="HIDDEN"})(ei||(ei={}));class Tt{constructor(){this.materialMap={}}static renderMaterialFromNode(e,t){var n;if(!e)return null;let i=null;if(e.model.raw.renderMaterial){const r=t?.model.raw.colors?new Zt(t?.model.raw.colors):void 0;i={id:e.model.raw.renderMaterial.id,color:e.model.raw.renderMaterial.diffuse,emissive:e.model.raw.renderMaterial.emissive,opacity:e.model.raw.renderMaterial.opacity!==void 0?e.model.raw.renderMaterial.opacity:1,roughness:e.model.raw.renderMaterial.roughness,metalness:e.model.raw.renderMaterial.metalness,vertexColors:(n=t&&r&&r.length>0)!==null&&n!==void 0&&n}}return i}static displayStyleFromNode(e){if(!e)return null;let t=null;if(e.model.raw.displayStyle){let n=e.model.raw.displayStyle.lineweight||0;const i=e.model.raw.displayStyle.units;n=i?n*xn(i):0,n=n<.001?0:n,t={id:e.model.raw.displayStyle.id,color:e.model.raw.displayStyle.diffuse||e.model.raw.displayStyle.color,lineWeight:n}}else e.model.raw.renderMaterial&&(t={id:e.model.raw.renderMaterial.id,color:e.model.raw.renderMaterial.diffuse,lineWeight:0});return t}static colorMaterialFromNode(e){if(!e)return null;let t=null;return e.model.color&&(t={color:e.model.color}),t}static fastCopy(e,t){t.fastCopy(e,t)}static renderMaterialToString(e){return e.color.toString()+"/"+e.opacity.toString()+"/"+e.roughness.toString()+"/"+e.metalness.toString()}static displayStyleToString(e){var t,n,i;return((t=e.color)===null||t===void 0?void 0:t.toString())+"/"+((n=e.lineWeight)===null||n===void 0?void 0:n.toString())+((i=e.opacity)===null||i===void 0?void 0:i.toString())}static minimalMaterialToString(e){return e.color.toString()}static hashCode(e){let t=0;for(let n=0;n<e.length;n++)t=Math.imul(31,t)+e.charCodeAt(n)|0;return t}static isMaterialInstance(e){return e instanceof cn}static isFilterMaterial(e){return"filterType"in e}static isRenderMaterial(e){return"color"in e&&"opacity"in e&&"roughness"in e&&"metalness"in e&&"vertexColors"in e}static isDisplayStyle(e){return"color"in e&&"lineWeight"in e}static getMaterialHash(e,t){var n,i;const r=e.renderData.colorMaterial;let s="";const o=r&&!t&&(e.geometryType===ze.LINE||e.geometryType===ze.POINT||e.geometryType===ze.TEXT),l=e.geometryType===ze.LINE;t||(t=l?e.renderData.displayStyle||e.renderData.renderMaterial:e.renderData.renderMaterial||e.renderData.displayStyle),o?s+=Et.minimalMaterialToString(r):t&&(s=!Et.isRenderMaterial(t)||e.geometryType!==ze.MESH&&e.geometryType!==ze.POINT&&e.geometryType!==ze.TEXT?Et.isDisplayStyle(t)&&e.geometryType!==ze.MESH?Et.displayStyleToString(t):Et.isRenderMaterial(t)?Et.renderMaterialToString(t):"":Et.renderMaterialToString(t),t.stencilOutlines&&(s+="/"+t.stencilOutlines),t.pointSize&&(s+="/"+t.pointSize));let c="";e.renderData.geometry.attributes&&(c=e.renderData.geometry.attributes.COLOR?"vertexColors":"");const u=e.geometryType.toString()+c+s+(e.geometryType===ze.TEXT&&((n=e.renderData.geometry.metaData)===null||n===void 0?void 0:n.screenOriented)!==void 0?((i=e.renderData.geometry.metaData)===null||i===void 0?void 0:i.screenOriented).toString():"")+(e.renderData.geometry.instanced?"instanced":"");return Et.hashCode(u)}static isTransparent(e){return e.transparent===!0&&e.opacity<1}static isOpaque(e){return e.transparent===!1||e.transparent===!0&&e.opacity>=1}static isSpeckleMaterial(e){return"speckleUserData"in e}async createDefaultMeshMaterials(){this.meshGhostMaterial=new Ya({color:16777215,side:An,transparent:!0,opacity:.1}),this.meshGhostMaterial.depthWrite=!1,this.meshGhostMaterial.alphaTest=1,this.meshGradientMaterial=new Ha({side:yt,transparent:!1,opacity:1}),this.meshGradientMaterial.setGradientTexture(await jn.getTexture(ic)),this.meshGradientMaterial.clipShadows=!0,this.meshTransparentGradientMaterial=new Ha({side:yt,transparent:!0,opacity:.5}),this.meshTransparentGradientMaterial.setGradientTexture(await jn.getTexture(ic)),this.meshTransparentGradientMaterial.clipShadows=!0,this.meshColoredMaterial=new Ha({side:yt,transparent:!1,wireframe:!1}),this.meshColoredMaterial.clipShadows=!0,this.meshTransparentColoredMaterial=new Ha({side:yt,transparent:!0,opacity:.5}),this.meshHiddenMaterial=new hi({side:yt,transparent:!1,opacity:1,wireframe:!1}),this.meshHiddenMaterial.visible=!1}async createLineDefaultMaterials(){this.lineGhostMaterial=new Or({color:16777215,linewidth:1,worldUnits:!1,vertexColors:!0,alphaToCoverage:!1,resolution:new te}),this.lineGhostMaterial.color=new Ie(16777215),this.lineGhostMaterial.linewidth=1,this.lineGhostMaterial.worldUnits=!0,this.lineGhostMaterial.vertexColors=!0,this.lineGhostMaterial.pixelThreshold=.5,this.lineGhostMaterial.resolution=new te,this.lineGhostMaterial.toneMapped=!1,this.lineGhostMaterial.opacity=.1,this.lineGhostMaterial.transparent=!0,this.lineColoredMaterial=new Or({color:16777215,linewidth:1,worldUnits:!1,vertexColors:!0,alphaToCoverage:!1,resolution:new te}),this.lineColoredMaterial.color=new Ie(16777215),this.lineColoredMaterial.linewidth=1,this.lineColoredMaterial.worldUnits=!1,this.lineColoredMaterial.vertexColors=!0,this.lineColoredMaterial.pixelThreshold=.5,this.lineColoredMaterial.resolution=new te,this.lineColoredMaterial.toneMapped=!1,this.lineHiddenMaterial=new Or({color:16777215,linewidth:1,worldUnits:!1,vertexColors:!0,alphaToCoverage:!1,resolution:new te}),this.lineHiddenMaterial.color=new Ie(16711680),this.lineHiddenMaterial.linewidth=1,this.lineHiddenMaterial.worldUnits=!1,this.lineHiddenMaterial.vertexColors=!0,this.lineHiddenMaterial.pixelThreshold=.5,this.lineHiddenMaterial.resolution=new te,this.lineHiddenMaterial.visible=!1}async createDefaultPointMaterials(){this.pointGhostMaterial=new fr({color:16777215,vertexColors:!1,size:2,opacity:.01,sizeAttenuation:!1}),this.pointCloudColouredMaterial=new Ag({color:16777215,vertexColors:!1,size:2,sizeAttenuation:!1},["USE_GRADIENT_RAMP"]),this.pointCloudColouredMaterial.toneMapped=!1,this.pointCloudGradientMaterial=new Ag({color:16777215,vertexColors:!1,size:2,sizeAttenuation:!1},["USE_GRADIENT_RAMP"]),this.pointCloudGradientMaterial.setGradientTexture(await jn.getTexture(ic)),this.pointGhostMaterial.toneMapped=!1}async createDefaultTextMaterials(){this.textGhostMaterial=new vr({color:16777215,opacity:.1,side:yt}),this.textGhostMaterial.transparent=this.textGhostMaterial.opacity<1,this.textGhostMaterial.depthWrite=!this.textGhostMaterial.transparent,this.textGhostMaterial.toneMapped=!1,this.textGhostMaterial.color.convertSRGBToLinear(),this.textGhostMaterial=this.textGhostMaterial.getDerivedBatchedMaterial(),this.textColoredMaterial=new Sg({color:16777215,opacity:1,side:yt}),this.textColoredMaterial.transparent=this.textColoredMaterial.opacity<1,this.textColoredMaterial.depthWrite=!this.textColoredMaterial.transparent,this.textColoredMaterial.toneMapped=!1,this.textColoredMaterial.color.convertSRGBToLinear(),this.textColoredMaterial=this.textColoredMaterial.getDerivedBatchedMaterial(),this.textGradientMaterial=new Sg({color:16777215,opacity:1,side:yt}),this.textGradientMaterial.transparent=this.textGradientMaterial.opacity<1,this.textGradientMaterial.depthWrite=!this.textGradientMaterial.transparent,this.textGradientMaterial.toneMapped=!1,this.textGradientMaterial.color.convertSRGBToLinear(),this.textGradientMaterial.setGradientTexture(await jn.getTexture(ic)),this.textGradientMaterial=this.textGradientMaterial.getDerivedBatchedMaterial(),this.textHiddenMaterial=new vr({color:16777215,opacity:1,side:yt}),this.textHiddenMaterial.visible=!1,this.textHiddenMaterial.toneMapped=!1,this.textHiddenMaterial.color.convertSRGBToLinear(),this.textHiddenMaterial=this.textHiddenMaterial.getDerivedBatchedMaterial()}async createDefaultNullMaterials(){this.materialMap[Et.NullRenderMaterialHash]=new hi({color:8355711,emissive:0,roughness:1,metalness:0,side:yt}),this.materialMap[Et.NullRenderMaterialHash].color.convertSRGBToLinear(),this.materialMap[Et.NullRenderMaterialVertexColorsHash]=new hi({color:16777215,emissive:0,roughness:1,metalness:0,side:yt,vertexColors:!0}),this.materialMap[Et.NullRenderMaterialVertexColorsHash].color.convertSRGBToLinear();const e=Et.NullDisplayStyleHash;this.materialMap[e]=new Or({color:8355711,linewidth:1,worldUnits:!1,vertexColors:!0,alphaToCoverage:!1,resolution:new te}),this.materialMap[e].color=new Ie(8355711),this.materialMap[e].color.convertSRGBToLinear(),this.materialMap[e].linewidth=1,this.materialMap[e].worldUnits=!1,this.materialMap[e].vertexColors=!0,this.materialMap[e].pixelThreshold=.5,this.materialMap[e].resolution=new te,this.materialMap[Et.NullTextDisplayStyle]=new vr({color:8355711,opacity:1,side:yt}),this.materialMap[Et.NullTextDisplayStyle].transparent=!1,this.materialMap[Et.NullTextDisplayStyle].depthWrite=!0,this.materialMap[Et.NullTextDisplayStyle].toneMapped=!1,this.materialMap[Et.NullTextDisplayStyle].color.convertSRGBToLinear(),this.materialMap[Et.NullPointMaterialHash]=new fr({color:8355711,vertexColors:!1,size:2,sizeAttenuation:!1}),this.materialMap[Et.NullPointMaterialHash].color.convertSRGBToLinear(),this.materialMap[Et.NullPointCloudVertexColorsMaterialHash]=new fr({color:16777215,vertexColors:!0,size:2,sizeAttenuation:!1}),this.materialMap[Et.NullPointCloudMaterialHash]=new fr({color:16777215,vertexColors:!1,size:2,sizeAttenuation:!1}),this.materialMap[Et.NullRenderMaterialInstancedHash]=new hi({color:8355711,emissive:0,roughness:1,metalness:0,side:yt}),this.materialMap[Et.NullRenderMaterialInstancedHash].color.convertSRGBToLinear(),this.materialMap[Et.NullRenderMaterialInstancedVertexColorHash]=new hi({color:16777215,emissive:0,roughness:1,metalness:0,side:yt,vertexColors:!0}),this.materialMap[Et.NullRenderMaterialInstancedVertexColorHash].color.convertSRGBToLinear()}async createDefaultMaterials(){await this.createDefaultMeshMaterials(),await this.createLineDefaultMaterials(),await this.createDefaultPointMaterials(),await this.createDefaultTextMaterials(),await this.createDefaultNullMaterials(),this.defaultGradientTextureData=await jn.getTextureData(ic)}makeMeshMaterial(e){const t=new hi({color:e.color,emissive:0,roughness:e.roughness,metalness:e.metalness,opacity:e.opacity,side:yt});return t.vertexColors=e.vertexColors,t.transparent=t.opacity<1,t.depthWrite=!t.transparent,t.clipShadows=!0,t.color.convertSRGBToLinear(),t.emissive.convertSRGBToLinear(),t.updateArtificialRoughness(Et.DEFAULT_ARTIFICIAL_ROUGHNESS),t}makeLineMaterial(e){const t=new Or({color:e.color,linewidth:e.lineWeight>0?e.lineWeight:1,worldUnits:e.lineWeight>0,vertexColors:!0,alphaToCoverage:!1,resolution:new te});return t.color=new Ie(e.color),t.color.convertSRGBToLinear(),t.opacity=e.opacity!==void 0?e.opacity:1,t.linewidth=e.lineWeight>0?e.lineWeight:1,t.worldUnits=e.lineWeight>0,t.vertexColors=!0,t.pixelThreshold=.5,t.resolution=new te,t.toneMapped=!1,t}makePointMaterial(e){const t=e.color===-16777216,n=e.vertexColors&&t?16777215:e.color,i=new fr({color:n,...e.opacity!==void 0&&{opacity:e.opacity},...e.vertexColors!==void 0&&{vertexColors:e.vertexColors},size:2,sizeAttenuation:!1});return i.opacity!==void 0&&(i.transparent=i.opacity<1),i.depthWrite=!i.transparent,i.toneMapped=!1,i.color.convertSRGBToLinear(),i}makeTextMaterial(e){if(!e)return this.materialMap[Et.NullTextDisplayStyle];const t=new vr({color:e.color,opacity:1,side:yt});return t.transparent=t.opacity<1,t.depthWrite=!t.transparent,t.toneMapped=!1,t.color.convertSRGBToLinear(),t}getMaterial(e,t,n){let i;switch(n){case ze.MESH:i=this.getMeshMaterial(e,t);break;case ze.LINE:i=this.getLineMaterial(e,t);break;case ze.POINT:i=this.getPointMaterial(e,t);break;case ze.POINT_CLOUD:i=this.getPointCloudMaterial(e,t);break;case ze.TEXT:i=this.getTextMaterial(e,t)}return i.clippingPlanes=[],i}getMeshMaterial(e,t){return this.materialMap[e]||(this.materialMap[e]=this.makeMeshMaterial(t)),this.materialMap[e]}getLineMaterial(e,t){return this.materialMap[e]||(this.materialMap[e]=this.makeLineMaterial(t)),this.materialMap[e]}getPointMaterial(e,t){return this.materialMap[e]||(this.materialMap[e]=this.makePointMaterial(t)),this.materialMap[e]}getPointCloudMaterial(e,t){return this.materialMap[e]||(this.materialMap[e]=this.getPointMaterial(e,t)),this.materialMap[e]}getTextMaterial(e,t){return this.materialMap[e]||(this.materialMap[e]=this.makeTextMaterial(t)),this.materialMap[e].getDerivedBatchedMaterial()}getGhostMaterial(e,t){switch(e.geometryType){case ze.MESH:return this.meshGhostMaterial;case ze.LINE:return this.lineGhostMaterial;case ze.POINT:case ze.POINT_CLOUD:return this.pointGhostMaterial;case ze.TEXT:return this.textGhostMaterial}}getGradientMaterial(e,t){switch(e.geometryType){case ze.MESH:{const i=e.transparent?this.meshTransparentGradientMaterial:this.meshGradientMaterial;return t?.rampTexture&&i.setGradientTexture(t.rampTexture),i}case ze.LINE:return this.lineColoredMaterial;case ze.POINT:{const i=this.pointCloudGradientMaterial;return t?.rampTexture&&i.setGradientTexture(t.rampTexture),i}case ze.POINT_CLOUD:{const i=this.pointCloudGradientMaterial;return t?.rampTexture&&i.setGradientTexture(t.rampTexture),i}case ze.TEXT:const n=this.textGradientMaterial;return t?.rampTexture&&n.setGradientTexture(t.rampTexture),n}}getColoredMaterial(e,t){switch(e.geometryType){case ze.MESH:{const i=e.transparent?this.meshTransparentColoredMaterial:this.meshColoredMaterial;return t?.rampTexture&&i.setGradientTexture(t.rampTexture),i}case ze.LINE:return this.lineColoredMaterial;case ze.POINT:{const i=this.pointCloudColouredMaterial;return t?.rampTexture&&i.setGradientTexture(t.rampTexture),i}case ze.POINT_CLOUD:{const i=this.pointCloudColouredMaterial;return t?.rampTexture&&i.setGradientTexture(t.rampTexture),i}case ze.TEXT:const n=this.textColoredMaterial;return t?.rampTexture&&n.setGradientTexture(t.rampTexture),n}}getHiddenMaterial(e,t){switch(e.geometryType){case ze.MESH:return this.meshHiddenMaterial;case ze.LINE:return this.lineHiddenMaterial;case ze.POINT:case ze.POINT_CLOUD:return this.meshHiddenMaterial;case ze.TEXT:return this.textHiddenMaterial}}getFilterMaterial(e,t){let n=null;switch(t.filterType){case ei.GHOST:n=this.getGhostMaterial(e,t);break;case ei.GRADIENT:n=this.getGradientMaterial(e,t);break;case ei.COLORED:n=this.getColoredMaterial(e,t);break;case ei.HIDDEN:n=this.getHiddenMaterial(e,t)}return n&&(n.clippingPlanes=[]),n}getDataMaterial(e,t){const n=Et.getMaterialHash(e,t);return this.getMaterial(n,t,e.geometryType)}getFilterMaterialOptions(e){switch(e.filterType){case ei.COLORED:return{rampIndex:e.rampIndex!==void 0?e.rampIndex:void 0,rampIndexColor:e.rampIndexColor,rampTexture:e.rampTexture?e.rampTexture:void 0,rampWidth:e.rampTexture?e.rampTexture.image.width:void 0};case ei.GRADIENT:return{rampIndex:e.rampIndex!==void 0?e.rampIndex:void 0,rampIndexColor:e.rampIndexColor!==void 0?e.rampIndexColor:e.rampIndex?new Ie().setRGB(this.defaultGradientTextureData.data[4*Math.floor(e.rampIndex*(this.defaultGradientTextureData.width-1))]/255,this.defaultGradientTextureData.data[4*Math.floor(e.rampIndex*(this.defaultGradientTextureData.width-1))+1]/255,this.defaultGradientTextureData.data[4*Math.floor(e.rampIndex*(this.defaultGradientTextureData.width-1))+2]/255).convertSRGBToLinear():void 0,rampTexture:e.rampTexture?e.rampTexture:this.meshGradientMaterial.userData.gradientRamp.value,rampWidth:e.rampTexture?e.rampTexture.image.width:this.meshGradientMaterial.userData.gradientRamp.value.image.width};default:return null}}purge(){}}Et=Tt,Tt.UNIFORM_VECTORS_USED=33,Tt.DEFAULT_ARTIFICIAL_ROUGHNESS=.6,Tt.NullRenderMaterialHash=Et.hashCode(ze.MESH.toString()),Tt.NullRenderMaterialVertexColorsHash=Et.hashCode(ze.MESH.toString()+"vertexColors"),Tt.NullDisplayStyleHash=Et.hashCode(ze.LINE.toString()),Tt.NullTextDisplayStyle=Et.hashCode(ze.TEXT.toString()),Tt.NullPointMaterialHash=Et.hashCode(ze.POINT.toString()),Tt.NullPointCloudMaterialHash=Et.hashCode(ze.POINT_CLOUD.toString()),Tt.NullPointCloudVertexColorsMaterialHash=Et.hashCode(ze.POINT_CLOUD.toString()+"vertexColors"),Tt.NullRenderMaterialInstancedHash=Et.hashCode(ze.MESH.toString()+"instanced"),Tt.NullRenderMaterialInstancedVertexColorHash=Et.hashCode(ze.MESH.toString()+"vertexColorsinstanced"),(function(a){a.View3D="View3D",a.BlockInstance="BlockInstance",a.Pointcloud="Pointcloud",a.Brep="Brep",a.Mesh="Mesh",a.Point="Point",a.Line="Line",a.Polyline="Polyline",a.Box="Box",a.Polycurve="Polycurve",a.Curve="Curve",a.Circle="Circle",a.Arc="Arc",a.Ellipse="Ellipse",a.RevitInstance="RevitInstance",a.Text="Text",a.Transform="Transform",a.InstanceProxy="InstanceProxy",a.RenderMaterialProxy="RenderMaterialProxy",a.ColorProxy="ColorProxy",a.Region="Region",a.Unknown="Unknown"})(et||(et={}));const Mu=[et.Pointcloud,et.Brep,et.Mesh,et.Point,et.Line,et.Polyline,et.Box,et.Polycurve,et.Curve,et.Circle,et.Arc,et.Ellipse,et.Text,et.Region];class l0{}class eb{get guid(){return this._guid||(this._guid=this._renderData.subtreeId+this._renderData.id),this._guid}get renderData(){return this._renderData}get renderMaterialHash(){return this._materialHash}get hasGeometry(){return this._renderData.geometry&&this._renderData.geometry.attributes}get hasMetadata(){return this._renderData.geometry&&this._renderData.geometry.metaData}get speckleType(){return this._renderData.speckleType}get geometryType(){return this._geometryType}get batchStart(){return this._batchIndexStart}get batchEnd(){return this._batchIndexStart+this._batchIndexCount}get batchCount(){return this._batchIndexCount}get batchId(){return this._batchId}get aabb(){return this._aabb}set aabb(e){this._aabb.copy(e)}get transparent(){return this._renderData.renderMaterial&&this._renderData.renderMaterial.opacity<1||!1}get vertStart(){return this._batchVertexStart}get vertEnd(){return this._batchVertexEnd}get needsSegmentConversion(){return this._renderData.speckleType===et.Curve||this._renderData.speckleType===et.Polyline||this._renderData.speckleType===et.Polycurve||this.renderData.speckleType===et.Arc||this.renderData.speckleType===et.Circle||this.renderData.speckleType===et.Ellipse}get validGeometry(){return this._renderData.geometry.attributes&&this._renderData.geometry.attributes.POSITION&&this._renderData.geometry.attributes.POSITION.length>0&&(this._geometryType!==ze.MESH||this._renderData.geometry.attributes.INDEX&&this._renderData.geometry.attributes.INDEX.length>0)||!1}constructor(e){this._guid=null,this._renderData=e,this._geometryType=this.getGeometryType(),this._materialHash=Tt.getMaterialHash(this),this._batchId="",this._batchIndexCount=0,this._batchIndexStart=-1,this._batchVertexStart=-1,this._batchVertexEnd=-1}setBatchData(e,t,n,i,r){this._batchId=e,this._batchIndexStart=t,this._batchIndexCount=n,i!==void 0&&(this._batchVertexStart=i),r!==void 0&&(this._batchVertexEnd=r)}computeAABB(e){this._aabb||(this._aabb=new He),this._renderData.geometry.attributes&&this._renderData.geometry.attributes.POSITION.length&&(this._aabb.copy(this._renderData.geometry.attributes.POSITION.computeBox3()),e&&this._aabb.applyMatrix4(e))}getGeometryType(){switch(this._renderData.speckleType){case et.Mesh:case et.Brep:return ze.MESH;case et.Point:return ze.POINT;case et.Pointcloud:return ze.POINT_CLOUD;case et.Text:return ze.TEXT;default:return ze.LINE}}disposeGeometry(){for(const e in this._renderData.geometry.attributes)this._renderData.geometry.attributes[e]=new Zt([])}}class tb{get id(){return this.root.model.id}get subtreeId(){return this.root.model.subtreeId}constructor(e,t){this.cancel=!1,this.buildNodeTime=0,this.applyTransformTime=0,this.convertTime=0,this.getNodeTime=0,this.otherTime=0,this.count=0,this.tree=e,this.root=t}buildRenderTree(e,t){return this.tree.walkAsync((n=>{let i=performance.now();const r=this.buildRenderNode(n,e,t);return n.model.renderView=r?new eb(r):null,this.buildNodeTime+=performance.now()-i,i=performance.now(),this.applyTransforms(n),this.applyTransformTime+=performance.now()-i,n.model.instanced||e.disposeNodeGeometryData(n.model),!this.cancel}),this.root)}applyTransforms(e){if(e.model.renderView){const t=this.computeTransform(e);(e.model.renderView.hasGeometry||e.model.renderView.hasMetadata)&&(e.model.renderView.renderData.geometry.bakeTransform&&t.multiply(e.model.renderView.renderData.geometry.bakeTransform),e.model.renderView.renderData.geometry.transform=t,e.model.renderView.computeAABB(e.model.instanced?void 0:t))}}buildRenderNode(e,t,n){let i=null,r=performance.now();const s=t.convertNodeToGeometryData(e.model);if(n?.(this.count++),this.convertTime+=performance.now()-r,s){r=performance.now();const o=this.getRenderMaterialNode(e),l=this.getDisplayStyleNode(e),c=this.getColorMaterialNode(e);this.getNodeTime+=performance.now()-r,r=performance.now(),i={id:e.model.id,subtreeId:e.model.subtreeId,speckleType:t.getSpeckleType(e.model),geometry:s,renderMaterial:Tt.renderMaterialFromNode(o||l,e),displayStyle:Tt.displayStyleFromNode(l||o),colorMaterial:Tt.colorMaterialFromNode(c)},this.otherTime+=performance.now()-r}return i}getRenderMaterialNode(e){if(e.model.raw.renderMaterial)return e;const t=this.tree.getAncestors(e);for(let n=0;n<t.length;n++)if(t[n].model.raw.renderMaterial)return t[n];return null}getDisplayStyleNode(e){if(e.model.raw.displayStyle)return e;const t=this.tree.getAncestors(e);for(let n=0;n<t.length;n++)if(t[n].model.raw.displayStyle)return t[n];return null}getColorMaterialNode(e){if(e.model.color)return e;const t=this.tree.getAncestors(e);for(let n=0;n<t.length;n++)if(t[n].model.color)return t[n];return null}computeTransform(e){if(e.model.renderView.speckleType===et.Transform)return e.model.renderView.renderData.transform;const t=new ae,n=this.tree.getAncestors(e);for(let i=0;i<n.length;i++)if(n[i].model.renderView){const r=n[i].model.renderView.renderData;r.speckleType===et.Transform&&r.geometry.transform&&t.premultiply(r.geometry.transform)}return t}getInstances(){return this.tree.getInstances(this.root.model.subtreeId)}getDuplicates(){return this.tree.getDuplicates(this.root.model.subtreeId)}getRenderableRenderViews(...e){return this.getRenderableNodes(...e).map((t=>t.model.renderView))}getRenderableNodes(...e){return this.root.all((t=>t.model.renderView&&(t.model.renderView.hasGeometry||t.model.renderView.hasMetadata)&&e.includes(t.model.renderView.renderData.speckleType)))}getRenderViewsForNode(e){return this.getRenderViewNodesForNode(e).map((t=>t.model.renderView))}getRenderViewNodesForNode(e){return e.model.atomic&&e.model.renderView?[e]:e.all((t=>t.model.renderView&&(t.model.renderView.hasGeometry||t.model.renderView.hasMetadata)))}getRenderViewsForNodeId(e,t){const n=this.tree.findId(e,t);if(!n)return De.warn(`Id ${e} does not exist`),null;const i=[];return n.forEach((r=>{i.push(...this.getRenderViewsForNode(r))})),i}getAtomicParent(e){return e.model.atomic?e:this.tree.getAncestors(e).find((t=>t.model.atomic))}purge(){}cancelBuild(){this.cancel=!0,this.tree.purge(this.id),this.purge()}}class wn{get nodeCount(){return Object.keys(this.all).length}constructor(e){this.all={},this.instances={},this.duplicates={},this.registerNode(e)}addNode(e){if(e.model.id.includes(wn.COMPOUND_ID_CHAR))this.registerInstance(e);else{if(this.all[e.model.id])return!1;this.registerNode(e),e.model.id.includes(wn.DUPLICATE_ID_CHAR)&&this.registerDuplicate(e)}return!0}removeNode(e){if(e.model.id.includes(wn.COMPOUND_ID_CHAR)){const t=e.model.id.substring(0,e.model.id.indexOf(wn.COMPOUND_ID_CHAR));delete this.instances[t][e.model.id]}else delete this.all[e.model.id];return!0}getNodeById(e){if(e.includes(wn.COMPOUND_ID_CHAR)){const t=e.substring(0,e.indexOf(wn.COMPOUND_ID_CHAR));if(!this.instances[t])return De.warn("Could not find instance with baseID: ",t),null;if(this.instances[t][e])return[this.instances[t][e]]}if(e.includes(wn.DUPLICATE_ID_CHAR)){const t=e.substring(0,e.indexOf(wn.DUPLICATE_ID_CHAR));if(!this.duplicates[t])return De.warn("Could not find duplicate with baseID: ",t),null;if(this.duplicates[t][e])return[this.duplicates[t][e]]}return this.all[e]?this.duplicates[e]?[this.all[e],...Object.values(this.duplicates[e])]:[this.all[e]]:this.instances[e]?Object.values(this.instances[e]):null}getSubtreeById(e){return this.all[e]}hasId(e){return this.hasNodeId(e)||this.hasInstanceId(e)}hasNodeId(e){return this.all[e]!==void 0}hasInstanceId(e){if(e.includes(wn.COMPOUND_ID_CHAR)){const t=e.substring(0,e.indexOf(wn.COMPOUND_ID_CHAR));return!!this.instances[t]}return!1}registerInstance(e){const t=e.model.id.substring(0,e.model.id.indexOf(wn.COMPOUND_ID_CHAR));this.instances[t]||(this.instances[t]={}),this.instances[t][e.model.id]=e}registerDuplicate(e){const t=e.model.id.substring(0,e.model.id.indexOf(wn.DUPLICATE_ID_CHAR));this.duplicates[t]||(this.duplicates[t]={}),this.duplicates[t][e.model.id]=e}registerNode(e){this.all[e.model.id]=e}purge(){this.all={},this.instances={}}}wn.COMPOUND_ID_CHAR="~",wn.DUPLICATE_ID_CHAR="#";class xl{constructor(){this.renderTreeInstances={},this.nodeMaps={},this.supressWarnings=!0,this.subtreeId=0,this.tree=new Lx,this._root=this.parse({id:xl.ROOT_ID,raw:{},atomic:!0,children:[],renderView:null})}getRenderTree(e){if(!this._root)return console.error("WorldTree not initialised"),null;const t=e?this.findSubtree(e):this.root;if(!t)return null;const n=t.model.id;return this.renderTreeInstances[n]||(this.renderTreeInstances[n]=new tb(this,t)),this.renderTreeInstances[n]}get root(){return this._root}get nextSubtreeId(){return++this.subtreeId}get nodeCount(){let e=0;for(const t in this.nodeMaps)e+=this.nodeMaps[t].nodeCount;return e}isRoot(e){return e===this._root}isSubtreeRoot(e){return e.parent===this._root}parse(e){return this.tree.parse(e)}addSubtree(e){if(this.nodeMaps[e.id])return void De.error(`Subtree with id ${e.id} already exists!`);const t=this.nextSubtreeId;e.model.subtreeId=t,this.nodeMaps[t]=new wn(e),this._root.addChild(e)}addNode(e,t){var n;t!==null&&t.model.subtreeId!==void 0?(e.model.subtreeId=t.model.subtreeId,!((n=this.nodeMaps[t.model.subtreeId])===null||n===void 0)&&n.addNode(e)&&t.addChild(e)):De.error("Invalid parent node!")}removeNode(e,t){var n;const i=e.children;if((n=this.nodeMaps[e.model.subtreeId])===null||n===void 0||n.removeNode(e),e.drop(),t&&i)for(let r=0;r<i.length;r++)this.removeNode(i[r],t)}hasNodeId(e,t=1){return this.nodeMaps[t]&&this.nodeMaps[t].hasNodeId(e)}hasInstanceId(e,t=1){return this.nodeMaps[t]&&this.nodeMaps[t].hasInstanceId(e)}hasId(e,t=1){return this.nodeMaps[t]&&this.nodeMaps[t].hasId(e)}findAll(e,t){return t||this.supressWarnings||De.warn("Root will be used for searching. You might not want that"),(t||this.root).all(e)}findId(e,t){if(!e)return null;let n=null;if(t)n=this.nodeMaps[t].getNodeById(e);else for(const i in this.nodeMaps){const r=this.nodeMaps[i].getNodeById(e);r&&(n=[...r])}return n}findSubtree(e){let t=null;for(const n in this.nodeMaps)if(t=this.nodeMaps[n].getSubtreeById(e))break;return t}getAncestors(e){return e.getPath().reverse().slice(1)}getInstances(e){return this.nodeMaps[e].instances}getDuplicates(e){return this.nodeMaps[e].duplicates}walk(e,t){t||this.supressWarnings||De.warn("Root will be used for searching. You might not want that"),this._root.walk(e,t)}async walkAsync(e,t){t||this.supressWarnings||De.warn("Root will be used for searching. You might not want that");const n=new jM;let i=!0;return(async function r(s,o){let l,c;for(n.tick(100),n.needsWait&&await n.wait(16),i&&(i=s(o)),l=0,c=o.children.length;l<c&&await r(s,o.children[l]);l++);return i})(e,t||this._root)}purge(e){if(e){delete this.renderTreeInstances[e];const t=this.findId(e);t&&(this.nodeMaps[t[0].model.subtreeId].purge(),delete this.nodeMaps[t[0].model.subtreeId],this.removeNode(t[0],!1))}else Object.keys(this.renderTreeInstances).forEach((t=>delete this.renderTreeInstances[t])),Object.keys(this.nodeMaps).forEach((t=>{this.nodeMaps[t].purge,delete this.nodeMaps[t]})),this._root.drop(),this._root.children.length=0,this.tree=new Lx,this._root=this.tree.parse({id:xl.ROOT_ID,raw:{},atomic:!0,children:[]})}}xl.ROOT_ID="ROOT";const Am=new ae,Sm=new He,Mm=new He,EN=new A;function zw(a,e=.001){if(a.isEmpty())return e;Am.identity(),Am.makeScale(1+e,1+e,1+e);const t=a.getSize(EN).multiplyScalar(.5);Sm.min.set(0,0,0),Sm.max.set(0,0,0),Mm.min.set(0,0,0),Mm.max.set(0,0,0);const n=Sm.expandByVector(t);return Mm.copy(n).applyMatrix4(Am).max.distanceTo(n.max)}const TN=new A,on=new Float32Array(16);var sf;(function(a){a.POSITION="POSITION",a.COLOR="COLOR",a.NORMAL="NORMAL",a.UV="UV",a.TANGENT="TANGENT",a.INDEX="INDEX"})(sf||(sf={}));class ft{static updateRTEGeometry(e,t){if(e.type==="BufferGeometry"||e.type==="PlaneGeometry"||e.type==="CircleGeometry"){const n=new Float32Array(t.length),i=e.attributes.position.array;ft.DoubleToHighLowBuffer(t,n,i),e.setAttribute("position_low",new je(n,3))}else if(e.type==="LineGeometry"||e.type==="LineSegmentsGeometry"){const n=new Float32Array(t.length),i=e.attributes.instanceStart.array;ft.DoubleToHighLowBuffer(t,n,i);const r=new no(n,6,1);e.setAttribute("instanceStartLow",new Wn(r,3,0)),e.setAttribute("instanceEndLow",new Wn(r,3,3))}}static mergeGeometryAttribute(e,t){let n=0;for(let i=0;i<e.length;i++){const r=e[i];if(!r||!t)throw new Error("Cannot merge geometries. Indices or positions are undefined");r.copyToBuffer(t,n),n+=r.length}return t}static mergeIndexAttribute(e,t){let n=0;const i=[];for(let r=0;r<e.length;++r){const s=e[r],o=t[r];if(!s||!o)throw new Error("Cannot merge geometries. Indices or positions are undefined");for(let l=0;l<s.length;++l)i.push(s.get(l)+n/3);n+=o.length}return i}static mergeGeometryData(e){const t=e[0].attributes,n={attributes:{},bakeTransform:null,transform:null};for(let i=0;i<e.length;i++)e[i].bakeTransform!==null&&ft.transformGeometryData(e[i],e[i].bakeTransform);if(t&&t.INDEX){const i=e.map((s=>{if(s.attributes)return s.attributes.INDEX})),r=e.map((s=>{if(s.attributes)return s.attributes.POSITION}));n.attributes&&(n.attributes.INDEX=new Zt([{data:ft.mergeIndexAttribute(i,r),id:It.generateUUID(),references:1}]))}for(const i in t)if(i!==sf.INDEX){const r=e.map((s=>{if(s.attributes)return s.attributes[i]}));if(n.attributes){const s=ft.mergeGeometryAttribute(r,i===sf.POSITION?new Float64Array(r.reduce(((o,l)=>l?o+l.length:0),0)):new Float32Array(r.reduce(((o,l)=>l?o+l.length:0),0)));n.attributes[i]=new Zt([{data:s,id:It.generateUUID(),references:1}])}}return e.forEach((i=>{for(const r in i.attributes)delete i.attributes[r]})),n}static transformGeometryData(e,t){if(!e.attributes||!e.attributes.POSITION||!t||ft.isMatrix4Identity(t))return;const n=t.elements;e.attributes.POSITION.chunkArray.forEach((i=>{for(let r=0;r<i.data.length;r+=3){const s=i.data[r],o=i.data[r+1],l=i.data[r+2],c=1/(n[3]*s+n[7]*o+n[11]*l+n[15]);i.data[r]=(n[0]*s+n[4]*o+n[8]*l+n[12])*c,i.data[r+1]=(n[1]*s+n[5]*o+n[9]*l+n[13])*c,i.data[r+2]=(n[2]*s+n[6]*o+n[10]*l+n[14])*c}}))}static transformArray(e,t,n,i){if(!t||ft.isMatrix4Identity(t))return;const r=t.elements;n=n||0,i=i||e.length;for(let s=n;s<n+i;s+=3){const o=e[s],l=e[s+1],c=e[s+2],u=1/(r[3]*o+r[7]*l+r[11]*c+r[15]);e[s]=(r[0]*o+r[4]*l+r[8]*c+r[12])*u,e[s+1]=(r[1]*o+r[5]*l+r[9]*c+r[13])*u,e[s+2]=(r[2]*o+r[6]*l+r[10]*c+r[14])*u}}static isMatrix4Identity(e){const t=e.elements;return t[1]===0&&t[2]===0&&t[3]===0&&t[4]===0&&t[6]===0&&t[7]===0&&t[8]===0&&t[9]===0&&t[11]===0&&t[12]===0&&t[13]===0&&t[14]===0&&t[0]===1&&t[5]===1&&t[10]===1&&t[15]===1}static unpackColors(e){const t=new Array(3*e.length);for(let n=0;n<e.length;n++){const i=e[n],r=i>>16&255,s=i>>8&255,o=255&i;t[3*n]=r/255,t[3*n+1]=s/255,t[3*n+2]=o/255}return t}static DoubleToHighLowVector(e,t,n){let i=e.x;if(i>=0){on[0]=i;const r=on[0];n.x=r,t.x=i-r}else{on[0]=-i;const r=on[0];n.x=-r,t.x=i+r}if(i=e.y,i>=0){on[0]=i;const r=on[0];n.y=r,t.y=i-r}else{on[0]=-i;const r=on[0];n.y=-r,t.y=i+r}if(i=e.z,i>=0){on[0]=i;const r=on[0];n.z=r,t.z=i-r}else{on[0]=-i;const r=on[0];n.z=-r,t.z=i+r}}static DoubleToHighLowBuffer(e,t,n){for(let i=0;i<e.length;i++){const r=e[i];if(r>=0){on[0]=r;const s=on[0];n[i]=s,t[i]=r-s}else{on[0]=-r;const s=on[0];n[i]=-s,t[i]=r+s}}}static needsRTE(e){const t=zw(e,.01),n=zw(e,.009),i=new te(1920,1080),r=(function(l,c,u,h){const d=l.x/l.y,f=u*Math.tan(.5*Mz*c),p=2*f,m=d*p,g=-.5*m;return new ae().makePerspective(g,g+m,f,f-p,u,h)})(i,50,n,10*n),s=new te(-1,-1),o=[e.min,e.max,e.getCenter(new A)];for(let l=0;l<o.length;l++){const c=ft.getFP32ProjectionDelta(o[l],r,i,t);s.x=Math.max(s.x,c.x),s.y=Math.max(s.y,c.y)}return s.x>=.5||s.y>=.5}static getFP32ProjectionDelta(e,t,n,i=1){on[0]=e.x,on[1]=e.y,on[2]=e.z;const r=TN.set(on[0],on[1],on[2]),s=new A().copy(e).add(new A(Math.random()*i,Math.random()*i,-i)),o=new ae().lookAt(s,e,new A(0,1,0));o.setPosition(s),o.invert(),o.premultiply(t);const l=new ae().copy(o);l.toArray(on),l.fromArray(on);const c=new lt(r.x,r.y,r.z,1),u=new lt(r.x,r.y,r.z,1);return c.applyMatrix4(l),c.multiplyScalar(.5/c.w),c.addScalar(.5),c.multiply(new lt(n.x,n.y,0,0)),u.applyMatrix4(o),u.multiplyScalar(.5/u.w),u.addScalar(.5),u.multiply(new lt(n.x,n.y,0,0)),new te(Math.abs(u.x-c.x),Math.abs(u.y-c.y))}static computeVertexNormalsBuffer(e,t,n){const i=new A,r=new A,s=new A,o=new A,l=new A,c=new A,u=new A,h=new A;for(let d=0,f=n.length;d<f;d+=3){const p=n[d+0],m=n[d+1],g=n[d+2];i.fromArray(t,3*p),r.fromArray(t,3*m),s.fromArray(t,3*g),u.subVectors(s,r),h.subVectors(i,r),u.cross(h),o.fromArray(e,3*p),l.fromArray(e,3*m),c.fromArray(e,3*g),o.add(u),l.add(u),c.add(u),e[3*p]=o.x,e[3*p+1]=o.y,e[3*p+2]=o.z,e[3*m]=l.x,e[3*m+1]=l.y,e[3*m+2]=l.z,e[3*g]=c.x,e[3*g+1]=c.y,e[3*g+2]=c.z}}static computeVertexNormalsBufferVirtual(e,t,n,i=!1){const r=new A,s=new A,o=new A,l=new A,c=new A,u=new A,h=new A,d=new A;for(let f=0,p=n.length;f<p;f+=3){const m=n.get(f+0),g=n.get(f+1),v=n.get(f+2);r.set(t.get(3*m),t.get(3*m+1),t.get(3*m+2)),s.set(t.get(3*g),t.get(3*g+1),t.get(3*g+2)),o.set(t.get(3*v),t.get(3*v+1),t.get(3*v+2)),h.subVectors(o,s),d.subVectors(r,s),h.cross(d),l.fromArray(e,3*m),c.fromArray(e,3*g),u.fromArray(e,3*v),l.add(h),c.add(h),u.add(h),i&&(l.normalize(),c.normalize(),u.normalize(),l.negate(),c.negate(),u.negate()),e[3*m]=l.x,e[3*m+1]=l.y,e[3*m+2]=l.z,e[3*g]=c.x,e[3*g+1]=c.y,e[3*g+2]=c.z,e[3*v]=u.x,e[3*v+1]=u.y,e[3*v+2]=u.z}}static flipNormalsBuffer(e){const t=new A;for(let n=0;n<e.length;n+=3)t.set(e[n],e[n+1],e[n+2]),t.normalize(),t.negate(),e[n]=t.x,e[n+1]=t.y,e[n+2]=t.z}static computeVertexNormals(e,t){const n=e.index,i=e.getAttribute("position");if(i!==void 0){let r=e.getAttribute("normal");if(r===void 0)r=new wt(new Float32Array(3*i.count),3),e.setAttribute("normal",r);else for(let p=0,m=r.count;p<m;p++)r.setXYZ(p,0,0,0);const s=new A,o=new A,l=new A,c=new A,u=new A,h=new A,d=new A,f=new A;if(n)for(let p=0,m=n.count;p<m;p+=3){const g=n.getX(p+0),v=n.getX(p+1),y=n.getX(p+2);s.fromArray(t,3*g),o.fromArray(t,3*v),l.fromArray(t,3*y),d.subVectors(l,o),f.subVectors(s,o),d.cross(f),c.fromBufferAttribute(r,g),u.fromBufferAttribute(r,v),h.fromBufferAttribute(r,y),c.add(d),u.add(d),h.add(d),r.setXYZ(g,c.x,c.y,c.z),r.setXYZ(v,u.x,u.y,u.z),r.setXYZ(y,h.x,h.y,h.z)}else for(let p=0,m=i.count;p<m;p+=3)s.fromArray(t,3*p),o.fromArray(t,3*p+1),l.fromArray(t,3*p+2),d.subVectors(l,o),f.subVectors(s,o),d.cross(f),r.setXYZ(p+0,d.x,d.y,d.z),r.setXYZ(p+1,d.x,d.y,d.z),r.setXYZ(p+2,d.x,d.y,d.z);e.normalizeNormals(),r.needsUpdate=!0}}static triangulatePolygon(e){const t=new Array(2*e.length);return e.forEach(((n,i)=>n.toArray(t,2*i))),Ez(t)}}const Nw=new lt;class Mg{get bounds(){return this.geometry.boundingBox||this.geometry.computeBoundingBox(),this.geometry.boundingBox?this.geometry.boundingBox:new He}get drawCalls(){return 1}get minDrawCalls(){return 1}get triCount(){return 0}get vertCount(){return this.geometry.attributes.position.count*this.geometry.instanceCount}constructor(e,t,n){this.visibilityRanges={},this.id=e,this.subtreeId=t,this.renderViews=n}get groups(){return[]}get pointCount(){return 0}get lineCount(){return(this.geometry.index?this.geometry.index.count:0)/3*this.geometry._maxInstanceCount}get renderObject(){return this.mesh}get geometryType(){return ze.LINE}get materials(){return this.mesh.material}getCount(){return this.geometry.attributes.instanceStart.array.length/6}setBatchMaterial(e){this.batchMaterial=e,this.batchTransparent=e.transparent,this.batchOpacity=e.opacity}onUpdate(e){}onRender(e){e.getDrawingBufferSize(this.batchMaterial.resolution)}setVisibleRange(e){if(e.length===1&&o0(e[0]))return void(this.mesh.visible=!1);if(e.length===1&&(t=e[0],n=this.getCount(),t.offset===en.offset&&(t.count===en.count||!n||t.count===n)))return void(this.mesh.visible=!0);var t,n;this.mesh.visible=!0;const i=this.colorBuffer.array;for(let r=0;r<i.length;r+=4)i[r+3]=0;for(let r=0;r<e.length;r++){const s=e[r].offset*this.colorBuffer.stride,o=e[r].offset*this.colorBuffer.stride+e[r].count*this.colorBuffer.stride;for(let l=s;l<o;l+=4)i[l+3]=1}this.colorBuffer.updateRange={offset:0,count:i.length},this.colorBuffer.needsUpdate=!0,this.geometry.attributes.instanceColorStart.needsUpdate=!0,this.geometry.attributes.instanceColorEnd.needsUpdate=!0}getVisibleRange(){return this.mesh.visible?en:Fn}getOpaque(){return Tt.isOpaque(this.batchMaterial)?en:Fn}getDepth(){return this.getOpaque()}getTransparent(){return Tt.isTransparent(this.batchMaterial)?en:Fn}getStencil(){return this.batchMaterial.stencilWrite===!0?en:Fn}setBatchBuffers(e){var t;const n=this.colorBuffer.array;this.batchMaterial.transparent=this.batchTransparent,this.batchMaterial.opacity=this.batchOpacity;for(let s=0;s<e.length;s++){const o=e[s].material,l=e[s].materialOptions,c=l&&l.rampIndexColor?l.rampIndexColor:o.color,u=o.visible?o.opacity:0;(t=this.batchMaterial).transparent||(t.transparent=o.opacity<1),this.batchMaterial.opacity=Math.min(this.batchMaterial.opacity,o.opacity);const h=e[s].offset*this.colorBuffer.stride,d=e[s].offset*this.colorBuffer.stride+e[s].count*this.colorBuffer.stride;Nw.set(c.r,c.g,c.b,u),this.updateColorBuffer(h,e[s].count===1/0?this.colorBuffer.array.length:d,Nw),this.visibilityRanges[e[s].offset]=o.visible}this.colorBuffer.updateRange={offset:0,count:n.length},this.colorBuffer.needsUpdate=!0,this.geometry.attributes.instanceColorStart.needsUpdate=!0,this.geometry.attributes.instanceColorEnd.needsUpdate=!0;const i=Object.values(this.visibilityRanges);let r=!1;for(let s=0;s<i.length;s++)r||(r=i[s]);r?this.setVisibleRange([en]):this.setVisibleRange([Fn])}setDrawRanges(e){this.setBatchBuffers(e)}resetDrawRanges(){this.setDrawRanges([{offset:0,count:this.getCount(),material:this.batchMaterial}]),this.mesh.material=this.batchMaterial,this.mesh.visible=!0,this.batchMaterial.transparent=this.batchTransparent,this.batchMaterial.opacity=this.batchOpacity,this.visibilityRanges={0:this.batchMaterial.visible}}buildBatch(){let e=0;const t=new He,n=new He;this.renderViews.forEach((s=>{if(!s.renderData.geometry.attributes)throw new Error(`Cannot build batch ${this.id}. Invalid geometry`);e+=s.needsSegmentConversion?2*(s.renderData.geometry.attributes.POSITION.length-3):s.renderData.geometry.attributes.POSITION.length,n.union(s.aabb)}));const i=ft.needsRTE(n)?new Float64Array(e):new Float32Array(e);let r=0;for(let s=0;s<this.renderViews.length;s++){const o=this.renderViews[s].renderData.geometry;if(!o.attributes)throw new Error(`Cannot build batch ${this.id}. Invalid geometry`);let l;if(this.renderViews[s].needsSegmentConversion){const u=o.attributes.POSITION.length-3;l=new Array(2*u);for(let h=0;h<u;h+=3)l[2*h]=o.attributes.POSITION.get(h),l[2*h+1]=o.attributes.POSITION.get(h+1),l[2*h+2]=o.attributes.POSITION.get(h+2),l[2*h+3]=o.attributes.POSITION.get(h+3),l[2*h+4]=o.attributes.POSITION.get(h+4),l[2*h+5]=o.attributes.POSITION.get(h+5);i.set(l,r)}else l=o.attributes.POSITION,o.attributes.POSITION.copyToBuffer(i,r);const c=i.subarray(r,r+l.length);ft.transformArray(c,o.transform,0,l.length),t.setFromArray(c),this.renderViews[s].aabb=t,this.renderViews[s].setBatchData(this.id,r/6,l.length/6),r+=l.length}return this.geometry=this.makeLineGeometry(i),ft.needsRTE(n)&&(ft.updateRTEGeometry(this.geometry,i),this.batchMaterial.defines.USE_RTE=" "),this.mesh=new ao(this.geometry,this.batchMaterial),this.mesh.computeLineDistances(),this.mesh.scale.set(1,1,1),this.mesh.uuid=this.id,this.mesh.layers.set(re.STREAM_CONTENT_LINE),this.visibilityRanges={0:this.batchMaterial.visible},Promise.resolve()}getRenderView(e){for(let t=0;t<this.renderViews.length;t++)if(e>=this.renderViews[t].batchStart&&e<this.renderViews[t].batchEnd&&this.colorBuffer.array[e*this.colorBuffer.stride+3]!==0)return this.renderViews[t];return null}getMaterialAtIndex(e){return this.batchMaterial}getMaterial(e){const t=e.batchStart*this.colorBuffer.stride,n=this.colorBuffer.array,i=this.batchMaterial.clone();return i.color.setRGB(n[t],n[t+1],n[t+2]),i.opacity=n[t+3],i}makeLineGeometry(e){const t=new la;e instanceof Float64Array?t.setPositions(new Float32Array(e)):t.setPositions(e);const n=new Float32Array(e.length+e.length/3);return this.colorBuffer=new no(n,8,1),this.colorBuffer.setUsage(Xn),this.updateColorBuffer(0,n.length,new lt(this.batchMaterial.color.r,this.batchMaterial.color.g,this.batchMaterial.color.b,1)),t.setAttribute("instanceColorStart",new Wn(this.colorBuffer,4,0)),t.setAttribute("instanceColorEnd",new Wn(this.colorBuffer,4,4)),t.computeBoundingBox(),t}updateColorBuffer(e,t,n){const i=this.colorBuffer.array;for(let r=e;r<t;r+=4)i[r]=n.x,i[r+1]=n.y,i[r+2]=n.z,i[r+3]=n.w}purge(){this.renderViews.length=0,this.geometry.dispose(),this.batchMaterial.dispose(),this.colorBuffer.length=0}}const Zf={strategy:t0,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!1,[Symbol("skip tree generation")]:!1};class zi{get geometry(){return this._bvh.geometry}get bvh(){return this._bvh}static buildBVH(e,t,n=Zf,i){if(!e||!t)throw new Error("Cannot build BVH with undefined indices or position!");let r=t;if(i){r=new Float32Array(t.length);const l=new A;for(let c=0;c<t.length;c+=3)l.set(t[c],t[c+1],t[c+2]),l.applyMatrix4(i),r[c]=l.x,r[c+1]=l.y,r[c+2]=l.z}const s=new nt;let o=null;return t.length>=65535||e.length>=65535?(o=new Uint32Array(e.length),o.set(e,0),s.setIndex(new ys(o,1))):(o=new Uint16Array(e.length),o.set(e,0),s.setIndex(new _i(o,1))),s.setAttribute("position",new je(r,3)),s.computeBoundingBox(),new rl(s,n)}constructor(e){this._bvh=e}raycast(e,t=An){const n=this._bvh.raycast(this.transformInput(e),t);return n.forEach((i=>{i.point=this.transformOutput(i.point)})),n}raycastFirst(e,t=An){const n=this._bvh.raycastFirst(this.transformInput(e),t);return n&&(n.point=this.transformOutput(n.point)),n}shapecast(e){const t=new He,n=new Qr,i=Object.create(null);return e.intersectsBounds&&(i.intersectsBounds=(r,s,o,l,c)=>(t.copy(r),this.transformOutput(t),e.intersectsBounds(t,s,o,l,c))),e.intersectsTriangle&&(i.intersectsTriangle=(r,s,o,l)=>(n.copy(r),this.transformOutput(n.a),this.transformOutput(n.b),this.transformOutput(n.c),e.intersectsTriangle(n,s,o,l))),i.intersectsRange=e.intersectsRange,i.traverseBoundsOrder=e.traverseBoundsOrder,this._bvh.shapecast(i)}transformInput(e){return zi.MatBuff.copy(this.inputOriginTransform).multiply(this.inputTransform),e.applyMatrix4(zi.MatBuff)}transformOutput(e){return zi.MatBuff.copy(this.outputOriginTransfom).premultiply(this.outputTransform),e.applyMatrix4(zi.MatBuff)}getBoundingBox(e){const t=e||new He;return this._bvh.getBoundingBox(t),this.transformOutput(t)}getVertexAtIndex(e){const t=this._bvh.geometry.attributes.position.array;return this.transformOutput(new A(t[3*e],t[3*e+1],t[3*e+2]))}}zi.MatBuff=new ae;class _n{constructor(e){this.debugBVH=!1,this.batchObjects=[],this.bounds=new He(new A(0,0,0),new A(0,0,0)),this.batchObjects=e,this.buildBVH(),this.getBoundingBox(this.bounds)}buildBVH(){const e=new Uint16Array(_n.cubeIndices.length*this.batchObjects.length),t=new Float32Array(3*_n.CUBE_VERTS*this.batchObjects.length);let n=0,i=0;for(let r=0;r<this.batchObjects.length;r++){const s=this.batchObjects[r].accelerationStructure.getBoundingBox(new He);this.updateVertArray(s,n,t),e.set(_n.cubeIndices.map((o=>o+n/3)),i),this.batchObjects[r].tasVertIndexStart=n/3,this.batchObjects[r].tasVertIndexEnd=n/3+_n.CUBE_VERTS,n+=3*_n.CUBE_VERTS,i+=_n.cubeIndices.length}if(this.accelerationStructure=new zi(zi.buildBVH(e,t)),this.accelerationStructure.inputTransform=new ae,this.accelerationStructure.outputTransform=new ae,this.accelerationStructure.inputOriginTransform=new ae,this.accelerationStructure.outputOriginTransfom=new ae,this.debugBVH){const r=new Ve(this.accelerationStructure.geometry);r.layers.set(re.OVERLAY),r.geometry.boundsTree=this.accelerationStructure.bvh,this.bvhHelper=new i0(r),this.bvhHelper.layers.set(re.OVERLAY),this.bvhHelper.children[0].layers.set(re.OVERLAY),this.bvhHelper.update()}}updateVertArray(e,t,n){n[t]=e.min.x,n[t+1]=e.min.y,n[t+2]=e.max.z,n[t+3]=e.max.x,n[t+4]=e.min.y,n[t+5]=e.max.z,n[t+6]=e.max.x,n[t+7]=e.max.y,n[t+8]=e.max.z,n[t+9]=e.min.x,n[t+10]=e.max.y,n[t+11]=e.max.z,n[t+12]=e.min.x,n[t+13]=e.min.y,n[t+14]=e.min.z,n[t+15]=e.max.x,n[t+16]=e.min.y,n[t+17]=e.min.z,n[t+18]=e.max.x,n[t+19]=e.max.y,n[t+20]=e.min.z,n[t+21]=e.min.x,n[t+22]=e.max.y,n[t+23]=e.min.z}refit(){var e;const t=this.accelerationStructure.geometry.attributes.position.array;for(let n=0;n<this.batchObjects.length;n++){const i=this.batchObjects[n].tasVertIndexStart,r=this.batchObjects[n].aabb;this.updateVertArray(r,3*i,t)}this.accelerationStructure.bvh.refit(),(e=this.bvhHelper)===null||e===void 0||e.update()}raycast(e,t=!1,n=An){const i=[],r=new On;r.copy(e);const s=this.accelerationStructure.raycast(r,n);if(!s.length)return i;const o=this.accelerationStructure.geometry.index;return s.forEach((l=>{const c=o.array[3*l.faceIndex],u=Math.trunc(c/_n.CUBE_VERTS);l.batchObject=this.batchObjects[u],!t&&(r.copy(e),this.batchObjects[u].accelerationStructure.raycast(r,n).forEach((h=>{const d=h;d.batchObject=this.batchObjects[u],i.push(d)})))})),t?s:i}raycastFirst(e,t=!1,n=An){const i=new On;i.copy(e);let r=null,s=null;return s=t?[this.accelerationStructure.raycastFirst(i,n)]:this.accelerationStructure.raycast(i,n),s&&s.length!==0?(s.some((o=>{const l=this.accelerationStructure.geometry.index.array[3*o.faceIndex],c=Math.trunc(l/_n.CUBE_VERTS);return o.batchObject=this.batchObjects[c],!t&&(i.copy(e),r=this.batchObjects[c].accelerationStructure.raycastFirst(i,n),r)?(r.batchObject=this.batchObjects[c],!0):!1})),t?s[0]:r):null}shapecast(e){const t=r=>{const s=Object.create(null);return e.intersectsBounds&&(s.intersectsBounds=e.intersectsBounds),e.intersectsTriangle&&(s.intersectsTriangle=(o,l,c,u)=>e.intersectsTriangle(o,l,c,u,r)),s.intersectsRange=e.intersectsRange,s.traverseBoundsOrder=e.traverseBoundsOrder,s};let n=!1;const i={};return this.accelerationStructure.shapecast({intersectsBounds:(r,s,o,l,c)=>!!e.intersectsTAS&&e.intersectsTAS(r,s,o,l,c),intersectsRange:(r,s)=>{const o=new Set;for(let l=0;l<s;l++){const c=this.accelerationStructure.geometry.index.array[3*r+3*l],u=Math.trunc(c/_n.CUBE_VERTS),h=this.batchObjects[u];if(e.intersectTASRange){if(i[h.renderView.renderData.id]!==void 0)continue;const d=e.intersectTASRange(h);i[h.renderView.renderData.id]=d,d&&o.add(h)}else o.add(h)}if(!o.size)return!1;for(const l of o)n||(n=l.accelerationStructure.shapecast(t(l)));return!1}}),n}closestPointToPoint(e){return this.accelerationStructure.bvh.closestPointToPoint(e)}closestPointToPointHalfplane(e,t,n,i={point:new A,distance:0,faceIndex:0},r=0,s=1/0){const o=new A,l=new A,c=new A,u=r*r,h=s*s;let d=1/0,f=-1;if(this.accelerationStructure.bvh.shapecast({boundsTraverseOrder:m=>(o.copy(e).clamp(m.min,m.max),o.distanceToSquared(e)),intersectsBounds:(m,g,v)=>v<d&&v<h,intersectsRange:m=>{const g=this.accelerationStructure.geometry.index.array[3*m],v=Math.trunc(g/_n.CUBE_VERTS);return this.batchObjects[v].aabb.containsPoint(e)&&n!==void 0&&(d=n*n),!1},intersectsTriangle:(m,g)=>{m.closestPointToPoint(e,o);const v=e.distanceToSquared(o),y=c.subVectors(o,e);return t.dot(y)>=0&&v<d&&(l.copy(o),d=v,f=g),v<u}}),d===1/0)return null;const p=Math.sqrt(d);return i.point?i.point.copy(l):i.point=l.clone(),i.distance=p,i.faceIndex=f,i}getBoundingBox(e){return this.accelerationStructure.getBoundingBox(e),e}}_n.cubeIndices=[0,1,2,2,3,0,1,5,6,6,2,1,7,6,5,5,4,7,4,0,3,3,7,4,4,5,1,1,0,4,3,2,6,6,7,3],_n.CUBE_VERTS=8;const bm=new On,kw=new ae,Uw=new A,CN=new A,Fw=new A,Em=new ae,Hw=new ae,Gw=new ae;class nb extends e0{constructor(){super(...arguments),this._textObjects={},this._dirty=!1,this.groups=[],this.materials=[],this.materialCache={},this.materialCacheLUT={},this.DEBUG_BILLBOARDS=!1,this.debugMeshes=[]}get TAS(){return this.tas}get batchObjects(){return this._batchObjects}get batchMaterial(){return this._batchMaterial}set dirty(e){this._dirty=e}get isBillboarded(){return this._batchMaterial&&this._batchMaterial.defines&&this._batchMaterial.defines.BILLBOARD}setBatchMaterial(e){e instanceof vr?(this._batchMaterial=this.getCachedMaterial(e),this.material=this._batchMaterial,this.materials.push(this._batchMaterial)):De.error(`SpeckleBatchedText requires a SpeckleTextMaterial. Found ${e.constructor.name}`)}setBatchObjects(e,t){this._batchObjects=e;for(let n=0;n<e.length;n++){const i=e[n].renderView.renderData.id;this._textObjects[i]=t[n]}}lookupMaterial(e){return this.materialCache[e.id]||this.materialCache[this.materialCacheLUT[e.id]]}getCachedMaterial(e,t=!1){let n=this.lookupMaterial(e);if(n)(t||e.needsCopy||n.needsCopy)&&Tt.fastCopy(e,n);else{const i=new vr({}).copy(e).getDerivedBatchedMaterial();this.materialCache[e.id]=i,this.materialCacheLUT[i.id]=e.id,n=i}return n}buildTAS(){this.tas=new _n(this.batchObjects),this.tas.refit(),this.geometry.boundingBox=this.TAS.getBoundingBox(new He),this.geometry.boundingSphere=this.geometry.boundingBox.getBoundingSphere(new rn)}updateTransformsUniform(){let e=!1;for(let t=0;t<this._batchObjects.length;t++){const n=this._batchObjects[t];if(!e&&!(e=n.transformDirty))continue;const i=this._textObjects[n.renderView.renderData.id];n.transform.decompose(i.position,i.quaternion,i.scale),i.updateMatrix();const r=i.matrix.elements,s=this._dataTextures[i.material.isTextOutlineMaterial?"outline":"main"],o=this._members.get(i);if(o){const l=32*o.index;for(let c=0;c<16;c++)this.setTexData(s,l+c,r[c]);n.transformDirty=!1}}this.tas&&e&&(this.tas.refit(),this.tas.getBoundingBox(this.tas.bounds))}updateMaterialTransformsUniform(e){}setGradientTexture(e){this._batchMaterial.setGradientTexture(e)}getBatchObjectMaterial(e){const t=e.renderView,n=this.groups.find((i=>t.batchStart>=i.start&&t.batchStart+t.batchCount<=i.count+i.start));return n?this.materials[n.materialIndex]:(De.warn(`Could not get material for ${e.renderView.renderData.id}`),null)}convertRaycastIntersect(e,t,n){return e===null?null:(e.point.applyMatrix4(t.matrixWorld),e.distance=e.point.distanceTo(n.ray.origin),e.object=t,e.distance<n.near||e.distance>n.far?null:e)}initDebugBox(){var e;const t=new Ve(new nt,new ti({wireframe:!0,color:16711680}));return t.geometry.setAttribute("position",new je(new Array(12),3)),t.geometry.setIndex(new wf([0,1,2,0,2,3],1)),t.layers.set(re.OVERLAY),(e=this.parent)===null||e===void 0||e.add(t),t}onBeforeRender(e,t,n,i,r,s){if(super.onBeforeRender(e,t,n,i,r,s),this.DEBUG_BILLBOARDS&&this.isBillboarded){const o=[new A,new A,new A,new A];for(let l=0;l<this._batchObjects.length;l++){this.debugMeshes[l]||(this.debugMeshes[l]=this.initDebugBox());const c=this._batchObjects[l].textTransform,u=Uw.set(c.elements[12],c.elements[13],c.elements[14]),h=new He().copy(this._batchObjects[l].aabb),d=CN.copy(h.min),f=Fw.copy(h.max);o[0].set(d.x,d.y,0),o[1].set(f.x,d.y,0),o[2].set(f.x,f.y,0),o[3].set(d.x,f.y,0);const p=Em.makeTranslation(u.x,u.y,u.z);p.multiply(Hw.extractRotation(n.matrixWorld)),p.multiply(Gw.copy(c).invert());for(let m=0;m<o.length;m++){const g=Fw.copy(o[m]);g.applyMatrix4(p),this.debugMeshes[l].geometry.attributes.position.setXYZ(m,g.x,g.y,g.z)}this.debugMeshes[l].geometry.attributes.position.needsUpdate=!0}}}raycast(e,t){if(this.isBillboarded){const n=new On;for(let i=0;i<this._batchObjects.length;i++){const r=this._batchObjects[i].textTransform,s=Uw.set(r.elements[12],r.elements[13],r.elements[14]),o=Em.makeTranslation(s.x,s.y,s.z);o.multiply(Hw.extractRotation(e.camera.matrixWorld)),o.multiply(Gw.copy(r).invert());const l=Em.copy(o).invert();if(n.copy(e.ray),n.applyMatrix4(l),e.firstHitOnly===!0){const c=this.convertRaycastIntersect(this._batchObjects[i].accelerationStructure.raycastFirst(n,this._batchMaterial),this,e);if(c){c.batchObject=this._batchObjects[i],t.push(c);break}}else{const c=this._batchObjects[i].accelerationStructure.raycast(n,this._batchMaterial);for(let u=0,h=c.length;u<h;u++){const d=this.convertRaycastIntersect(c[u],this,e);d&&(d.batchObject=this._batchObjects[i],t.push(d))}}}}else if(this.tas){if(this._batchMaterial===void 0)return;kw.copy(this.matrixWorld).invert(),bm.copy(e.ray).applyMatrix4(kw);const n=e.intersectTASOnly||!0;if(e.firstHitOnly===!0){const i=this.convertRaycastIntersect(this.tas.raycastFirst(bm,n,this._batchMaterial),this,e);i&&t.push(i)}else{const i=this.tas.raycast(bm,n,this._batchMaterial);for(let r=0,s=i.length;r<s;r++){const o=this.convertRaycastIntersect(i[r],this,e);o&&t.push(o)}}}else super.raycast(e,t)}updateBounds(){var e,t;if(!this._dirty)return;const n=new He,i=((e=this.geometry.boundingBox)!==null&&e!==void 0?e:new He).makeEmpty();this._members.forEach(((r,s)=>{var o;s.matrixAutoUpdate&&s.updateMatrix(),n.copy((o=s.geometry.boundingBox)!==null&&o!==void 0?o:new He).applyMatrix4(s.matrix),i.union(n)})),i.getBoundingSphere((t=this.geometry.boundingSphere)!==null&&t!==void 0?t:new rn)}addText(e){this._members.has(e)||(this._members.set(e,{index:-1,glyphCount:-1,dirty:!0,needsUpdate:!0}),e.addEventListener("synccomplete",this._onMemberSynced))}setTexData(e,t,n){const i=e.image.data;n!==i[t]&&(i[t]=n,e.needsUpdate=!0)}_prepareForRender(e){if(!this._dirty)return;this._dirty=!1;const t=new Ie,n=e.isTextOutlineMaterial;e.uniforms.uTroikaIsOutline.value=n;let i=this._dataTextures[n?"outline":"main"];const r=Math.pow(2,Math.ceil(Math.log2(32*this._members.size)));if(!i||r!==i.image.data.length){i&&i.dispose();const s=Math.min(r/4,1024);i=this._dataTextures[n?"outline":"main"]=new Yi(new Float32Array(r),s,r/4/s,Hn,Dn)}this._members.forEach(((s,o)=>{var l;if(s.index>-1&&s.needsUpdate){s.needsUpdate=!1;const c=32*s.index,u=o.matrix.elements;for(let b=0;b<16;b++)this.setTexData(i,c+b,u[b]);if(e.defines&&e.defines.USE_RTE!==void 0){const b=new A(u[12],u[13],u[14]),E=new A,M=new A;ft.DoubleToHighLowVector(b,E,M),this.setTexData(i,c+3,E.x),this.setTexData(i,c+7,E.y),this.setTexData(i,c+11,E.z)}o._prepareForRender(e);const{uTroikaTotalBounds:h,uTroikaClipRect:d,uTroikaPositionOffset:f,uTroikaEdgeOffset:p,uTroikaBlurRadius:m,uTroikaStrokeWidth:g,uTroikaStrokeColor:v,uTroikaStrokeOpacity:y,uTroikaFillOpacity:w,uTroikaCurveRadius:x}=e.uniforms;for(let b=0;b<4;b++)this.setTexData(i,c+16+b,h.value.getComponent(b));for(let b=0;b<4;b++)this.setTexData(i,c+20+b,d.value.getComponent(b));let S=n?o.outlineColor||0:o.color;S===null&&(S=this.color),S===null&&(S=this.material.color),S===null&&(S=16777215),this.setTexData(i,c+24,t.set(S).getHex()),this.setTexData(i,c+25,(l=o.material.opacity)!==null&&l!==void 0?l:w.value),this.setTexData(i,c+26,x.value),this.setTexData(i,c+27,o.userData.gradientIndex),n?(this.setTexData(i,c+28,f.value.x),this.setTexData(i,c+29,f.value.y),this.setTexData(i,c+30,p.value),this.setTexData(i,c+31,m.value)):(this.setTexData(i,c+28,g.value),this.setTexData(i,c+29,t.set(v.value).getHex()),this.setTexData(i,c+30,y.value))}})),e.setMatrixTexture(i),Za.prototype._prepareForRender.call(this,e)}}class Mt{get renderView(){return this._renderView}get accelerationStructure(){return this._accelerationStructure}get batchIndex(){return this._batchIndex}get aabb(){if(this.renderView.aabb){const e=new He().copy(this.renderView.aabb);return e.applyMatrix4(this.transform),e}return new He}get localOrigin(){return this._localOrigin}set pivot(e){e?this.pivotValue.copy(e):this.pivotValue.copy(this._localOrigin),ft.DoubleToHighLowVector(this.pivotValue,this.pivot_Low,this.pivot_High)}set position(e){this.transformTRS(e,this.eulerValue,this.scaleValue,this.pivotValue)}set euler(e){this.transformTRS(this.translation,e,this.scaleValue,this.pivotValue)}set scale(e){this.transformTRS(this.translation,this.eulerValue,e,this.pivotValue)}constructor(e,t){this.quaternion=new dt,this.eulerValue=new mi,this.pivot_High=new A,this.pivot_Low=new A,this.translation=new A,this.scaleValue=new A(1,1,1),this.pivotValue=new A,this.transformDirty=!0,this._renderView=e,this._batchIndex=t,this.transform=new ae().identity(),this.transformInv=new ae().identity(),this._localOrigin=this._renderView.aabb.getCenter(new A),this.pivotValue.copy(this._localOrigin),ft.DoubleToHighLowVector(new A(this._localOrigin.x,this._localOrigin.y,this._localOrigin.z),this.pivot_Low,this.pivot_High)}buildAccelerationStructure(e,t){const n=new ae().makeTranslation(this._localOrigin.x,this._localOrigin.y,this._localOrigin.z);n.invert();let i=e;if(!(i instanceof rl)){if(!t)throw new Error("Cannot build a BVH with only positions. Need indices too");i=zi.buildBVH(t,e,Zf,n)}this._accelerationStructure=new zi(i),this._accelerationStructure.inputTransform=this.transformInv,this._accelerationStructure.outputTransform=this.transform,this._accelerationStructure.inputOriginTransform=new ae().copy(n),this._accelerationStructure.outputOriginTransfom=new ae().copy(n).invert()}transformTRS(e,t,n,i){let r=Mt.matBuff0.identity(),s=Mt.matBuff1.identity(),o=Mt.matBuff2.identity();Mt.eulerBuff.set(0,0,0,"XYZ"),Mt.translationBuff.set(0,0,0),Mt.scaleBuff.set(1,1,1),Mt.pivotBuff.copy(this._localOrigin),e&&(r=Mt.matBuff0.makeTranslation(e.x,e.y,e.z),Mt.translationBuff.set(e.x,e.y,e.z)),t&&(Mt.eulerBuff.set(t.x,t.y,t.z,"XYZ"),s=Mt.matBuff1.makeRotationFromEuler(Mt.eulerBuff),this.quaternion.setFromEuler(Mt.eulerBuff),this.eulerValue.copy(Mt.eulerBuff)),n&&(o=Mt.matBuff2.makeScale(n.x,n.y,n.z),Mt.scaleBuff.set(n.x,n.y,n.z)),i&&Mt.pivotBuff.set(i.x,i.y,i.z),this.transform.identity(),this.transform.multiply(r),this.transform.multiply(s),this.transform.multiply(o);const l=new ae().multiplyMatrices(new ae().makeTranslation(Mt.pivotBuff.x,Mt.pivotBuff.y,Mt.pivotBuff.z),this.transform);l.multiply(new ae().makeTranslation(-Mt.pivotBuff.x,-Mt.pivotBuff.y,-Mt.pivotBuff.z)),this.transform.copy(l),this.transformInv.copy(this.transform),this.transformInv.invert(),this.translation.copy(Mt.translationBuff),this.quaternion.setFromEuler(Mt.eulerBuff),this.scaleValue.copy(Mt.scaleBuff),this.pivotValue.copy(Mt.pivotBuff),ft.DoubleToHighLowVector(Mt.pivotBuff,this.pivot_Low,this.pivot_High),this.transformDirty=!0}}Mt.matBuff0=new ae,Mt.matBuff1=new ae,Mt.matBuff2=new ae,Mt.eulerBuff=new mi,Mt.translationBuff=new A,Mt.scaleBuff=new A,Mt.pivotBuff=new A;class IN extends Mt{constructor(e,t){super(e,t),this.textTransform=new ae,e.renderData.geometry.transform&&this.textTransform.copy(e.renderData.geometry.transform),this.transform.copy(this.textTransform),this.transformInv.copy(new ae().copy(this.textTransform).invert()),this.transformDirty=!1}get aabb(){return this._accelerationStructure.getBoundingBox(new He)}transformTRS(e,t,n,i){super.transformTRS(e,t,n,i),this.transform.multiply(this.textTransform),this.transformInv.copy(this.transform),this.transformInv.invert()}}class Kf{integrateRanges(e,t,n){let i=[];e.sort(((u,h)=>u.start-h.start)),n.sort(((u,h)=>u.offset-h.offset));const r={},s={};for(let u=0,h=e.length-1;u<e.length;u++,h--){const d=e[u],f=e[h];r[d.start]=d.materialIndex,s[f.start+f.count]=f.materialIndex}i=e.map((u=>u.start+u.count)),i.unshift(0);for(let u=0;u<n.length;u++){const h=n[u],d=h.offset,f=i.findIndex((y=>y>d)),p=i[f];i.splice(f,0,d);const m=h.offset+h.count,g=i.findIndex((y=>y>m));i.splice(g,0,m),i=i.filter((y=>!(y>d&&y<m))),i=[...new Set(i)];const v=t.indexOf(h.material);r[d]=v,r[m]=m>=p?r[p]:s[p]}const o=[];let l=-1,c=0;for(let u=0;u<i.length-1;u++){const h=i[u];c+=i[u+1]-h;const d=r[h],f=u===i.length-2;(r[i[u+1]]!==d&&!f||(l===-1&&(l=h),f))&&(o.push({start:l===-1?h:l,count:c,materialIndex:d}),l=-1,c=0)}return o}}class bg{get bounds(){return this.mesh.TAS.getBoundingBox(new He)}get drawCalls(){return this.groups.length}get minDrawCalls(){return[...Array.from(new Set(this.groups.map((e=>e.materialIndex))))].length}get maxDrawCalls(){return 1}get triCount(){return 2*this.renderViews.length}get vertCount(){return 4*this.renderViews.length}get pointCount(){return 0}get lineCount(){return 0}get geometryType(){return ze.TEXT}get renderObject(){return this.mesh}getCount(){return this.renderViews.length}get materials(){return this.mesh.materials}get groups(){return this.mesh.groups}constructor(e,t,n){this.drawRanges=new Kf,this.id=e,this.subtreeId=t,this.renderViews=n}setBatchMaterial(e){this.batchMaterial=e}onUpdate(e){}onRender(e){}setVisibleRange(e){}getVisibleRange(){if(this.mesh.groups.length===1){const e=this.mesh.groups[0];if(!this.materials[e.materialIndex].visible)return Fn}return en}getOpaque(){return Tt.isOpaque(this.batchMaterial)?en:Fn}getDepth(){return this.getOpaque()}getTransparent(){return Tt.isTransparent(this.batchMaterial)?en:Fn}getStencil(){return this.batchMaterial.stencilWrite===!0?en:Fn}setBatchBuffers(e){const t=[];e.forEach((n=>{for(let i=0;i<n.count;i++)t.push({offset:n.offset+i,count:1,material:n.material,materialOptions:n.materialOptions})})),this.mesh._members.forEach(((n,i)=>{var r,s,o,l;const c=t.find((u=>u.offset===n.index));if(c){if(i.color=(r=c.material)===null||r===void 0?void 0:r.color,i.material.color=(s=c.material)===null||s===void 0?void 0:s.color,i.material.opacity=!((o=c.material)===null||o===void 0)&&o.visible?(l=c.material)===null||l===void 0?void 0:l.opacity:0,c.material instanceof Sg)if(c.materialOptions){if(c.materialOptions.rampIndex!==void 0&&c.materialOptions.rampWidth!==void 0){const u=c.materialOptions.rampIndex+.5/c.materialOptions.rampWidth;c.material.updateGradientIndexMap(n.index,u),i.userData.gradientIndex=u}c.materialOptions.rampTexture!==void 0&&(c.material.setGradientTexture(c.materialOptions.rampTexture),this.mesh.setGradientTexture(c.materialOptions.rampTexture))}else i.userData.gradientIndex=c.material.gradientIndexMap[n.index],this.mesh.setGradientTexture(c.material.userData.gradientRamp.value);else i.userData.gradientIndex=-1;n.needsUpdate=!0}})),this.mesh.dirty=!0,this.mesh.sync()}setDrawRanges(e){const t=e.map((r=>r.material)),n=[...Array.from(new Set(t.map((r=>r))))];for(let r=0;r<n.length;r++)this.materials.includes(n[r])||this.materials.push(n[r]);this.mesh.groups=this.drawRanges.integrateRanges(this.groups,this.materials,e);let i=0;this.groups.forEach((r=>i+=r.count)),i!==this.renderViews.length&&De.error(`Draw groups invalid on ${this.id}`),this.setBatchBuffers(e),this.cleanMaterials()}cleanMaterials(){const e=[...Array.from(new Set(this.groups.map((n=>this.materials[n.materialIndex]))))];let t=0;for(;this.materials.length>e.length;)e.includes(this.materials[t])?t++:(this.materials.splice(t,1),this.groups.forEach((n=>{n.materialIndex>t&&n.materialIndex--})),t=0)}resetDrawRanges(){this.groups.length=0,this.materials.length=0,this.materials.push(this.batchMaterial),this.setVisibleRange([en]),this.setDrawRanges([{offset:0,count:this.renderViews.length,material:this.batchMaterial}])}alignmentXToAnchorX(e){switch(e){case 0:return"left";case 1:default:return"center";case 2:return"right"}}alignmentYToAnchorY(e){switch(e){case 0:return"top";case 1:default:return"middle";case 2:return"bottom"}}async buildBatch(){return new Promise((e=>{var t,n;this.mesh=new nb;const i=new Map,r=[],s=[],o=new He;let l=!1,c=!1,u=this.renderViews.length;for(let h=0;h<this.renderViews.length;h++){const d=this.renderViews[h].renderData.geometry.metaData;if(((t=this.renderViews[h].renderData.geometry.metaData)===null||t===void 0?void 0:t.value)===""){u--;continue}const f=new Za;(n=this.renderViews[h].renderData.geometry.transform)===null||n===void 0||n.decompose(f.position,f.quaternion,f.scale),f.updateMatrixWorld(!0),d&&(f.text=d.value,f.fontSize=d.height,f.maxWidth=d.maxWidth!==null?d.maxWidth:Number.POSITIVE_INFINITY,f.anchorX=this.alignmentXToAnchorX(d.alignmentH),f.anchorY=this.alignmentYToAnchorY(d.alignmentV)),c||(c=d!==void 0&&d.screenOriented),f.material=new vr({color:16711680}).getDerivedMaterial(),i.set(f,this.renderViews[h]),f.sync((()=>{var p;const{textRenderInfo:m}=f,g=m.visibleBounds,v=new Float32Array(12);v[0]=g[0],v[1]=g[3],v[2]=0,v[3]=g[2],v[4]=g[3],v[5]=0,v[6]=g[0],v[7]=g[1],v[8]=0,v[9]=g[2],v[10]=g[1],v[11]=0,o.setFromArray(v),o.applyMatrix4(this.renderViews[h].renderData.geometry.transform||new ae),l||(l=ft.needsRTE(o));const y=f.geometry;y.computeBoundingBox();const w=zi.buildBVH((p=y.index)===null||p===void 0?void 0:p.array,v,Zf);w.refit();const x=new IN(this.renderViews[h],h);x.buildAccelerationStructure(w),r.push(x),s.push(f),this.mesh.addText(f),u--,u||(this.batchMaterial.defines||(this.batchMaterial.defines={}),l&&(this.batchMaterial.defines.USE_RTE=" "),c&&(this.batchMaterial.defines.BILLBOARD=" "),this.mesh.setBatchObjects(r,s),this.mesh.setBatchMaterial(this.batchMaterial),this.mesh.buildTAS(),this.mesh.uuid=this.id,this.mesh.layers.set(re.STREAM_CONTENT_TEXT),this.mesh.frustumCulled=!1,this.mesh.dirty=!0,this.groups.push({start:0,count:this.renderViews.length,materialIndex:0}),this.mesh.sync((()=>{this.mesh._members.forEach(((S,b)=>{i.get(b).setBatchData(this.id,S.index,1),S.needsUpdate=!0})),this.setBatchBuffers([{offset:0,count:this.renderViews.length,material:this.batchMaterial}]),e()})))}))}}))}getRenderView(e){return De.warn("Deprecated! Use InstancedBatchObject"),null}getMaterialAtIndex(e){return De.warn("Deprecated! Use InstancedBatchObject"),null}getMaterial(e){const t=this.groups.find((n=>e.batchStart>=n.start&&e.batchStart+e.batchCount<=n.count+n.start));return t?this.materials[t.materialIndex]:(De.warn(`Could not get material for ${e.renderData.id}`),null)}purge(){this.renderViews.length=0,this.batchMaterial.dispose(),this.mesh.dispose()}}const Vw=new ae,Wo=new On,Tm=new rn,Cm=new A,is=new A,rs=new A,ss=new A,Im=new A,Rm=new A,Pm=new A,hd=new A,dd=new A,fd=new A,pd=new te,md=new te,gd=new te,Dm=new A,vd=new A,Om=new On,jw=new ae;var ds;(function(a){a[a.VERTEX_TEXTURE=0]="VERTEX_TEXTURE",a[a.UNIFORM_ARRAY=1]="UNIFORM_ARRAY"})(ds||(ds={}));class wl extends Ve{get TAS(){return this.tas}get batchObjects(){return this._batchObjects}get batchIndex(){return this._batchIndex}get needsRTE(){return this._needsRTE}constructor(e,t=!1){super(e),this.materialCache={},this.materialStack=[],this.batchMaterialStack=[],this.materialCacheLUT={},this.transformsBuffer=void 0,this.transformsArrayUniforms=null,this._batchIndex=QM(),this._needsRTE=t}setBatchMaterial(e){this.batchMaterial=this.getCachedMaterial(e),this.material=[this.batchMaterial]}setBatchObjects(e,t){this._batchObjects=e,this.transformStorage=t,this.transformStorage===ds.VERTEX_TEXTURE?(this.transformsBuffer=new Float32Array(4*this._batchObjects.length*4),this.transformsTextureUniform=new Yi(this.transformsBuffer,this.transformsBuffer.length/4,1,Hn,Dn)):this.transformStorage===ds.UNIFORM_ARRAY&&(this.transformsArrayUniforms=this._batchObjects.map((()=>new ae))),this.updateTransformsUniform()}setOverrideMaterial(e){this.materialStack.push(this.material),this.material=this.getCachedMaterial(e,!0),this.material.needsUpdate=!0}setOverrideBatchMaterial(e){const t=this.getCachedMaterial(e,!0);this.batchMaterialStack.push(t);const n=this.material;for(let i=0;i<n.length;i++)n[i].uuid===this.batchMaterial.uuid&&(n[i]=t)}restoreBatchMaterial(){const e=this.material,t=this.batchMaterialStack.pop();if(t)for(let n=0;n<e.length;n++)e[n].uuid===t.uuid&&(e[n]=this.batchMaterial)}lookupMaterial(e){return this.materialCache[e.id]||this.materialCache[this.materialCacheLUT[e.id]]}getCachedMaterial(e,t=!1){let n=this.lookupMaterial(e);if(n)(t||e.needsCopy||n.needsCopy)&&Tt.fastCopy(e,n);else{const i=e.clone();this._needsRTE&&(i.defines||(i.defines={}),i.defines.USE_RTE=" "),this.materialCache[e.id]=i,this.materialCacheLUT[i.id]=e.id,n=i,this.updateMaterialTransformsUniform(this.materialCache[e.id])}return n}restoreMaterial(){this.materialStack.length>0&&(this.material=this.materialStack.pop())}updateMaterialTransformsUniform(e){Tt.isSpeckleMaterial(e)&&(e.defines||(e.defines={}),e.defines.TRANSFORM_STORAGE=this.transformStorage,this.transformStorage===ds.VERTEX_TEXTURE?(e.userData.tTransforms.value=this.transformsTextureUniform,e.userData.objCount&&(e.userData.objCount.value=this._batchObjects.length)):this.transformStorage===ds.UNIFORM_ARRAY&&(e.defines.OBJ_COUNT&&e.defines.OBJ_COUNT===this._batchObjects.length||(e.defines.OBJ_COUNT=this._batchObjects.length),e.userData.uTransforms.value=this.transformsArrayUniforms),e.needsUpdate=!0)}updateTransformsUniform(){if(!this.transformsBuffer)return;let e=!1;if(this.transformStorage===ds.VERTEX_TEXTURE){for(let t=0;t<this._batchObjects.length;t++){const n=this._batchObjects[t];if(!e&&!(e=n.transformDirty))continue;const i=16*n.batchIndex;this.transformsBuffer[i]=n.quaternion.x,this.transformsBuffer[i+1]=n.quaternion.y,this.transformsBuffer[i+2]=n.quaternion.z,this.transformsBuffer[i+3]=n.quaternion.w,this.transformsBuffer[i+4]=n.pivot_Low.x,this.transformsBuffer[i+5]=n.pivot_Low.y,this.transformsBuffer[i+6]=n.pivot_Low.z,this.transformsBuffer[i+7]=n.scaleValue.x,this.transformsBuffer[i+8]=n.pivot_High.x,this.transformsBuffer[i+9]=n.pivot_High.y,this.transformsBuffer[i+10]=n.pivot_High.z,this.transformsBuffer[i+11]=n.scaleValue.y,this.transformsBuffer[i+12]=n.translation.x,this.transformsBuffer[i+13]=n.translation.y,this.transformsBuffer[i+14]=n.translation.z,this.transformsBuffer[i+15]=n.scaleValue.z,n.transformDirty=!1}this.transformsTextureUniform.needsUpdate=e}else{if(!this.transformsArrayUniforms)return;for(let t=0;t<this._batchObjects.length;t++){const n=this._batchObjects[t];(e||(e=n.transformDirty))&&this.transformsArrayUniforms[t].set(n.quaternion.x,n.pivot_Low.x,n.pivot_High.x,n.translation.x,n.quaternion.y,n.pivot_Low.y,n.pivot_High.y,n.translation.y,n.quaternion.z,n.pivot_Low.z,n.pivot_High.z,n.translation.z,n.quaternion.w,n.scaleValue.x,n.scaleValue.y,n.scaleValue.z)}}this.tas&&e&&(this.tas.refit(),this.tas.getBoundingBox(this.tas.bounds),this.geometry.boundingBox||(this.geometry.boundingBox=new He),this.geometry.boundingBox.copy(this.tas.bounds),this.geometry.boundingSphere||(this.geometry.boundingSphere=new rn),this.geometry.boundingBox.getBoundingSphere(this.geometry.boundingSphere))}buildTAS(){this.tas=new _n(this.batchObjects),this.tas.refit()}getBatchObjectMaterial(e){const t=e.renderView,n=this.geometry.groups.find((i=>t.batchStart>=i.start&&t.batchStart+t.batchCount<=i.count+i.start));return Array.isArray(this.material)?n?this.material[n.materialIndex]:(De.warn(`Could not get material for ${e.renderView.renderData.id}`),null):this.material}convertRaycastIntersect(e,t,n){return e===null?null:(e.point.applyMatrix4(t.matrixWorld),e.distance=e.point.distanceTo(n.ray.origin),e.object=t,e.distance<n.near||e.distance>n.far?null:e)}raycast(e,t){if(this.tas){if(this.batchMaterial===void 0)return;if(jw.copy(this.matrixWorld).invert(),Om.copy(e.ray).applyMatrix4(jw),e.firstHitOnly===!0){const n=this.convertRaycastIntersect(this.tas.raycastFirst(Om,e.intersectTASOnly,this.batchMaterial),this,e);n&&t.push(n)}else{const n=this.tas.raycast(Om,e.intersectTASOnly,this.batchMaterial);for(let i=0,r=n.length;i<r;i++){const s=this.convertRaycastIntersect(n[i],this,e);s&&t.push(s)}}}else{const n=this.geometry,i=this.material,r=this.matrixWorld;if(i===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),Tm.copy(n.boundingSphere||new rn),Tm.applyMatrix4(r),e.ray.intersectsSphere(Tm)===!1)||(Vw.copy(r).invert(),Wo.copy(e.ray).applyMatrix4(Vw),n.boundingBox!==null&&Wo.intersectsBox(n.boundingBox)===!1))return;let s;const o=n.index,l=n.attributes.position,c=n.attributes.position_low,u=n.morphAttributes.position,h=n.morphTargetsRelative,d=n.attributes.uv,f=n.attributes.uv2,p=n.groups,m=n.drawRange;if(o!==null)if(Array.isArray(i))for(let g=0,v=p.length;g<v;g++){const y=p[g];if(!y.materialIndex){De.error("Group with no material, skipping!");continue}const w=i[y.materialIndex];for(let x=Math.max(y.start,m.start),S=Math.min(o.count,Math.min(y.start+y.count,m.start+m.count));x<S;x+=3){const b=o.getX(x),E=o.getX(x+1),M=o.getX(x+2);s=yd(this,w,e,Wo,c,l,u,h,d,f,b,E,M),s&&(s.faceIndex=Math.floor(x/3),s.face&&(s.face.materialIndex=y.materialIndex),t.push(s))}}else for(let g=Math.max(0,m.start),v=Math.min(o.count,m.start+m.count);g<v;g+=3){const y=o.getX(g),w=o.getX(g+1),x=o.getX(g+2);s=yd(this,i,e,Wo,c,l,u,h,d,f,y,w,x),s&&(s.faceIndex=Math.floor(g/3),t.push(s))}else if(l!==void 0)if(Array.isArray(i))for(let g=0,v=p.length;g<v;g++){const y=p[g],w=i[y.materialIndex];for(let x=Math.max(y.start,m.start),S=Math.min(l.count,Math.min(y.start+y.count,m.start+m.count));x<S;x+=3)s=yd(this,w,e,Wo,c,l,u,h,d,f,x,x+1,x+2),s&&(s.faceIndex=Math.floor(x/3),s.face&&(s.face.materialIndex=y.materialIndex),t.push(s))}else for(let g=Math.max(0,m.start),v=Math.min(l.count,m.start+m.count);g<v;g+=3)s=yd(this,i,e,Wo,c,l,u,h,d,f,g,g+1,g+2),s&&(s.faceIndex=Math.floor(g/3),t.push(s))}}}function yd(a,e,t,n,i,r,s,o,l,c,u,h,d){is.fromBufferAttribute(r,u),rs.fromBufferAttribute(r,h),ss.fromBufferAttribute(r,d),i&&(is.add(Cm.fromBufferAttribute(i,u)),rs.add(Cm.fromBufferAttribute(i,h)),ss.add(Cm.fromBufferAttribute(i,d)));const f=a.morphTargetInfluences;if(s&&f){hd.set(0,0,0),dd.set(0,0,0),fd.set(0,0,0);for(let m=0,g=s.length;m<g;m++){const v=f[m],y=s[m];v!==0&&(Im.fromBufferAttribute(y,u),Rm.fromBufferAttribute(y,h),Pm.fromBufferAttribute(y,d),o?(hd.addScaledVector(Im,v),dd.addScaledVector(Rm,v),fd.addScaledVector(Pm,v)):(hd.addScaledVector(Im.sub(is),v),dd.addScaledVector(Rm.sub(rs),v),fd.addScaledVector(Pm.sub(ss),v)))}is.add(hd),rs.add(dd),ss.add(fd)}a.isSkinnedMesh&&(a.boneTransform(u,is),a.boneTransform(h,rs),a.boneTransform(d,ss));const p=(function(m,g,v,y,w,x,S,b){let E;if(E=g.side===pi?y.intersectTriangle(S,x,w,!0,b):y.intersectTriangle(w,x,S,g.side!==yt,b),E===null)return null;vd.copy(b),vd.applyMatrix4(m.matrixWorld);const M=v.ray.origin.distanceTo(vd);return M<v.near||M>v.far?null:{distance:M,point:vd.clone(),object:m,uv:void 0,uv2:void 0,face:void 0}})(a,e,t,n,is,rs,ss,Dm);if(p){l&&(pd.fromBufferAttribute(l,u),md.fromBufferAttribute(l,h),gd.fromBufferAttribute(l,d),p.uv=Ht.getUV(Dm,is,rs,ss,pd,md,gd,new te)),c&&(pd.fromBufferAttribute(c,u),md.fromBufferAttribute(c,h),gd.fromBufferAttribute(c,d),p.uv2=Ht.getUV(Dm,is,rs,ss,pd,md,gd,new te));const m={a:u,b:h,c:d,normal:new A,materialIndex:0};Ht.getNormal(is,rs,ss,m.normal),p.face=m}return p}wl.MeshBatchNumber=0;class Yu extends JM{get vertexProgram(){return`
#include <common>
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
    uniform mat4 rteModelViewMatrix;
#endif

#ifdef TRANSFORM_STORAGE
    attribute float objIndex;

    #if TRANSFORM_STORAGE == 0
        #if __VERSION__ == 300
            #define TRANSFORM_STRIDE 4
        #else
            #define TRANSFORM_STRIDE 4.
        #endif
        uniform sampler2D tTransforms;
        uniform float objCount;
    #elif TRANSFORM_STORAGE == 1
        uniform mat4 uTransforms[OBJ_COUNT];
    #endif
#endif

#ifdef LINEAR_DEPTH
    varying vec4 vViewPosition;
#endif

#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
varying vec2 vHighPrecisionZW;

#ifdef TRANSFORM_STORAGE
    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){
        #if TRANSFORM_STORAGE == 0
            #if __VERSION__ == 300
                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); 
                vec4 v0 = texelFetch( tTransforms, uv, 0 );
                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);
                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);
                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #else
                float size = objCount * TRANSFORM_STRIDE;
                vec2 cUv = vec2(0.5/size, 0.5);
                vec2 dUv = vec2(1./size, 0.);
                
                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);
                vec4 v0 = texture2D( tTransforms, uv);
                vec4 v1 = texture2D( tTransforms, uv + dUv);
                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);
                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #endif
        #elif TRANSFORM_STORAGE == 1
            mat4 tMatrix = uTransforms[int(objIndex)];
            quaternion = tMatrix[0];
            pivotLow = vec4(tMatrix[1].xyz, 1.);
            pivotHigh = vec4(tMatrix[2].xyz, 1.);
            translation = vec4(tMatrix[3].xyz, 1.);
            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);
        #endif
    }

    vec3 rotate_vertex_position(vec3 position, vec4 quat)
    { 
        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);
    }

    /** Another workaround for Apple's stupid compiler */
    vec4 safeMul(vec4 a, vec4 b) {
        // Prevents constant folding and optimization
        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);
    }

    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)
    {
        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */
        /** The code below will not produce correct results in intel IrisXE integrated GPUs. 
         *  The geometry will turn mangled, albeit stable
         *  I can't know for sure what is going on, but rotating the difference seems to 
         *  force the result into a lower precision?
         */
        // highp vec4 position = v0 - v1;
        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);

        /** Subtracting the rotated vectors works. */
        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;

        /** An alternate workaround is
         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));
           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);

           However I'm not such a fan of the (1. + 1e-7) part
         */
    }

    
#endif

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }
#endif


void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	//#include <project_vertex> // EDITED CHUNK
    #ifdef TRANSFORM_STORAGE
        vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;
        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);
    #endif
    #ifdef USE_RTE
        vec4 position_lowT = vec4(position_low, 1.);
        vec4 position_highT = vec4(position, 1.);
        const vec3 ZERO3 = vec3(0., 0., 0.);

        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);
        #ifdef TRANSFORM_STORAGE
            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;
        #endif
    #endif

    #ifdef USE_RTE
        vec4 mvPosition = rteLocalPosition;
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
        #ifdef TRANSFORM_STORAGE
            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif
    #endif
   
    #ifdef USE_RTE
        mvPosition = rteModelViewMatrix * mvPosition;
    #else
        mvPosition = modelViewMatrix * mvPosition;
    #endif
    
    #ifdef LINEAR_DEPTH
        vViewPosition = mvPosition;
    #endif 
    
    gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	// #include <clipping_planes_vertex>
    #if NUM_CLIPPING_PLANES > 0
	    vClipPosition = - mvPosition.xyz;
    #endif
	vHighPrecisionZW = gl_Position.zw;
}
`}get fragmentProgram(){return`
#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#ifdef LINEAR_DEPTH
    varying vec4 vViewPosition;
	uniform float near;
	uniform float far;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;

void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	// #include <alphatest_fragment>
	#ifdef USE_ALPHATEST
		if ( diffuseColor.a < alphaTest ) discard;
		/** This is a workaround for rejecting shadows for certain materials, since three.js gave me no choice*/
		#ifdef ALPHATEST_REJECTION
			if (alphaTest > 0. ) discard;
		#endif
	#endif
	#include <logdepthbuf_fragment>
	// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.
	#ifdef LINEAR_DEPTH
		/** View z is negative moving away from the camera */
		gl_FragColor = packDepthToRGBA((vViewPosition.z + near) / (near - far));
	#else
		float fragCoordZ = (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5);
		#if DEPTH_PACKING == 3200
			gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
		#elif DEPTH_PACKING == 3201
			gl_FragColor = packDepthToRGBA( fragCoordZ );
		#endif
	#endif
}
`}get baseUniforms(){return Rn.depth.uniforms}get uniformsDef(){return{uViewer_high:new A,uViewer_low:new A,rteModelViewMatrix:new ae,near:0,far:0,uTransforms:[new ae],tTransforms:null,objCount:1}}constructor(e,t=[]){super(e),this.init(t)}customProgramCacheKey(){return this.constructor.name}copy(e){return super.copy(e),this.copyFrom(e),this}fastCopy(e,t){super.fastCopy(e,t),t.userData.near.value=e.userData.near.value,t.userData.far.value=e.userData.far.value}onBeforeRender(e,t,n,i,r){this.defines&&this.defines.USE_RTE&&(r.modelViewMatrix.copy(e.RTEBuffers.rteViewModelMatrix),this.userData.uViewer_low.value.copy(e.RTEBuffers.viewerLow),this.userData.uViewer_high.value.copy(e.RTEBuffers.viewerHigh),this.userData.rteModelViewMatrix.value.copy(e.RTEBuffers.rteViewModelMatrix),this.needsUpdate=!0)}}class ib extends If{constructor(e,t,n,i){super(e,t,n),this._batchIndex=i}get batchIndex(){return this._batchIndex}}const Qw=new ae,Xo=new On,Bm=new rn,Lm=new A,as=new A,os=new A,ls=new A,zm=new A,Nm=new A,km=new A,xd=new A,wd=new A,Ad=new A,Sd=new te,Md=new te,bd=new te,Um=new A,Ed=new A,Fm=new On,Ww=new ae;class bu extends fi{get TAS(){return this.tas}get batchObjects(){return this._batchObjects}get needsRTE(){return this._needsRTE}constructor(e,t=!1){super(),this.materialCache={},this.materialStack=[],this.batchMaterialStack=[],this.materialCacheLUT={},this.groups=[],this.materials=[],this.instanceGeometry=void 0,this.instances=[],this.instanceGeometry=e,this.userData.raycastChildren=!1,this._needsRTE=t}setBatchMaterial(e){this.batchMaterial=e,this.materialCache[e.id]=e,this.materials.push(this.batchMaterial)}setBatchObjects(e){this._batchObjects=e}setOverrideMaterial(e){const t=[];for(let i=0;i<this.instances.length;i++)t.push(this.instances[i].material);this.materialStack.push(t);const n=this.getCachedMaterial(e,!0);this.instances.forEach((i=>i.material=n))}setOverrideBatchMaterial(e){const t=this.getCachedMaterial(e,!0);this.batchMaterialStack.push(t);const n=this.materials;for(let i=0;i<n.length;i++)n[i].uuid===this.batchMaterial.uuid&&(n[i]=t);this.instances.forEach((i=>{i.material.uuid===this.batchMaterial.uuid&&(i.material=t)}))}restoreBatchMaterial(){const e=this.batchMaterialStack.pop();if(e){for(let t=0;t<this.materials.length;t++)this.materials[t].uuid===e.uuid&&(this.materials[t]=this.batchMaterial);this.instances.forEach((t=>{t.material.uuid===e.uuid&&(t.material=this.batchMaterial)}))}}lookupMaterial(e){return this.materialCache[e.id]||this.materialCache[this.materialCacheLUT[e.id]]}getCachedMaterial(e,t=!1){let n=this.lookupMaterial(e);if(n)(t||e.needsCopy||n.needsCopy)&&Tt.fastCopy(e,n);else{const i=e.clone();this.materialCache[e.id]=i,this.materialCacheLUT[i.id]=e.id,n=i,this.updateMaterialTransformsUniform(this.materialCache[e.id])}return n}restoreMaterial(){if(this.materialStack.length>0){const e=this.materialStack.pop();for(let t=0;t<e.length;t++)this.instances[t].material=e[t]}}buildTAS(){this.tas=new _n(this.batchObjects),this.tas.refit()}updateDrawGroups(e,t,n){this.instances.forEach((i=>{var r;this.remove(i),(r=i.customDepthMaterial)===null||r===void 0||r.dispose(),i.dispose()})),this.instances.length=0;for(let i=0;i<this.groups.length;i++){const r=this.groups[i].materialIndex,s=this.materials[r],o=new ib(this.getInstanceGeometryShallowCopy(),s,0,QM());o.instanceMatrix=new yr(e.subarray(this.groups[i].start,this.groups[i].start+this.groups[i].count),qn),o.geometry.setAttribute("gradientIndex",new yr(t.subarray(this.groups[i].start/qn,(this.groups[i].start+this.groups[i].count)/qn),1)),n&&o.geometry.setAttribute("objIndex",new yr(n.subarray(this.groups[i].start/qn,(this.groups[i].start+this.groups[i].count)/qn),1)),o.count=this.groups[i].count/qn,o.instanceMatrix.needsUpdate=!0,o.layers.set(re.STREAM_CONTENT_MESH),o.frustumCulled=!1,o.customDepthMaterial=new Yu({depthPacking:da},["ALPHATEST_REJECTION"]),o.castShadow=!s.transparent,o.receiveShadow=!s.transparent,this.instances.push(o),this.add(o)}this.tas.refit(),this.tas.getBoundingBox(this.tas.bounds)}updateTransformsUniform(){let e=!1;for(let t=0;t<this._batchObjects.length;t++){const n=this._batchObjects[t];if(!e&&!(e=n.transformDirty))continue;const i=n.renderView,r=this.groups.find((s=>i.batchStart>=s.start&&i.batchStart+i.batchCount<=s.count+s.start));if(r){const s=this.instances[this.groups.indexOf(r)];s.setMatrixAt((i.batchStart-r.start)/qn,n.transform),s.instanceMatrix.needsUpdate=!0}n.transformDirty=!1}this.tas&&e&&(this.tas.refit(),this.tas.getBoundingBox(this.tas.bounds))}updateMaterialTransformsUniform(e){}getBatchObjectMaterial(e){const t=e.renderView,n=this.groups.find((i=>t.batchStart>=i.start&&t.batchStart+t.batchCount<=i.count+i.start));return n?this.materials[n.materialIndex]:(De.warn(`Could not get material for ${e.renderView.renderData.id}`),null)}getInstanceGeometryShallowCopy(){var e,t;const n=new nt;for(const i in(e=this.instanceGeometry)===null||e===void 0?void 0:e.attributes)n.setAttribute(i,this.instanceGeometry.attributes[i]);return n.setIndex((t=this.instanceGeometry)===null||t===void 0?void 0:t.index),n}convertRaycastIntersect(e,t,n){return e===null?null:(e.point.applyMatrix4(t.matrixWorld),e.distance=e.point.distanceTo(n.ray.origin),e.object=t,e.distance<n.near||e.distance>n.far?null:e)}raycast(e,t){if(this.tas){if(!this.batchMaterial)return;if(Ww.copy(this.matrixWorld).invert(),Fm.copy(e.ray).applyMatrix4(Ww),e.firstHitOnly===!0){const n=this.convertRaycastIntersect(this.tas.raycastFirst(Fm,e.intersectTASOnly,this.batchMaterial),this,e);n&&t.push(n)}else{const n=this.tas.raycast(Fm,e.intersectTASOnly,this.batchMaterial);for(let i=0,r=n.length;i<r;i++){const s=this.convertRaycastIntersect(n[i],this,e);s&&t.push(s)}}}else{const n=this.instanceGeometry,i=this.materials[0],r=this.matrixWorld;if(i===void 0||n===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),Bm.copy(n.boundingSphere||new rn),Bm.applyMatrix4(r),e.ray.intersectsSphere(Bm)===!1)||(Qw.copy(r).invert(),Xo.copy(e.ray).applyMatrix4(Qw),n.boundingBox!==null&&Xo.intersectsBox(n.boundingBox)===!1))return;let s;const o=n.index,l=n.attributes.position,c=n.attributes.position_low,u=n.morphAttributes.position,h=n.morphTargetsRelative,d=n.attributes.uv,f=n.attributes.uv2,p=n.groups,m=n.drawRange;if(o!==null)if(Array.isArray(i))for(let g=0,v=p.length;g<v;g++){const y=p[g];if(!y.materialIndex){De.error("Group with no material, skipping!");continue}const w=i[y.materialIndex];for(let x=Math.max(y.start,m.start),S=Math.min(o.count,Math.min(y.start+y.count,m.start+m.count));x<S;x+=3){const b=o.getX(x),E=o.getX(x+1),M=o.getX(x+2);s=Td(this,w,e,Xo,c,l,u,h,d,f,b,E,M),s&&(s.faceIndex=Math.floor(x/3),s.face&&(s.face.materialIndex=y.materialIndex),t.push(s))}}else for(let g=Math.max(0,m.start),v=Math.min(o.count,m.start+m.count);g<v;g+=3){const y=o.getX(g),w=o.getX(g+1),x=o.getX(g+2);s=Td(this,i,e,Xo,c,l,u,h,d,f,y,w,x),s&&(s.faceIndex=Math.floor(g/3),t.push(s))}else if(l!==void 0)if(Array.isArray(i))for(let g=0,v=p.length;g<v;g++){const y=p[g];if(!y.materialIndex){De.error("Group with no material, skipping!");continue}const w=i[y.materialIndex];for(let x=Math.max(y.start,m.start),S=Math.min(l.count,Math.min(y.start+y.count,m.start+m.count));x<S;x+=3)s=Td(this,w,e,Xo,c,l,u,h,d,f,x,x+1,x+2),s&&(s.faceIndex=Math.floor(x/3),s.face&&(s.face.materialIndex=y.materialIndex),t.push(s))}else for(let g=Math.max(0,m.start),v=Math.min(l.count,m.start+m.count);g<v;g+=3)s=Td(this,i,e,Xo,c,l,u,h,d,f,g,g+1,g+2),s&&(s.faceIndex=Math.floor(g/3),t.push(s))}}}function Td(a,e,t,n,i,r,s,o,l,c,u,h,d){as.fromBufferAttribute(r,u),os.fromBufferAttribute(r,h),ls.fromBufferAttribute(r,d),i&&(as.add(Lm.fromBufferAttribute(i,u)),os.add(Lm.fromBufferAttribute(i,h)),ls.add(Lm.fromBufferAttribute(i,d)));const f=a.morphTargetInfluences;if(s&&f){xd.set(0,0,0),wd.set(0,0,0),Ad.set(0,0,0);for(let m=0,g=s.length;m<g;m++){const v=f[m],y=s[m];v!==0&&(zm.fromBufferAttribute(y,u),Nm.fromBufferAttribute(y,h),km.fromBufferAttribute(y,d),o?(xd.addScaledVector(zm,v),wd.addScaledVector(Nm,v),Ad.addScaledVector(km,v)):(xd.addScaledVector(zm.sub(as),v),wd.addScaledVector(Nm.sub(os),v),Ad.addScaledVector(km.sub(ls),v)))}as.add(xd),os.add(wd),ls.add(Ad)}a.isSkinnedMesh&&(a.boneTransform(u,as),a.boneTransform(h,os),a.boneTransform(d,ls));const p=(function(m,g,v,y,w,x,S,b){let E;if(E=g.side===pi?y.intersectTriangle(S,x,w,!0,b):y.intersectTriangle(w,x,S,g.side!==yt,b),E===null)return null;Ed.copy(b),Ed.applyMatrix4(m.matrixWorld);const M=v.ray.origin.distanceTo(Ed);return M<v.near||M>v.far?null:{distance:M,point:Ed.clone(),object:m,uv:void 0,uv2:void 0,face:void 0,faceIndex:void 0}})(a,e,t,n,as,os,ls,Um);if(p){l&&(Sd.fromBufferAttribute(l,u),Md.fromBufferAttribute(l,h),bd.fromBufferAttribute(l,d),p.uv=Ht.getUV(Um,as,os,ls,Sd,Md,bd,new te)),c&&(Sd.fromBufferAttribute(c,u),Md.fromBufferAttribute(c,h),bd.fromBufferAttribute(c,d),p.uv2=Ht.getUV(Um,as,os,ls,Sd,Md,bd,new te));const m={a:u,b:h,c:d,normal:new A,materialIndex:0};Ht.getNormal(as,os,ls,m.normal),p.face=m}return p}bu.MeshBatchNumber=0;class rb extends Mt{constructor(e,t){super(e,t),this.instanceTransform=new ae,e.renderData.geometry.transform&&this.instanceTransform.copy(e.renderData.geometry.transform),this.transform.copy(this.instanceTransform),this.transformInv.copy(new ae().copy(this.instanceTransform).invert()),this.transformDirty=!1}transformTRS(e,t,n,i){super.transformTRS(e,t,n,i),this.transform.multiply(this.instanceTransform),this.transformInv.copy(this.transform),this.transformInv.invert()}}class Eg{get bounds(){return this.mesh.TAS.getBoundingBox(new He)}get drawCalls(){return this.groups.length}get minDrawCalls(){return[...Array.from(new Set(this.groups.map((e=>e.materialIndex))))].length}get maxDrawCalls(){return 1}get triCount(){return(this.geometry.index?this.geometry.index.count:0)/3*this.renderViews.length}get vertCount(){return this.geometry.attributes.position.count*this.renderViews.length}get pointCount(){return 0}get lineCount(){return 0}get geometryType(){return ze.MESH}get renderObject(){return this.mesh}getCount(){return 16*this.renderViews.length}get materials(){return this.mesh.materials}get groups(){return this.mesh.groups}constructor(e,t,n,i){this.drawRanges=new Kf,this.transformBufferIndex=0,this.needsShuffle=!1,this.id=e,this.subtreeId=t,this.renderViews=n,i||(this.instanceObjectIdBuffer=new Float32Array(this.renderViews.length))}setBatchMaterial(e){this.batchMaterial=e}onUpdate(e){this.needsShuffle&&(this.shuffleDrawGroups(),this.needsShuffle=!1)}onRender(e){}setVisibleRange(e){e.length===1&&o0(e[0])?this.mesh.children.forEach((t=>t.visible=!1)):e.length!==1||e[0]!==en?(this.mesh.children.forEach((t=>t.visible=!1)),e.forEach((t=>{const n=this.groups.find((i=>t.offset===i.start&&t.offset+t.count===i.start+i.count));if(n){const i=this.groups.indexOf(n);i!==-1&&(this.mesh.children[i].visible=!0)}}))):this.mesh.children.forEach((t=>t.visible=!0))}getVisibleRange(){if(!this.mesh.children[0].visible)return Fn;for(let e=0;e<this.mesh.children.length;e++)if(!this.mesh.children[e].visible)return{offset:0,count:16*e};return en}getOpaque(){const e=this.groups.find((t=>t.materialIndex!==void 0&&(Tt.isTransparent(this.materials[t.materialIndex])||this.materials[t.materialIndex].visible===!1)));return e?{offset:0,count:e.start}:en}getDepth(){const e=this.groups.find((t=>t.materialIndex!==void 0&&(Tt.isTransparent(this.materials[t.materialIndex])||this.materials[t.materialIndex].visible===!1||this.materials[t.materialIndex].colorWrite===!1)));return e?{offset:0,count:e.start}:en}getTransparent(){const e=this.groups.find((n=>n.materialIndex!==void 0&&Tt.isTransparent(this.materials[n.materialIndex]))),t=this.groups.find((n=>n.materialIndex!==void 0&&this.materials[n.materialIndex].visible===!1));if(e){const n=e.start,i=t!==void 0?t.start-e.start:this.getCount()-e.start;return n===0&&i===this.getCount()?en:{offset:n,count:i}}return Fn}getStencil(){if(this.groups.length===1&&this.materials[0].stencilWrite===!0)return en;const e=this.groups.find((t=>t.materialIndex!==void 0&&this.materials[t.materialIndex].stencilWrite===!0));return e?{offset:e.start,count:e.count}:Fn}setBatchBuffers(e){for(let t=0;t<e.length;t++){const n=e[t];if(n.materialOptions){if(n.materialOptions.rampIndex!==void 0&&n.materialOptions.rampWidth!==void 0){const i=e[t].offset,r=e[t].count,s=n.materialOptions.rampIndex+.5/n.materialOptions.rampWidth;this.updateGradientIndexBufferData(i/16,(i+r)/16,s)}n.materialOptions.rampTexture!==void 0&&n.material instanceof Ha&&n.material.setGradientTexture(n.materialOptions.rampTexture)}}}setDrawRanges(e){e.forEach((s=>{s.material&&(s.material=this.mesh.getCachedMaterial(s.material))}));const t=e.map((s=>s.material)),n=[...Array.from(new Set(t.map((s=>s))))];for(let s=0;s<n.length;s++)this.materials.includes(n[s])||this.materials.push(n[s]);this.mesh.groups=this.drawRanges.integrateRanges(this.groups,this.materials,e);let i=0;this.groups.forEach((s=>i+=s.count)),i!==16*this.renderViews.length&&De.error(`Draw groups invalid on ${this.id}`),this.setBatchBuffers(e),this.cleanMaterials();const r=this.groups.find((s=>this.materials[s.materialIndex].transparent===!0||this.materials[s.materialIndex].visible===!1||this.materials[s.materialIndex].colorWrite===!1));if(this.drawCalls>this.maxDrawCalls)this.needsShuffle=!0;else if(r)if(this.groups.length===1)this.needsShuffle=!0;else for(let s=this.groups.indexOf(r);s<this.groups.length;s++){const o=this.materials[this.groups[s].materialIndex];if(o.visible&&(!o.transparent||o.colorWrite)){this.needsShuffle=!0;break}}else this.mesh.updateDrawGroups(this.getCurrentTransformBuffer(),this.getCurrentGradientBuffer(),this.getCurrentObjectIndexBuffer())}cleanMaterials(){const e=[...Array.from(new Set(this.groups.map((n=>this.materials[n.materialIndex]))))];let t=0;for(;this.materials.length>e.length;)e.includes(this.materials[t])?t++:(this.materials.splice(t,1),this.groups.forEach((n=>{n.materialIndex>t&&n.materialIndex--})),t=0)}shuffleDrawGroups(){const e=this.groups.slice();e.sort(((d,f)=>{const p=this.materials[d.materialIndex],m=this.materials[f.materialIndex],g=+m.visible+ +m.colorWrite-(+p.visible+ +p.colorWrite),v=+p.transparent-+m.transparent;return g!==0?g:v}));const t=[];e.reduce(((d,f)=>(f.materialIndex!==void 0&&d.indexOf(f.materialIndex)===-1&&d.push(f.materialIndex),d)),t);const n=[];for(let d=0;d<t.length;d++)n.push(e.filter((f=>f.materialIndex===t[d])));const i=this.getCurrentTransformBuffer(),r=this.getNextTransformBuffer(),s=this.getCurrentGradientBuffer(),o=new Float32Array(s.length),l=[],c=this.renderViews.slice();c.sort(((d,f)=>d.batchStart-f.batchStart));let u=0;for(let d=0;d<n.length;d++){const f=n[d],p=u;let m=0;for(let g=0;g<f.length;g++){const v=f[g].start,y=f[g].count;let w=i.subarray(v,v+y);r.set(w,u),w=s.subarray(v/qn,(v+y)/qn),o.set(w,u/qn);let x=0;for(let S=0;S<c.length;S++)c[S].batchStart>=v&&c[S].batchEnd<=v+y&&(c[S].setBatchData(this.id,u+x,c[S].batchCount),x+=c[S].batchCount,c.splice(S,1),S--);u+=y,m+=y}l.push({offset:p,count:m,materialIndex:f[0].materialIndex})}this.groups.length=0;for(let d=0;d<l.length;d++)this.groups.push({start:l[d].offset,count:l[d].count,materialIndex:l[d].materialIndex});s.set(o,0),this.mesh.updateDrawGroups(r,s,this.getCurrentObjectIndexBuffer());const h=this.groups.find((d=>d.materialIndex!==void 0&&this.materials[d.materialIndex].visible===!1));h&&this.setVisibleRange([{offset:0,count:h.start}])}resetDrawRanges(){this.groups.length=0,this.materials.length=0,this.groups.push({start:0,count:this.renderViews.length*qn,materialIndex:0}),this.materials.push(this.batchMaterial),this.setVisibleRange([en]),this.mesh.updateDrawGroups(this.getCurrentTransformBuffer(),this.getCurrentGradientBuffer(),this.getCurrentObjectIndexBuffer())}getCurrentTransformBuffer(){return this.transformBufferIndex%2==0?this.instanceTransformBuffer0:this.instanceTransformBuffer1}getNextTransformBuffer(){return++this.transformBufferIndex%2==0?this.instanceTransformBuffer0:this.instanceTransformBuffer1}getCurrentGradientBuffer(){return this.instanceGradientBuffer}getCurrentObjectIndexBuffer(){return this.instanceObjectIdBuffer}buildBatch(){var e,t,n,i,r,s,o,l,c,u,h;const d=[];let f=null;this.instanceTransformBuffer0=new Float32Array(this.renderViews.length*qn),this.instanceTransformBuffer1=new Float32Array(this.renderViews.length*qn);const p=this.getCurrentTransformBuffer(),m=(e=this.renderViews[0].renderData.geometry.attributes)===null||e===void 0?void 0:e.POSITION.getFloat32Array(),g=(n=(t=this.renderViews[0].renderData.geometry.attributes)===null||t===void 0?void 0:t.INDEX.length)!==null&&n!==void 0?n:0,v=(r=(i=this.renderViews[0].renderData.geometry.attributes)===null||i===void 0?void 0:i.POSITION.length)!==null&&r!==void 0?r:0,y=g<65535&&v<65535?(s=this.renderViews[0].renderData.geometry.attributes)===null||s===void 0?void 0:s.INDEX.getUint16Array():(o=this.renderViews[0].renderData.geometry.attributes)===null||o===void 0?void 0:o.INDEX.getUint32Array(),w=(c=(l=this.renderViews[0].renderData.geometry.attributes)===null||l===void 0?void 0:l.COLOR)===null||c===void 0?void 0:c.getFloat32Array(),x=(h=(u=this.renderViews[0].renderData.geometry.attributes)===null||u===void 0?void 0:u.NORMAL)===null||h===void 0?void 0:h.getFloat32Array();for(let S=0;S<this.renderViews.length;S++){const b=this.renderViews[S];if(!b.renderData.geometry.transform)throw new Error(`Instanced Render view with id ${b.renderData.id} has null transform!`);b.renderData.geometry.transform.toArray(p,S*qn),this.renderViews[S].setBatchData(this.id,S*qn,qn),this.instanceObjectIdBuffer&&(this.instanceObjectIdBuffer[S]=S);const E=new rb(this.renderViews[S],S);if(!f){const M=new ae().makeTranslation(E.localOrigin.x,E.localOrigin.y,E.localOrigin.z);M.invert(),f=zi.buildBVH(y,m,Zf,M),f.refit()}E.buildAccelerationStructure(f),d.push(E)}if(!y||!m)throw new Error(`Cannot build batch ${this.id}. Undefined indices or positions`);return this.geometry=this.makeInstancedMeshGeometry(y,m,x,w),this.mesh=new bu(this.geometry),this.mesh.setBatchObjects(d),this.mesh.setBatchMaterial(this.batchMaterial),this.mesh.buildTAS(),this.geometry.boundingBox=this.mesh.TAS.getBoundingBox(new He),this.geometry.boundingSphere=this.geometry.boundingBox.getBoundingSphere(new rn),this.mesh.uuid=this.id,this.mesh.layers.set(re.STREAM_CONTENT_MESH),this.mesh.frustumCulled=!1,this.groups.push({start:0,count:this.renderViews.length*qn,materialIndex:0}),this.mesh.updateDrawGroups(this.getCurrentTransformBuffer(),this.getCurrentGradientBuffer(),this.getCurrentObjectIndexBuffer()),Promise.resolve()}getRenderView(e){return De.warn("Deprecated! Use InstancedBatchObject"),null}getMaterialAtIndex(e){return De.warn("Deprecated! Use InstancedBatchObject"),null}getMaterial(e){const t=this.groups.find((n=>e.batchStart>=n.start&&e.batchStart+e.batchCount<=n.count+n.start));return t?this.materials[t.materialIndex]:(De.warn(`Could not get material for ${e.renderData.id}`),null)}makeInstancedMeshGeometry(e,t,n,i){const r=new nt;t&&r.setAttribute("position",new je(t,3)),i&&r.setAttribute("color",new je(i,3));let s=null;return s=t.length>=65535||e.length>=65535?new ys(e,1):new _i(e,1),r.setIndex(s),this.instanceGradientBuffer=new Float32Array(this.renderViews.length),n?r.setAttribute("normal",new je(n,3)).normalizeNormals():ft.computeVertexNormals(r,t),r}updateGradientIndexBufferData(e,t,n){const i=this.getCurrentGradientBuffer();for(let r=e;r<t;r++)i[r]=n}purge(){this.renderViews.length=0,this.geometry.dispose(),this.batchMaterial.dispose()}}class sb{constructor(){this.needsShuffle=!1}get materials(){return this.primitive.material}get groups(){return this.primitive.geometry.groups}set groups(e){this.primitive.geometry.groups=e}get renderObject(){return this.primitive}get drawCalls(){return this.groups.length}get vertCount(){return this.primitive.geometry.attributes.position.count}getCount(){var e;return((e=this.primitive.geometry.index)===null||e===void 0?void 0:e.count)||0}setBatchMaterial(e){this.batchMaterial=e}onUpdate(){this.needsShuffle&&(this.shuffleDrawGroups(),this.needsShuffle=!1)}setVisibleRange(e){if(e.length===1&&o0(e[0]))return this.primitive.geometry.setDrawRange(0,0),void(this.primitive.visible=!1);if(e.length===1&&e[0]===en)return this.primitive.geometry.setDrawRange(0,this.getCount()),void(this.primitive.visible=!0);let t=1/0,n=0;e.forEach((r=>{t=Math.min(t,r.offset),n=Math.max(n,r.offset)}));const i=e.find((r=>r.offset===n));this.primitive.geometry.setDrawRange(t,n-t+(i?i.count:0)),this.primitive.visible=!0}getVisibleRange(){return this.groups.length===1&&this.primitive.visible?en:this.primitive.visible?{offset:this.primitive.geometry.drawRange.start,count:this.primitive.geometry.drawRange.count}:Fn}getOpaque(){const e=this.groups.find((t=>t.materialIndex!==void 0&&(Tt.isTransparent(this.materials[t.materialIndex])||this.materials[t.materialIndex].visible===!1)));return e?{offset:0,count:e.start}:en}getDepth(){const e=this.groups.find((t=>t.materialIndex!==void 0&&(Tt.isTransparent(this.materials[t.materialIndex])||this.materials[t.materialIndex].visible===!1||this.materials[t.materialIndex].colorWrite===!1)));return e?{offset:0,count:e.start}:en}getTransparent(){const e=this.groups.find((n=>n.materialIndex!==void 0&&Tt.isTransparent(this.materials[n.materialIndex]))),t=this.groups.find((n=>n.materialIndex!==void 0&&this.materials[n.materialIndex].visible===!1));return e?{offset:e.start,count:t!==void 0?t.start-e.start:this.getCount()-e.start}:Fn}getStencil(){if(this.groups.length===1&&this.materials[0].stencilWrite===!0)return en;const e=this.groups.find((t=>t.materialIndex!==void 0&&this.materials[t.materialIndex].stencilWrite===!0));return e?{offset:e.start,count:e.count}:Fn}setBatchBuffers(e){let t=1/0,n=0;for(let i=0;i<e.length;i++){const r=e[i];if(r.materialOptions){if(r.materialOptions.rampIndex!==void 0&&r.materialOptions.rampWidth!==void 0){const s=e[i].offset,o=e[i].offset+e[i].count,l=r.materialOptions.rampIndex+.5/r.materialOptions.rampWidth,c=this.updateGradientIndexBufferData(s,r.count===1/0?this.primitive.geometry.attributes.gradientIndex.array.length:o,l);t=Math.min(t,c.minIndex),n=Math.max(n,c.maxIndex)}r.materialOptions.rampTexture!==void 0&&(r.material instanceof Ha||r.material instanceof Ag)&&r.material.setGradientTexture(r.materialOptions.rampTexture)}}t<1/0&&n>0&&this.updateGradientIndexBuffer()}cleanMaterials(){const e=[...Array.from(new Set(this.groups.map((n=>{if(n.materialIndex!==void 0)return this.materials[n.materialIndex]}))))];let t=0;for(;this.materials.length>e.length;)e.includes(this.materials[t])?t++:(this.materials.splice(t,1),this.groups.forEach((n=>{n.materialIndex!==void 0&&n.materialIndex>t&&n.materialIndex--})),t=0)}shuffleDrawGroups(){const e=this.groups.slice();e.sort(this.shuffleMaterialOrder.bind(this));const t=[];e.reduce(((d,f)=>(f.materialIndex!==void 0&&d.indexOf(f.materialIndex)===-1&&d.push(f.materialIndex),d)),t);const n=[];for(let d=0;d<t.length;d++)n.push(e.filter((f=>f.materialIndex===t[d])));const i=this.getCurrentIndexBuffer(),r=this.getNextIndexBuffer(),s=i.array,o=r.array,l=[],c=this.renderViews.slice();c.sort(((d,f)=>d.batchStart-f.batchStart));let u=0;for(let d=0;d<n.length;d++){const f=n[d],p=u;let m=0;for(let g=0;g<f.length;g++){const v=f[g].start,y=f[g].count,w=s.subarray(v,v+y);o.set(w,u);let x=0;for(let S=0;S<c.length;S++)c[S].batchStart>=v&&c[S].batchEnd<=v+y&&(c[S].setBatchData(this.id,u+x,c[S].batchCount),x+=c[S].batchCount,c.splice(S,1),S--);u+=y,m+=y}l.push({offset:p,count:m,materialIndex:f[0].materialIndex})}this.groups=[];for(let d=0;d<l.length;d++)this.primitive.geometry.addGroup(l[d].offset,l[d].count,l[d].materialIndex);this.primitive.geometry.setIndex(r),this.primitive.geometry.index&&(this.primitive.geometry.index.needsUpdate=!0);const h=this.groups.find((d=>d.materialIndex!==void 0&&this.materials[d.materialIndex].visible===!1));h?this.setVisibleRange([{offset:0,count:h.start}]):this.setVisibleRange([en])}updateGradientIndexBuffer(e,t){this.gradientIndexBuffer.updateRange={offset:e!==void 0?e:0,count:e!==void 0&&t!==void 0?t-e+1:-1},this.gradientIndexBuffer.needsUpdate=!0,this.primitive.geometry.attributes.gradientIndex.needsUpdate=!0}resetDrawRanges(){this.primitive.visible=!0,this.primitive.geometry.clearGroups(),this.primitive.geometry.addGroup(0,this.getCount(),0),this.primitive.geometry.setDrawRange(0,1/0)}getMaterial(e){for(let t=0;t<this.groups.length;t++){const n=this.groups[t];if(e.batchStart>=n.start&&e.batchEnd<=n.start+n.count)return this.materials[n.materialIndex]}return null}purge(){this.renderViews.length=0,this.primitive.geometry.dispose(),this.batchMaterial.dispose()}}class Tg extends sb{get bounds(){return this.primitive.TAS.getBoundingBox(new He)}get minDrawCalls(){return[...Array.from(new Set(this.groups.map((e=>e.materialIndex))))].length}get triCount(){return this.getCount()/3}get pointCount(){return 0}get lineCount(){return 0}get geometryType(){return ze.MESH}get mesh(){return this.primitive}constructor(e,t,n,i){super(),this.indexBufferIndex=0,this.drawRanges=new Kf,this.id=e,this.subtreeId=t,this.renderViews=n,this.transformStorage=i}getCurrentIndexBuffer(){return this.indexBufferIndex%2==0?this.indexBuffer0:this.indexBuffer1}getNextIndexBuffer(){return++this.indexBufferIndex%2==0?this.indexBuffer0:this.indexBuffer1}shuffleMaterialOrder(e,t){const n=this.materials[e.materialIndex],i=this.materials[t.materialIndex],r=+i.visible-+n.visible,s=+i.colorWrite-+n.colorWrite,o=+n.transparent-+i.transparent;return r!==0?r:s!==0?s:o}updateGradientIndexBufferData(e,t,n){if(!this.primitive.geometry.index)throw new Error(`Invalid geometry on batch ${this.id}`);const i=this.primitive.geometry.index.array,r=this.gradientIndexBuffer.array;let s=1/0,o=0;for(let l=e;l<t;l++){const c=i[l];s=Math.min(s,c),o=Math.max(o,c),r[c]=n}return this.gradientIndexBuffer.updateRange={offset:s,count:o-s+1},this.gradientIndexBuffer.needsUpdate=!0,this.primitive.geometry.attributes.gradientIndex.needsUpdate=!0,{minIndex:s,maxIndex:o}}setDrawRanges(e){e.forEach((r=>{r.material&&(r.material=this.primitive.getCachedMaterial(r.material))}));const t=e.map((r=>r.material)),n=[...Array.from(new Set(t.map((r=>r))))];for(let r=0;r<n.length;r++)this.materials.includes(n[r])||this.materials.push(n[r]);this.groups=this.drawRanges.integrateRanges(this.groups,this.materials,e);let i=0;if(this.groups.forEach((r=>i+=r.count)),i!==this.getCount()&&De.error(`Draw groups invalid on ${this.id}, ${this.renderViews[0].renderData.id}, ${this.getCount()}, ${this.getCount()-i}`),this.setBatchBuffers(e),this.cleanMaterials(),this.drawCalls>this.minDrawCalls+2)this.needsShuffle=!0;else{const r=this.groups.find((s=>this.materials[s.materialIndex].transparent===!0||this.materials[s.materialIndex].visible===!1||this.materials[s.materialIndex].colorWrite===!1));if(r)if(this.groups.length===1)this.needsShuffle=!0;else for(let s=this.groups.indexOf(r);s<this.groups.length;s++){const o=this.materials[this.groups[s].materialIndex];if(o.visible&&(!o.transparent||o.colorWrite)){this.needsShuffle=!0;break}}}}resetDrawRanges(){super.resetDrawRanges(),this.primitive.setBatchMaterial(this.batchMaterial)}buildBatch(){var e,t,n,i,r,s,o,l,c,u,h,d,f,p;let m=0,g=0;const v=new He,y=new He;for(let P=0;P<this.renderViews.length;P++){const F=this.renderViews[P];if(!F.renderData.geometry.attributes||!F.renderData.geometry.attributes.INDEX)throw new Error(`Cannot build batch ${this.id}. Invalid geometry, or indices`);m+=F.renderData.geometry.attributes.INDEX.length,g+=F.renderData.geometry.attributes.POSITION.length,y.union(F.aabb)}const w=ft.needsRTE(y),x=((e=this.renderViews[0].renderData.geometry.attributes)===null||e===void 0?void 0:e.COLOR)!==void 0,S=g>=65535||m>=65535?new Uint32Array(m):new Uint16Array(m),b=w?new Float64Array(g):new Float32Array(g),E=new Float32Array(x?g:0);E.fill(1);const M=new Float32Array(g/3),T=new Float32Array(g);let I=0,O=0;const R=[];for(let P=0;P<this.renderViews.length;P++){const F=this.renderViews[P].renderData.geometry;if(!F.attributes||!(!((t=F.attributes)===null||t===void 0)&&t.INDEX))throw new Error(`Cannot build batch ${this.id}. Invalid geometry, or indices`);(n=F.attributes)===null||n===void 0||n.INDEX.copyToBuffer(S,O);const N=S.subarray(O,O+((i=F.attributes)===null||i===void 0?void 0:i.INDEX.length));(r=F.attributes)===null||r===void 0||r.POSITION.copyToBuffer(b,I);const Y=b.subarray(I,I+((o=(s=this.renderViews[P].renderData.geometry.attributes)===null||s===void 0?void 0:s.POSITION.length)!==null&&o!==void 0?o:0));ft.transformArray(Y,F.transform,0,(l=F.attributes)===null||l===void 0?void 0:l.POSITION.length),F.attributes.COLOR&&((c=F.attributes)===null||c===void 0||c.COLOR.copyToBuffer(E,I)),F.attributes.NORMAL?((u=F.attributes)===null||u===void 0||u.NORMAL.copyToBuffer(T,I),F.flipNormals&&ft.flipNormalsBuffer(T.subarray(I,I+((h=F.attributes)===null||h===void 0?void 0:h.NORMAL.length)))):ft.computeVertexNormalsBufferVirtual(T.subarray(I,I+((f=(d=this.renderViews[P].renderData.geometry.attributes)===null||d===void 0?void 0:d.POSITION.length)!==null&&f!==void 0?f:0)),F.attributes.POSITION,F.attributes.INDEX,F.flipNormals),M.fill(P,I/3,I/3+F.attributes.POSITION.length),this.renderViews[P].setBatchData(this.id,O,F.attributes.INDEX.length,I/3,I/3+F.attributes.POSITION.length),v.setFromArray(Y),this.renderViews[P].aabb=v;const _=new Mt(this.renderViews[P],P);_.buildAccelerationStructure(Y,N),R.push(_),S.set((p=_.accelerationStructure.bvh.geometry.index)===null||p===void 0?void 0:p.array,O);for(let G=0;G<N.length;G++)N[G]=N[G]+I/3;I+=F.attributes.POSITION.length,O+=F.attributes.INDEX.length,this.renderViews[P].disposeGeometry()}const k=this.makeMeshGeometry(S,b,T,M,x?E:void 0);return w&&ft.updateRTEGeometry(k,b),this.primitive=new wl(k,w),this.primitive.setBatchObjects(R,this.transformStorage),this.primitive.setBatchMaterial(this.batchMaterial),this.primitive.buildTAS(),this.primitive.geometry.boundingBox=this.primitive.TAS.getBoundingBox(new He),this.primitive.geometry.boundingSphere=this.primitive.geometry.boundingBox.getBoundingSphere(new rn),this.primitive.uuid=this.id,this.primitive.layers.set(re.STREAM_CONTENT_MESH),this.primitive.frustumCulled=!1,this.primitive.geometry.addGroup(0,this.getCount(),0),Promise.resolve()}makeMeshGeometry(e,t,n,i,r){const s=new nt;t.length>=65535||e.length>=65535?(this.indexBuffer0=new ys(e,1),this.indexBuffer1=new ys(e,1)):(this.indexBuffer0=new _i(e,1),this.indexBuffer1=new _i(e,1)),s.setIndex(this.indexBuffer0),t&&s.setAttribute("position",new je(t,3)),n&&s.setAttribute("normal",new je(n,3)).normalizeNormals(),i&&s.setAttribute("objIndex",new je(i,1)),r&&s.setAttribute("color",new je(r,3));const o=new Float32Array(t.length/3);return this.gradientIndexBuffer=new je(o,1),this.gradientIndexBuffer.setUsage(Xn),s.setAttribute("gradientIndex",this.gradientIndexBuffer),s}getRenderView(e){return De.warn("Deprecated! Use BatchObject"),null}getMaterialAtIndex(e){return De.warn("Deprecated! Use BatchObject"),null}}class Cg extends sb{get geometryType(){return this.renderViews[0].geometryType}get bounds(){return this.primitive.geometry.boundingBox||this.primitive.geometry.computeBoundingBox(),this.primitive.geometry.boundingBox?this.primitive.geometry.boundingBox:new He}get minDrawCalls(){return this.materials.length}get triCount(){return 0}get pointCount(){return this.getCount()}get lineCount(){return 0}constructor(e,t,n){super(),this.drawRanges=new Kf,this.id=e,this.subtreeId=t,this.renderViews=n}setDrawRanges(e){const t=e.map((r=>r.material)),n=[...Array.from(new Set(t.map((r=>r))))];for(let r=0;r<n.length;r++)this.materials.includes(n[r])||this.materials.push(n[r]);this.groups=this.drawRanges.integrateRanges(this.groups,this.materials,e);let i=0;if(this.groups.forEach((r=>i+=r.count)),i!==this.getCount()&&De.error(`Draw groups invalid on ${this.id}`),this.setBatchBuffers(e),this.cleanMaterials(),this.drawCalls>this.minDrawCalls+2)this.needsShuffle=!0;else{const r=this.groups.find((s=>this.materials[s.materialIndex].transparent===!0||this.materials[s.materialIndex].visible===!1));if(r)for(let s=this.groups.indexOf(r);s<this.groups.length;s++){const o=this.materials[this.groups[s].materialIndex];if(o.transparent!==!0&&o.visible!==!1){this.needsShuffle=!0;break}}}}resetDrawRanges(){super.resetDrawRanges(),this.primitive.material=[this.batchMaterial]}getCurrentIndexBuffer(){if(!this.primitive.geometry.index)throw new Error(`Invalid index buffer for batch ${this.id}`);return this.primitive.geometry.index}getNextIndexBuffer(){if(!this.primitive.geometry.index)throw new Error(`Invalid index buffer for batch ${this.id}`);return new wt(this.primitive.geometry.index.array.slice(),this.primitive.geometry.index.itemSize)}shuffleMaterialOrder(e,t){const n=this.materials[e.materialIndex],i=this.materials[t.materialIndex],r=+i.visible-+n.visible,s=+n.transparent-+i.transparent;return r!==0?r:s}updateGradientIndexBufferData(e,t,n){return this.gradientIndexBuffer.array.fill(n,e,t),this.gradientIndexBuffer.updateRange={offset:e,count:t-e},this.gradientIndexBuffer.needsUpdate=!0,this.primitive.geometry.attributes.gradientIndex.needsUpdate=!0,{minIndex:e,maxIndex:t}}buildBatch(){var e,t,n,i,r,s;let o=0;const l=new He,c=new He;for(let w=0;w<this.renderViews.length;w++){const x=this.renderViews[w];if(!x.renderData.geometry.attributes)throw new Error(`Cannot build batch ${this.id}. Invalid geometry, or indices`);o+=x.renderData.geometry.attributes.POSITION.length,c.union(x.aabb)}const u=ft.needsRTE(c),h=((e=this.renderViews[0].renderData.geometry.attributes)===null||e===void 0?void 0:e.COLOR)!==void 0,d=o>=65535,f=u?new Float64Array(o):new Float32Array(o),p=new Float32Array(h?o:0).fill(1),m=d?new Uint32Array(o/3):new Uint16Array(o/3);let g=0,v=0;for(let w=0;w<this.renderViews.length;w++){const x=this.renderViews[w].renderData.geometry;if(!x.attributes)throw new Error(`Cannot build batch ${this.id}. Invalid geometry, or indices`);(t=x.attributes)===null||t===void 0||t.POSITION.copyToBuffer(f,g);const S=f.subarray(g,g+((i=(n=this.renderViews[w].renderData.geometry.attributes)===null||n===void 0?void 0:n.POSITION.length)!==null&&i!==void 0?i:0));ft.transformArray(S,x.transform,0,(r=x.attributes)===null||r===void 0?void 0:r.POSITION.length),x.attributes.COLOR&&((s=x.attributes)===null||s===void 0||s.COLOR.copyToBuffer(p,g)),m.set((d?new Uint32Array(x.attributes.POSITION.length/3):new Uint16Array(x.attributes.POSITION.length/3)).map(((b,E)=>E+v)),v),l.setFromArray(S),this.renderViews[w].aabb=l,this.renderViews[w].setBatchData(this.id,g/3,x.attributes.POSITION.length/3),g+=x.attributes.POSITION.length,v+=x.attributes.POSITION.length/3,this.renderViews[w].disposeGeometry()}const y=this.makePointGeometry(m,f,p);return u&&(ft.updateRTEGeometry(y,f),this.batchMaterial.defines||(this.batchMaterial.defines={}),this.batchMaterial.defines.USE_RTE=" "),this.primitive=new ms(y,this.batchMaterial),this.primitive.material=[this.batchMaterial],this.primitive.geometry.addGroup(0,this.getCount(),0),this.primitive.uuid=this.id,this.primitive.layers.set(this.renderViews[0].geometryType===ze.POINT?re.STREAM_CONTENT_POINT:re.STREAM_CONTENT_POINT_CLOUD),Promise.resolve()}makePointGeometry(e,t,n){const i=new nt;i.setAttribute("position",new je(t,3)),i.setAttribute("color",new je(n,3)),t.length>=65535||e.length>=65535?i.setIndex(new ys(e,1)):i.setIndex(new _i(e,1));const r=new Float32Array(t.length/3);return this.gradientIndexBuffer=new je(r,1),this.gradientIndexBuffer.setUsage(Xn),i.setAttribute("gradientIndex",this.gradientIndexBuffer),i.computeBoundingSphere(),i.computeBoundingBox(),i}getRenderView(e){for(let t=0;t<this.renderViews.length;t++)if(e>=this.renderViews[t].batchStart&&e<this.renderViews[t].batchEnd)return this.renderViews[t];return null}getMaterialAtIndex(e){for(let t=0;t<this.renderViews.length;t++)if(e>=this.renderViews[t].batchStart&&e<this.renderViews[t].batchEnd){const n=this.renderViews[t],i=this.groups.find((r=>n.batchStart>=r.start&&n.batchStart+n.batchCount<=r.count+r.start));return i?this.materials[i.materialIndex]:(De.warn("Malformed material index!"),null)}return null}}var ut,Ct,kn;(function(a){a.OPAQUE="opaque",a.TRANSPARENT="transparent",a.DEPTH="depth",a.STENCIL="stencil",a.CUSTOM="custom"})(ut||(ut={})),(function(a){a[a.COLOR=256]="COLOR",a[a.DEPTH=1024]="DEPTH",a[a.STENCIL=16384]="STENCIL"})(Ct||(Ct={}));class Ts{constructor(){this._enabled=!0,this.layers=null,this._enabledLayers=[],this._objectVisibility=null,this._jitter=!1,this._options={},this._clearColor=void 0,this._clearAlpha=void 0,this._clearFlags=void 0,this._outputTarget=null,this.onBeforeRender=void 0,this.onAfterRender=void 0,this._visibilityFunction=()=>{throw new Error("Undefined visibility function")}}get enabledLayers(){return this._enabledLayers}get displayName(){return"BASE"}get outputTarget(){return this._outputTarget}set outputTarget(e){this._outputTarget=e}get enabled(){return this._enabled}set enabled(e){this._enabled=e}set options(e){Object.assign(this._options,e)}get visibility(){return this._objectVisibility}get overrideMaterial(){return null}get overrideBatchMaterial(){return null}get jitter(){return this._jitter}get clearColor(){return this._clearColor}get clearAlpha(){return this._clearAlpha}get clearFlags(){return this._clearFlags}get visibilityFunction(){return this._visibilityFunction}setClearColor(e,t){this._clearColor=e,this._clearAlpha=t}setClearFlags(e){this._clearFlags=e}setLayers(e){this.layers=e,this._enabledLayers=e.slice()}enableLayer(e,t){this._enabledLayers.includes(e)?t||this._enabledLayers.splice(this._enabledLayers.indexOf(e),1):t&&this._enabledLayers.push(e)}setVisibility(e,t){this._objectVisibility=e,e===ut.CUSTOM&&(this._visibilityFunction=t)}setJitter(e){this._jitter=e}applyLayers(e){e!==null&&(this.layers!==null?(e.layers.disableAll(),this.layers.forEach((t=>{this._enabledLayers.includes(t)&&e.layers.enable(t)}))):e.layers.enableAll())}clear(e){this._clearColor!==void 0&&e.setClearColor(this._clearColor,this._clearAlpha||0),this._clearColor===void 0&&this._clearFlags===void 0||e.clear(this._clearColor!==void 0||this._clearFlags!==void 0&&!!(this._clearFlags&Ct.COLOR),this._clearFlags!==void 0&&!!(this._clearFlags&Ct.DEPTH),this._clearFlags!==void 0&&!!(this._clearFlags&Ct.STENCIL))}setSize(e,t){var n;(n=this._outputTarget)===null||n===void 0||n.setSize(e,t)}}class qu extends Ts{constructor(){super(...arguments),this._frameIndex=0,this._accumulationFrames=0}get frameIndex(){return this._frameIndex}set frameIndex(e){this._frameIndex=e}get accumulationFrames(){return this._accumulationFrames}set accumulationFrames(e){this._accumulationFrames=e}render(e,t,n){return!(this._frameIndex>=this._accumulationFrames-1)}}class RN{constructor(e){this.maxBatchObjects=0,this.maxBatchVertices=5e5,this.minInstancedBatchVertices=1e4,this.maxBatchTextObjects=5e3,this.batches={},this.caps=e,this.maxBatchObjects=Math.floor((this.caps.maxVertexUniforms-Tt.UNIFORM_VECTORS_USED)/4),this.materials=new Tt,this.materials.createDefaultMaterials()}async*makeBatches(e,t,n,i){let r=Number.MAX_SAFE_INTEGER,s=-1,o=0,l=0;const c=t.getInstances(),u={},h=new jM;for(const p in c){h.tick(100),h.needsWait&&await h.wait(50);let m=e.findId(p,t.subtreeId);if(!m||(m=m.filter((v=>v.model.renderView&&v.model.renderView.speckleType===et.Mesh)),!m.length))continue;const g=m[0].model.renderView.renderData.geometry.attributes.POSITION.length/3*m.length;u[g]||(u[g]=[]),u[g].push(p)}for(const p in u)for(let m=0;m<u[p].length;m++){const g=e.findId(u[p][m],t.subtreeId);if(!g)continue;let v=!0;g.every((b=>v&&(v=b.model.instanced)));const y=g.map((b=>b.model.renderView)).filter((b=>b));let w=ft.needsRTE(y[0].aabb);if(!w){const b=y.map((T=>T.renderData.geometry.transform)).filter((T=>T!==null)),E=new He().copy(y[0].aabb),M=new He;for(let T=0;T<b.length&&(M.copy(E),M.applyMatrix4(b[T]),w||(w=ft.needsRTE(M)),!w);T++);}if(Number.parseInt(p)<this.minInstancedBatchVertices||!v||w){y.forEach((b=>{var E,M;const T=b.renderData.geometry;T.instanced=!1,b.computeAABB(T.transform),((M=(E=T.transform)===null||E===void 0?void 0:E.determinant())!==null&&M!==void 0?M:0)<0&&(T.flipNormals=!0)}));continue}const x=y[0].renderMaterialHash,S=await this.buildInstancedBatch(t,y,x);S&&(this.batches[S.id]=S,r=Math.min(r,S.renderViews.length),s=Math.max(s,S.renderViews.length),l++,yield this.batches[S.id])}const d=t.getRenderableNodes(...n).flatMap((p=>p.model.renderView?p.model.renderView.renderData.geometry.instanced?p.model.renderView.speckleType!==et.Mesh?[p.model.renderView]:[]:[p.model.renderView]:[])).sort(((p,m)=>p.renderMaterialHash===0?-1:m.renderMaterialHash===0?1:p.renderMaterialHash-m.renderMaterialHash)),f=[...Array.from(new Set(d.map((p=>p.renderMaterialHash))))];for(let p=0;p<f.length;p++){let m=d.filter((y=>y.renderMaterialHash===f[p])),g=0;if(m=m.filter((y=>{const w=y.validGeometry;return w&&(g+=y.renderData.geometry.attributes.POSITION.length/3),w||y.hasMetadata})),m.length===0)continue;const v=this.splitBatch(m,g);for(let y=0;y<v.length;y++){h.tick(100),h.needsWait&&await h.wait(50);const w=v[y],x=await this.buildBatch(t,w,f[p],i);x&&(this.batches[x.id]=x,r=Math.min(r,x.renderViews.length),s=Math.max(s,x.renderViews.length),o+=x.renderViews.length,l++,yield this.batches[x.id])}}De.warn(`Batch total: ${l} min: ${r}, max: ${s}, average: ${o/f.length}`)}splitBatch(e,t){const n=[];if(Math.floor(t/this.maxBatchVertices)>0){let o=0,l=0;n.push([]);for(let c=0;c<e.length;c++){const u=e[c],h=e[c+1];if(!u.renderData.geometry.attributes)throw new Error(`Invalid geometry on render view ${e[c].renderData.id}`);n[l].push(e[c]),o+=u.renderData.geometry.attributes.POSITION.length/3,o+(h&&h.renderData.geometry.attributes?h.renderData.geometry.attributes.POSITION.length/3:0)>=this.maxBatchVertices&&e[c+1]&&(n.push([]),l++,o=0)}}else n.push(e);const i=e[0].geometryType,r=this.getMaxObjectCount(i);if(!r)return n;const s=[];for(let o=0;o<n.length;o++){const l=n[o].length,c=Math.floor(l/r),u=l%r;let h=0;for(let d=0;d<c;d++)s.push(n[o].slice(h,h+r)),h+=r;u>0&&s.push(n[o].slice(h,h+u))}return s}getMaxObjectCount(e){switch(e){case ze.MESH:return this.maxBatchObjects;case ze.TEXT:return this.maxBatchTextObjects;default:return 0}}async buildInstancedBatch(e,t,n){if(!t.length)return De.warn("All renderviews have invalid geometries. Skipping batch!",t),null;const i=t[0].renderData.renderMaterial,r=this.materials.getMaterial(n,i,ze.MESH),s=It.generateUUID(),o=new Eg(s,e.id,t,this.caps.isWebGL2);return o.setBatchMaterial(r),await o.buildBatch(),o}async buildBatch(e,t,n,i){if(!t.length)return De.warn("All renderviews have invalid geometries. Skipping batch!",t),null;const r=i!==void 0?i:t[0].geometryType;let s=t[0].renderData.renderMaterial;r===ze.MESH?s=t[0].renderData.renderMaterial:r===ze.LINE?s=t[0].renderData.colorMaterial?t[0].renderData.colorMaterial:t[0].renderData.displayStyle:r===ze.POINT?s=t[0].renderData.colorMaterial?t[0].renderData.colorMaterial:t[0].renderData.renderMaterial||t[0].renderData.displayStyle:r===ze.POINT_CLOUD?s=t[0].renderData.renderMaterial:r===ze.TEXT&&(s=t[0].renderData.colorMaterial?t[0].renderData.colorMaterial:t[0].renderData.displayStyle);const o=this.materials.getMaterial(n,s,r),l=It.generateUUID();let c=null;switch(r){case ze.MESH:c=new Tg(l,e.id,t,this.caps.floatVertexTextures?ds.VERTEX_TEXTURE:ds.UNIFORM_ARRAY);break;case ze.LINE:c=new Mg(l,e.id,t);break;case ze.POINT:case ze.POINT_CLOUD:c=new Cg(l,e.id,t);break;case ze.TEXT:c=new bg(l,e.id,t)}return c.setBatchMaterial(o),await c.buildBatch(),c}update(e){for(const t in this.batches)this.batches[t].onUpdate(e)}render(e){for(const t in this.batches){const n=this.batches[t];n.onRender&&n.onRender(e)}}saveVisiblity(){const e={};for(const t in this.batches){const n=this.batches[t];e[t]=n.getVisibleRange()}return e}applyVisibility(e){for(const t in this.batches){const n=this.batches[t],i=e[t];i?n.setVisibleRange([i]):n.setVisibleRange([Fn])}}getVisibility(e){switch(e){case ut.OPAQUE:return this.getOpaque();case ut.TRANSPARENT:return this.getTransparent();case ut.STENCIL:return this.getStencil();case ut.DEPTH:return this.getDepth();case ut.CUSTOM:return De.error("Custom visibility requires visibility function"),{}}}getTransparent(){const e={};for(const t in this.batches)e[t]=this.batches[t].getTransparent();return e}getStencil(){const e={};for(const t in this.batches)e[t]=this.batches[t].getStencil();return e}getOpaque(){const e={};for(const t in this.batches)e[t]=this.batches[t].getOpaque();return e}getDepth(){const e={};for(const t in this.batches)e[t]=this.batches[t].getDepth();return e}overrideMaterial(e,t){for(const n in e)this.batches[n].geometryType===ze.MESH&&this.batches[n].renderObject.setOverrideMaterial(t)}overrideBatchMaterial(e,t){for(const n in e)this.batches[n].geometryType===ze.MESH&&this.batches[n].renderObject.setOverrideBatchMaterial(t)}restoreMaterial(e){for(const t in e)this.batches[t].geometryType===ze.MESH&&this.batches[t].renderObject.restoreMaterial()}restoreBatchMaterial(e){for(const t in e)this.batches[t].geometryType===ze.MESH&&this.batches[t].renderObject.restoreBatchMaterial()}purgeBatches(e){for(const t in this.batches)this.batches[t].subtreeId===e&&(this.batches[t].purge(),delete this.batches[t])}getBatches(e,t){return Object.values(this.batches).filter((n=>{const i=e===void 0||n.subtreeId===e,r=t===void 0||this.isBatchType(n,t);return i&&r}))}isBatchType(e,t){if(t===void 0)return!0;let n=!1;return(Array.isArray(t)?t:[t]).forEach((i=>{switch(i){case ze.MESH:n||(n=e instanceof Tg||e instanceof Eg);break;case ze.LINE:n||(n=e instanceof Mg);break;case ze.POINT:case ze.POINT_CLOUD:n||(n=e instanceof Cg);break;case ze.TEXT:n||(n=e instanceof bg);break;default:n=!1}})),n}getBatch(e){return this.batches[e.batchId]}getRenderView(e,t){return this.batches[e]?this.batches[e].getRenderView(t):(De.error("Invalid batch id!"),null)}getRenderViewMaterial(e,t){return this.batches[e]?this.batches[e].getMaterialAtIndex(t):(De.error("Invalid batch id!"),null)}resetBatchesDrawRanges(){for(const e in this.batches)this.batches[e].resetDrawRanges()}isolateBatch(e){for(const t in this.batches)t!==e&&this.batches[t].setDrawRanges([{offset:0,count:this.batches[t].getCount(),material:this.materials.getFilterMaterial(this.batches[t].renderViews[0],{filterType:ei.GHOST})}])}}(function(a){a.PointerDown="pointer-down",a.PointerUp="pointer-up",a.PointerMove="pointer-move",a.PointerCancel="pointer-cancel",a.Wheel="wheel",a.Click="click",a.DoubleClick="double-click",a.KeyUp="key-up"})(kn||(kn={}));class oo extends Ku{constructor(e){let t;super(),this.tapTimeout=0,this.lastTap=0,this.lastClick=0,this.container=e,this.container.addEventListener("pointerdown",(n=>{n.preventDefault();const i=this._getNormalisedClickPosition(n);i.event=n,t=new Date().getTime(),this.emit(kn.PointerDown,i)})),this.container.addEventListener("pointerup",(n=>{n.preventDefault();const i=this._getNormalisedClickPosition(n);i.event=n,this.emit(kn.PointerUp,i);const r=new Date().getTime(),s=r-t,o=r-this.lastClick;s>oo.MIN_CLICK_TIMING||o<oo.MAX_DOUBLE_CLICK_TIMING||(n.shiftKey&&(i.multiSelect=!0),this.emit(kn.Click,i),this.lastClick=new Date().getTime())})),this.container.addEventListener("touchstart",(n=>{this.touchLocation=n.targetTouches[0]})),this.container.addEventListener("touchend",(n=>{if(n.targetTouches.length>0)return;const i=new Date().getTime(),r=i-this.lastTap;if(clearTimeout(this.tapTimeout),r<500&&r>0){if(this.touchLocation){const s=this._getNormalisedClickPosition(this.touchLocation);this.emit(kn.DoubleClick,s)}}else this.tapTimeout=setTimeout((()=>{clearTimeout(this.tapTimeout)}),500);this.lastTap=i})),this.container.addEventListener("dblclick",(n=>{const i=this._getNormalisedClickPosition(n);i.event=n,n.shiftKey&&(i.multiSelect=!0),this.emit(kn.DoubleClick,i)})),this.container.addEventListener("pointermove",(n=>{const i=this._getNormalisedClickPosition(n);i.event=n,this.emit(kn.PointerMove,i)})),document.addEventListener("keyup",(n=>{this.emit(kn.KeyUp,n)})),document.addEventListener("wheel",(n=>{this.emit(kn.Wheel,n)})),document.addEventListener("pointercancel",(n=>{const i=this._getNormalisedClickPosition(n);i.event=n,this.emit(kn.PointerUp,i),this.emit(kn.PointerCancel,i)}))}on(e,t){super.on(e,t)}_getNormalisedClickPosition(e){const t=this.container,n=this.container.getBoundingClientRect(),i=(e.clientX-n.left)*t.width/n.width,r=(e.clientY-n.top)*t.height/n.height;return new te(i/t.width*2-1,r/t.height*-2+1)}dispose(){super.dispose()}}oo.MAX_DOUBLE_CLICK_TIMING=500,oo.MIN_CLICK_TIMING=200;const PN=0,DN=1,ON=2;class BN extends Wu{constructor(e,t,n=0,i=1/0){super(e,t,n,i),this.intersectTASOnly=!1,this.onObjectIntersectionTest=null,this.layers.disableAll(),this.layers.enable(re.STREAM_CONTENT),this.layers.enable(re.STREAM_CONTENT_MESH),this.layers.enable(re.STREAM_CONTENT_LINE),this.layers.enable(re.STREAM_CONTENT_TEXT),this.layers.enable(re.STREAM_CONTENT_POINT_CLOUD),this.layers.enable(re.STREAM_CONTENT_POINT),this.params={Line2:{threshold:0}}}intersectObjects(e,t=!0,n=[]){for(let i=0,r=e.length;i<r;i++){const s=ab(e[i],this,n,t);if(this.firstHitOnly===!0&&!s)break}return n.sort(LN),n}}function LN(a,e){return a.distance-e.distance}function ab(a,e,t,n){const i=t.length;if(a.layers.test(e.layers)&&(e.onObjectIntersectionTest&&e.onObjectIntersectionTest(a),a.raycast(e,t)),e.firstHitOnly===!0&&t.length-i>0)return!0;let r=!1;if(n&&(n=a.userData.raycastChildren==null||a.userData.raycastChildren),n===!0){const s=a.children;for(let o=0,l=s.length;o<l&&(r=ab(s[o],e,t,!0),e.firstHitOnly!==!0||!r);o++);}return r}class ob{constructor(){this.boxBuffer=new He,this.vec0Buffer=new lt,this.vec1Buffer=new lt,this.raycaster=new BN,this.raycaster.params.Line={threshold:.01},this.raycaster.params.Points={threshold:.01},this.raycaster.params.Line2={threshold:1},this.raycaster.onObjectIntersectionTest=this.onObjectIntersection.bind(this)}onObjectIntersection(e){if(e instanceof ao){const t=this.boxBuffer.setFromObject(e),n=this.vec0Buffer.set(t.min.x,t.min.y,t.min.z,1),i=this.vec1Buffer.set(t.max.y,t.max.y,t.max.z,1);n.applyMatrix4(this.raycaster.camera.matrixWorldInverse).applyMatrix4(this.raycaster.camera.projectionMatrix),i.applyMatrix4(this.raycaster.camera.matrixWorldInverse).applyMatrix4(this.raycaster.camera.projectionMatrix),n.multiplyScalar(.5).multiplyScalar(1/n.w).addScalar(.5),i.multiplyScalar(.5).multiplyScalar(1/i.w).addScalar(.5);const r=new te().set(n.x,n.y).distanceTo(new te(i.x,i.y)),s=e.material,o=s.linewidth,l=s.worldUnits;this.raycaster.params.Line2.threshold=l?r<1?2*o:o:r<1?8*o:5*o}}intersect(e,t,n,i=void 0,r=!0,s,o=!1,l=!1){this.raycaster.setFromCamera(n,t),this.raycaster.firstHitOnly=o,this.raycaster.intersectTASOnly=l;const c=this.setRaycasterLayers(i);let u;return u=(re.STREAM_CONTENT_MESH,this.intersectInternal(e,r,s)),this.raycaster.layers.mask=c,u}intersectRay(e,t,n,i=void 0,r=!0,s,o=!1,l=!1){this.raycaster.camera=t,this.raycaster.set(n.origin,n.direction),this.raycaster.firstHitOnly=o,this.raycaster.intersectTASOnly=l;const c=this.setRaycasterLayers(i);let u;return u=(re.STREAM_CONTENT_MESH,this.intersectInternal(e,r,s)),this.raycaster.layers.mask=c,u}setRaycasterLayers(e){const t=this.raycaster.layers.mask;return e!==void 0&&(this.raycaster.layers.disableAll(),Array.isArray(e)?e.forEach((n=>{this.raycaster.layers.enable(n)})):this.raycaster.layers.enable(e)),t}intersectInternal(e,t,n){let i=[];const r=e.getObjectByName("ContentGroup");return r&&(i=this.raycaster.intersectObjects(r.children)),i.length===0?null:(t&&i.sort(((s,o)=>s.distance-o.distance)),n&&(this.boundsBuffer=ca.expandBoxRelative(n),i=i.filter((s=>this.boundsBuffer.containsPoint(s.point)||!!s.pointOnLine&&this.boundsBuffer.containsPoint(s.pointOnLine)))),i)}}ob.aabbPlanePoints=(a,e)=>{const t=new On,n=new Array,i=new A(e.max.x-e.min.x,0,0),r=new A().copy(e.min);t.set(r,i);let s=t.distanceToPlane(a);return s&&n.push(new A().copy(r).addScaledVector(i,s)),r.set(e.min.x,e.max.y,e.min.z),t.set(r,i),s=t.distanceToPlane(a),s&&n.push(new A().copy(r).addScaledVector(i,s)),r.set(e.min.x,e.min.y,e.max.z),t.set(r,i),s=t.distanceToPlane(a),s&&n.push(new A().copy(r).addScaledVector(i,s)),r.set(e.min.x,e.max.y,e.max.z),t.set(r,i),s=t.distanceToPlane(a),s&&n.push(new A().copy(r).addScaledVector(i,s)),i.set(0,e.max.y-e.min.y,0),r.set(e.min.x,e.min.y,e.min.z),t.set(r,i),s=t.distanceToPlane(a),s&&n.push(new A().copy(r).addScaledVector(i,s)),r.set(e.max.x,e.min.y,e.min.z),t.set(r,i),s=t.distanceToPlane(a),s&&n.push(new A().copy(r).addScaledVector(i,s)),r.set(e.min.x,e.min.y,e.max.z),t.set(r,i),s=t.distanceToPlane(a),s&&n.push(new A().copy(r).addScaledVector(i,s)),r.set(e.max.x,e.min.y,e.max.z),t.set(r,i),s=t.distanceToPlane(a),s&&n.push(new A().copy(r).addScaledVector(i,s)),i.set(0,0,e.max.z-e.min.z),r.set(e.min.x,e.min.y,e.min.z),t.set(r,i),s=t.distanceToPlane(a),s&&n.push(new A().copy(r).addScaledVector(i,s)),r.set(e.max.x,e.min.y,e.min.z),t.set(r,i),s=t.distanceToPlane(a),s&&n.push(new A().copy(r).addScaledVector(i,s)),r.set(e.min.x,e.max.y,e.min.z),t.set(r,i),s=t.distanceToPlane(a),s&&n.push(new A().copy(r).addScaledVector(i,s)),r.set(e.max.x,e.max.y,e.min.z),t.set(r,i),s=t.distanceToPlane(a),s&&n.push(new A().copy(r).addScaledVector(i,s)),n};class zN extends Ar{get vertexProgram(){return`
	varying vec2 vUv;
		void main() {
			vUv = vec2(1. - uv.x, uv.y);
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}
`}get fragmentProgram(){return`
varying vec2 vUv;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform sampler2D tex3;
uniform vec4 weights;
uniform float sigmoidRange;
uniform float sigmoidStrength;

void main() {
	float color0 = texture2D(tex0, vUv).r * weights.x;
	float color1 = texture2D(tex1, vUv).r * weights.y;
	float color2 = texture2D(tex2, vUv).r * weights.z;
	float color3 = texture2D(tex3, vUv).r * weights.w;

	// float c0 = mix(color0, 0., color1);
	// float c1 = mix(color1, 0., color0);
	// float c2 = mix(color3, 0., color0 * 0.5 + color1 * 0.5);
	// float sum = c0 + c1 + c2;

	float sum = color0 + color1 + color3 + color2;

	float a = sigmoidRange;//2.;
	float b = 0.03;
	float c = sigmoidStrength;//2.43;
	float d = 0.59;
	float e = 0.14;
	sum = clamp((sum*(a*sum+b))/(sum*(c*sum+d)+e), 0., 1.);

	vec2 sUv = vUv * 2. - 1.;
	sum *= 1. - pow(abs(sUv.x), 6.);
	sum *= 1. - pow(abs(sUv.y), 6.);

	gl_FragColor = vec4( vec3(sum), sum );
}
`}get uniformsDef(){return{...super.uniformsDef,tex0:null,tex1:null,tex2:null,tex3:null,weights:new lt,sigmoidRange:0,sigmoidStrength:0}}constructor(e,t=[]){super(e,t)}}const Ig={textureSize:512,weights:{x:1,y:1,z:0,w:1},blurRadius:16,stdDeviation:4,sigmoidRange:1.1,sigmoidStrength:2};class NN extends Ts{get displayName(){return"Shadowcatcher"}get outputTexture(){return this.outputTarget?this.outputTarget.texture:null}set needsUpdate(e){this._needsUpdate=e}get drawDepthMaterial(){return this.depthMaterial}constructor(){super(),this.levels=4,this.debugCamera=!1,this.renderTargets=[],this.tempTargets=[],this._needsUpdate=!1,this.blurStdDev=Ig.stdDeviation,this.blurRadius=Ig.blurRadius,this.prevBlurStdDev=0,this.prevBlurRadius=0,this.onBeforeRender=void 0,this.onAfterRender=void 0;for(let e=0;e<this.levels;e++){const t=new pn(256,256,{minFilter:St,magFilter:St});this.renderTargets.push(t),this.tempTargets.push(t.clone())}this.outputTarget=new pn(256,256,{minFilter:St,magFilter:St}),this.outputTarget.texture.wrapS=vs,this.outputTarget.texture.wrapT=vs,this.camera=new ki(-128,128,128,-128,0,10),this.vBlurMaterial=new gn({uniforms:Hr.clone(Hs.uniforms),defines:Object.assign({},Hs.defines),vertexShader:Hs.vertexShader,fragmentShader:Hs.fragmentShader}),this.vBlurMaterial.defines.DEPTH_PACKING=1,this.vBlurMaterial.blending=Mn,this.hBlurMaterial=new gn({uniforms:Hr.clone(Hs.uniforms),defines:Object.assign({},Hs.defines),vertexShader:Hs.vertexShader,fragmentShader:Hs.fragmentShader}),this.hBlurMaterial.defines.DEPTH_PACKING=1,this.hBlurMaterial.blending=Mn,this.depthMaterial=new Yu({depthPacking:iv},["USE_RTE"]),this.depthMaterial.blending=Mn,this.depthMaterial.side=yt,this.blendMaterial=new zN({}),this.fsQuad=new zl(this.vBlurMaterial)}update(e){if(this.scene=e,this._needsUpdate){!this.cameraHelper&&this.debugCamera&&(this.cameraHelper=new Uv(this.camera),this.cameraHelper.layers.set(re.PROPS),this.scene.add(this.cameraHelper)),this.cameraHelper&&this.cameraHelper.update(),this.vBlurMaterial.defines.PERSPECTIVE_CAMERA=0,this.hBlurMaterial.defines.PERSPECTIVE_CAMERA=0,this.vBlurMaterial.uniforms.cameraNear.value=this.camera.near,this.vBlurMaterial.uniforms.cameraFar.value=this.camera.far,this.hBlurMaterial.uniforms.cameraNear.value=this.camera.near,this.hBlurMaterial.uniforms.cameraFar.value=this.camera.far;const t=0;this.vBlurMaterial.uniforms.depthCutoff.value=t,this.hBlurMaterial.uniforms.depthCutoff.value=t,this.prevBlurStdDev===this.blurStdDev&&this.prevBlurRadius===this.blurRadius||(nf.configure(this.vBlurMaterial,this.blurRadius,this.blurStdDev,new te(0,1)),nf.configure(this.hBlurMaterial,this.blurRadius,this.blurStdDev,new te(1,0)),this.prevBlurStdDev=this.blurStdDev,this.prevBlurRadius=this.blurRadius),this.vBlurMaterial.needsUpdate=!0,this.hBlurMaterial.needsUpdate=!0}}render(e){if(this._needsUpdate){const t=e;t.RTEBuffers.push(),t.updateRTEViewModel(this.camera);const n=new Ie;t.getClearColor(n);const i=t.getClearAlpha(),r=t.autoClear;this.onBeforeRender&&this.onBeforeRender(),this.applyLayers(this.camera);const s=this.camera.far;for(let o=0;o<this.renderTargets.length;o++)this.camera.far=s,o<2&&(this.camera.far=s/100),o===2&&(this.camera.far=s/4),this.camera.updateProjectionMatrix(),t.setRenderTarget(this.renderTargets[o]),t.setClearColor(0),t.setClearAlpha(1),t.clear(),t.render(this.scene,this.camera),this.scene.overrideMaterial=null,t.setRenderTarget(this.tempTargets[o]),t.setClearColor(16777215),t.setClearAlpha(1),t.clear(),this.vBlurMaterial.uniforms.tDiffuse.value=this.renderTargets[o].texture,this.vBlurMaterial.uniforms.size.value.set(this.renderTargets[o].width,this.renderTargets[o].height),this.vBlurMaterial.needsUpdate=!0,this.fsQuad.material=this.vBlurMaterial,this.fsQuad.render(t),t.setRenderTarget(this.renderTargets[o]),this.hBlurMaterial.uniforms.tDiffuse.value=this.tempTargets[o].texture,this.hBlurMaterial.uniforms.size.value.set(this.tempTargets[o].width,this.tempTargets[o].height),this.hBlurMaterial.needsUpdate,this.fsQuad.material=this.hBlurMaterial,this.fsQuad.render(t);t.setRenderTarget(this.outputTarget),t.setClearColor(0),t.setClearAlpha(1),this.blendMaterial.userData.tex0.value=this.renderTargets[0].texture,this.blendMaterial.userData.tex1.value=this.renderTargets[1].texture,this.blendMaterial.userData.tex2.value=this.renderTargets[2].texture,this.blendMaterial.userData.tex3.value=this.renderTargets[3].texture,this.fsQuad.material=this.blendMaterial,this.fsQuad.render(t),t.setRenderTarget(null),t.autoClear=r,t.setClearColor(n),t.setClearAlpha(i),t.RTEBuffers.pop(),this.onAfterRender&&this.onAfterRender(),this._needsUpdate=!1}return!1}updateClippingPlanes(e){this.depthMaterial.clippingPlanes=e,this.depthMaterial.needsUpdate=!0}setOutputSize(e,t){var n;if(this.renderTargets[0].width!==e||this.renderTargets[0].height!==t){(n=this.outputTarget)===null||n===void 0||n.setSize(e,t),this.blendMaterial.needsUpdate=!0;let i=1;for(let r=0;r<this.renderTargets.length;r++){const s=Math.trunc(e*i),o=Math.trunc(t*i);this.renderTargets[r].setSize(s,o),this.tempTargets[r].setSize(s,o),i*=.5}}}setWeights(e){this.blendMaterial.userData.weights.value=new lt(e.x,e.y,e.z,e.w),this.blendMaterial.needsUpdate=!0}updateCamera(e,t,n){const i=e.getSize(new A),r=e.getCenter(new A);this.camera.position.copy(new A().copy(r).add(new A(0,0,-.001))),this.camera.lookAt(r),this.camera.left=i.x/-2,this.camera.right=i.x/2,this.camera.top=i.y/2,this.camera.bottom=i.y/-2,this.camera.near=t,this.camera.far=n,this.camera.updateProjectionMatrix(),this.camera.updateMatrixWorld(!0)}updateConfig(e){this.blurRadius=e.blurRadius,this.blurStdDev=e.stdDeviation,this.blendMaterial.userData.sigmoidRange.value=e.sigmoidRange,this.blendMaterial.userData.sigmoidStrength.value=e.sigmoidStrength,this.blendMaterial.needsUpdate=!0}setSize(e,t){}}class Br{get shadowcatcherMesh(){return this.planeMesh}set configuration(e){this._config=JSON.parse(JSON.stringify(e))}constructor(e,t){this.planeSize=new te,this._config=Ig,this.shadowcatcherPass=new NN,this.shadowcatcherPass.setLayers(t),this.displayMaterial=new Ar({color:16777215},["USE_RTE"]),this.displayMaterial.toneMapped=!1,this.displayMaterial.map=this.shadowcatcherPass.outputTexture,this.displayMaterial.toneMapped=!1,this.displayMaterial.transparent=!0,this.displayMaterial.blending=Du,this.displayMaterial.blendEquation=hr,this.displayMaterial.blendEquationAlpha=Qd,this.displayMaterial.blendSrc=Dc,this.displayMaterial.blendSrcAlpha=Js,this.displayMaterial.blendDst=pf,this.displayMaterial.blendDstAlpha=Js,this.displayMaterial.alphaTest=.001,this.displayMaterial.depthWrite=!1,this.planeMesh=new Ve,this.planeMesh.material=this.displayMaterial,this.planeMesh.layers.set(e),this.planeMesh.name=Br.MESH_NAME,this.planeMesh.frustumCulled=!1}update(e){this.shadowcatcherPass.updateConfig(this._config),this.shadowcatcherPass.update(e)}render(e){this.shadowcatcherPass.render(e)}bake(e,t,n){this.updatePlaneMesh(e,n);const i=this.getTextureSize(t),r=new He().setFromObject(this.planeMesh),s=e.getSize(new A).z;this.shadowcatcherPass.updateCamera(r,.001,s),this.shadowcatcherPass.setOutputSize(i.x,i.y),this.shadowcatcherPass.setWeights(this._config.weights),this.shadowcatcherPass.needsUpdate=!0}updateClippingPlanes(e){this.displayMaterial.clippingPlanes=e,this.displayMaterial.needsUpdate=!0,this.shadowcatcherPass.updateClippingPlanes(e)}getTextureSize(e){const t=this.planeSize.x/this.planeSize.y,n=new te;return n.x=Math.trunc(this._config.textureSize),n.y=Math.trunc(this._config.textureSize/t),n.y>e*Br.MAX_TEXTURE_SIZE_SCALE&&(n.y=e*Br.MAX_TEXTURE_SIZE_SCALE,n.x=t*n.y),n}updatePlaneMesh(e,t){const n=e.getSize(new A),i=e.getCenter(new A);(new te(n.x,n.y).distanceTo(this.planeSize)>.001||t)&&this.updatePlaneMeshGeometry(new te(2*n.x,2*n.y),new A(i.x,i.y,i.z-.5*n.z-.001)),this.planeSize.set(n.x,n.y)}updatePlaneMeshGeometry(e,t){this.planeMesh.geometry&&this.planeMesh.geometry.dispose();const n=new Hi(e.x,e.y,Br.PLANE_SUBD,Br.PLANE_SUBD),i=new ae().makeTranslation(t.x,t.y,t.z);n.applyMatrix4(i);const r=new Float64Array(n.attributes.position.array);ft.updateRTEGeometry(n,r),this.planeMesh.geometry=n,this.planeMesh.geometry.computeBoundingBox()}}var Si,af;Br.MESH_NAME="Shadowcatcher",Br.PLANE_SUBD=2,Br.MAX_TEXTURE_SIZE_SCALE=.5,(function(a){a.Stationary="stationary",a.Dynamic="dynamic",a.FrameUpdate="frame-update",a.LateFrameUpdate="late-frame-update",a.ProjectionChanged="projection-changed",a.InteractionStarted="interaction-started",a.InteractionEnded="interaction-ended"})(Si||(Si={})),(function(a){a[a.PERSPECTIVE=0]="PERSPECTIVE",a[a.ORTHOGRAPHIC=1]="ORTHOGRAPHIC"})(af||(af={}));class of{constructor(){this.viewer=new A,this.viewerLow=new A,this.viewerHigh=new A,this.rteViewModelMatrix=new ae,this.shadowViewer=new A,this.shadowViewerLow=new A,this.shadowViewerHigh=new A,this.rteShadowViewModelMatrix=new ae,this.rteShadowMatrix=new ae}copy(e,t){t.viewer.copy(e.viewer),t.viewerLow.copy(e.viewerLow),t.viewerHigh.copy(e.viewerHigh),t.rteViewModelMatrix.copy(e.rteViewModelMatrix),t.shadowViewer.copy(e.shadowViewer),t.shadowViewerLow.copy(e.shadowViewerLow),t.shadowViewerHigh.copy(e.shadowViewerHigh),t.rteShadowViewModelMatrix.copy(e.rteShadowViewModelMatrix),t.rteShadowMatrix.copy(e.rteShadowMatrix)}push(){this._cache||(this._cache=new of),this.copy(this,this._cache)}pop(){this._cache||(this._cache=new of),this.copy(this._cache,this)}}class lb extends Wt{constructor(){super(...arguments),this.RTEBuffers=new of,this.readRenderTargetPixels=(e,t,n,i,r,s,o=0)=>{if(!e||!(e instanceof pn||e instanceof yf))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let l=this.properties.get(e).__webglFramebuffer;if(e instanceof Nu&&o!==void 0&&(l=l[o]),l){this.state.bindFramebuffer(36160,l);try{const c=Array.isArray(e.texture)?e.texture[0]:e.texture,u=c.format,h=c.type;if(u!==Hn&&this.convert(u)!==this.context.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const d=h===di&&(this.extensions.has("EXT_color_buffer_half_float")||this.capabilities.isWebGL2&&this.extensions.has("EXT_color_buffer_float"));if(!(h===Fr||this.convert(h)===this.context.getParameter(35738)||h===Dn&&(this.capabilities.isWebGL2||this.extensions.has("OES_texture_float")||this.extensions.has("WEBGL_color_buffer_float"))||d))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");t>=0&&t<=e.width-i&&n>=0&&n<=e.height-r&&this.context.readPixels(t,n,i,r,this.convert(u),this.convert(h),s)}finally{const c=this.getRenderTarget()!==null?this.properties.get(this.getRenderTarget()).__webglFramebuffer:null;this.state.bindFramebuffer(36160,c)}}}}updateRTEViewModel(e){this.RTEBuffers.rteViewModelMatrix.copy(e.matrixWorldInverse),this.RTEBuffers.rteViewModelMatrix.elements[12]=0,this.RTEBuffers.rteViewModelMatrix.elements[13]=0,this.RTEBuffers.rteViewModelMatrix.elements[14]=0,this.RTEBuffers.viewer.set(e.matrixWorld.elements[12],e.matrixWorld.elements[13],e.matrixWorld.elements[14]),ft.DoubleToHighLowVector(this.RTEBuffers.viewer,this.RTEBuffers.viewerLow,this.RTEBuffers.viewerHigh)}convert(e,t=null){let n;if(e===Fr)return 5121;if(e===Wg)return 32819;if(e===Xg)return 32820;if(e===Vg)return 5120;if(e===jg)return 5122;if(e===qa)return 5123;if(e===Qg)return 5124;if(e===tl)return 5125;if(e===Dn)return 5126;if(e===di)return this.capabilities.isWebGL2?5131:(n=this.extensions.get("OES_texture_half_float"),n!==null?n.HALF_FLOAT_OES:null);if(e===Jg)return 6406;if(e===Hn)return 6408;if(e===Kg)return 6409;if(e===Yg)return 6410;if(e===ps)return 6402;if(e===aa)return 34041;if(e===gf)return 6403;if(e===Zg)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(e===su)return n=this.extensions.get("EXT_sRGB"),n!==null?n.SRGB_ALPHA_EXT:null;if(e===qg)return 36244;if(e===_g)return 33319;if(e===$g)return 33320;if(e===ev)return 36249;if(e===Ga||e===Va||e===ja||e===Qa)if(t===vt){if(n=this.extensions.get("WEBGL_compressed_texture_s3tc_srgb"),n===null)return null;if(e===Ga)return n.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(e===Va)return n.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(e===ja)return n.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(e===Qa)return n.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(n=this.extensions.get("WEBGL_compressed_texture_s3tc"),n===null)return null;if(e===Ga)return n.COMPRESSED_RGB_S3TC_DXT1_EXT;if(e===Va)return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(e===ja)return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(e===Qa)return n.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(e===zc||e===Nc||e===kc||e===Uc){if(n=this.extensions.get("WEBGL_compressed_texture_pvrtc"),n===null)return null;if(e===zc)return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(e===Nc)return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(e===kc)return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(e===Uc)return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(e===tv)return n=this.extensions.get("WEBGL_compressed_texture_etc1"),n!==null?n.COMPRESSED_RGB_ETC1_WEBGL:null;if(e===Fc||e===Hc){if(n=this.extensions.get("WEBGL_compressed_texture_etc"),n===null)return null;if(e===Fc)return t===vt?n.COMPRESSED_SRGB8_ETC2:n.COMPRESSED_RGB8_ETC2;if(e===Hc)return t===vt?n.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:n.COMPRESSED_RGBA8_ETC2_EAC}if(e===Gc||e===Vc||e===jc||e===Qc||e===Wc||e===Xc||e===Jc||e===Zc||e===Kc||e===Yc||e===qc||e===_c||e===$c||e===eu){if(n=this.extensions.get("WEBGL_compressed_texture_astc"),n===null)return null;if(e===Gc)return t===vt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:n.COMPRESSED_RGBA_ASTC_4x4_KHR;if(e===Vc)return t===vt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:n.COMPRESSED_RGBA_ASTC_5x4_KHR;if(e===jc)return t===vt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:n.COMPRESSED_RGBA_ASTC_5x5_KHR;if(e===Qc)return t===vt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:n.COMPRESSED_RGBA_ASTC_6x5_KHR;if(e===Wc)return t===vt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:n.COMPRESSED_RGBA_ASTC_6x6_KHR;if(e===Xc)return t===vt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:n.COMPRESSED_RGBA_ASTC_8x5_KHR;if(e===Jc)return t===vt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:n.COMPRESSED_RGBA_ASTC_8x6_KHR;if(e===Zc)return t===vt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:n.COMPRESSED_RGBA_ASTC_8x8_KHR;if(e===Kc)return t===vt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:n.COMPRESSED_RGBA_ASTC_10x5_KHR;if(e===Yc)return t===vt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:n.COMPRESSED_RGBA_ASTC_10x6_KHR;if(e===qc)return t===vt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:n.COMPRESSED_RGBA_ASTC_10x8_KHR;if(e===_c)return t===vt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:n.COMPRESSED_RGBA_ASTC_10x10_KHR;if(e===$c)return t===vt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:n.COMPRESSED_RGBA_ASTC_12x10_KHR;if(e===eu)return t===vt?n.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:n.COMPRESSED_RGBA_ASTC_12x12_KHR}if(e===tu){if(n=this.extensions.get("EXT_texture_compression_bptc"),n===null)return null;if(e===tu)return t===vt?n.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:n.COMPRESSED_RGBA_BPTC_UNORM_EXT}return e===_s?this.capabilities.isWebGL2?34042:(n=this.extensions.get("WEBGL_depth_texture"),n!==null?n.UNSIGNED_INT_24_8_WEBGL:null):this.context[e]!==void 0?this.context[e]:null}}class Sn extends Ts{get displayName(){return"GEOMETRY"}setClippingPlanes(e){this.overrideMaterial&&(this.overrideMaterial.clippingPlanes=e),this.overrideBatchMaterial&&(this.overrideBatchMaterial.clippingPlanes=e)}render(e,t,n){return!(!t||!n)&&(this.onBeforeRender&&this.onBeforeRender(),this.applyLayers(t),e.setRenderTarget(this.outputTarget),this.clear(e),e.render(n,t),this.onAfterRender&&this.onAfterRender(),!1)}}const Cs={edges:!0};class pa{get options(){return this._options}set options(e){Object.assign(this.options,e)}constructor(e,t={}){this._options=Object.assign({},Cs),this.passList=[],this.drawingSize=new te,this.frameProjection=new ae,this.jitterIndex=0,this.jitterOffsets=this.generateHaltonJiters(16),this.speckleRenderer=e,this.options=t}get passes(){return this.passList}onBeforePipelineRender(){}onAfterPipelineRender(){}getPass(e){return this.passList.filter((t=>t.displayName===e))}setClippingPlanes(e){this.passList.forEach((t=>{var n;return(n=t.setClippingPlanes)===null||n===void 0?void 0:n.call(t,e)}))}update(e){this.passList.forEach((t=>{var n;return t.enabled&&((n=t.update)===null||n===void 0?void 0:n.call(t,e))}))}reset(){this.jitterIndex=0}render(){if(this.speckleRenderer.renderer.getDrawingBufferSize(this.drawingSize),this.drawingSize.length()===0)return!1;const e=this.speckleRenderer.renderingCamera,t=this.speckleRenderer.batcher.saveVisiblity(),n={[ut.OPAQUE]:this.speckleRenderer.batcher.getOpaque(),[ut.TRANSPARENT]:this.speckleRenderer.batcher.getTransparent(),[ut.DEPTH]:this.speckleRenderer.batcher.getDepth(),[ut.STENCIL]:this.speckleRenderer.batcher.getStencil()},[i,r]=this.jitterOffsets[this.jitterIndex];this.onBeforePipelineRender(),this.speckleRenderer.renderer.setRenderTarget(null),this.speckleRenderer.renderer.setClearColor(16777215,0),this.speckleRenderer.renderer.clear(!0,!0,!0);let s,o=!1;return this.passList.forEach((l=>{if(!l.enabled||!l.render)return;let c=t;if(l.visibility&&(l.visibility===ut.CUSTOM?l.visibilityFunction&&(c=l.visibilityFunction(this.speckleRenderer)):c=n[l.visibility]),l.visibility?(this.speckleRenderer.batcher.applyVisibility(c),s=l.visibility):s&&this.speckleRenderer.batcher.applyVisibility(t),l.overrideMaterial&&this.speckleRenderer.batcher.overrideMaterial(l.visibility?c:t,l.overrideMaterial),l.overrideBatchMaterial&&this.speckleRenderer.batcher.overrideBatchMaterial(l.visibility?c:t,l.overrideBatchMaterial),l.jitter&&e)if(this.frameProjection.copy(e.projectionMatrix),e instanceof ki){const h=this.drawingSize.x,d=this.drawingSize.y,f=e.right-e.left,p=e.top-e.bottom,m=h/f,g=d/p;e.setViewOffset(f,p,i/m*.5,r/g*.5,f,p)}else e instanceof tn&&(e.projectionMatrix.elements[8]=i/this.drawingSize.x,e.projectionMatrix.elements[9]=r/this.drawingSize.y);const u=l.render(this.speckleRenderer.renderer,this.speckleRenderer.renderingCamera,this.speckleRenderer.scene);o||(o=u),l.visibility&&this.speckleRenderer.batcher.applyVisibility(t),l.overrideMaterial&&this.speckleRenderer.batcher.restoreMaterial(l.visibility?c:t),l.overrideBatchMaterial&&this.speckleRenderer.batcher.restoreBatchMaterial(l.visibility?c:t),l.jitter&&e&&e.projectionMatrix.copy(this.frameProjection)})),this.onAfterPipelineRender(),this.jitterIndex=(this.jitterIndex+1)%this.jitterOffsets.length,o}resize(e,t){this.passList.forEach((n=>{var i;return(i=n.setSize)===null||i===void 0?void 0:i.call(n,e,t)}))}haltonNumber(e,t){let n=0,i=1;for(;t>0;)i/=e,n+=i*(t%e),t=Math.floor(t/e);return n}generateHaltonJiters(e){const t=[];for(let n=1;n<=e;n++)t.push([2*(this.haltonNumber(2,n)-.5),2*(this.haltonNumber(3,n)-.5)]);return t}static createRenderTarget(e,t,n){const i=new pn(t||1,n||1,e);return i.depthBuffer=!0,i.stencilBuffer=!0,i}static createMultipleRenderTarget(e,t,n,i){const r=new yf(n||1,i||1,e,t);return r.depthBuffer=!0,r.stencilBuffer=!0,r}}var Eu;(function(a){a[a.PERSPECTIVE_DEPTH=0]="PERSPECTIVE_DEPTH",a[a.LINEAR_DEPTH=1]="LINEAR_DEPTH"})(Eu||(Eu={}));const cb={depthType:Eu.LINEAR_DEPTH};class Al extends Sn{get displayName(){return"DEPTH"}get depthTexture(){var e;return(e=this._outputTarget)===null||e===void 0?void 0:e.texture}get overrideMaterial(){return this.depthMaterial}set options(e){super.options=e,this.depthType=this._options.depthType}set depthType(e){e===Eu.LINEAR_DEPTH&&(this.depthMaterial.defines?this.depthMaterial.defines.LINEAR_DEPTH=" ":this.depthMaterial.defines&&delete this.depthMaterial.defines.LINEAR_DEPTH),this.depthMaterial.needsUpdate=!0}set depthSide(e){this.depthMaterial.side=e}constructor(){super(),this._options=Object.assign({},cb),this._outputTarget=pa.createRenderTarget({minFilter:Dt,magFilter:Dt}),this.depthMaterial=new Yu({depthPacking:da},["ALPHATEST_REJECTION"]),this.depthMaterial.blending=Mn,this.depthMaterial.side=yt,this.depthType=this._options.depthType}update(e){this.depthMaterial.userData.near.value=e.near,this.depthMaterial.userData.far.value=e.far,this.depthMaterial.needsUpdate=!0}}const ub={intensity:1,kernelRadius:30,bias:.01,kernelSize:16};class Yf extends qu{setTexture(e,t){this.generationMaterial.uniforms[e].value=t,this.generationMaterial.needsUpdate=!0}get displayName(){return"PROGRESSIVE-AO"}set options(e){super.options=e,this.kernels=[],this.noiseTextures=[]}constructor(){super(),this._options=Object.assign({},ub),this.kernels=[],this.noiseTextures=[],this._generationBuffer=new pn(256,256),this._outputTarget=new pn(256,256),this.generationMaterial=new gn({fragmentShader:`
		#include <common>
		#define AO_ESTIMATOR 1
		#define NORMAL_TEXTURE 0
		#define IMPROVED_NORMAL_RECONSTRUCTION 0
		#define ACCURATE_NORMAL_RECONSTRUCTION 1

		varying vec2 vUv;
		uniform sampler2D tDepth;
		uniform sampler2D tNormal;
        uniform vec2 size;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;
		
		uniform float intensity;
		uniform float bias;
		uniform float kernelRadius;
		
		
		#if AO_ESTIMATOR == 0
			#define NUM_SAMPLES 16
        	#define SPIRAL_TURNS 2
			#define INV_NUM_SAMPLES 1.0 / float( NUM_SAMPLES )
        	#define offset PI2 / float(NUM_FRAMES)

			uniform float minResolution;
			uniform float frameIndex;
			uniform float scale;
		#endif

		#if AO_ESTIMATOR == 1
			uniform float tanFov;
			uniform sampler2D tNoise;
			uniform vec3 kernel[ KERNEL_SIZE ];
		#endif

		// RGBA depth
		#include <packing>
		vec4 getDefaultColor( const in vec2 screenPosition ) {
			return vec4( 1.0 );
		}


		float getLinearDepth( const in vec2 screenPosition ) {
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
		}

		float getPerspectiveDepth(const in vec2 coords) {
			float linearDepth = unpackRGBAToDepth( texture2D( tDepth, coords ) );
			#if PERSPECTIVE_CAMERA == 1
				float viewZ = orthographicDepthToViewZ(linearDepth, cameraNear, cameraFar);
				float centerDepth = viewZToPerspectiveDepth(viewZ, cameraNear, cameraFar);
				return centerDepth;
			#else
				return linearDepth;
			#endif
		}

		float getViewDepth(const in float linearDepth) {
			return orthographicDepthToViewZ(linearDepth, cameraNear, cameraFar);
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {
			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );
			clipPosition *= clipW; // unprojection.
			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;
		}

		//https://wickedengine.net/2019/09/22/improved-normal-reconstruction-from-depth/
		vec3 viewNormalImproved(in vec2 uv, in vec3 origin)
		{	
			highp vec2 dd = abs(vec2(1./size.x, 1./size.y));
			highp vec2 ddx = vec2(dd.x, 0.);
			highp vec2 ddy = vec2(0., dd.y);

			float sampleDepth = getPerspectiveDepth( uv - ddy );
			float sampleViewZ = getViewZ( sampleDepth );
			highp vec3 top = getViewPosition( uv - ddy, sampleDepth, sampleViewZ );

			sampleDepth = getPerspectiveDepth( uv + ddy );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 bottom = getViewPosition( uv + ddy, sampleDepth, sampleViewZ );

			highp vec3 center = origin;
			
			sampleDepth = getPerspectiveDepth( uv - ddx );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 left = getViewPosition( uv - ddx, sampleDepth, sampleViewZ );

			sampleDepth = getPerspectiveDepth( uv + ddx );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 right = getViewPosition( uv + ddx, sampleDepth, sampleViewZ );

			 // get the difference between the current and each offset position
			vec3 l = center - left;
			vec3 r = right - center;
			vec3 d = center - top;
			vec3 u = bottom - center;

			// pick horizontal and vertical diff with the smallest z difference
			vec3 hDeriv = abs(l.z) < abs(r.z) ? l : r;
			vec3 vDeriv = abs(d.z) < abs(u.z) ? d : u;

			// get view space normal from the cross product of the two smallest offsets
			vec3 viewNormal = normalize(cross(hDeriv, vDeriv));

			return viewNormal;
		}

		vec3 viewNormalAccurate(in vec2 uv, in vec3 origin, in float centerDepth) {
			highp vec2 dd = abs(vec2(1./size.x, 1./size.y));
			highp vec2 ddx = vec2(dd.x, 0.);
			highp vec2 ddy = vec2(0., dd.y);

			float sampleDepth = getPerspectiveDepth( uv - ddy );
			float sampleViewZ = getViewZ( sampleDepth );
			highp vec3 top = getViewPosition( uv - ddy, sampleDepth, sampleViewZ );

			sampleDepth = getPerspectiveDepth( uv + ddy );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 bottom = getViewPosition( uv + ddy, sampleDepth, sampleViewZ );

			highp vec3 center = origin;
			
			sampleDepth = getPerspectiveDepth( uv - ddx );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 left = getViewPosition( uv - ddx, sampleDepth, sampleViewZ );

			sampleDepth = getPerspectiveDepth( uv + ddx );
			sampleViewZ = getViewZ( sampleDepth );
			highp vec3 right = getViewPosition( uv + ddx, sampleDepth, sampleViewZ );

			 // get the difference between the current and each offset position
			vec3 l = center - left;
			vec3 r = right - center;
			vec3 d = center - top;
			vec3 u = bottom - center;

			// get depth values at 1 & 2 pixels offsets from current along the horizontal axis
			vec4 H = vec4(
				getLinearDepth(uv - ddx),
				getLinearDepth(uv + ddx),
				getLinearDepth(uv - 2. * ddx),
				getLinearDepth(uv + 2. * ddx)
			);

			// get depth values at 1 & 2 pixels offsets from current along the vertical axis
			vec4 V = vec4(
				getLinearDepth(uv - ddy),
				getLinearDepth(uv + ddy),
				getLinearDepth(uv - 2. * ddy),
				getLinearDepth(uv + 2. * ddy)
			);

			// current pixel's depth difference from slope of offset depth samples
			// differs from original article because we're using non-linear depth values
			// see article's comments
			vec2 he = abs((2. * H.xy - H.zw) - centerDepth);
			vec2 ve = abs((2. * V.xy - V.zw) - centerDepth);

			// pick horizontal and vertical diff with the smallest depth difference from slopes
			vec3 hDeriv = he.x < he.y ? l : r;
			vec3 vDeriv = ve.x < ve.y ? d : u;

			// get view space normal from the cross product of the best derivatives
			vec3 viewNormal = normalize(cross(hDeriv, vDeriv));

			return viewNormal;

		}

		vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition, in float centerDepth ) {
			#if NORMAL_TEXTURE == 1
				return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );
			#elif IMPROVED_NORMAL_RECONSTRUCTION == 1
				return viewNormalImproved(screenPosition, viewPosition);
			#elif ACCURATE_NORMAL_RECONSTRUCTION == 1
				return viewNormalAccurate(screenPosition, viewPosition, centerDepth);
			#else
				return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );
			#endif
		}


		float scaleDividedByCameraFar;
		float minResolutionMultipliedByCameraFar;
        // moving costly divides into consts
		

		float computeKernelSize(float d, float r) {
			#if PERSPECTIVE_CAMERA == 1
				// Apparently this is wrong
				// return (r * tan(fov) * d) / (size.y * 0.5);
				// And this is correct
				float rp = r / (size.y * 0.5);
				return sqrt((rp*rp*tanFov*tanFov*d*d)/(1. + rp*rp*tanFov*tanFov));
			#else
				float twoOrthoSize = size.y / (2./ cameraProjectionMatrix[1][1]);
				return r / twoOrthoSize;
			#endif
		}

		float getAmbientOcclusion( const in vec3 centerViewPosition, in float centerDepth ) {
            #if AO_ESTIMATOR == 0
                // precompute some variables require in getOcclusion.
                scaleDividedByCameraFar = scale / cameraFar;
                minResolutionMultipliedByCameraFar = minResolution * cameraFar;
                vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv, centerDepth );
                // jsfiddle that shows sample pattern: https://jsfiddle.net/TenHands/jun67k9y/7/
                float occlusionSum = 0.0;
                float weightSum = 0.0;
                for( int i = 0; i < NUM_SAMPLES; i ++ ) {
                    float alpha = ( float(i) + 1. ) / float(NUM_SAMPLES);
                    float angle = float(SPIRAL_TURNS)  * alpha;
                    vec2 radius = (kernelRadius / size) * pow( alpha, 1.1 );
                    vec2 sampleUv = vUv + vec2( cos( angle + frameIndex * offset ), sin( angle + frameIndex * offset ) ) * radius;

                    float sampleDepth = getPerspectiveDepth( sampleUv );
                    if( sampleDepth >= ( 1.0 - EPSILON ) ) {
                        continue;
                    }
                    float sampleViewZ = getViewZ( sampleDepth );
                    vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );

					/** McGuire Estimator*/
					vec3 v = sampleViewPosition - centerViewPosition;
					float vv = dot(v, v);
					float vn = dot(v, centerViewNormal) - bias;
					
					// Note large epsilon to avoid overdarkening within cracks
					float radius2 = 2.;//uSampleRadiusWS * uSampleRadiusWS
					float epsilon = 0.01;
					
					float f = max(radius2 - vv, 0.0) / radius2;
					occlusionSum += f * f * f * max(vn / (epsilon + vv), 0.0) / 4.;

					/** Three.js SAO Estimator*/
                    // vec3 viewDelta = sampleViewPosition - centerViewPosition;
                    // float viewDistance = length( viewDelta );
                    // float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;
                    // occlusionSum += max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );
                    weightSum += 1.0;
                }
                if( weightSum == 0.0 ) discard;
                return occlusionSum * ( intensity / weightSum );
			#elif AO_ESTIMATOR == 1
				vec3 viewPosition = centerViewPosition;
				vec3 viewNormal = getViewNormal( centerViewPosition, vUv, centerDepth );
				vec2 noiseScale = vec2( size.x / 4.0, size.y / 4.0 );
				vec3 random = vec3( texture2D( tNoise, vUv * noiseScale ).r );
				// compute matrix used to reorient a kernel vector
				vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );
				vec3 bitangent = cross( viewNormal, tangent );
				mat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );
				float occlusion = 0.0;
				float kernelSize_ws = computeKernelSize(-viewPosition.z, kernelRadius);
				float div = float( KERNEL_SIZE);
				float maxDist = kernelSize_ws / (cameraFar - cameraNear);
				for ( int i = 0; i < KERNEL_SIZE; i ++ ) {
					vec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space
					vec3 samplePoint = viewPosition + ( sampleVector * kernelSize_ws ); // calculate sample point
					vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 ); // project point and calculate NDC
					samplePointNDC /= samplePointNDC.w;
					vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates
					float realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture
					float sampleDepth = viewZToOrthographicDepth( samplePoint.z + bias, cameraNear, cameraFar ); // compute linear depth of the sample view Z value
					float delta = sampleDepth - realDepth;
					if ( delta > 0. && delta < maxDist ) { // if fragment is before sample point, increase occlusion
						occlusion += 1.0;
					}
				}
				return clamp( occlusion * intensity / div, 0.0, 1.0 );
			#endif
			}
		void main() {
			float linearDepth = unpackRGBAToDepth( texture2D( tDepth, vUv ) );
			float centerDepth = getPerspectiveDepth(vUv);
			if( centerDepth >= ( 1.0 - EPSILON ) ) {
				discard;
			}
			float centerViewZ = getViewDepth(linearDepth);
			vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );
			vec3 viewNormal = getViewNormal(viewPosition, vUv, linearDepth);
			float ambientOcclusion = getAmbientOcclusion( viewPosition, centerDepth );
			gl_FragColor = getDefaultColor( vUv );
			gl_FragColor.xyz *=  ambientOcclusion;
			gl_FragColor.a = 1.;
		}`,vertexShader:`
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`,uniforms:{tDepth:{value:null},tNormal:{value:null},size:{value:new te(512,512)},cameraNear:{value:1},cameraFar:{value:100},cameraProjectionMatrix:{value:new ae},cameraInverseProjectionMatrix:{value:new ae},tanFov:{value:0},intensity:{value:this._options.intensity},bias:{value:this._options.bias},kernelRadius:{value:this._options.kernelRadius},tNoise:{value:null},kernel:{value:null}}}),this.generationMaterial.extensions.derivatives=!0,this.generationMaterial.uniforms.size.value.set(256,256),this.generationMaterial.blending=Mn,this.generationMaterial.uniformsNeedUpdate=!0,this.accumulateMaterial=new gn({defines:{},fragmentShader:`
    uniform float opacity;
    uniform sampler2D tDiffuse;
    varying vec2 vUv;
    // #define NUM_FRAMES 16

    void main() {
        vec4 frameSample = texture2D( tDiffuse, vUv );
        gl_FragColor.xyz = frameSample.rgb * 1./float(NUM_FRAMES);
        gl_FragColor.a = 1.;//*= opacity;
    }`,vertexShader:`
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }`,uniforms:{tDiffuse:{value:null},opacity:{value:1}}}),this.accumulateMaterial.uniforms.tDiffuse.value=this._generationBuffer.texture,this.accumulateMaterial.blending=Du,this.accumulateMaterial.blendSrc=Js,this.accumulateMaterial.blendDst=Js,this.accumulateMaterial.blendEquation=Ng,this.accumulateMaterial.blendSrcAlpha=Js,this.accumulateMaterial.blendDstAlpha=Js,this.accumulateMaterial.blendEquationAlpha=hr,this.fsQuad=new zl(this.generationMaterial)}update(e){this.generationMaterial.defines.PERSPECTIVE_CAMERA=e.isPerspectiveCamera?1:0,this.generationMaterial.defines.NUM_FRAMES=this.accumulationFrames,this.generationMaterial.defines.KERNEL_SIZE=this._options.kernelSize,this.accumulateMaterial.defines.NUM_FRAMES=this.accumulationFrames,this.generationMaterial.uniforms.cameraNear.value=e.near,this.generationMaterial.uniforms.cameraFar.value=e.far,this.generationMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(e.projectionMatrixInverse),this.generationMaterial.uniforms.cameraProjectionMatrix.value.copy(e.projectionMatrix);const t=e.fov/2*Math.PI/180;this.generationMaterial.uniforms.tanFov.value=Math.tan(t),this.kernels[this.frameIndex]||this.generateSampleKernel(this.frameIndex),this.noiseTextures[this.frameIndex]||this.generateRandomKernelRotations(this.frameIndex),this.generationMaterial.uniforms.kernel.value=this.kernels[this.frameIndex],this.generationMaterial.uniforms.tNoise.value=this.noiseTextures[this.frameIndex],this.generationMaterial.uniforms.intensity.value=this._options.intensity,this.generationMaterial.uniforms.kernelRadius.value=this._options.kernelRadius,this.generationMaterial.uniforms.bias.value=this._options.bias,this.generationMaterial.needsUpdate=!0,this.accumulateMaterial.needsUpdate=!0}render(e){return e.setRenderTarget(this._generationBuffer),e.setClearColor(0),e.setClearAlpha(1),e.clear(!0),this.fsQuad.material=this.generationMaterial,this.fsQuad.render(e),e.setRenderTarget(this._outputTarget),this.frameIndex===0&&this.clear(e),this.fsQuad.material=this.accumulateMaterial,this.fsQuad.render(e),super.render(e)}setSize(e,t){super.setSize(e,t),this._generationBuffer.setSize(e,t),this.generationMaterial.uniforms.size.value.set(e,t),this.generationMaterial.needsUpdate=!0}generateSampleKernel(e){const t=this._options.kernelSize||0;this.kernels[e]=[];for(let n=0;n<t;n++){const i=new A;i.x=2*Math.random()-1,i.y=2*Math.random()-1,i.z=Math.random(),i.normalize();let r=n/t;r=It.lerp(.1,1,r*r),i.multiplyScalar(r),this.kernels[e].push(i)}}generateRandomKernelRotations(e){Pw===void 0&&console.error("The pass relies on SimplexNoise.");const t=new Pw,n=new Float32Array(64);for(let i=0;i<64;i+=4){const r=2*Math.random()-1,s=2*Math.random()-1,o=0;n[i]=t.noise3d(r,s,o),n[i+1]=0,n[i+2]=0,n[i+3]=0}this.noiseTextures[e]=new Yi(n,4,4,Hn,Dn),this.noiseTextures[e].wrapS=vs,this.noiseTextures[e].wrapT=vs,this.noiseTextures[e].needsUpdate=!0}}const kN={blendAO:!0,blendEdges:!1};class qi extends qu{set options(e){super.options=e,this.materialCopy.defines.BLEND_AO=+this._options.blendAO,this.materialCopy.defines.BLEND_EDGES=+this._options.blendEdges,this.materialCopy.needsUpdate=!0}constructor(){super(),this._options=Object.assign({},kN),this.materialCopy=new gn({defines:{BLEND_AO:+this._options.blendAO,BLEND_EDGES:+this._options.blendEdges},uniforms:{tAo:{value:null},tEdges:{value:null}},vertexShader:`
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`,fragmentShader:`

        #if BLEND_AO == 1
		    uniform sampler2D tAo;
        #endif
        #if BLEND_EDGES == 1
            uniform sampler2D tEdges;
        #endif
		varying vec2 vUv;

        #define ONE3 vec3(1.,1.,1.)

		void main() {
            vec3 ao = ONE3;
            vec3 edges = ONE3;
            
            #if BLEND_AO == 1
                ao = texture2D( tAo, vUv ).rgb;
            #endif

            #if BLEND_EDGES == 1
                edges = texture2D (tEdges, vUv).rgb;
            #endif
             
            gl_FragColor.rgb = min(ao, edges);
			gl_FragColor.a = 1.;
		}`,blending:Mn}),this.materialCopy.transparent=!0,this.materialCopy.depthTest=!1,this.materialCopy.depthWrite=!1,this.materialCopy.blending=Du,this.materialCopy.blendSrc=Fg,this.materialCopy.blendDst=Dc,this.materialCopy.blendEquation=hr,this.materialCopy.blendSrcAlpha=pf,this.materialCopy.blendDstAlpha=Dc,this.materialCopy.blendEquationAlpha=hr,this.materialCopy.needsUpdate=!0,this.fsQuad=new zl(this.materialCopy)}setTexture(e,t){this.materialCopy.uniforms[e].value=t,this.materialCopy.needsUpdate=!0}get displayName(){return"BLEND"}render(e){return e.setRenderTarget(this._outputTarget),this.fsQuad.render(e),super.render(e)}}class Xr extends pa{constructor(){super(...arguments),this.accumulationFrameIndex=0,this.accumulationFrameCount=16,this.dynamicStage=[],this.progressiveStage=[],this.passthroughStage=[],this.accumulating=!1}get passes(){return[...this.dynamicStage,...this.progressiveStage,...this.passthroughStage]}get dynamicPasses(){return[...this.dynamicStage]}get progressivePasses(){return[...this.progressiveStage]}get passthroughPasses(){return[...this.passthroughStage]}getPass(e){return[...this.dynamicStage.filter((t=>t.displayName===e)),...this.progressiveStage.filter((t=>t.displayName===e)),...this.passthroughStage.filter((t=>t.displayName===e))]}setClippingPlanes(e){this.dynamicStage.forEach((t=>{var n;return(n=t.setClippingPlanes)===null||n===void 0?void 0:n.call(t,e)})),this.progressiveStage.forEach((t=>{var n;return(n=t.setClippingPlanes)===null||n===void 0?void 0:n.call(t,e)})),this.passthroughStage.forEach((t=>{var n;return(n=t.setClippingPlanes)===null||n===void 0?void 0:n.call(t,e)}))}update(e){this.passList.forEach((t=>{var n;t.enabled&&((n=t.update)===null||n===void 0||n.call(t,e)),t instanceof qu&&(t.frameIndex=this.accumulationFrameIndex)}))}render(){const e=super.render();return this.accumulating&&++this.accumulationFrameIndex===this.accumulationFrameCount&&this.onAccumulationComplete(),e}reset(){super.reset(),this.accumulationFrameIndex=0,this.onStationaryBegin()}resize(e,t){super.resize(e,t),this.dynamicStage.forEach((n=>{var i;return(i=n.setSize)===null||i===void 0?void 0:i.call(n,e,t)})),this.progressiveStage.forEach((n=>{var i;return(i=n.setSize)===null||i===void 0?void 0:i.call(n,e,t)}))}onStationaryBegin(){this.accumulationFrameIndex=0,this.accumulating=!0,this.passList=this.progressiveStage}onStationaryEnd(){this.accumulating=!1,this.passList=this.dynamicStage}onAccumulationComplete(){this.accumulating=!1,this.passList=this.passthroughStage}}class hb extends Ar{get vertexProgram(){return`
#include <common>
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
#endif
uniform vec2 size;
uniform float displacement;

#ifdef TRANSFORM_STORAGE
    attribute float objIndex;

    #if TRANSFORM_STORAGE == 0
        #if __VERSION__ == 300
            #define TRANSFORM_STRIDE 4
        #else
            #define TRANSFORM_STRIDE 4.
        #endif
        uniform sampler2D tTransforms;
        uniform float objCount;
    #elif TRANSFORM_STORAGE == 1
        uniform mat4 uTransforms[OBJ_COUNT];
    #endif
#endif

#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef TRANSFORM_STORAGE
    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){
        #if TRANSFORM_STORAGE == 0
            #if __VERSION__ == 300
                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); 
                vec4 v0 = texelFetch( tTransforms, uv, 0 );
                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);
                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);
                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #else
                float size = objCount * TRANSFORM_STRIDE;
                vec2 cUv = vec2(0.5/size, 0.5);
                vec2 dUv = vec2(1./size, 0.);
                
                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);
                vec4 v0 = texture2D( tTransforms, uv);
                vec4 v1 = texture2D( tTransforms, uv + dUv);
                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);
                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #endif
        #elif TRANSFORM_STORAGE == 1
            mat4 tMatrix = uTransforms[int(objIndex)];
            quaternion = tMatrix[0];
            pivotLow = vec4(tMatrix[1].xyz, 1.);
            pivotHigh = vec4(tMatrix[2].xyz, 1.);
            translation = vec4(tMatrix[3].xyz, 1.);
            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);
        #endif
    }

    vec3 rotate_vertex_position(vec3 position, vec4 quat)
    { 
        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);
    }

    /** Another workaround for Apple's stupid compiler */
    vec4 safeMul(vec4 a, vec4 b) {
        // Prevents constant folding and optimization
        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);
    }

    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)
    {
        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */
        /** The code below will not produce correct results in intel IrisXE integrated GPUs. 
         *  The geometry will turn mangled, albeit stable
         *  I can't know for sure what is going on, but rotating the difference seems to 
         *  force the result into a lower precision?
         */
        // highp vec4 position = v0 - v1;
        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);

        /** Subtracting the rotated vectors works. */
        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;

        /** An alternate workaround is
         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));
           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);

           However I'm not such a fan of the (1. + 1e-7) part
         */
    }
    
#endif

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }
#endif

void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
        // #include <defaultnormal_vertex> // COMMENTED CHUNK
        vec3 transformedNormal = objectNormal;
        #ifdef USE_INSTANCING

            // this is in lieu of a per-instance normal-matrix
            // shear transforms in the instance matrix are not supported
            mat3 m = mat3( instanceMatrix );
            transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
            transformedNormal = m * transformedNormal;
            
            /* If we have negative scaling, we flip the normal */
            float signDet = sign(dot(m[0], cross(m[1], m[2])));
            // Optional fallback: treat 0 as +1
            signDet = signDet + (1.0 - abs(signDet));
            transformedNormal *= signDet;
        #endif
        transformedNormal = normalMatrix * transformedNormal;
        #ifdef FLIP_SIDED
            transformedNormal = - transformedNormal;
        #endif
        #ifdef USE_TANGENT
            vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
            #ifdef FLIP_SIDED
                transformedTangent = - transformedTangent;
            #endif
        #endif
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	// #include <project_vertex> COMMENTED CHUNK
    #ifdef TRANSFORM_STORAGE
        vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;
        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);
    #endif
    #ifdef USE_RTE
        vec4 position_lowT = vec4(position_low, 1.);
        vec4 position_highT = vec4(position, 1.);
        const vec3 ZERO3 = vec3(0., 0., 0.);

        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);
        #ifdef TRANSFORM_STORAGE
            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;
        #endif
    #endif

    #ifdef USE_RTE
        vec4 mvPosition = rteLocalPosition;
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
        #ifdef TRANSFORM_STORAGE
            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif
    #endif
    
    mvPosition = modelViewMatrix * mvPosition;

    gl_Position = projectionMatrix * mvPosition;
    
    // Transform normal vector from object space to clip space.
    vec3 normalHCS = mat3(projectionMatrix) * normalMatrix * normal;

    // Move vertex along normal vector in clip space.
    gl_Position.xy += normalize(normalHCS.xy) / size * gl_Position.w * displacement * 2.;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`}get fragmentProgram(){return`
uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	// modulation
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`}get uniformsDef(){return{...super.uniformsDef,size:new te,displacement:0}}constructor(e,t=[]){super(e,t)}fastCopy(e,t){super.fastCopy(e,t),t.userData.displacement.value=e.userData.displacement.value}}class ua extends Sn{constructor(){super(),this.stencilMaterial=new hb({color:16711680}),this.stencilMaterial.userData.displacement.value=2,this.stencilMaterial.colorWrite=!1,this.stencilMaterial.depthWrite=!1,this.stencilMaterial.stencilWrite=!0,this.stencilMaterial.stencilFunc=Bu,this.stencilMaterial.stencilWriteMask=255,this.stencilMaterial.stencilRef=255,this.stencilMaterial.stencilZFail=$s,this.stencilMaterial.stencilZPass=$s,this.stencilMaterial.stencilFail=$s,this.stencilMaterial.side=yt}get displayName(){return"STENCIL"}get overrideMaterial(){return this.stencilMaterial}setSize(e,t){super.setSize(e,t),this.stencilMaterial.userData.size.value.copy(new te(e,t)),this.stencilMaterial.needsUpdate=!0}}class ha extends Sn{constructor(){super(),this.stencilMaskMaterial=new hb({color:304635}),this.stencilMaskMaterial.userData.displacement.value=2,this.stencilMaskMaterial.colorWrite=!0,this.stencilMaskMaterial.depthWrite=!1,this.stencilMaskMaterial.stencilWrite=!0,this.stencilMaskMaterial.stencilFunc=VA,this.stencilMaskMaterial.stencilRef=255,this.stencilMaskMaterial.side=yt}get displayName(){return"STENCIL-MASK"}get overrideMaterial(){return this.stencilMaskMaterial}setSize(e,t){super.setSize(e,t),this.stencilMaskMaterial.userData.size.value.copy(new te(e,t)),this.stencilMaskMaterial.needsUpdate=!0}}const ur={depthMultiplier:1,depthBias:.001,normalMultiplier:1,normalBias:15,outlineThickness:1,outlineOpacity:.75,outlineColor:3289650,backgroundColor:268435455};class mc extends Ts{set options(e){var t,n,i,r,s,o,l,c;super.options=e,this.edgesMaterial.uniforms.uDepthMultiplier.value=(t=this._options.depthMultiplier)!==null&&t!==void 0?t:ur.depthMultiplier,this.edgesMaterial.uniforms.uDepthBias.value=(n=this._options.depthBias)!==null&&n!==void 0?n:ur.depthBias,this.edgesMaterial.uniforms.uNormalMultiplier.value=(i=this._options.normalMultiplier)!==null&&i!==void 0?i:ur.normalMultiplier,this.edgesMaterial.uniforms.uNormalBias.value=(r=this._options.normalBias)!==null&&r!==void 0?r:ur.normalBias,this.edgesMaterial.uniforms.uOutlineThickness.value=(s=this._options.outlineThickness)!==null&&s!==void 0?s:ur.outlineThickness,this.edgesMaterial.uniforms.uOutlineDensity.value=(o=this._options.outlineOpacity)!==null&&o!==void 0?o:ur.outlineOpacity,this.edgesMaterial.uniforms.uOutlineColor.value=new Ie((l=this._options.outlineColor)!==null&&l!==void 0?l:ur.outlineColor),this.edgesMaterial.uniforms.uBackgroundColor.value=new Ie((c=this._options.backgroundColor)!==null&&c!==void 0?c:ur.backgroundColor)}constructor(){super(),this._options=Object.assign({},ur),this._outputTarget=pa.createRenderTarget({minFilter:St,magFilter:St}),this.edgesMaterial=new gn({fragmentShader:`
#include <common>
varying vec2 vUv;
uniform sampler2D tDepth;
uniform sampler2D tNormal;
uniform sampler2D tId;
uniform float uDepthMultiplier;
uniform float uDepthBias;
uniform float uNormalMultiplier;
uniform float uNormalBias;
uniform float uOutlineThickness;
uniform float uOutlineDensity;
uniform vec3 uOutlineColor;
uniform vec3 uBackgroundColor;
uniform vec2 size;

uniform float cameraNear;
uniform float cameraFar;
uniform mat4 cameraProjectionMatrix;
uniform mat4 cameraInverseProjectionMatrix;

#define ID_GRADIENT_THRESHOLD 1e-4
#include <packing>


float getDepth( const in ivec2 screenPosition ) {
  #if __VERSION__ == 300
	  return unpackRGBAToDepth( texelFetch( tDepth, clamp(screenPosition, ivec2(0,0), ivec2(size)), 0 ) );
  #else
    vec2 cUv = vec2(0.5/size.x, 0.5/size.y);
    return unpackRGBAToDepth( texture2D( tDepth, vec2(min(screenPosition, ivec2(size)))/size + cUv ) );
  #endif
}



vec3 SobelSample(sampler2D t, vec2 uv, vec3 offset){
	vec3 pixelCenter = texture2D(t, uv).rgb;
	vec3 pixelLeft   = texture2D(t, uv - offset.xz).rgb;
	vec3 pixelRight  = texture2D(t, uv + offset.xz).rgb;
	vec3 pixelUp     = texture2D(t, uv + offset.zy).rgb;
	vec3 pixelDown   = texture2D(t, uv - offset.zy).rgb;

	return abs(pixelLeft - pixelCenter)  +
			abs(pixelRight - pixelCenter) +
			abs(pixelUp - pixelCenter)    +
			abs(pixelDown - pixelCenter);
}


float GetTolerance(float d, float k)
{
    // -------------------------------------------
    // Find a tolerance for depth that is constant
    // in view space (k in view space).
    //
    // tol = k*ddx(ZtoDepth(z))
    // -------------------------------------------
    
    float A=-   (cameraFar+cameraNear)/(cameraFar - cameraNear);
    float B=-2.0*cameraFar*cameraNear /(cameraFar -cameraNear);
    
    d = d*2.0-1.0;
    
    return -k*(d+A)*(d+A)/B;   
}

float DetectSilho(ivec2 fragCoord, ivec2 dir, float tolerance)
{
    // -------------------------------------------
    //   x0 ___ x1----o 
    //          :    : 
    //       r0 :    : r1
    //          :    : 
    //          o---x2 ___ x3
    //
    // r0 and r1 are the differences between actual
    // and expected (as if x0..3 where on the same
    // plane) depth values.
    // -------------------------------------------
    float x0 = abs(getDepth(fragCoord + dir*-2));
    float x1 = abs(getDepth(fragCoord + dir*-1));
    float x2 = abs(getDepth(fragCoord + dir* 0));
    float x3 = abs(getDepth(fragCoord + dir* 1));
    
    float d0 = (x1-x0);
    float d1 = (x2-x3);
    
    float r0 = x1 + d0 - x2;
    float r1 = x2 + d1 - x1;
    
    float tol = GetTolerance(x2, tolerance);
    
    return smoothstep(0.0, tol*tol, max( - r0*r1, 0.0));

}

// Source: https://www.shadertoy.com/view/DslXz2
float DepthEdge(ivec2 fragCoord, float tolerance)
{
    return max(
        DetectSilho(fragCoord, ivec2(1,0), tolerance), // Horizontal
        DetectSilho(fragCoord, ivec2(0,1), tolerance)  // Vertical
        );
}

float NormalEdge(float scale)
{
	float halfScaleFloor = floor(scale * 0.5);
	float halfScaleCeil = ceil(scale * 0.5);

	vec2 pixelSize = vec2(1.0 / size.x, 1.0 / size.y);

	vec2 bottomLeftUV = vUv - pixelSize * halfScaleFloor;
	vec2 topRightUV = vUv + pixelSize * halfScaleCeil;  
	vec2 bottomRightUV = vUv + vec2(pixelSize.x * halfScaleCeil, -pixelSize.y * halfScaleFloor);
	vec2 topLeftUV = vUv + vec2(-pixelSize.x * halfScaleFloor, pixelSize.y * halfScaleCeil);

	vec3 centerNormal = unpackRGBToNormal(texture2D(tNormal, vUv).rgb);
	vec3 normal0 = unpackRGBToNormal(texture2D(tNormal, bottomLeftUV).rgb);
	vec3 normal1 = unpackRGBToNormal(texture2D(tNormal, topRightUV).rgb);
	vec3 normal2 = unpackRGBToNormal(texture2D(tNormal, bottomRightUV).rgb);
	vec3 normal3 = unpackRGBToNormal(texture2D(tNormal, topLeftUV).rgb);

	vec3 normalFiniteDifference0 = normal1 - normal0;
	vec3 normalFiniteDifference1 = normal3 - normal2;

	return sqrt(dot(normalFiniteDifference0, normalFiniteDifference0) + dot(normalFiniteDifference1, normalFiniteDifference1));
}

/** Alternative to NormalEdge. */
vec3 SobelSampleNormal(vec2 uv){
	float w = 1.0 / size.x;
	float h = 1.0 / size.y;
	vec3 n[9];
	n[0] = unpackRGBToNormal(texture2D(tNormal, uv + vec2( -w, -h)).rgb);
	n[1] = unpackRGBToNormal(texture2D(tNormal, uv + vec2(0.0, -h)).rgb);
	n[2] = unpackRGBToNormal(texture2D(tNormal, uv + vec2(  w, -h)).rgb);
	n[3] = unpackRGBToNormal(texture2D(tNormal, uv + vec2( -w, 0.0)).rgb);
	n[4] = unpackRGBToNormal(texture2D(tNormal, uv).rgb);
	n[5] = unpackRGBToNormal(texture2D(tNormal, uv + vec2(  w, 0.0)).rgb);
	n[6] = unpackRGBToNormal(texture2D(tNormal, uv + vec2( -w, h)).rgb);
	n[7] = unpackRGBToNormal(texture2D(tNormal, uv + vec2(0.0, h)).rgb);
	n[8] = unpackRGBToNormal(texture2D(tNormal, uv + vec2(  w, h)).rgb);

	vec3 sobel_edge_h = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);
  	vec3 sobel_edge_v = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);
	vec3 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));
	return sobel;
}


void main() {
	// Depth edge
  float depthEdge = DepthEdge(ivec2(gl_FragCoord), uDepthBias) * uDepthMultiplier; 
  // Normal edge
	float normalEdge = pow(NormalEdge(uOutlineThickness) * uNormalMultiplier, uNormalBias);
  // Id edge
	vec3 offset = vec3((1.0 / size.x), (1.0 / size.y), 0.0) * uOutlineThickness;
	vec3 sobelIdVec = abs(SobelSample(tId, vUv, offset));
  // This is the branchless equivalent of sobelIdVec.x + sobelIdVec.y + sobelIdVec.z > ID_GRADIENT_THRESHOLD ? 1. : 0.
	float sobelIdEdge = step(ID_GRADIENT_THRESHOLD, sobelIdVec.x + sobelIdVec.y + sobelIdVec.z);

  // Combine the three edges by taking the minimum
  float maxOutline = saturate(max(sobelIdEdge, max(depthEdge, normalEdge)));
	float sobelOutline = maxOutline * uOutlineDensity;

  
  vec3 color = mix(uBackgroundColor, uOutlineColor, sobelOutline);
  float alpha = mix(0., uOutlineDensity, sobelOutline);
  // vec3 color = vec3(depthEdge, normalEdge, sobelIdEdge); // Debug
	gl_FragColor = vec4(color, alpha);

}`,vertexShader:`
varying vec2 vUv;
void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,uniforms:{tDepth:{value:null},tNormal:{value:null},tId:{value:null},size:{value:new te(512,512)},uDepthMultiplier:{value:this._options.depthMultiplier},uDepthBias:{value:this._options.depthBias},uNormalMultiplier:{value:this._options.normalMultiplier},uNormalBias:{value:this._options.normalBias},uOutlineThickness:{value:this._options.outlineThickness},uOutlineDensity:{value:this._options.outlineOpacity},uOutlineColor:{value:new Ie(this._options.outlineColor)},uBackgroundColor:{value:new Ie(this._options.backgroundColor)},cameraNear:{value:1},cameraFar:{value:100},cameraProjectionMatrix:{value:new ae},cameraInverseProjectionMatrix:{value:new ae}}}),this.edgesMaterial.depthWrite=!1,this.fsQuad=new zl(this.edgesMaterial)}setTexture(e,t){this.edgesMaterial.uniforms[e].value=t,this.edgesMaterial.needsUpdate=!0}get displayName(){return"EDGES"}update(e){this.edgesMaterial.defines.PERSPECTIVE_CAMERA=e.isPerspectiveCamera?1:0,this.edgesMaterial.uniforms.cameraNear.value=e.near,this.edgesMaterial.uniforms.cameraFar.value=e.far}render(e){return this.onBeforeRender&&this.onBeforeRender(),e.setRenderTarget(this._outputTarget),this.fsQuad.render(e),this.onAfterRender&&this.onAfterRender(),!1}setSize(e,t){super.setSize(e,t),this.edgesMaterial.uniforms.size.value.set(e,t),this.edgesMaterial.needsUpdate=!0}}class lf extends qu{constructor(){super(),this.outputToScreen=!1,this._outputTarget=new pn(256,256,{minFilter:St,magFilter:St}),this.historyTarget=new pn(256,256,{minFilter:St,magFilter:St}),this.materialCopy=new gn({uniforms:Hr.clone(Gd.uniforms),vertexShader:Gd.vertexShader,fragmentShader:Gd.fragmentShader,blending:Mn}),this.materialCopy.needsUpdate=!0,this.reprojectionMaterial=new gn({uniforms:{tDiffuse:{value:null},tLastFrame:{value:null},width:{value:0},height:{value:0}},transparent:!0,blending:Mn,depthTest:!1,depthWrite:!1,vertexShader:`
    varying vec2 Uv;
    
    void main() {
        Uv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }`,fragmentShader:`
    uniform float height;
    uniform float width;
    uniform sampler2D tDiffuse;
    uniform sampler2D tLastFrame;
    varying vec2 Uv;

    #define LuminanceEncodeApprox vec3(0.2126, 0.7152, 0.0722)
    float getLuminance(vec3 color) {
        return clamp(dot(color, LuminanceEncodeApprox), 0., 1.);
    }
    
    void main() {
        vec4 texel = texture2D(tDiffuse, Uv);
        vec2 oldPixelUv = Uv;
        vec4 oldTexel = texture2D(tLastFrame, oldPixelUv);

        // Use simple neighbor clamping
        vec4 maxNeighbor = vec4(0.0, 0.0, 0.0, 1.0);
        vec4 minNeighbor = vec4(1.0);
        vec4 average = vec4(0.0);
        for (int x = -1; x <= 1; x++) {
            for (int y = -1; y <= 1; y++) {
                vec2 neighborUv = Uv + vec2(float(x) / width, float(y) / height);
                vec4 neighborTexel = texture2D(tDiffuse, neighborUv);
                maxNeighbor = max(maxNeighbor, neighborTexel);
                minNeighbor = min(minNeighbor, neighborTexel);
                average += neighborTexel / 9.0;
            }
        }
        float lum0 = getLuminance(texel.rgb);
        float lum1 = getLuminance(oldTexel.rgb);

        float unbiased_diff = abs(lum0 - lum1) / max(lum0, max(lum1, 0.2));
        float unbiased_weight = 1.0 - unbiased_diff;
        float unbiased_weight_sqr = unbiased_weight * unbiased_weight;
        float k_feedback = mix(0.8800, 0.9700, unbiased_weight_sqr);
        
        // UE Method to get rid of flickering. Weight frame mixing amount
        // based on local contrast.
        float contrast = distance(average, texel);
        float weight = 0.05 * contrast;

        float blendFactor = mix(1. - weight, k_feedback, 1.);
        vec4 compositeColor = mix(texel, oldTexel, blendFactor);
    
        gl_FragColor = compositeColor;
    }`}),this.reprojectionMaterial.needsUpdate=!0,this.fsQuad=new zl}get displayName(){return"TAA"}set inputTexture(e){this.inputTex=e}render(e){var t,n;return this.frameIndex===0&&(e.setRenderTarget(this._outputTarget),e.clear(),this.materialCopy.uniforms.tDiffuse.value=this.inputTex,this.materialCopy.needsUpdate=!0,this.fsQuad.material=this.materialCopy,this.fsQuad.render(e)),e.setRenderTarget(this.historyTarget),e.clear(),this.reprojectionMaterial.uniforms.tLastFrame.value=(t=this._outputTarget)===null||t===void 0?void 0:t.texture,this.reprojectionMaterial.uniforms.tDiffuse.value=this.inputTex,this.reprojectionMaterial.needsUpdate=!0,this.fsQuad.material=this.reprojectionMaterial,this.fsQuad.render(e),e.setRenderTarget(this._outputTarget),e.clear(),this.materialCopy.uniforms.tDiffuse.value=this.historyTarget.texture,this.materialCopy.needsUpdate=!0,this.fsQuad.material=this.materialCopy,this.fsQuad.render(e),this.outputToScreen&&(e.setRenderTarget(null),this.materialCopy.uniforms.tDiffuse.value=(n=this._outputTarget)===null||n===void 0?void 0:n.texture,this.materialCopy.needsUpdate=!0,this.fsQuad.material=this.materialCopy,this.fsQuad.render(e)),super.render(e)}setSize(e,t){super.setSize(e,t),this.historyTarget.setSize(e,t),this.reprojectionMaterial.uniforms.width.value=e,this.reprojectionMaterial.uniforms.height.value=t}}class db extends Yu{get vertexProgram(){return`
#include <common>
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
    uniform mat4 rteModelViewMatrix;
#endif

#ifdef TRANSFORM_STORAGE
    attribute float objIndex;

    #if TRANSFORM_STORAGE == 0
        #if __VERSION__ == 300
            #define TRANSFORM_STRIDE 4
        #else
            #define TRANSFORM_STRIDE 4.
        #endif
        uniform sampler2D tTransforms;
        uniform float objCount;
    #elif TRANSFORM_STORAGE == 1
        uniform mat4 uTransforms[OBJ_COUNT];
    #endif
#endif

#ifdef LINEAR_DEPTH
    varying vec4 vViewPosition;
#endif
varying vec3 vNormal;

#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
varying vec2 vHighPrecisionZW;

#ifdef TRANSFORM_STORAGE
    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){
        #if TRANSFORM_STORAGE == 0
            #if __VERSION__ == 300
                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); 
                vec4 v0 = texelFetch( tTransforms, uv, 0 );
                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);
                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);
                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #else
                float size = objCount * TRANSFORM_STRIDE;
                vec2 cUv = vec2(0.5/size, 0.5);
                vec2 dUv = vec2(1./size, 0.);
                
                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);
                vec4 v0 = texture2D( tTransforms, uv);
                vec4 v1 = texture2D( tTransforms, uv + dUv);
                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);
                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #endif
        #elif TRANSFORM_STORAGE == 1
            mat4 tMatrix = uTransforms[int(objIndex)];
            quaternion = tMatrix[0];
            pivotLow = vec4(tMatrix[1].xyz, 1.);
            pivotHigh = vec4(tMatrix[2].xyz, 1.);
            translation = vec4(tMatrix[3].xyz, 1.);
            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);
        #endif
    }

    vec3 rotate_vertex_position(vec3 position, vec4 quat)
    { 
        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);
    }

    /** Another workaround for Apple's stupid compiler */
    vec4 safeMul(vec4 a, vec4 b) {
        // Prevents constant folding and optimization
        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);
    }

    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)
    {
        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */
        /** The code below will not produce correct results in intel IrisXE integrated GPUs. 
         *  The geometry will turn mangled, albeit stable
         *  I can't know for sure what is going on, but rotating the difference seems to 
         *  force the result into a lower precision?
         */
        // highp vec4 position = v0 - v1;
        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);

        /** Subtracting the rotated vectors works. */
        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;

        /** An alternate workaround is
         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));
           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);

           However I'm not such a fan of the (1. + 1e-7) part
         */
    }
#endif

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }
#endif


void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
    #include <beginnormal_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
    // #include <defaultnormal_vertex> // COMMENTED CHUNK
    vec3 transformedNormal = objectNormal;
    #ifdef USE_INSTANCING

        // this is in lieu of a per-instance normal-matrix
        // shear transforms in the instance matrix are not supported
        mat3 m = mat3( instanceMatrix );
        transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
        transformedNormal = m * transformedNormal;
        
        /* If we have negative scaling, we flip the normal */
        float signDet = sign(dot(m[0], cross(m[1], m[2])));
        // Optional fallback: treat 0 as +1
        signDet = signDet + (1.0 - abs(signDet));
        transformedNormal *= signDet;
    #endif
    transformedNormal = normalMatrix * transformedNormal;
    #ifdef FLIP_SIDED
        transformedNormal = - transformedNormal;
    #endif
    #ifdef USE_TANGENT
        vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
        #ifdef FLIP_SIDED
            transformedTangent = - transformedTangent;
        #endif
    #endif
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	//#include <project_vertex> // EDITED CHUNK
    #ifdef TRANSFORM_STORAGE
        vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;
        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);
    #endif
    #ifdef USE_RTE
        vec4 position_lowT = vec4(position_low, 1.);
        vec4 position_highT = vec4(position, 1.);
        const vec3 ZERO3 = vec3(0., 0., 0.);

        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);
        #ifdef TRANSFORM_STORAGE
            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;
        #endif
    #endif

    #ifdef USE_RTE
        vec4 mvPosition = rteLocalPosition;
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
        #ifdef TRANSFORM_STORAGE
            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif
    #endif
   
    #ifdef USE_RTE
        mvPosition = rteModelViewMatrix * mvPosition;
    #else
        mvPosition = modelViewMatrix * mvPosition;
    #endif
    
    #ifdef LINEAR_DEPTH
        vViewPosition = mvPosition;
    #endif 
    vNormal = normalize( transformedNormal );
    gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	// #include <clipping_planes_vertex>
    #if NUM_CLIPPING_PLANES > 0
	    vClipPosition = - mvPosition.xyz;
    #endif
	vHighPrecisionZW = gl_Position.zw;
}
`}get fragmentProgram(){return`
#if __VERSION__ == 100
    #extension GL_EXT_draw_buffers : require
#endif

#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#ifdef LINEAR_DEPTH
    varying vec4 vViewPosition;
	uniform float near;
	uniform float far;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
varying vec3 vNormal;

#if __VERSION__ == 300
    layout(location = 1) out vec4 gNormal;
#endif

void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	// #include <alphatest_fragment>
	#ifdef USE_ALPHATEST
		if ( diffuseColor.a < alphaTest ) discard;
		/** This is a workaround for rejecting shadows for certain materials, since three.js gave me no choice*/
		#ifdef ALPHATEST_REJECTION
			if (alphaTest > 0. ) discard;
		#endif
	#endif
	#include <logdepthbuf_fragment>
    vec3 normal = normalize( vNormal );

    /** Output view space normals*/
    
    vec4 outNormal = vec4( packNormalToRGB( normal ), 1.0 );
    vec4 outDepth;
	// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.
	#ifdef LINEAR_DEPTH
		/** View z is negative moving away from the camera */
		outDepth = packDepthToRGBA((vViewPosition.z + near) / (near - far));
	#else
		float fragCoordZ = (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5);
		#if DEPTH_PACKING == 3200
			outDepth = vec4( vec3( 1.0 - fragCoordZ ), opacity );
		#elif DEPTH_PACKING == 3201
			outDepth = packDepthToRGBA( fragCoordZ );
		#endif
	#endif
    #if __VERSION__ == 300
        pc_fragColor = outDepth;
        gNormal = outNormal;
    #else
        gl_FragData[0] = outDepth;
        gl_FragData[1] = outNormal;
    #endif
}
`}}const fb={...cb};class pb extends Ts{get displayName(){return"DEPTH-NORMAL"}get overrideMaterial(){return this.mrtMaterial}get depthTexture(){return this.mrt.texture[0]}get normalTexture(){return this.mrt.texture[1]}get outputTarget(){return this.mrt}set outputTarget(e){this.mrt=e}set options(e){super.options=e,this.depthType=this._options.depthType}set depthType(e){e===Eu.LINEAR_DEPTH&&(this.mrtMaterial.defines?this.mrtMaterial.defines.LINEAR_DEPTH=" ":this.mrtMaterial.defines&&delete this.mrtMaterial.defines.LINEAR_DEPTH),this.mrtMaterial.needsUpdate=!0}constructor(){super(),this._options=Object.assign({},fb),this.mrt=pa.createMultipleRenderTarget(2,{minFilter:Dt,magFilter:Dt}),this.mrtMaterial=new db({depthPacking:da},["ALPHATEST_REJECTION"]),this.mrtMaterial.blending=Mn,this.mrtMaterial.side=yt,this.depthType=this._options.depthType}setClippingPlanes(e){this.mrtMaterial.clippingPlanes=e}update(e){this.mrtMaterial.userData.near.value=e.near,this.mrtMaterial.userData.far.value=e.far,this.mrtMaterial.needsUpdate=!0}render(e,t,n){return!(!t||!n)&&(this.onBeforeRender&&this.onBeforeRender(),e.setRenderTarget(this.mrt),this.applyLayers(t),this.clear(e),e.render(n,t),this.onAfterRender&&this.onAfterRender(),!1)}setSize(e,t){this.mrt.setSize(e,t)}}class UN extends db{get vertexProgram(){return`
#include <common>
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
    uniform mat4 rteModelViewMatrix;
#endif

#if defined( TRANSFORM_STORAGE ) || ( defined( USE_INSTANCING ) && __VERSION__ == 100)
    attribute float objIndex;
#endif

#ifdef TRANSFORM_STORAGE
    #if TRANSFORM_STORAGE == 0
        #if __VERSION__ == 300
            #define TRANSFORM_STRIDE 4
        #else
            #define TRANSFORM_STRIDE 4.
        #endif
        uniform sampler2D tTransforms;
        uniform float objCount;
    #elif TRANSFORM_STORAGE == 1
        uniform mat4 uTransforms[OBJ_COUNT];
    #endif
#endif

varying vec3 vIdColor;
uniform int batchIndex;

#ifdef LINEAR_DEPTH
    varying vec4 vViewPosition;
#endif
varying vec3 vNormal;

#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
varying vec2 vHighPrecisionZW;

#ifdef TRANSFORM_STORAGE
    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){
        #if TRANSFORM_STORAGE == 0
            #if __VERSION__ == 300
                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); 
                vec4 v0 = texelFetch( tTransforms, uv, 0 );
                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);
                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);
                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #else
                float size = objCount * TRANSFORM_STRIDE;
                vec2 cUv = vec2(0.5/size, 0.5);
                vec2 dUv = vec2(1./size, 0.);
                
                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);
                vec4 v0 = texture2D( tTransforms, uv);
                vec4 v1 = texture2D( tTransforms, uv + dUv);
                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);
                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #endif
        #elif TRANSFORM_STORAGE == 1
            mat4 tMatrix = uTransforms[int(objIndex)];
            quaternion = tMatrix[0];
            pivotLow = vec4(tMatrix[1].xyz, 1.);
            pivotHigh = vec4(tMatrix[2].xyz, 1.);
            translation = vec4(tMatrix[3].xyz, 1.);
            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);
        #endif
    }

    vec3 rotate_vertex_position(vec3 position, vec4 quat)
    { 
        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);
    }

    /** Another workaround for Apple's stupid compiler */
    vec4 safeMul(vec4 a, vec4 b) {
        // Prevents constant folding and optimization
        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);
    }

    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)
    {
        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */
        /** The code below will not produce correct results in intel IrisXE integrated GPUs. 
         *  The geometry will turn mangled, albeit stable
         *  I can't know for sure what is going on, but rotating the difference seems to 
         *  force the result into a lower precision?
         */
        // highp vec4 position = v0 - v1;
        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);

        /** Subtracting the rotated vectors works. */
        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;

        /** An alternate workaround is
         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));
           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);

           However I'm not such a fan of the (1. + 1e-7) part
         */
    }
#endif

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }
#endif


/** Original glsl100 and glsl300 hash functions. Good outputs but maybe a bit slow? */
/*
#if __VERSION__ == 300
    vec3 hashColor(uint id) {
        // A simple integer hash function
        id = (id ^ 61u) ^ (id >> 16u);
        id = id * 9u;
        id = id ^ (id >> 4u);
        id = id * 0x27d4eb2du;
        id = id ^ (id >> 15u);

        return vec3(
            float((id >> 16u) & 0xFFu) / 255.0,
            float((id >> 8u) & 0xFFu) / 255.0,
            float(id & 0xFFu) / 255.0
        );
    }
#elif __VERSION__ == 100
    vec3 hashColor(float id) {
        // Step 1: Simulate XOR by using mod and floating-point arithmetic
        id = mod(id + 61.0, 4294967296.0);
        id = mod(id - floor(id / 65536.0), 4294967296.0); // Approximate id ^ (id >> 16)
        // Step 2: Multiply by 9 (same as original)
        id = mod(id * 9.0, 4294967296.0);
        // Step 3: Simulate XOR with division/mod trick
        id = mod(id - floor(id / 16.0), 4294967296.0); // Approximate id ^ (id >> 4)
        // Step 4: Multiply by large prime
        id = mod(id * 666083407.0, 4294967296.0); // Approximate * 0x27d4eb2dU
        // Step 5: Simulate final XOR
        id = mod(id - floor(id / 32768.0), 4294967296.0); // Approximate id ^ (id >> 15)
        // Convert hash to RGB by extracting "fake" bit shifts
        return vec3(
            mod(floor(id / 65536.0), 256.0) / 255.0, // Simulates (id >> 16) & 0xFF
            mod(floor(id / 256.0), 256.0) / 255.0,   // Simulates (id >> 8) & 0xFF
            mod(id, 256.0) / 255.0                   // Simulates id & 0xFF
        );
    }
#endif
*/

/** Simpler hash function works on both glsl versions */
highp vec3 hashColor(float id) {
    // Large prime multipliers
    highp float r = mod(id * 127.1, 256.0) / 255.0;
    highp float g = mod(id * 987.654, 256.0) / 255.0;
    highp float b = mod(id * 4321.123, 256.0) / 255.0;
    
    return vec3(r, g, b);
}

int szudzikHash(int x, int y) {
    return (x >= y) ? (x * x + x + y) : (y * y + x);
}

void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
    #include <beginnormal_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
    // #include <defaultnormal_vertex> // COMMENTED CHUNK
    vec3 transformedNormal = objectNormal;
    #ifdef USE_INSTANCING

        // this is in lieu of a per-instance normal-matrix
        // shear transforms in the instance matrix are not supported
        mat3 m = mat3( instanceMatrix );
        transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
        transformedNormal = m * transformedNormal;
        
        /* If we have negative scaling, we flip the normal */
        float signDet = sign(dot(m[0], cross(m[1], m[2])));
        // Optional fallback: treat 0 as +1
        signDet = signDet + (1.0 - abs(signDet));
        transformedNormal *= signDet;
    #endif
    transformedNormal = normalMatrix * transformedNormal;
    #ifdef FLIP_SIDED
        transformedNormal = - transformedNormal;
    #endif
    #ifdef USE_TANGENT
        vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
        #ifdef FLIP_SIDED
            transformedTangent = - transformedTangent;
        #endif
    #endif
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	//#include <project_vertex> // EDITED CHUNK
    #ifdef TRANSFORM_STORAGE
        vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;
        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);
    #endif
    #ifdef USE_RTE
        vec4 position_lowT = vec4(position_low, 1.);
        vec4 position_highT = vec4(position, 1.);
        const vec3 ZERO3 = vec3(0., 0., 0.);

        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);
        #ifdef TRANSFORM_STORAGE
            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;
        #endif
    #endif

    #ifdef USE_RTE
        vec4 mvPosition = rteLocalPosition;
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
        #ifdef TRANSFORM_STORAGE
            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif
    #endif
   
    #ifdef USE_RTE
        mvPosition = rteModelViewMatrix * mvPosition;
    #else
        mvPosition = modelViewMatrix * mvPosition;
    #endif
    
    #ifdef LINEAR_DEPTH
        vViewPosition = mvPosition;
    #endif 

    vNormal = normalize( transformedNormal );
    
    #ifdef TRANSFORM_STORAGE
        vIdColor = hashColor(float(szudzikHash(int(objIndex), batchIndex)));
    #else
        #if defined( USE_INSTANCING ) 
            #if __VERSION__ == 300
                vIdColor = hashColor(float(szudzikHash(int(gl_InstanceID), batchIndex)));
            #elif __VERSION__ == 100
                vIdColor = hashColor(float(szudzikHash(int(objIndex), batchIndex)));
            #endif
        #else
            vIdColor = vec3(0.);
        #endif
    #endif


    gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	// #include <clipping_planes_vertex>
    #if NUM_CLIPPING_PLANES > 0
	    vClipPosition = - mvPosition.xyz;
    #endif
	vHighPrecisionZW = gl_Position.zw;
}
`}get fragmentProgram(){return`
#if __VERSION__ == 100
    #extension GL_EXT_draw_buffers : require
#endif

#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#ifdef LINEAR_DEPTH
    varying vec4 vViewPosition;
	uniform float near;
	uniform float far;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
varying vec3 vNormal;

varying vec3 vIdColor;

#if __VERSION__ == 300
    layout(location = 1) out vec4 gNormal;
    layout(location = 2) out vec4 gId;
#endif

void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	// #include <alphatest_fragment>
	#ifdef USE_ALPHATEST
		if ( diffuseColor.a < alphaTest ) discard;
		/** This is a workaround for rejecting shadows for certain materials, since three.js gave me no choice*/
		#ifdef ALPHATEST_REJECTION
			if (alphaTest > 0. ) discard;
		#endif
	#endif
	#include <logdepthbuf_fragment>
    vec3 normal = normalize( vNormal );

    /** Output view space normals*/
    
    vec4 outNormal = vec4( packNormalToRGB( normal ), 1.0 );
    vec4 outDepth;
	// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.
	#ifdef LINEAR_DEPTH
		/** View z is negative moving away from the camera */
		outDepth = packDepthToRGBA((vViewPosition.z + near) / (near - far));
	#else
		float fragCoordZ = (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5);
		#if DEPTH_PACKING == 3200
			outDepth = vec4( vec3( 1.0 - fragCoordZ ), opacity );
		#elif DEPTH_PACKING == 3201
			outDepth = packDepthToRGBA( fragCoordZ );
		#endif
	#endif
    #if __VERSION__ == 300
        pc_fragColor = outDepth;
        gNormal = outNormal;
        gId = vec4(vIdColor, 1.0);
    #else
        gl_FragData[0] = outDepth;
        gl_FragData[1] = outNormal;
        gl_FragData[2] = vec4(vIdColor, 1.0);
    #endif
}
`}get uniformsDef(){return{...super.uniformsDef,batchIndex:0}}onBeforeRender(e,t,n,i,r){this.defines&&this.defines.USE_RTE&&(r.modelViewMatrix.copy(e.RTEBuffers.rteViewModelMatrix),this.userData.uViewer_low.value.copy(e.RTEBuffers.viewerLow),this.userData.uViewer_high.value.copy(e.RTEBuffers.viewerHigh),this.userData.rteModelViewMatrix.value.copy(e.RTEBuffers.rteViewModelMatrix),this.needsUpdate=!0),(r instanceof wl||r instanceof ib)&&(this.userData.batchIndex.value=r.batchIndex,this.needsUpdate=!0)}}const FN={...fb};class Cd extends pb{get displayName(){return"DEPTH-NORMAL-ID"}get idTexture(){return this.mrt.texture[2]}set options(e){super.options=e}constructor(){super(),this._options=Object.assign({},FN),this.mrt=pa.createMultipleRenderTarget(3,{minFilter:Dt,magFilter:Dt}),this.mrtMaterial=new UN({depthPacking:da},["ALPHATEST_REJECTION"]),this.mrtMaterial.blending=Mn,this.mrtMaterial.side=yt,this.depthType=this._options.depthType}}class HN extends ZM{get vertexProgram(){return`
#define NORMAL
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
#endif

#ifdef TRANSFORM_STORAGE
    attribute float objIndex;

    #if TRANSFORM_STORAGE == 0
        #if __VERSION__ == 300
            #define TRANSFORM_STRIDE 4
        #else
            #define TRANSFORM_STRIDE 4.
        #endif
        uniform sampler2D tTransforms;
        uniform float objCount;
    #elif TRANSFORM_STORAGE == 1
        uniform mat4 uTransforms[OBJ_COUNT];
    #endif
#endif

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }
#endif

#ifdef TRANSFORM_STORAGE
    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){
        #if TRANSFORM_STORAGE == 0
            #if __VERSION__ == 300
                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); 
                vec4 v0 = texelFetch( tTransforms, uv, 0 );
                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);
                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);
                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #else
                float size = objCount * TRANSFORM_STRIDE;
                vec2 cUv = vec2(0.5/size, 0.5);
                vec2 dUv = vec2(1./size, 0.);
                
                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);
                vec4 v0 = texture2D( tTransforms, uv);
                vec4 v1 = texture2D( tTransforms, uv + dUv);
                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);
                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #endif
        #elif TRANSFORM_STORAGE == 1
            mat4 tMatrix = uTransforms[int(objIndex)];
            quaternion = tMatrix[0];
            pivotLow = vec4(tMatrix[1].xyz, 1.);
            pivotHigh = vec4(tMatrix[2].xyz, 1.);
            translation = vec4(tMatrix[3].xyz, 1.);
            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);
        #endif
    }

    vec3 rotate_vertex_position(vec3 position, vec4 quat)
    { 
        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);
    }

    /** Another workaround for Apple's stupid compiler */
    vec4 safeMul(vec4 a, vec4 b) {
        // Prevents constant folding and optimization
        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);
    }

    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)
    {
        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */
        /** The code below will not produce correct results in intel IrisXE integrated GPUs. 
         *  The geometry will turn mangled, albeit stable
         *  I can't know for sure what is going on, but rotating the difference seems to 
         *  force the result into a lower precision?
         */
        // highp vec4 position = v0 - v1;
        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);

        /** Subtracting the rotated vectors works. */
        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;

        /** An alternate workaround is
         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));
           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);

           However I'm not such a fan of the (1. + 1e-7) part
         */
    }

#endif

void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
    // #include <defaultnormal_vertex> // COMMENTED CHUNK
    vec3 transformedNormal = objectNormal;
    #ifdef USE_INSTANCING

        // this is in lieu of a per-instance normal-matrix
        // shear transforms in the instance matrix are not supported
        mat3 m = mat3( instanceMatrix );
        transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
        transformedNormal = m * transformedNormal;
        
        /* If we have negative scaling, we flip the normal */
        float signDet = sign(dot(m[0], cross(m[1], m[2])));
        // Optional fallback: treat 0 as +1
        signDet = signDet + (1.0 - abs(signDet));
        transformedNormal *= signDet;
    #endif
    transformedNormal = normalMatrix * transformedNormal;
    #ifdef FLIP_SIDED
        transformedNormal = - transformedNormal;
    #endif
    #ifdef USE_TANGENT
        vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
        #ifdef FLIP_SIDED
            transformedTangent = - transformedTangent;
        #endif
    #endif
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
    //#include <project_vertex> // EDITED CHUNK
   #ifdef TRANSFORM_STORAGE
        vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;
        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);
    #endif
    #ifdef USE_RTE
        vec4 position_lowT = vec4(position_low, 1.);
        vec4 position_highT = vec4(position, 1.);
        const vec3 ZERO3 = vec3(0., 0., 0.);

        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);
        #ifdef TRANSFORM_STORAGE
            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;
        #endif
    #endif

    #ifdef USE_RTE
        vec4 mvPosition = rteLocalPosition;
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
        #ifdef TRANSFORM_STORAGE
            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif
    #endif

    mvPosition = modelViewMatrix * mvPosition;

    gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
    #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	    vViewPosition = - mvPosition.xyz;
    #endif
}
`}get fragmentProgram(){return`
#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}
`}get baseUniforms(){return Rn.normal.uniforms}get uniformsDef(){return{uViewer_high:new A,uViewer_low:new A,uTransforms:[new ae],tTransforms:null}}constructor(e,t=[]){super(e),this.init(t)}customProgramCacheKey(){return this.constructor.name}copy(e){return super.copy(e),this.copyFrom(e),this}onBeforeRender(e,t,n,i,r){this.defines&&this.defines.USE_RTE&&(r.modelViewMatrix.copy(e.RTEBuffers.rteViewModelMatrix),this.userData.uViewer_low.value.copy(e.RTEBuffers.viewerLow),this.userData.uViewer_high.value.copy(e.RTEBuffers.viewerHigh),this.needsUpdate=!0)}}class Rg extends Sn{get displayName(){return"GEOMETRY-NORMALS"}get overrideMaterial(){return this.normalsMaterial}constructor(){super(),this._outputTarget=pa.createRenderTarget({minFilter:Dt,magFilter:Dt}),this.normalsMaterial=new HN({}),this.normalsMaterial.blending=Mn,this.normalsMaterial.side=yt}}const c0={outlineThickness:1,outlineOpacity:.75,outlineColor:3289650};class xo extends Xr{constructor(e,t=c0){super(e,t),e.renderer.capabilities.isWebGL2||e.renderer.context.getExtension("WEBGL_draw_buffers")!==null?this.MRTPipeline(t):this.SRTPipeline(t)}depthNormalIdPassVisibility(e){const t={};for(const n in e.batcher.batches){const i=e.batcher.batches[n];if(i.geometryType!==ze.MESH){t[n]=Fn;continue}const r=i.groups.find((o=>{if(o.materialIndex===void 0)return!1;const l=i.materials[o.materialIndex];return Tt.isTransparent(l)&&l.visible&&!(l instanceof Ya)})),s=i.groups.find((o=>o.materialIndex!==void 0&&i.materials[o.materialIndex].visible===!1));r?t[n]={offset:r.start,count:s!==void 0?s.start-r.start:i.getCount()-r.start}:t[n]=Fn}return t}MRTPipeline(e){var t,n,i;const r=new Cd;r.setLayers([re.STREAM_CONTENT_MESH]),r.setJitter(!0),r.setClearColor(0,1),r.setClearFlags(Ct.COLOR|Ct.DEPTH),r.setVisibility(ut.DEPTH);const s=new Cd;s.setLayers([re.STREAM_CONTENT_MESH]),s.setJitter(!0),s.setVisibility(ut.CUSTOM,this.depthNormalIdPassVisibility),s.outputTarget=r.outputTarget;const o=new Cd;o.setLayers([re.STREAM_CONTENT_MESH]),o.setClearColor(0,1),o.setClearFlags(Ct.COLOR|Ct.DEPTH),o.setVisibility(ut.DEPTH);const l=new Cd;l.setLayers([re.STREAM_CONTENT_MESH]),l.setVisibility(ut.CUSTOM,this.depthNormalIdPassVisibility),l.outputTarget=o.outputTarget;const c=new mc;c.setTexture("tDepth",r.depthTexture),c.setTexture("tNormal",r.normalTexture),c.setTexture("tId",r.idTexture),c.options=e;const u=new mc;u.setTexture("tDepth",o.depthTexture),u.setTexture("tNormal",o.normalTexture),u.setTexture("tId",o.idTexture),u.options=e;const h=new lf;h.inputTexture=(t=c.outputTarget)===null||t===void 0?void 0:t.texture,h.accumulationFrames=this.accumulationFrameCount,this.dynamicStage.push(o,l,u),this.progressiveStage.push(r,s,c,h),this.passList=this.dynamicStage,this.depthPass=r,this.depthPassDynamic=o,this.edgePass=c,this.edgePassDynamic=u,this.outputTexture=(n=h.outputTarget)===null||n===void 0?void 0:n.texture,this.outputTextureDynamic=(i=u.outputTarget)===null||i===void 0?void 0:i.texture}SRTPipeline(e){var t,n,i,r,s,o,l;const c=new Al;c.setLayers([re.STREAM_CONTENT_MESH]),c.setVisibility(ut.DEPTH),c.setJitter(!0),c.setClearColor(0,1),c.setClearFlags(Ct.COLOR|Ct.DEPTH);const u=new Rg;u.setLayers([re.STREAM_CONTENT_MESH]),u.setVisibility(ut.OPAQUE),u.setJitter(!0),u.setClearColor(0,1),u.setClearFlags(Ct.COLOR|Ct.DEPTH);const h=new Al;h.setLayers([re.STREAM_CONTENT_MESH]),h.setVisibility(ut.DEPTH),h.setClearColor(0,1),h.setClearFlags(Ct.COLOR|Ct.DEPTH);const d=new Rg;d.setLayers([re.STREAM_CONTENT_MESH]),d.setVisibility(ut.OPAQUE),d.setClearColor(0,1),d.setClearFlags(Ct.COLOR|Ct.DEPTH);const f=new mc;f.setTexture("tDepth",(t=c.outputTarget)===null||t===void 0?void 0:t.texture),f.setTexture("tNormal",(n=u.outputTarget)===null||n===void 0?void 0:n.texture),f.options=e;const p=new mc;p.setTexture("tDepth",(i=h.outputTarget)===null||i===void 0?void 0:i.texture),p.setTexture("tNormal",(r=d.outputTarget)===null||r===void 0?void 0:r.texture),p.options=e;const m=new lf;m.inputTexture=(s=f.outputTarget)===null||s===void 0?void 0:s.texture,m.accumulationFrames=this.accumulationFrameCount,this.dynamicStage.push(h,d,p),this.progressiveStage.push(c,u,f,m),this.passList=this.dynamicStage,this.depthPass=c,this.depthPassDynamic=h,this.edgePass=f,this.edgePassDynamic=p,this.outputTexture=(o=m.outputTarget)===null||o===void 0?void 0:o.texture,this.outputTextureDynamic=(l=p.outputTarget)===null||l===void 0?void 0:l.texture}}class u0 extends Xr{constructor(e,t=Cs){var n,i;super(e);const r=t.edges?new xo(e):null,s=t.edges?null:new Al;s&&(s.setLayers([re.STREAM_CONTENT_MESH]),s.setVisibility(ut.DEPTH),s.setJitter(!0),s.setClearColor(0,1),s.setClearFlags(Ct.COLOR|Ct.DEPTH));const o=t.edges?r?.depthPass.depthTexture:(n=s?.outputTarget)===null||n===void 0?void 0:n.texture,l=(t.edges?r?.dynamicPasses:[])||[],c=(t.edges?r?.progressivePasses:s?[s]:[])||[],u=new Sn;u.setLayers([re.STREAM_CONTENT,re.STREAM_CONTENT_MESH,re.STREAM_CONTENT_LINE,re.STREAM_CONTENT_POINT,re.STREAM_CONTENT_POINT_CLOUD,re.PROPS]),u.setVisibility(ut.OPAQUE);const h=new Sn;h.setLayers([re.STREAM_CONTENT,re.STREAM_CONTENT_MESH,re.STREAM_CONTENT_LINE,re.STREAM_CONTENT_POINT,re.STREAM_CONTENT_POINT_CLOUD,re.STREAM_CONTENT_TEXT,re.SHADOWCATCHER]),h.setVisibility(ut.TRANSPARENT);const d=new Yf;d.setTexture("tDepth",o),d.accumulationFrames=this.accumulationFrameCount,d.setClearColor(16777215,1);const f=new qi;f.options={blendAO:!0,blendEdges:t.edges},f.setTexture("tAo",(i=d.outputTarget)===null||i===void 0?void 0:i.texture),f.setTexture("tEdges",t.edges?r?.outputTexture:void 0),f.accumulationFrames=this.accumulationFrameCount;const p=new qi;p.options={blendAO:!1,blendEdges:t.edges},p.setTexture("tEdges",t.edges?r?.outputTextureDynamic:void 0),p.accumulationFrames=this.accumulationFrameCount;const m=new ua;m.setVisibility(ut.STENCIL),m.setLayers([re.STREAM_CONTENT_MESH]);const g=new ha;g.setVisibility(ut.STENCIL),g.setLayers([re.STREAM_CONTENT_MESH]),g.setClearFlags(Ct.DEPTH);const v=new Sn;v.setLayers([re.OVERLAY,re.MEASUREMENTS]),this.dynamicStage.push(...l,m,u,h,...t.edges?[p]:[],g,v),this.progressiveStage.push(...c,m,u,h,g,d,f,v),this.passthroughStage.push(m,u,h,g,f,v),this.passList=this.dynamicStage}}const Jo=new A,Zo=new He;Un.prototype.isEmpty=function(){return this.halfSize.length()===0},Un.prototype.equals=function(a,e=1e-6){if(Jo.copy(this.center),Jo.sub(a.center),Jo.length()>e||(Jo.copy(this.halfSize),Jo.sub(a.halfSize),Jo.length()>e))return!1;for(let t=0;t<9;t++)if(Math.abs(this.rotation.elements[t]-a.rotation.elements[t])>e)return!1;return!0},Un.prototype._min=new A,Un.prototype._max=new A,Object.defineProperty(Un.prototype,"min",{get(){return new A().copy(this.center).sub(this.halfSize)},set(a){this._min.copy(a),Zo.set(a,this._max),Zo.getCenter(this.center),Zo.getSize(this.halfSize),this.halfSize.multiplyScalar(.5)},enumerable:!0,configurable:!0}),Object.defineProperty(Un.prototype,"max",{get(){return new A().copy(this.center).add(this.halfSize)},set(a){this._max.copy(a),Zo.set(this._min,a),Zo.getCenter(this.center),Zo.getSize(this.halfSize),this.halfSize.multiplyScalar(.5)},enumerable:!0,configurable:!0}),He.prototype.fromOBB=function(a){const{center:e,halfSize:t,rotation:n}=a,i=[new A(-t.x,-t.y,-t.z),new A(-t.x,-t.y,t.z),new A(-t.x,t.y,-t.z),new A(-t.x,t.y,t.z),new A(t.x,-t.y,-t.z),new A(t.x,-t.y,t.z),new A(t.x,t.y,-t.z),new A(t.x,t.y,t.z)].map((r=>r.applyMatrix3(n).add(e)));return new He().setFromPoints(i)},He.prototype.intersectOBB=function(a){const e=[new A(this.min.x,this.min.y,this.min.z),new A(this.min.x,this.min.y,this.max.z),new A(this.min.x,this.max.y,this.min.z),new A(this.min.x,this.max.y,this.max.z),new A(this.max.x,this.min.y,this.min.z),new A(this.max.x,this.min.y,this.max.z),new A(this.max.x,this.max.y,this.min.z),new A(this.max.x,this.max.y,this.max.z)],t=new Kt().copy(a.rotation).invert(),n=e.map((c=>c.clone().sub(a.center).applyMatrix3(t))),i=[];for(const c of n)Math.abs(c.x)<=a.halfSize.x&&Math.abs(c.y)<=a.halfSize.y&&Math.abs(c.z)<=a.halfSize.z&&i.push(c);if(i.length===0)return null;const r=new A;i.forEach((c=>r.add(c))),r.divideScalar(i.length);const s=[new A,new A,new A];a.rotation.extractBasis(s[0],s[1],s[2]);const o=new A;for(const c of i)for(let u=0;u<3;u++){const h=c.clone().sub(r).dot(s[u]);o.setComponent(u,Math.max(o.getComponent(u),Math.abs(h)))}const l=r.applyMatrix3(a.rotation).add(a.center);return new Un(l,o,a.rotation.clone())},He.prototype.isInfiniteBox=function(){return this.min.x===-1/0||this.min.y===-1/0||this.min.z===-1/0||this.max.x===1/0||this.max.y===1/0||this.max.z===1/0};class GN{constructor(){this.renderTimeAcc=0,this.renderTimeSamples=0,this.renderTimeMaxSamples=500,this.renderTimeStart=0,this.renderTime=0,this.objects=0,this.batchCount=0,this.drawCalls=0,this.trisCount=0,this.vertCount=0}frameStart(){this.renderTimeStart=performance.now()}frameEnd(){this.renderTimeAcc+=performance.now()-this.renderTimeStart,this.renderTimeSamples++,this.renderTimeSamples%this.renderTimeMaxSamples==0&&(this.renderTime=this.renderTimeAcc/this.renderTimeSamples,this.renderTimeSamples=0,this.renderTimeAcc=0)}}const mb={pickedObjectsFilter:a=>{const e=a[1];return e&&e.visible&&(!e.transparent||e.opacity>0)&&!(e instanceof Ya)}};class gb{get renderer(){return this._renderer}set needsRender(e){this._needsRender||(this._needsRender=e)}set shadowMapNeedsUpdate(e){this._renderer.shadowMap.needsUpdate=e}get sceneBox(){const e=new He,t=this.batcher.getBatches();for(let n=0;n<t.length;n++)e.union(t[n].bounds);return e}get visibleSceneBox(){const e=new He,t=this.batcher.getBatches();for(let n=0;n<t.length;n++){const i=t[n],r=i.renderViews.slice();r.sort(((d,f)=>d.batchStart-f.batchStart));let s=null;Dw(i)&&(s=i.mesh.batchObjects.slice(),s.sort(((d,f)=>d.renderView.batchStart-f.renderView.batchStart)));const o=i.getVisibleRange();let l=0,c=r.length;for(;l<c;){const d=l+c>>>1;r[d].batchStart<o.offset?l=d+1:c=d}const u=o.offset,h=o.offset+o.count;for(;l<r.length;l++){const d=r[l],f=s?s[l]:null;if(d.batchStart>=h)break;const p=d.batchStart+d.batchCount;d.batchStart>=u&&p<=h&&e.union(f?f.aabb:d.aabb)}}return e}get sceneSphere(){return this.sceneBox.getBoundingSphere(new rn)}get sceneCenter(){return this.sceneBox.getCenter(new A)}get clippingVolume(){return!this._clippingVolume.isEmpty()&&this._renderer.localClippingEnabled?this._clippingVolume:new Un().fromBox3(this.visibleSceneBox)}set clippingVolume(e){this.sceneBox&&(e instanceof He?this._clippingVolume=new Un().fromBox3(this.sceneBox.intersect(e)):e instanceof Un?this._clippingVolume=new Un().copy(e):De.error(`Incorrect clipping volume set: ${e}. Required Box3 or OBB`))}get clippingPlanes(){return this._clippingPlanes}set clippingPlanes(e){this._clippingPlanes=e.map((t=>new kt().copy(t))),this.updateClippingPlanes(),this.renderer.shadowMap.needsUpdate=!0,this.needsRender=!0,this.resetPipeline()}get allObjects(){return this._scene.getObjectByName("ContentGroup")}get scene(){return this._scene}get sunLight(){return this.sun}set indirectIBL(e){this._scene.environment=e}set indirectIBLIntensity(e){const t=this.batcher.getBatches(void 0,ze.MESH);for(let n=0;n<t.length;n++){const i=t[n].materials;for(let r=0;r<i.length;r++)i[r].envMapIntensity=e}}get speckleCamera(){return this._speckleCamera}set speckleCamera(e){this._speckleCamera=e,this._speckleCamera.on(Si.Dynamic,(()=>{this._needsRender=!0,this._pipeline instanceof Xr&&this._pipeline.onStationaryEnd()})),this._speckleCamera.on(Si.Stationary,(()=>{this._needsRender=!0,this._pipeline instanceof Xr&&this._pipeline.onStationaryBegin()})),this._speckleCamera.on(Si.FrameUpdate,(t=>{this.needsRender=t}))}get renderingCamera(){return this._speckleCamera?this._speckleCamera.renderingCamera:null}set pipeline(e){this._pipeline=e,this._pipeline.setClippingPlanes(this._clippingPlanes),this._pipeline.reset(),this.resize()}get pipeline(){return this._pipeline}get shadowcatcher(){return this._shadowcatcher}get intersections(){return this._intersections}get renderingStats(){const e=Object.values(this.batcher.batches);return this._renderinStats.objects=e.reduce(((t,n)=>t+n.renderViews.length),0),this._renderinStats.batchCount=e.length,this._renderinStats.drawCalls=e.reduce(((t,n)=>t+n.drawCalls),0),this._renderinStats.trisCount=e.reduce(((t,n)=>t+n.triCount),0),this._renderinStats.vertCount=e.reduce(((t,n)=>t+n.vertCount),0),this._renderinStats.batchDetails=e.map((t=>({type:t.constructor.name,objCount:t.renderViews.length,drawCalls:t.drawCalls,minDrawCalls:t.minDrawCalls,tris:t.triCount,verts:t.vertCount}))),this._renderinStats}constructor(e,t){this.SHOW_HELPERS=!1,this.IGNORE_ZERO_OPACITY_OBJECTS=!0,this.SHOW_BVH=!1,this._speckleCamera=null,this.sunConfiguration=VM,this.cancel={},this._clippingPlanes=[],this._clippingVolume=new Un,this._renderOverride=null,this.objectPickConfiguration=mb,this.tree=e,this._renderinStats=new GN,this._scene=new Hu,this.rootGroup=new fi,this.rootGroup.name="ContentGroup",this.rootGroup.layers.set(re.STREAM_CONTENT),this._scene.add(this.rootGroup),this._intersections=new ob,this.viewer=t}create(e){if(this._renderer=new lb({antialias:!0,alpha:!0,preserveDrawingBuffer:!0,stencil:!0}),this._renderer.setClearColor(16777215,0),this._renderer.setPixelRatio(window.devicePixelRatio),this._renderer.outputEncoding=vt,this._renderer.toneMapping=Hg,this._renderer.toneMappingExposure=.5,this._renderer.shadowMap.enabled=!0,this._renderer.shadowMap.type=Na,this._renderer.shadowMap.autoUpdate=!1,this._renderer.shadowMap.needsUpdate=!0,this._renderer.physicallyCorrectLights=!0,this._renderer.autoClear=!1,this._renderer.autoClearColor=!1,this._renderer.autoClearDepth=!1,this._renderer.autoClearStencil=!1,this.container=e,this._renderer.setSize(e.offsetWidth,e.offsetHeight),e.appendChild(this._renderer.domElement),this.batcher=new RN(this.renderer.capabilities),this._pipeline=new u0(this),this.input=new oo(this._renderer.domElement),this.input.on(kn.Click,this.onClick.bind(this)),this.input.on(kn.DoubleClick,this.onDoubleClick.bind(this)),this.addDirectLights(),this.SHOW_HELPERS){const i=new fi;i.name="Helpers",this._scene.add(i);const r=new jS(this.sun,50,16711680);r.name="DirLightHelper",r.layers.set(re.PROPS),i.add(r);const s=new Uv(this.sun.shadow.camera);s.name="CamHelper",s.layers.set(re.PROPS),i.add(s)}let t,n;this._shadowcatcher=new Br(re.SHADOWCATCHER,[re.STREAM_CONTENT_MESH]),this._shadowcatcher.shadowcatcherPass.onBeforeRender=()=>{t=this.batcher.saveVisiblity(),n=this.batcher.getOpaque(),this.batcher.applyVisibility(n),this.batcher.overrideMaterial(n,this._shadowcatcher.shadowcatcherPass.drawDepthMaterial)},this._shadowcatcher.shadowcatcherPass.onAfterRender=()=>{this.batcher.applyVisibility(t),this.batcher.restoreMaterial(n)},this._scene.add(this._shadowcatcher.shadowcatcherMesh)}update(e){this.renderingCamera&&(this.batcher.update(e),this.renderingCamera.updateMatrixWorld(!0),this._renderer.updateRTEViewModel(this.renderingCamera),this.updateRTEShadows(),this.updateTransforms(),this._pipeline.update(this.renderingCamera),this.sunConfiguration.shadowcatcher&&this._shadowcatcher&&this._shadowcatcher.update(this._scene))}updateRTEShadowBuffers(){return!!this._renderer.shadowMap.needsUpdate&&(this._renderer.RTEBuffers.shadowViewer.set(this.sun.shadow.camera.matrixWorld.elements[12],this.sun.shadow.camera.matrixWorld.elements[13],this.sun.shadow.camera.matrixWorld.elements[14]),ft.DoubleToHighLowVector(this._renderer.RTEBuffers.shadowViewer,this._renderer.RTEBuffers.shadowViewerLow,this._renderer.RTEBuffers.shadowViewerHigh),this._renderer.RTEBuffers.rteShadowViewModelMatrix.copy(this.sun.shadow.camera.matrixWorldInverse),this._renderer.RTEBuffers.rteShadowViewModelMatrix.elements[12]=0,this._renderer.RTEBuffers.rteShadowViewModelMatrix.elements[13]=0,this._renderer.RTEBuffers.rteShadowViewModelMatrix.elements[14]=0,this._renderer.RTEBuffers.rteShadowMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this._renderer.RTEBuffers.rteShadowMatrix.multiply(this.sun.shadow.camera.projectionMatrix),this._renderer.RTEBuffers.rteShadowMatrix.multiply(this._renderer.RTEBuffers.rteShadowViewModelMatrix),!0)}updateRTEShadows(){if(!this.updateRTEShadowBuffers())return;const e=this.batcher.getBatches(void 0,ze.MESH);for(let t=0;t<e.length;t++)e[t].mesh.traverse((n=>{const i=n.customDepthMaterial;i&&(i.userData.uViewer_low.value.copy(this._renderer.RTEBuffers.shadowViewerLow),i.userData.uViewer_high.value.copy(this._renderer.RTEBuffers.shadowViewerHigh),i.userData.rteModelViewMatrix.value.copy(this._renderer.RTEBuffers.rteShadowViewModelMatrix),i.needsUpdate=!0)}))}updateTransforms(){const e=this.batcher.getBatches(void 0,[ze.MESH,ze.TEXT]);for(let t=0;t<e.length;t++){const n=e[t].mesh;n.updateTransformsUniform(),n.traverse((i=>{const r=i.customDepthMaterial;r&&n.updateMaterialTransformsUniform(r)}))}}resetPipeline(){this._needsRender=!0,this._pipeline.reset()}render(){this._renderOverride?this._renderOverride():this._speckleCamera&&this._needsRender&&(this._renderinStats.frameStart(),this.batcher.render(this.renderer),this._needsRender=this._pipeline.render(),this._renderinStats.frameEnd(),this.sunConfiguration.shadowcatcher&&this._shadowcatcher&&this._shadowcatcher.render(this._renderer))}resize(e,t){if(!e||!t){const i=this._renderer.getSize(new te);e=i.x,t=i.y}e=Math.floor(e),t=Math.floor(t),this.renderer.setSize(e,t);const n=this._renderer.getPixelRatio();this._pipeline.resize(e*n,t*n),this._pipeline.reset(),this._needsRender=!0}async*addRenderTree(e){this.cancel[e.id]=!1;const t=new fi;t.name=e.id,t.layers.set(re.STREAM_CONTENT),this.rootGroup.add(t);const n=this.batcher.makeBatches(this.tree,e,Mu);let i=0,r=-1;this._renderOverride=()=>{i>r&&(this._pipeline.render(),r=i)};for await(const s of n)if(s){if(this.addBatch(s,t),s.geometryType===ze.MESH&&this.updateDirectLights(),this.cancel[e.id]){n.return(),this.removeRenderTree(e.id),delete this.cancel[e.id];break}i++,yield}this._renderOverride=null,this.updateHelpers(),this.updateShadowCatcher(!0),this.updateClippingPlanes(),this._speckleCamera&&this._speckleCamera.updateCameraPlanes(this.sceneBox),delete this.cancel[e.id]}addBatch(e,t){const n=e.renderObject;t.add(n);let i=!1;(n instanceof wl||n instanceof bu||n instanceof nb)&&n.TAS.bvhHelper&&t.add(n.TAS.bvhHelper),(n instanceof wl||n instanceof bu)&&(i=n.needsRTE),e.geometryType===ze.MESH&&n.traverse((r=>{if(r instanceof Ve){const s=Array.isArray(r.material)?r.material[0]:r.material;r.castShadow=!s.transparent,r.receiveShadow=!s.transparent,r.customDepthMaterial=new Yu({depthPacking:da},i?["USE_RTE","ALPHATEST_REJECTION"]:["ALPHATEST_REJECTION"])}})),this.viewer.World.expandWorld(e.bounds)}removeRenderTree(e){this.rootGroup.remove(this.rootGroup.getObjectByName(e)),this.batcher.getBatches(e).forEach((t=>{this.viewer.World.reduceWorld(t.bounds)})),this.batcher.purgeBatches(e),this.updateDirectLights(),this.updateHelpers(),this.updateShadowCatcher(!0)}cancelRenderTree(e){this.cancel[e]!==void 0&&(this.cancel[e]=!0)}setMaterial(e,t){if(!t)return;const n={};for(let i=0;i<e.length;i++)e[i].batchId&&(n[e[i].batchId]||(n[e[i].batchId]=[]),n[e[i].batchId].includes(e[i])||n[e[i].batchId].push(e[i]));Tt.isMaterialInstance(t)?this.setMaterialInstance(n,t):Tt.isFilterMaterial(t)?this.setFilterMaterial(n,t):(Tt.isRenderMaterial(t)||Tt.isDisplayStyle(t))&&this.setDataMaterial(n,t)}setMaterialInstance(e,t){for(const n in e){const i=e[n].map((r=>({offset:r.batchStart,count:r.batchCount,material:t})));this.batcher.batches[n]&&this.batcher.batches[n].setDrawRanges(this.flattenDrawRanges(i))}}setFilterMaterial(e,t){for(const n in e){const i=e[n].map((r=>({offset:r.batchStart,count:r.batchCount,material:this.batcher.materials.getFilterMaterial(r,t),materialOptions:this.batcher.materials.getFilterMaterialOptions(t)})));this.batcher.batches[n]&&this.batcher.batches[n].setDrawRanges(this.flattenDrawRanges(i))}}setDataMaterial(e,t){for(const n in e){const i=e[n].map((r=>{const s=this.batcher.materials.getDataMaterial(r,t);return s.setMaterialOptions(t),{offset:r.batchStart,count:r.batchCount,material:s}}));this.batcher.batches[n]&&this.batcher.batches[n].setDrawRanges(this.flattenDrawRanges(i))}}flattenDrawRanges(e){if(e.length<3)return e;const t=[];let n=(e=e.sort(((r,s)=>r.offset-s.offset)))[0].offset,i=0;for(let r=0;r<e.length-1;r++)i+=e[r].count,n+i!==e[r+1].offset?(t.push({offset:n,count:i,material:e[r].material,...e[r].materialOptions&&{materialOptions:e[r].materialOptions}}),n=e[r+1].offset,i=0,r===e.length-2&&t.push({offset:e[r+1].offset,count:e[r+1].count,material:e[r+1].material,...e[r].materialOptions&&{materialOptions:e[r].materialOptions}})):r===e.length-2&&t.push({offset:n,count:i+e[r+1].count,material:e[r].material,...e[r].materialOptions&&{materialOptions:e[r].materialOptions}});return t}getMaterial(e){var t,n;return e&&e.batchId&&(n=(t=this.batcher.getBatch(e))===null||t===void 0?void 0:t.getMaterial(e))!==null&&n!==void 0?n:null}getBatchMaterial(e){var t,n;return e&&e.batchId&&(n=(t=this.batcher.getBatch(e))===null||t===void 0?void 0:t.batchMaterial)!==null&&n!==void 0?n:null}resetMaterials(){this.batcher.resetBatchesDrawRanges()}getBatch(e){return this.batcher.batches[e]}updateClippingPlanes(){var e;if(!this.allObjects)return;const t=this._clippingPlanes;this.allObjects.traverse((n=>{const i=n.material;if(i)if(Array.isArray(i))for(let r=0;r<i.length;r++)i[r].clippingPlanes=t;else i.clippingPlanes=t})),this._pipeline.setClippingPlanes(t),(e=this._shadowcatcher)===null||e===void 0||e.updateClippingPlanes(t)}updateShadowCatcher(e=!1){this.sunConfiguration.shadowcatcher!==void 0&&(this._shadowcatcher.shadowcatcherMesh.visible=this.sunConfiguration.shadowcatcher),this.sunConfiguration.shadowcatcher&&(this._shadowcatcher.bake(new He().fromOBB(this.clippingVolume),this._renderer.capabilities.maxTextureSize,e),this.needsRender=!0)}addDirectLights(){this.sun=new Ff(16777215,5),this.sun.name="sun",this.sun.layers.set(re.STREAM_CONTENT),this._scene.add(this.sun),this.sun.castShadow=!0,this.sun.shadow.mapSize.width=2048,this.sun.shadow.mapSize.height=2048,this.sun.shadow.camera.left=-50,this.sun.shadow.camera.right=50,this.sun.shadow.camera.top=50,this.sun.shadow.camera.bottom=-50,this.sun.shadow.camera.near=5,this.sun.shadow.camera.far=350,this.sun.shadow.bias=-.001,this.sun.shadow.radius=2,this.sunTarget=new gt,this._scene.add(this.sunTarget),this.sunTarget.position.copy(this.sceneCenter),this.sun.target=this.sunTarget}updateDirectLights(){const e=this.sunConfiguration.elevation,t=this.sunConfiguration.azimuth,n=this.sunConfiguration.radius||0;this.sunConfiguration.castShadow!==void 0&&(this.sun.castShadow=this.sunConfiguration.castShadow),this.sunConfiguration.intensity!==void 0&&(this.sun.intensity=this.sunConfiguration.intensity),this.sun.color=new Ie(this.sunConfiguration.color),this.sunConfiguration.enabled!==void 0&&(this.sun.visible=this.sunConfiguration.enabled),this.sunTarget.position.copy(this.sceneCenter);const i=new Sc(this.sceneSphere.radius+n,e,t);this.sun.position.setFromSpherical(i),this.sun.position.add(this.sunTarget.position),this.sun.updateWorldMatrix(!0,!0),this.sunTarget.updateMatrixWorld(),this.sun.shadow.updateMatrices(this.sun);const r=this.sceneBox,s=r.min,o=r.max,l=new A(s.x,s.y,s.z),c=new A(o.x,s.y,s.z),u=new A(s.x,o.y,s.z),h=new A(s.x,s.y,o.z),d=new A(o.x,o.y,s.z),f=new A(o.x,s.y,o.z),p=new A(s.x,o.y,o.z),m=new A(o.x,o.y,o.z);l.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse),c.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse),u.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse),h.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse),d.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse),f.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse),p.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse),m.applyMatrix4(this.sun.shadow.camera.matrixWorldInverse);const g=new He().setFromPoints([l,c,u,h,d,f,p,m]);this.sun.shadow.camera.left=g.min.x,this.sun.shadow.camera.right=g.max.x,this.sun.shadow.camera.top=g.min.y,this.sun.shadow.camera.bottom=g.max.y,this.sun.shadow.camera.near=Math.abs(g.max.z),this.sun.shadow.camera.far=Math.abs(g.min.z),this.sun.shadow.camera.updateProjectionMatrix(),this.renderer.shadowMap.needsUpdate=!0,this.updateHelpers()}setSunLightConfiguration(e){Object.assign(this.sunConfiguration,e),e.indirectLightIntensity!==void 0&&(this.indirectIBLIntensity=e.indirectLightIntensity),this.updateDirectLights(),this.updateShadowCatcher(),this.viewer.emit(Cn.LightConfigUpdated,{...e})}updateHelpers(){this.SHOW_HELPERS&&(this._scene.getObjectByName("CamHelper").update(),this._scene.getObjectByName("DirLightHelper").update())}queryHits(e){const t=[],n=[];for(let r=0;r<e.length;r++){const s=this.renderViewFromIntersection(e[r]);!s[0]||this.objectPickConfiguration.pickedObjectsFilter&&!this.objectPickConfiguration.pickedObjectsFilter(s)||(t.push(s[0]),n.push(e[r].point))}if(t.length===0)return null;const i=[];for(let r=0;r<t.length;r++){const s=t[r].renderData.id,o=t[r].renderData.subtreeId,l=this.tree.findId(s,o);if(!l)continue;let c=l[0];for(;!c.model.atomic&&c.parent;)c=c.parent;i.push({node:c,point:n[r]})}return i}queryHitIds(e){var t;const n=[];for(let i=0;i<e.length;i++){let r=(t=e[i].batchObject)===null||t===void 0?void 0:t.renderView;if(!r){const s=e[i].faceIndex!==void 0?e[i].faceIndex:e[i].index;s&&(r=this.batcher.getRenderView(e[i].object.uuid,s))}r&&n.push({nodeId:r.renderData.id,point:e[i].point})}return n.length===0?null:n}renderViewFromIntersection(e){let t=null,n=null;if(e.batchObject)t=e.batchObject.renderView,n=e.object.getBatchObjectMaterial(e.batchObject);else{const i=e.faceIndex!==void 0&&e.faceIndex!==null?e.faceIndex:e.index!==void 0&&e.index!==null?e.index:void 0;i!==void 0&&(t=this.batcher.getRenderView(e.object.uuid,i),t&&(n=this.batcher.getRenderViewMaterial(e.object.uuid,i)))}return[t,n]}onClick(e){if(!this.renderingCamera)return;const t=this._intersections.intersect(this._scene,this.renderingCamera,e,void 0,!0,this.clippingVolume);if(!t)return void this.viewer.emit(Cn.ObjectClicked,null);let n=!1;e.multiSelect&&(n=!0);const i=this.queryHits(t);if(!i)return void this.viewer.emit(Cn.ObjectClicked,n?{multiple:!0,event:e.event}:null);const r={multiple:n,event:e.event,hits:i.map((s=>({node:s.node,point:s.point})))};this.viewer.emit(Cn.ObjectClicked,r)}onDoubleClick(e){if(!this.renderingCamera)return;const t=this._intersections.intersect(this._scene,this.renderingCamera,e,void 0,!0,this.clippingVolume);if(!t)return void this.viewer.emit(Cn.ObjectDoubleClicked,null);let n=!1;e.multiSelect&&(n=!0);const i=this.queryHits(t);if(!i)return void this.viewer.emit(Cn.ObjectDoubleClicked,null);const r={multiple:n,hits:i.map((s=>({node:s.node,point:s.point})))};this.viewer.emit(Cn.ObjectDoubleClicked,r)}boxFromObjects(e){let t=new He;const n=[];if(e.length>0)for(let i=0;i<e.length;i++){const r=this.tree.findId(e[i]);r&&r.forEach((s=>{n.push(...this.tree.getRenderTree().getRenderViewsForNode(s))}))}else t=this.visibleSceneBox;for(let i=0;i<n.length;i++){const r=this.getObject(n[i]),s=r?r.aabb:n[i].aabb;s&&t.union(s)}return t.getSize(new A).length()===0&&console.error("object selection resulted in empty box"),t}screenToNDC(e,t,n,i){const r=this._renderer.domElement,s=this.container.getBoundingClientRect(),o=n===void 0?(e-s.left)*r.width/s.width:e,l=i===void 0?(t-s.top)*r.height/s.height:t;return{x:o/(n===void 0?r.width:n)*2-1,y:l/(i===void 0?r.height:i)*-2+1}}NDCToScreen(e,t,n,i){const r=this._renderer.domElement;return{x:(.5*e+.5)*(n=n!==void 0?n:r.width),y:(-.5*t+.5)*(i=i!==void 0?i:r.height)}}debugShowBatches(){for(const e in this.batcher.batches){const t={id:"string",color:Math.floor(16777215*Math.random()),opacity:1,roughness:1,metalness:0,vertexColors:!1,lineWeight:1};this.setMaterial(this.batcher.batches[e].renderViews,t)}}getBatchIds(){const e=Object.values(this.batcher.batches);e.sort(((n,i)=>n.renderViews.length-i.renderViews.length));const t=[];for(let n=0;n<e.length;n++)t.push(e[n].id);return t.reverse()}getBatchSize(e){return this.batcher.batches[e].renderViews.length}isolateBatch(e){this.batcher.resetBatchesDrawRanges(),this.batcher.isolateBatch(e)}getObjects(){return this.batcher.getBatches(void 0,[ze.MESH,ze.TEXT]).map((e=>e.mesh)).flatMap((e=>e.batchObjects))}getObject(e){const t=this.batcher.getBatch(e);return t&&Dw(t)?t.mesh.batchObjects.find((n=>n.renderView.guid===e.guid)):null}enableLayers(e,t){this._pipeline.passes.forEach((n=>{n instanceof Ts&&e.forEach((i=>{n.enableLayer(i,t)}))}))}}const vb=function(a){const e={};for(const t in a){if(t==="id"||t==="__closure"||t==="__parents"||t==="bbox"||t==="totalChildrenCount")continue;const n=a[t];if(n==null||Array.isArray(n))continue;if(n.constructor===Object){const r=vb(n);for(const s in r)e[t+"."+s]=r[s];continue}const i=typeof n;i!=="string"&&i!=="number"&&i!=="boolean"||(e[t]=n)}return a.id&&(e.id=a.id),e};class VN{constructor(){this.propCache={}}async getProperties(e,t=null,n=!1){let i=e.root;if(!n&&this.propCache[t||i.model.id])return this.propCache[t||i.model.id];if(t){const o=i.children.find((l=>l.model.id===t));if(!o)throw new Error(`Could not find root node for ${t} - is it loaded?`);i=o}const r={};await e.walkAsync((o=>{if(!o.model.atomic)return!0;const l=vb(o.model.raw);for(const c in l)Array.isArray(l[c])||(r[c]||(r[c]=[]),r[c].push({value:l[c],id:l.id}));return!0}),i);const s=[];for(const o in r){const l=r[o],c={};if(c.key=o,c.type=typeof l[0].value=="string"?"string":"number",c.objectCount=l.length,c.type==="string"){const u=c,h={};for(const{value:d,id:f}of l)h[d]||(h[d]=[]),h[d].push(f);u.valueGroups=[];for(const d in h)u.valueGroups.push({value:d,ids:h[d]});u.valueGroups=u.valueGroups.sort(((d,f)=>d.value.localeCompare(f.value)))}if(c.type==="number"){const u=c;u.min=Number.MAX_VALUE,u.max=Number.MIN_VALUE;for(const{value:h}of l)h<u.min&&(u.min=h),h>u.max&&(u.max=h);u.valueGroups=l.sort(((h,d)=>h.value-d.value))}s.push(c)}return this.propCache[i.model.id]=s,s}}const Xw=new El,Ko=new A;class Pi{static isPointQuery(e){return e.operation==="Project"||e.operation==="Unproject"}static isIntersectionQuery(e){return e.operation==="Occlusion"||e.operation==="Pick"}}Pi.DefaultPointQuerySolver=new class{setContext(a){this.renderer=a}solve(a){switch(a.operation){case"Project":return this.solveProjection(a);case"Unproject":return this.solveUnprojection(a);default:return De.error("Malformed query"),null}}solveProjection(a){const e=new A(a.point.x,a.point.y,a.point.z);let t=!1;return this.renderer.renderingCamera?(Ko.copy(e),Ko.applyMatrix4(this.renderer.renderingCamera.matrixWorldInverse),t=Xw.setFromProjectionMatrix(this.renderer.renderingCamera.projectionMatrix).containsPoint(Ko),e.project(this.renderer.renderingCamera)):De.error("Could not run query. Camera is null"),{x:e.x,y:e.y,z:e.z,inFrustum:t}}solveUnprojection(a){let e=!1;const t=new A(a.point.x,a.point.y,a.point.z);return this.renderer.renderingCamera?(t.unproject(this.renderer.renderingCamera),Ko.copy(t),Ko.applyMatrix4(this.renderer.renderingCamera.matrixWorldInverse),e=Xw.setFromProjectionMatrix(this.renderer.renderingCamera.projectionMatrix).containsPoint(Ko)):De.error("Could not run query. Camera is null"),{x:t.x,y:t.y,z:t.z,inFrustum:e}}},Pi.DefaultIntersectionQuerySolver=new class{constructor(){this.vecBuff0=new A,this.vecBuff1=new A}setContext(a){this.renderer=a}solve(a){switch(a.operation){case"Occlusion":return this.solveOcclusion(a);case"Pick":return this.solvePick(a);default:return De.error("Malformed query"),null}}solveOcclusion(a){if(!this.renderer.renderingCamera)return{objects:null};const e=this.vecBuff0.set(a.point.x,a.point.y,a.point.z||0),t=this.vecBuff1.copy(e).sub(this.renderer.renderingCamera.position);t.normalize();const n=new On(this.renderer.renderingCamera.position,t),i=this.renderer.intersections.intersectRay(this.renderer.scene,this.renderer.renderingCamera,n,re.STREAM_CONTENT_MESH,!0,this.renderer.clippingVolume);if(!i||i.length===0)return{objects:null};const r=this.renderer.queryHitIds(i);if(!r)return{objects:null};let s=this.renderer.renderingCamera.position.distanceTo(e);return s-=a.tolerance!==void 0?a.tolerance:0,s<i[0].distance?{objects:null}:{objects:[{guid:r[0].nodeId,point:r[0].point}]}}solvePick(a){if(!this.renderer.renderingCamera)return null;const e=this.renderer.intersections.intersect(this.renderer.scene,this.renderer.renderingCamera,new te(a.point.x,a.point.y),void 0,!0,this.renderer.clippingVolume);if(!e)return null;const t=this.renderer.queryHits(e);return t?{objects:t.map((n=>({guid:n.node.model.id,object:n.node.model.raw,point:n.point})))}:null}};class Zr extends Ku{get inject(){return[]}get enabled(){return this._enabled}set enabled(e){this._enabled=e}constructor(e,...t){super(),this._enabled=!1,this.viewer=e}onEarlyUpdate(e){}onLateUpdate(e){}onRender(){}onResize(){}}const yb=10*Zu.second;class Rr{constructor(e=50){this.velocity=0,this.naturalFrequency=0,this.setDecayTime(e)}setDecayTime(e){this.naturalFrequency=1/Math.max(.001,e)}update(e,t,n,i){const r=2e-4*this.naturalFrequency;if(e===null||i===0||e===t&&this.velocity===0)return t;if(n<0)return e;const s=e-t,o=this.velocity+this.naturalFrequency*s,l=s+n*o,c=Math.exp(-this.naturalFrequency*n),u=(o-this.naturalFrequency*l)*c,h=-this.naturalFrequency*(u+o*c);return Math.abs(u)<r*Math.abs(i)&&h*s>=0?(this.velocity=0,t):(this.velocity=u,t+l*c)}}class xb extends Ku{constructor(){super(...arguments),this._up=new A(0,1,0),this._minDist=0}get up(){return this._up}set up(e){this._up.copy(e)}get minDist(){return this._minDist}set minDist(e){this._minDist=e}}Zu.second;class Hm{constructor(e=50){this.velocity=0,this.naturalFrequency=0,this.setDecayTime(e)}setDecayTime(e){this.naturalFrequency=1/Math.max(.001,e)}wrapAngle(e){const t=2*Math.PI;return((e+Math.PI)%t+t)%t-Math.PI}update(e,t,n,i){const r=2e-4*this.naturalFrequency;if(e===null||i===0||e===t&&this.velocity===0)return t;if(n<0)return e;const s=this.wrapAngle(e-t),o=this.velocity+this.naturalFrequency*s,l=s+n*o,c=Math.exp(-this.naturalFrequency*n),u=(o-this.naturalFrequency*l)*c,h=-this.naturalFrequency*(u+o*c);return Math.abs(u)<r*Math.abs(i)&&h*s>=0?(this.velocity=0,t):(this.velocity=u,t+l*c)}}const Pa=new A,Jw=Math.PI/2;class Zw extends xb{get enabled(){return this._enabled}set enabled(e){this._enabled=e}get options(){return this._options}set options(e){Object.assign(this._options,e),e.moveSpeed&&console.warn("Fly speed modifier: ",this._options.moveSpeed),this.setDamperDecayTime(this._options.damperDecay)}set targetCamera(e){this._targetCamera=e,this.rotate(this.euler),this._targetCamera.position.copy(this.position)}get up(){return this._up}set up(e){this._up.copy(e),this._basisTransform.makeRotationFromQuaternion(new dt().setFromUnitVectors(new A(0,1,0),this._up)),this._basisTransformInv.copy(this._basisTransform),this._basisTransformInv.invert()}set minDist(e){this._minDist=e}constructor(e,t,n,i){super(),this.velocity=new A,this.euler=new mi(0,0,0,"YXZ"),this.position=new A,this.goalEuler=new mi(0,0,0,"YXZ"),this.goalPosition=new A,this.keyMap={forward:!1,back:!1,left:!1,right:!1,up:!1,down:!1},this.contextMenuTriggered=!1,this.eulerXDamper=new Hm,this.eulerYDamper=new Hm,this.eulerZDamper=new Hm,this.positionXDamper=new Rr,this.positionYDamper=new Rr,this.positionZDamper=new Rr,this._lastTick=0,this._enabled=!1,this._basisTransform=new ae,this._basisTransformInv=new ae,this.onMouseMove=r=>{if(r.buttons!==1||!this._enabled)return;const s=r.movementX||0,o=r.movementY||0,l=new te;l.y=.005*s*this._options.lookSpeed,l.x=.005*o*this._options.lookSpeed,this.rotateBy(l),this.emit("change")},this.onKeyDown=r=>{if(!(r.ctrlKey||r.metaKey||r.altKey||r.shiftKey))switch(r.code){case"ArrowUp":case"KeyW":this.keyMap.forward=!0;break;case"ArrowLeft":case"KeyA":this.keyMap.left=!0;break;case"ArrowDown":case"KeyS":this.keyMap.back=!0;break;case"ArrowRight":case"KeyD":this.keyMap.right=!0;break;case"PageUp":case"KeyE":this.keyMap.up=!0;break;case"PageDown":case"KeyQ":this.keyMap.down=!0}},this.onKeyUp=r=>{if(!(r.ctrlKey||r.metaKey||r.altKey||r.shiftKey))switch(r.code){case"ArrowUp":case"KeyW":this.keyMap.forward=!1;break;case"ArrowLeft":case"KeyA":this.keyMap.left=!1;break;case"ArrowDown":case"KeyS":this.keyMap.back=!1;break;case"ArrowRight":case"KeyD":this.keyMap.right=!1;break;case"PageUp":case"KeyE":this.keyMap.up=!1;break;case"PageDown":case"KeyQ":this.keyMap.down=!1}},this.onContextMenu=()=>{this.contextMenuTriggered=!0},this._targetCamera=e,this.container=t,this.world=n,this._options=Object.assign({},i),this.connect()}isStationary(){return this.goalEuler.equals(this.euler)&&this.goalPosition.equals(this.position)&&this.velocity.length()===0}update(e){this.contextMenuTriggered&&(this.cancelMove(),this.contextMenuTriggered=!1);const t=performance.now();if(e=e!==void 0?e:t-this._lastTick,this._lastTick=t,!this._enabled)return!1;let n=this.world.getRelativeOffset(.2);this._minDist&&this._minDist<.5*n&&(n=this.world.getRelativeOffset(.03));const i=e/Zu.second,r=1.42*n;return this.keyMap.forward&&(this.velocity.z=-r*this._options.moveSpeed*i),this.keyMap.back&&(this.velocity.z=r*this._options.moveSpeed*i),this.keyMap.forward||this.keyMap.back||(this.velocity.z=0),this.keyMap.left&&(this.velocity.x=-r*this._options.moveSpeed*i),this.keyMap.right&&(this.velocity.x=r*this._options.moveSpeed*i),this.keyMap.left||this.keyMap.right||(this.velocity.x=0),this.keyMap.up&&(this.velocity.y=r*this._options.moveSpeed*i),this.keyMap.down&&(this.velocity.y=-r*this._options.moveSpeed*i),this.keyMap.down||this.keyMap.up||(this.velocity.y=0),!this.isStationary()&&(this.moveBy(this.velocity),this.updatePositionRotation(e),!0)}updatePositionRotation(e){const t=this.world.worldBox.min.distanceTo(this.world.worldBox.max),n=t<1?this.world.getRelativeOffset(t):1;this.position.x=this.positionXDamper.update(this.position.x,this.goalPosition.x,e,n),this.position.y=this.positionYDamper.update(this.position.y,this.goalPosition.y,e,n),this.position.z=this.positionZDamper.update(this.position.z,this.goalPosition.z,e,n),this.euler.x=this.eulerXDamper.update(this.euler.x,this.goalEuler.x,e,1),this.euler.y=this.eulerYDamper.update(this.euler.y,this.goalEuler.y,e,1),this.euler.z=this.eulerZDamper.update(this.euler.z,this.goalEuler.z,e,1),this.rotate(this.euler),this._targetCamera.position.copy(this.position)}jumpToGoal(){this.updatePositionRotation(yb)}fitToSphere(e){const t=this._targetCamera.getWorldDirection(new A);t.negate();const n=new A().copy(e.center).addScaledVector(t,e.radius);this.goalPosition.copy(n)}fromPositionAndTarget(e,t){const n=this.getPosition(),i=this.getTarget();if(n.equals(e)&&i.equals(t))return;const r=new A().copy(e),s=new A().copy(t),o=new ae().lookAt(r,s,this._up).premultiply(this._basisTransformInv),l=new dt().setFromRotationMatrix(o);this.goalEuler.setFromQuaternion(l),this.goalPosition.copy(r)}getTarget(){const e=new A().copy(this.goalPosition),t=new ae().makeRotationFromEuler(this.goalEuler),n=new A().setFromMatrixColumn(t,2).applyMatrix4(this._basisTransform).normalize();return e.addScaledVector(n,-this.world.getRelativeOffset(.01)),e}getPosition(){return new A().copy(this.goalPosition)}getCurrentPosition(){return this.position}getCurrentTarget(){const e=new A().copy(this.position),t=new ae().makeRotationFromEuler(this.euler),n=new A().setFromMatrixColumn(t,2).applyMatrix4(this._basisTransform).normalize();return e.addScaledVector(n,-this.world.getRelativeOffset(.01)),e}setDamperDecayTime(e){this.eulerXDamper.setDecayTime(e),this.eulerYDamper.setDecayTime(e),this.eulerZDamper.setDecayTime(e),this.positionXDamper.setDecayTime(e),this.positionYDamper.setDecayTime(e),this.positionZDamper.setDecayTime(e)}moveBy(e){const t=this._targetCamera;Pa.setFromMatrixColumn(t.matrix,2),this.goalPosition.addScaledVector(Pa,e.z),this._options.relativeUpDown?Pa.setFromMatrixColumn(t.matrix,1):Pa.copy(this.up),this.goalPosition.addScaledVector(Pa,e.y),Pa.setFromMatrixColumn(t.matrix,0),this.goalPosition.addScaledVector(Pa,e.x)}rotateBy(e){this.goalEuler.y-=e.y,this.goalEuler.x-=e.x;const t=Math.PI;this.goalEuler.x=Math.max(Jw-t,Math.min(Jw-0,this.goalEuler.x))}connect(){this._enabled||(this.container.addEventListener("pointermove",this.onMouseMove),document.addEventListener("keydown",this.onKeyDown),document.addEventListener("keyup",this.onKeyUp),document.addEventListener("contextmenu",this.onContextMenu))}disconnect(){if(this._enabled){this.container.removeEventListener("pointermove",this.onMouseMove),document.removeEventListener("keydown",this.onKeyDown),document.removeEventListener("keyup",this.onKeyUp),document.removeEventListener("contextmenu",this.onContextMenu);for(const e in this.keyMap)this.keyMap[e]=!1}}dispose(){this.disconnect()}rotate(e){if(!this._options.enableLook)return;const t=new dt,n=new dt().setFromRotationMatrix(this._basisTransform);t.setFromEuler(e).premultiply(n),this._targetCamera.quaternion.slerp(t,.999)}cancelMove(){this.keyMap.forward=!1,this.keyMap.left=!1,this.keyMap.back=!1,this.keyMap.right=!1,this.keyMap.up=!1,this.keyMap.down=!1}}const cs=(a,e,t)=>Math.max(e,Math.min(t,a)),Kw=1e-5,Gm=new A;var cf;(function(a){a.PointerChangeStart="pointer-change-start",a.PointerChangeEnd="pointer-change-end"})(cf||(cf={}));class Vm extends xb{get enabled(){return this._enabled}set enabled(e){e?this.enableInteraction():(this.disableInteraction(),this.orbitSphere.visible=!1),this._enabled=e}get up(){return this._up}set up(e){this._up.copy(e),this._basisTransform.makeRotationFromQuaternion(new dt().setFromUnitVectors(new A(0,1,0),this._up)),this._basisTransformInv.copy(this._basisTransform),this._basisTransformInv.invert()}constructor(e,t,n,i,r){super(),this._enabled=!1,this.isUserPointing=!1,this.enablePan=!0,this.enableTap=!0,this.panProjection=new Kt,this.panPerPixel=0,this.spherical=new Sc,this.goalSpherical=new Sc,this.origin=new A,this.pivotalOrigin=new A,this.goalOrigin=new A,this.targetDamperX=new Rr,this.targetDamperY=new Rr,this.targetDamperZ=new Rr,this.thetaDamper=new Rr,this.phiDamper=new Rr,this.radiusDamper=new Rr,this.logFov=Math.log(55),this.goalLogFov=this.logFov,this.fovDamper=new Rr,this.touchMode=null,this.pointers=[],this.startPointerPosition={clientX:0,clientY:0},this.lastSeparation=0,this.touchDecided=!1,this.zoomControlCoord=new te,this._lastTick=0,this._basisTransform=new ae,this._basisTransformInv=new ae,this._radiusDelta=0,this.pivotPoint=new A,this.lastPivotPoint=new A,this.usePivotal=!1,this.touchModeZoom=(o,l)=>{const c=this.twoTouchDistance(this.pointers[0],this.pointers[1]),u=.08*this._options.zoomSensitivity*+this._options.enableZoom*(this.lastSeparation-c)*50/this._container.offsetHeight;this.lastSeparation=c,this.userAdjustOrbit(0,0,u),this.panPerPixel>0&&this.movePan(o,l)},this.disableScroll=o=>{o.preventDefault()},this.touchModeRotate=(o,l)=>{const{touchAction:c}=this._options;if(!this.touchDecided&&c!=="none"){this.touchDecided=!0;const u=Math.abs(o),h=Math.abs(l);if(c==="pan-y"&&h>u||c==="pan-x"&&u>h)return void(this.touchMode=null);this._container.addEventListener("touchmove",this.disableScroll,{passive:!1})}this.handleSinglePointerMove(o,l)},this.onPointerDown=o=>{var l;if(this._options.orbitAroundCursor){const c=this._container.getBoundingClientRect(),u=(o.clientX-c.left)/c.width*2-1,h=(o.clientY-c.top)/c.height*-2+1;let d=this.renderer.intersections.intersect(this.renderer.scene,this._targetCamera,new te(u,h),re.STREAM_CONTENT_MESH,!0,this.renderer.clippingVolume);d=(l=d?.filter(this.filterOrbitToCursorHits.bind(this)))!==null&&l!==void 0?l:[],d.length?(this.pivotPoint.copy(d[0].point),this.usePivotal=!0,this.orbitSphere.visible=this._options.showOrbitPoint):(this.usePivotal=!1,this.orbitSphere.visible=!1)}this.pointers.length>2||(this.pointers.length===0&&(this._container.addEventListener("pointermove",this.onPointerMove),this._container.addEventListener("pointerup",this.onPointerUp),this.touchMode=null,this.touchDecided=!1,this.startPointerPosition.clientX=o.clientX,this.startPointerPosition.clientY=o.clientY),this.pointers.push({clientX:o.clientX,clientY:o.clientY,id:o.pointerId}),this.isUserPointing=!1,o.pointerType==="touch"?this.onTouchChange(o):this.onMouseDown(o))},this.onPointerMove=o=>{const l=this.pointers.find((d=>d.id===o.pointerId));if(!l)return;if(o.pointerType==="mouse"&&o.buttons===0)return void this.onPointerUp(o);const c=this.pointers.length,u=(o.clientX-l.clientX)/c,h=(o.clientY-l.clientY)/c;u===0&&h===0||(l.clientX=o.clientX,l.clientY=o.clientY,o.pointerType==="touch"?this.touchMode!==null&&this.touchMode(u,h):this.panPerPixel>0?this.movePan(u,h):this.handleSinglePointerMove(u,h))},this.onPointerUp=o=>{const l=this.pointers.findIndex((c=>c.id===o.pointerId));l!==-1&&this.pointers.splice(l,1),this.pointers.length===0?(this._container.removeEventListener("pointermove",this.onPointerMove),this._container.removeEventListener("pointerup",this.onPointerUp),this._container.removeEventListener("touchmove",this.disableScroll)):this.touchMode!==null&&this.onTouchChange(o),this.panPerPixel=0,this.isUserPointing&&this.emit(cf.PointerChangeEnd),this.orbitSphere.visible=!1},this.onWheel=o=>{const l=this._container.getBoundingClientRect(),c=(o.clientX-l.left)/l.width*2-1,u=(o.clientY-l.top)/l.height*-2+1;this.zoomControlCoord.set(c,u);const h=o.deltaY*(o.deltaMode===1?18:1)*.08*this._options.zoomSensitivity*+this._options.enableZoom/60;this.userAdjustOrbit(0,0,h),o.preventDefault(),this.usePivotal=!1,this.orbitSphere.visible=!1},this.onContext=o=>{if(this.enablePan)o.preventDefault();else for(const l of this.pointers)this.onPointerUp(new PointerEvent("pointercancel",{...this.startPointerPosition,pointerId:l.id}))},this._targetCamera=e,this._container=t,this.world=n,this.renderer=i,this._options=Object.assign({},r),this.setDamperDecayTime(this._options.damperDecay);const s=new Ar({color:294651},["BILLBOARD_SCREEN"]);s.opacity=.75,s.transparent=!0,s.color.convertSRGBToLinear(),s.toneMapped=!1,s.depthTest=!1,s.billboardPixelSize=new te(15*window.devicePixelRatio,15*window.devicePixelRatio),this.orbitSphere=new Ve(new xs(.5,32,16),s),this.orbitSphere.layers.set(re.OVERLAY),this.orbitSphere.visible=!1,this.orbitSphere.frustumCulled=!1,this.renderer.scene.add(this.orbitSphere)}get options(){return this._options}set options(e){this.applyOptions(e)}set targetCamera(e){if(e instanceof ki&&this.goalSpherical.radius<this._minDist){let t=this.options.minimumRadius+.5*(this._options.maximumRadius-this.options.minimumRadius);const n=new On(this._targetCamera.position,this._targetCamera.getWorldDirection(new A)),i=this.renderer.intersections.intersectRay(this.renderer.scene,this._targetCamera,n,re.STREAM_CONTENT_MESH,!1,this.renderer.clippingVolume,!1,!1);i&&i.length&&(t=i[0].distance),this.spherical.radius=t,this.goalSpherical.radius=t}this._targetCamera=e,this.usePivotal=this._options.orbitAroundCursor,this.lastPivotPoint.set(this.world.worldOrigin.x+this.world.worldSize.x,this.world.worldOrigin.y+this.world.worldSize.y,this.world.worldOrigin.z+this.world.worldSize.z),this.moveCamera()}set minDist(e){this._minDist=e}fromPositionAndTarget(e,t){const n=this.getPosition(),i=this.getTarget(),r=Gm.subVectors(t,i).length(),s=1e-6;if(Gm.subVectors(e,n).length()<s&&r<s)return;const o=new A().copy(e),l=new A().copy(t);o.sub(l).applyMatrix4(this._basisTransformInv);const c=new Sc;c.setFromCartesianCoords(o.x,o.y,o.z),this.setOrbit(c.theta,c.phi,c.radius),l.applyMatrix4(this._basisTransformInv),this.setTarget(l.x,l.y,l.z),this.usePivotal=!1}jumpToGoal(){this.update(yb)}fitToSphere(e){const t=new A().copy(e.center).applyMatrix4(this._basisTransformInv);this.setTarget(t.x,t.y,t.z),this.setRadius(e.radius),this.usePivotal=!1}getPosition(){return this.positionFromSpherical(this.goalSpherical,this.goalOrigin).applyMatrix4(this._basisTransform)}getTarget(){return this.goalOrigin.clone().applyMatrix4(this._basisTransform)}getCurrentPosition(){return this.positionFromSpherical(this.spherical,this.origin).applyMatrix4(this._basisTransform)}getCurrentTarget(){return this.origin.clone().applyMatrix4(this._basisTransform)}isStationary(){return this.goalSpherical.theta===this.spherical.theta&&this.goalSpherical.phi===this.spherical.phi&&this.goalSpherical.radius===this.spherical.radius&&this.goalLogFov===this.logFov&&this.goalOrigin.equals(this.origin)&&this.pivotPoint.equals(this.lastPivotPoint)}applyOptions(e){Object.assign(this._options,e),this.setDamperDecayTime(this._options.damperDecay),this.setOrbit(),this.setFieldOfView(Math.exp(this.goalLogFov))}computeMinMaxRadius(){if(this.world){const e=this.world.getRelativeOffset(10),t=this.world.getRelativeOffset(.01);isNaN(e)||isNaN(t)||Object.assign(this._options,{maximumRadius:e,minimumRadius:t})}}setOrbit(e=this.goalSpherical.theta,t=this.goalSpherical.phi,n=this.goalSpherical.radius){this.computeMinMaxRadius();const{minimumAzimuthalAngle:i,maximumAzimuthalAngle:r,minimumPolarAngle:s,maximumPolarAngle:o,minimumRadius:l,maximumRadius:c}=this._options,{theta:u,phi:h,radius:d}=this.goalSpherical,f=cs(e,i,r);isFinite(i)||isFinite(r)||(this.spherical.theta=this.wrapAngle(this.spherical.theta-f)+f);const p=cs(t,s,o),m=cs(n,l,c);return(f!==u||p!==h||m!==d)&&!!(isFinite(f)&&isFinite(p)&&isFinite(m))&&(this.goalSpherical.theta=f,this.goalSpherical.phi=p,this.goalSpherical.radius=m,this.goalSpherical.makeSafe(),!0)}setRadius(e){this.goalSpherical.radius=e,this.setOrbit()}setFieldOfView(e){const{minimumFieldOfView:t,maximumFieldOfView:n}=this._options;e=cs(e,t,n),this.goalLogFov=Math.log(e)}setDamperDecayTime(e){this.thetaDamper.setDecayTime(e),this.phiDamper.setDecayTime(e),this.radiusDamper.setDecayTime(e),this.fovDamper.setDecayTime(e),this.targetDamperX.setDecayTime(e),this.targetDamperY.setDecayTime(e),this.targetDamperZ.setDecayTime(e)}setTarget(e,t,n){this.goalOrigin.set(e,t,n)}adjustOrbit(e,t,n){this._radiusDelta;const{theta:i,phi:r,radius:s}=this.goalSpherical,o=this.spherical.theta-i,l=Math.PI-.001,c=i-cs(e,-l-o,l-o),u=r-t;if(this.setOrbit(c,u),n===0)return;const h=this.spherical.radius/this.world.worldBox.getSize(new A).length();let d=bz(this.world.getRelativeOffset(.16)*Math.abs(n),this.world.getRelativeOffset(.64)*Math.abs(n),h>=.5?Math.exp(h):h);d=cs(d,this.world.getRelativeOffset(.01),this.world.getRelativeOffset(.2));const f=d*Math.sign(n),p=s+f;if(this.setOrbit(c,u,p),this._radiusDelta=s-this.goalSpherical.radius,this._options.zoomToCursor){const m=new A;if(p<this._options.minimumRadius&&this._options.infiniteZoom&&this._targetCamera instanceof tn){const T=new A().setFromSpherical(this.spherical).normalize();m.copy(T).multiplyScalar(f),this._radiusDelta=-f}const g=new A().setFromSpherical(this.spherical).normalize().negate(),v=new A().copy(g).cross(new A(0,1,0)).normalize();v.lengthSq()===0&&(v.x=1);const y=new A().crossVectors(v,g),w={x:this._container.offsetWidth,y:this._container.offsetHeight},x=w.x/w.y,S=cs(this.goalSpherical.radius,Math.abs(f),Number.MAX_VALUE)*Math.tan(Math.exp(this.logFov)*It.DEG2RAD*.5),b=new A().copy(this.goalOrigin).add(v.multiplyScalar(this.zoomControlCoord.x*S*x*1)).add(y.multiplyScalar(this.zoomControlCoord.y*S*1)).add(m),E=cs(this._radiusDelta/this.goalSpherical.radius,-1,1),M=new A().copy(this.goalOrigin).lerp(b,E);this.setTarget(M.x,M.y,M.z)}}update(e){const t=performance.now();if(e=e!==void 0?e:t-this._lastTick,this._lastTick=t,this.isStationary())return!1;this.computeMinMaxRadius();const{maximumPolarAngle:n}=this._options,i=this.spherical.theta-this.goalSpherical.theta;Math.abs(i)>Math.PI&&!isFinite(this._options.minimumAzimuthalAngle)&&!isFinite(this._options.maximumAzimuthalAngle)&&(this.spherical.theta-=2*Math.sign(i)*Math.PI),this.spherical.theta=this.thetaDamper.update(this.spherical.theta,this.goalSpherical.theta,e,Math.PI),this.spherical.phi=this.phiDamper.update(this.spherical.phi,this.goalSpherical.phi,e,n);const r=this._options.maximumRadius-this._options.minimumRadius,s=r<1?r:1;this.spherical.radius=this.radiusDamper.update(this.spherical.radius,this.goalSpherical.radius,e,s),this.logFov=this.goalLogFov;let o=1;this.world&&(o=this.world.worldBox.getBoundingSphere(new rn).radius/10);const l=this.targetDamperX.update(this.origin.x,this.goalOrigin.x,e,o),c=this.targetDamperY.update(this.origin.y,this.goalOrigin.y,e,o),u=this.targetDamperZ.update(this.origin.z,this.goalOrigin.z,e,o);return this.origin.set(l,c,u),this.moveCamera()}polarFromPivotal(e){const t=this.quaternionFromSpherical(this.spherical),n=new A().setFromMatrixColumn(new ae().makeRotationFromQuaternion(t),2),i=new A().copy(e),r=new A().copy(this.pivotPoint).applyMatrix4(this._basisTransformInv),s=i.distanceTo(r),o=new A().copy(i).sub(r);o.normalize();const l=Math.min(Math.max(n.dot(o),-1),1),c=Math.acos(l),u=s*Math.cos(c),h=i.sub(new A().copy(n).multiplyScalar(u));this.goalOrigin.copy(h),this.origin.copy(h),this._targetCamera instanceof tn&&(this.goalSpherical.radius=u,this.spherical.radius=u)}positionFromPivotal(e,t){const n=new A().copy(this.pivotPoint).applyMatrix4(this._basisTransformInv),i=new A;return i.copy(e),i.sub(n),i.applyQuaternion(t),i.add(n),i}getPivotalOrigin(e,t,n){const i=new A().copy(t);return i.sub(e),i.applyQuaternion(new dt().copy(n).invert()),i.add(e),i}moveCamera(){const e=new A().copy(this._targetCamera.position),t=new dt().copy(this._targetCamera.quaternion);this.spherical.makeSafe();const n=this.quaternionFromSpherical(this.spherical);let i=this.positionFromSpherical(this.spherical,this.origin);if(this.usePivotal){const o=new A().copy(this.pivotPoint).applyMatrix4(this._basisTransformInv);new A().copy(this.lastPivotPoint).applyMatrix4(this._basisTransformInv).sub(o).length()>0&&this.pivotalOrigin.copy(this.getPivotalOrigin(o,i,n)),i=this.positionFromPivotal(this.pivotalOrigin,n),this.polarFromPivotal(i),this.lastPivotPoint.copy(this.pivotPoint)}if(i.applyQuaternion(new dt().setFromRotationMatrix(this._basisTransform)),n.premultiply(new dt().setFromRotationMatrix(this._basisTransform)),this._targetCamera instanceof ki){const o=new A().setFromSpherical(this.spherical).applyQuaternion(new dt().setFromRotationMatrix(this._basisTransform)).normalize();i.add(o.multiplyScalar(this._options.maximumRadius-this.options.minimumRadius-this.spherical.radius))}if(this._targetCamera.position.copy(i),this._targetCamera.quaternion.copy(n),this._targetCamera.updateMatrixWorld(!0),this._targetCamera instanceof tn&&this._targetCamera.fov!==Math.exp(this.logFov)&&(this._targetCamera.fov=Math.exp(this.logFov),this._targetCamera.updateProjectionMatrix()),this._targetCamera instanceof ki){const o=wb(this.spherical.radius,Math.exp(this.logFov),this._container.offsetWidth/this._container.offsetHeight);this._targetCamera.zoom=1,this._targetCamera.left=o.x/-2,this._targetCamera.right=o.x/2,this._targetCamera.top=o.y/2,this._targetCamera.bottom=o.y/-2,this._targetCamera.updateProjectionMatrix()}const r=this._options.orbitAroundCursor&&this.usePivotal?this.pivotPoint:new A().copy(this.origin).applyMatrix4(this._basisTransform);this.orbitSphere.position.copy(r);const s=Math.min(Kw,this.world.getRelativeOffset(Kw));return e.sub(this._targetCamera.position).length()>s||t.angleTo(this._targetCamera.quaternion)>s}positionFromSpherical(e,t){const n=new A;return n.setFromSpherical(e),t&&n.add(t),n}quaternionFromSpherical(e){const t=new dt;return t.setFromEuler(new mi(e.phi-Math.PI/2,e.theta,0,"YXZ")),t}userAdjustOrbit(e,t,n){this.adjustOrbit(e*this._options.orbitSensitivity*+this._options.enableOrbit*this._options.inputSensitivity,t*this._options.orbitSensitivity*+this._options.enableOrbit*this._options.inputSensitivity,n*this._options.zoomSensitivity*+this._options.enableZoom*this._options.inputSensitivity)}enableInteraction(){this._enabled||(this._container.addEventListener("pointerdown",this.onPointerDown),this._container.addEventListener("pointercancel",this.onPointerUp),this._container.addEventListener("wheel",this.onWheel),this._container.addEventListener("touchmove",(()=>{}),{passive:!1}),this._container.addEventListener("contextmenu",this.onContext))}disableInteraction(){this._enabled&&(this._container.removeEventListener("pointerdown",this.onPointerDown),this._container.removeEventListener("pointermove",this.onPointerMove),this._container.removeEventListener("pointerup",this.onPointerUp),this._container.removeEventListener("pointercancel",this.onPointerUp),this._container.removeEventListener("wheel",this.onWheel),this._container.removeEventListener("contextmenu",this.onContext),this.touchMode=null,this.pointers.length=0)}wrapAngle(e){const t=(e+Math.PI)/(2*Math.PI);return 2*(t-Math.floor(t))*Math.PI-Math.PI}pixelLengthToSphericalAngle(e){return 2*Math.PI*e/this._container.offsetHeight}twoTouchDistance(e,t){const{clientX:n,clientY:i}=e,{clientX:r,clientY:s}=t,o=r-n,l=s-i;return Math.sqrt(o*o+l*l)}handleSinglePointerMove(e,t){const n=this.pixelLengthToSphericalAngle(e),i=this.pixelLengthToSphericalAngle(t);this.isUserPointing===!1&&(this.isUserPointing=!0,this.emit(cf.PointerChangeStart)),this.userAdjustOrbit(n,i,0)}initializePan(){const{theta:e,phi:t}=this.spherical,n=e;this.panPerPixel=.018*this._options.panSensitivity*+this._options.enablePan/this._container.offsetHeight,this.panProjection.set(-Math.cos(n),-Math.cos(t)*Math.sin(n),0,0,Math.sin(t),0,Math.sin(n),-Math.cos(t)*Math.cos(n),0)}movePan(e,t){const n=Gm.set(e,t,0).multiplyScalar(this._options.inputSensitivity);let i=this.world.getRelativeOffset(.4);this._minDist&&this._minDist<.5*i&&(i=this.world.getRelativeOffset(.06));const r=cs(this.spherical.radius,this.world.getRelativeOffset(.025),Number.MAX_VALUE),s=Math.max(i,r)*Math.exp(this.logFov)*this.panPerPixel;n.multiplyScalar(s);const o=this.getTarget().applyMatrix4(this._basisTransformInv);o.add(n.applyMatrix3(this.panProjection)),this.setTarget(o.x,o.y,o.z),this.usePivotal=!1,this.orbitSphere.visible=!1}filterOrbitToCursorHits(e){var t;const n=this.renderer.getMaterial(e.batchObject.renderView);return(t=n?.visible)!==null&&t!==void 0&&t}onTouchChange(e){if(this.pointers.length===1)this.touchMode=this.touchModeRotate;else{if(!this._options.enableZoom)return this.touchMode=null,void this._container.removeEventListener("touchmove",this.disableScroll);this.touchMode=this.touchDecided&&this.touchMode===null?null:this.touchModeZoom,this.touchDecided=!0,this._container.addEventListener("touchmove",this.disableScroll,{passive:!1}),this.lastSeparation=this.twoTouchDistance(this.pointers[0],this.pointers[1]),this.enablePan&&this.touchMode!==null&&(this.initializePan(),e.altKey)}}onMouseDown(e){this.panPerPixel=0,this.enablePan&&(e.button===2||e.ctrlKey||e.metaKey||e.shiftKey)&&(this.initializePan(),this.orbitSphere.visible=!1)}dispose(){throw new Error("Method not implemented.")}}var Tu;function wb(a,e,t){const n=2*Math.tan(It.DEG2RAD*(e/2))*a;return new te(n*t,n)}(function(a){a[a.EMPIRIC=0]="EMPIRIC",a[a.ACCURATE=1]="ACCURATE"})(Tu||(Tu={}));const jN={enableOrbit:!0,enableZoom:!0,enablePan:!0,orbitSensitivity:1,zoomSensitivity:1,panSensitivity:1,inputSensitivity:1,minimumRadius:0,maximumRadius:1/0,minimumPolarAngle:0,maximumPolarAngle:Math.PI,minimumAzimuthalAngle:-1/0,maximumAzimuthalAngle:1/0,minimumFieldOfView:40,maximumFieldOfView:60,touchAction:"none",infiniteZoom:!0,zoomToCursor:!0,orbitAroundCursor:!0,showOrbitPoint:!0,lookSpeed:1,moveSpeed:1,damperDecay:30,enableLook:!0,relativeUpDown:!1,nearPlaneCalculation:Tu.ACCURATE};class lo extends Zr{get renderingCamera(){return this._renderingCamera}set renderingCamera(e){this._renderingCamera=e}get enabled(){return this._activeControls.enabled}set enabled(e){this.controls.enabled=e}get fieldOfView(){return this.perspectiveCamera.fov}set fieldOfView(e){this.perspectiveCamera.fov=e,this.perspectiveCamera.updateProjectionMatrix()}get aspect(){return this.perspectiveCamera.aspect}get controls(){return this._activeControls}get options(){return this._options}set options(e){Object.assign(this._options,e),this._orbitControls.options=e,this._flyControls.options=e}constructor(e){super(e),this._lastCameraChanged=!1,this._options=jN,this.perspectiveCamera=new tn(55,window.innerWidth/window.innerHeight);const t=this.viewer.getContainer().offsetWidth/this.viewer.getContainer().offsetHeight;this.orthographicCamera=new ki(-50*t/2,50*t/2,25,-25,.001,1e4),this.renderingCamera=this.perspectiveCamera,this._flyControls=new Zw(this._renderingCamera,this.viewer.getContainer(),this.viewer.World,this._options),this._flyControls.enabled=!1,this._flyControls.setDamperDecayTime(30),this._flyControls.up=new A(0,0,1),this._orbitControls=new Vm(this.perspectiveCamera,this.viewer.getContainer(),this.viewer.World,this.viewer.getRenderer(),this._options),this._orbitControls.enabled=!0,this.viewer.getRenderer().speckleCamera=this,this._activeControls=this._orbitControls,this.default()}default(){this._activeControls instanceof Vm&&(this._activeControls.up=new A(0,0,1),this._activeControls.setOrbit(2.356,.955),this._activeControls.jumpToGoal())}on(e,t){super.on(e,t)}getTarget(){return this._activeControls.getTarget()}getPosition(){return this._activeControls.getPosition()}toggleControls(){const e=this._activeControls;let t;if(this._activeControls instanceof Vm?t=this._flyControls:this._activeControls instanceof Zw&&(t=this._orbitControls),!t)throw new Error("Not controls found!");e.enabled=!1,t.enabled=!0,t.fromPositionAndTarget(e.getCurrentPosition(),e.getCurrentTarget()),t.jumpToGoal(),this._activeControls=t,this.viewer.requestRender()}setCameraView(e,t=!0,n=1.2){e?Array.isArray(e)?this.zoom(e,n,t):this.isBox3(e)?this.zoomToBox(e,n,t):this.setView(e,t):this.zoomExtents(n,t),this.emit(Si.Dynamic)}onEarlyUpdate(e){const t=this._activeControls.update(e);t!==this._lastCameraChanged&&this.emit(t?Si.Dynamic:Si.Stationary),this.emit(Si.FrameUpdate,t),this._lastCameraChanged=t,t&&this.updateCameraPlanes()}onLateUpdate(){this._lastCameraChanged&&this.emit(Si.Dynamic),this.emit(Si.LateFrameUpdate,this._lastCameraChanged)}onResize(){const e=this.viewer.getContainer().offsetWidth/this.viewer.getContainer().offsetHeight;this.perspectiveCamera.aspect=e,this.perspectiveCamera.updateProjectionMatrix();const t=wb(this._activeControls.getPosition().distanceTo(this._activeControls.getTarget()),this.perspectiveCamera.fov,e);this.orthographicCamera.zoom=1,this.orthographicCamera.left=t.x/-2,this.orthographicCamera.right=t.x/2,this.orthographicCamera.top=t.y/2,this.orthographicCamera.bottom=t.y/-2,this.orthographicCamera.updateProjectionMatrix()}setPerspectiveCameraOn(){this._renderingCamera!==this.perspectiveCamera&&(this.renderingCamera=this.perspectiveCamera,this.setupPerspectiveCamera(),this.viewer.requestRender(Qt.RENDER_RESET))}setOrthoCameraOn(){this._renderingCamera!==this.orthographicCamera&&(this.renderingCamera=this.orthographicCamera,this.setupOrthoCamera(),this.viewer.requestRender(Qt.RENDER_RESET))}toggleCameras(){this._renderingCamera===this.perspectiveCamera?this.setOrthoCameraOn():this.setPerspectiveCameraOn()}setupOrthoCamera(){this.controls.targetCamera=this.orthographicCamera,this.enableRotations(),this.updateCameraPlanes(this.viewer.getRenderer().sceneBox),this.emit(Si.ProjectionChanged,af.ORTHOGRAPHIC)}setupPerspectiveCamera(){this.controls.targetCamera=this.perspectiveCamera,this.enableRotations(),this.updateCameraPlanes(this.viewer.getRenderer().sceneBox),this.emit(Si.ProjectionChanged,af.PERSPECTIVE)}disableRotations(){this.options={enableOrbit:!1,enableLook:!1}}enableRotations(){this.options={enableOrbit:!0,enableLook:!0}}updateCameraPlanes(e,t=1){const n=this.viewer.getRenderer();if(!n.renderingCamera)return;e||(e=this.viewer.getRenderer().sceneBox);let i=this.computeNearCameraPlaneEmpiric(e,t);this._options.nearPlaneCalculation===Tu.ACCURATE&&(i=this.computeNearCameraPlaneAccurate(e,t,i)),i&&(n.renderingCamera.near=i,n.renderingCamera.updateProjectionMatrix()),this.updateFarCameraPlane()}computeNearCameraPlaneEmpiric(e,t=1){if(!e)return;if(e.isEmpty())return void De.warn("Cannot set camera planes for empty volume");const n=e.getSize(new A),i=Math.max(n.x,n.y,n.z),r=this._renderingCamera===this.perspectiveCamera?this.fieldOfView:55,s=this._renderingCamera===this.perspectiveCamera?this.aspect:1.2,o=i/(2*Math.atan(Math.PI*r/360)),l=o/s,c=t*Math.max(o,l);return this.perspectiveCamera?c/100:.001}computeNearCameraPlaneAccurate(e,t=1,n){const i=this.getClosestGeometryDistance(n);if(this._flyControls.minDist=i,this._orbitControls.minDist=i,i===Number.POSITIVE_INFINITY)return this.computeNearCameraPlaneEmpiric(e,t);const r=this._renderingCamera===this.perspectiveCamera?this.fieldOfView:55,s=this._renderingCamera===this.perspectiveCamera?this.aspect:1.2;return Math.max(i,0)/Math.sqrt(1+Math.pow(Math.tan(r/180*Math.PI/2),2)*(Math.pow(s,2)+1))}updateFarCameraPlane(){const e=this.viewer.getRenderer();if(!e.renderingCamera)return;const t=new A,n=e.sceneBox,i=new A().copy(e.renderingCamera.position);let r=0;t.set(n.min.x,n.min.y,n.min.z),r=Math.max(i.distanceTo(t),r),t.set(n.min.x,n.min.y,n.max.z),r=Math.max(i.distanceTo(t),r),t.set(n.min.x,n.max.y,n.min.z),r=Math.max(i.distanceTo(t),r),t.set(n.min.x,n.max.y,n.max.z),r=Math.max(i.distanceTo(t),r),t.set(n.max.x,n.min.y,n.min.z),r=Math.max(i.distanceTo(t),r),t.set(n.max.x,n.min.y,n.max.z),r=Math.max(i.distanceTo(t),r),t.set(n.max.x,n.max.y,n.min.z),r=Math.max(i.distanceTo(t),r),t.set(n.max.x,n.max.y,n.max.z),r=Math.max(i.distanceTo(t),r),e.renderingCamera.far=2*r,e.renderingCamera.updateProjectionMatrix()}getClosestGeometryDistance(e){const t=this._activeControls.getCurrentPosition(),n=this._activeControls.getCurrentTarget(),i=new A().subVectors(n,t).normalize(),r=this.viewer.getRenderer().batcher.getBatches(void 0,[ze.MESH,ze.TEXT]);let s=Number.POSITIVE_INFINITY;for(let o=0;o<r.length;o++){const l=r[o].mesh.TAS.closestPointToPointHalfplane(t,i,e);l&&(s=Math.min(s,l.distance))}return s}zoom(e,t,n){e?this.zoomToBox(this.viewer.getRenderer().boxFromObjects(e),t,n):this.zoomExtents(t,n)}zoomExtents(e=1.2,t=!0){if(this.viewer.getRenderer().clippingVolume.isEmpty()){const i=new He(new A(-1,-1,-1),new A(1,1,1));return void this.zoomToBox(i,e,t)}const n=new He().fromOBB(this.viewer.getRenderer().clippingVolume);n.min.equals(n.max)&&n.expandByVector(new A(1,1,1)),this.zoomToBox(n,e,t)}zoomToBox(e,t=1.2,n=!0){e.max.x!==1/0&&e.max.x!==-1/0||(e=new He(new A(-1,-1,-1),new A(1,1,1)));const i=new rn;e.getBoundingSphere(i),i.radius=this.fitToRadius(i.radius)*t,this._activeControls.fitToSphere(i),n||this._activeControls.jumpToGoal(),this.updateCameraPlanes(e,t)}fitToRadius(e){const t=this.perspectiveCamera.getEffectiveFOV()*It.DEG2RAD,n=2*Math.atan(Math.tan(.5*t)*this.perspectiveCamera.aspect),i=1<this.perspectiveCamera.aspect?t:n;return e/Math.sin(.5*i)}isSpeckleView(e){return e.name!==void 0}isCanonicalView(e){return typeof e=="string"}isInlineView(e){return e.position!==void 0&&e.target!==void 0}isPolarView(e){return e.azimuth!==void 0&&e.polar!==void 0}isBox3(e){return e instanceof He}setView(e,t=!0){this.isSpeckleView(e)&&this.setViewSpeckle(e,t),this.isCanonicalView(e)&&this.setViewCanonical(e,t),this.isInlineView(e)&&this.setViewInline(e,t),this.isPolarView(e)&&this.setViewPolar(e,t)}setViewSpeckle(e,t=!0){this._activeControls.fromPositionAndTarget(new A(e.origin.x,e.origin.y,e.origin.z),new A(e.target.x,e.target.y,e.target.z)),t||this._activeControls.jumpToGoal(),this.enableRotations()}setViewCanonical(e,t=!0){const n=new rn;this.viewer.World.worldBox.getBoundingSphere(n);const i=this.fitToRadius(n.radius),r=new A().copy(this.viewer.World.worldBox.getCenter(new A)),s=new A().copy(r),o=new dt().setFromUnitVectors(new A(0,1,0),this._activeControls.up);switch(e){case"front":this._activeControls.fromPositionAndTarget(r.add(new A(0,0,1).applyQuaternion(o).multiplyScalar(i)),s),this._renderingCamera===this.orthographicCamera&&this.disableRotations();break;case"back":this._activeControls.fromPositionAndTarget(r.add(new A(0,0,-1).applyQuaternion(o).multiplyScalar(i)),s),this._renderingCamera===this.orthographicCamera&&this.disableRotations();break;case"up":case"top":this._activeControls.fromPositionAndTarget(r.add(new A(0,1,0).applyQuaternion(o).multiplyScalar(i)),s),this._renderingCamera===this.orthographicCamera&&this.disableRotations();break;case"down":case"bottom":this._activeControls.fromPositionAndTarget(r.add(new A(0,-1,0).applyQuaternion(o).multiplyScalar(i)),s),this._renderingCamera===this.orthographicCamera&&this.disableRotations();break;case"right":this._activeControls.fromPositionAndTarget(r.add(new A(1,0,0).applyQuaternion(o).multiplyScalar(i)),s),this._renderingCamera===this.orthographicCamera&&this.disableRotations();break;case"left":this._activeControls.fromPositionAndTarget(r.add(new A(-1,0,0).applyQuaternion(o).multiplyScalar(i)),s),this._renderingCamera===this.orthographicCamera&&this.disableRotations();break;case"3d":this._activeControls.fromPositionAndTarget(new A().copy(this.viewer.World.worldBox.max),s),this.zoomExtents();break;default:this.enableRotations()}t||this._activeControls.jumpToGoal()}setViewInline(e,t=!0){this._activeControls.fromPositionAndTarget(e.position,e.target),t||this._activeControls.jumpToGoal(),this.enableRotations()}setViewPolar(e,t=!0){this._activeControls.adjustOrbit(e.azimuth,e.polar,e.radius?e.radius:0),t||this._activeControls.jumpToGoal(),this.enableRotations()}}const QN=Ic;class qf extends Ku{get World(){return this.world}get Utils(){return this.utils||(this.utils={screenToNDC:this.speckleRenderer.screenToNDC.bind(this.speckleRenderer),NDCToScreen:this.speckleRenderer.NDCToScreen.bind(this.speckleRenderer)}),this.utils}get input(){return this.speckleRenderer.input}getConstructorChain(e){const t=[];let n=e;do(n=Object.getPrototypeOf(n))&&t.push(n.constructor.name||null);while(n!==null);return t}createExtension(e){const t=e.prototype.inject,n=[];t.forEach((r=>{if(this.extensions[r.name])n.push(this.extensions[r.name]);else for(const s in this.extensions)this.getConstructorChain(this.extensions[s]).includes(r.name)&&n.push(this.extensions[s])}));const i=new e(this,...n);return this.extensions[e.name]=i,i}getExtension(e){let t;if((t=this.getExtensionInternal(e))!==null)return t;throw new Error(`Could not get Extension of type ${e.name}. Is it created?`)}hasExtension(e){return!!this.getExtensionInternal(e)}getExtensionInternal(e){if(this.extensions[e.name])return this.extensions[e.name];for(const t in this.extensions)if(this.getConstructorChain(this.extensions[t]).includes(e.name))return this.extensions[t];return null}constructor(e,t=a0){super(),this.tree=new xl,this.world=new ca,this.loaders={},this.extensions={},De.useDefaults(),De.setLevel(t.verbose?De.TRACE:De.ERROR),this.container=e||document.getElementById("renderer"),t.showStats&&(this.stats=QN(),this.container.prepend(this.stats.dom),this.stats.dom.style.position="relative"),this.loaders={},this.startupParams=t,this.clock=new Lv,this.speckleRenderer=new gb(this.tree,this),this.speckleRenderer.create(this.container),window.addEventListener("resize",this.resize.bind(this),!1),this.propertyManager=new VN,this.frame(),this.resize()}getContainer(){return this.container}getRenderer(){return this.speckleRenderer}resize(){const e=this.container.offsetWidth,t=this.container.offsetHeight;this.speckleRenderer.resize(e,t),Object.values(this.extensions).forEach((n=>{n.onResize()}))}requestRender(e=Qt.RENDER){e&Qt.RENDER&&(this.speckleRenderer.needsRender=!0),e&Qt.SHADOWS&&(this.speckleRenderer.shadowMapNeedsUpdate=!0),e&Qt.CLIPPING_PLANES&&this.speckleRenderer.updateClippingPlanes(),e&Qt.RENDER_RESET&&(this.speckleRenderer.needsRender=!0,this.speckleRenderer.resetPipeline())}frame(){this.update(),this.render()}update(){var e;const t=this.clock.getDelta()*Zu.second,n=Object.values(this.extensions);n.forEach((i=>{i.onEarlyUpdate(t)})),this.speckleRenderer.update(t),n.forEach((i=>{i.onLateUpdate(t)})),(e=this.stats)===null||e===void 0||e.update(),requestAnimationFrame(this.frame.bind(this))}render(){this.speckleRenderer.render(),Object.values(this.extensions).forEach((e=>{e.onRender()}))}async init(){this.startupParams.environmentSrc&&jn.getEnvironment(this.startupParams.environmentSrc,this.speckleRenderer.renderer).then((e=>{this.speckleRenderer.indirectIBL=e})).catch((e=>{De.error(e),De.error("Environment failed to load!")}))}on(e,t){super.on(e,t)}getObjectProperties(e=null,t=!0){return this.propertyManager.getProperties(this.tree,e,t)}getDataTree(){De.error("DataTree has been deprecated! Please use WorldTree")}getWorldTree(){return this.tree}query(e){return Pi.isPointQuery(e)?(Pi.DefaultPointQuerySolver.setContext(this.speckleRenderer),Pi.DefaultPointQuerySolver.solve(e)):Pi.isIntersectionQuery(e)?(Pi.DefaultIntersectionQuerySolver.setContext(this.speckleRenderer),Pi.DefaultIntersectionQuerySolver.solve(e)):null}setLightConfiguration(e){this.speckleRenderer.setSunLightConfiguration(e)}getViews(){return this.tree.findAll((e=>{var t;return((t=e.model.renderView)===null||t===void 0?void 0:t.speckleType)===et.View3D})).map((e=>e.model.raw))}screenshot(){return new Promise((e=>{e(this.speckleRenderer.renderer.domElement.toDataURL("image/png"))}))}async loadObject(e,t=!0){var n;if(t&&((n=this.getExtension(lo))===null||n===void 0||n.default()),this.loaders[e.resource]=e,await e.load()){const i=this.tree.getRenderTree(e.resource);if(!i)throw new Error(`Could not get render tree ${e.resource}`);const r=performance.now();for await(const s of this.speckleRenderer.addRenderTree(i))if(t){const o=this.getExtension(lo);o&&(o.setCameraView([],!1),this.speckleRenderer.pipeline.render())}De.log(this.getRenderer().renderingStats),De.log("ASYNC batch build time -> ",performance.now()-r),this.requestRender(Qt.RENDER_RESET|Qt.SHADOWS),this.emit(Cn.LoadComplete,e.resource)}this.loaders[e.resource]&&this.loaders[e.resource].dispose(),delete this.loaders[e.resource]}async cancelLoad(e,t=!1){var n;this.loaders[e].cancel(),(n=this.tree.getRenderTree(e))===null||n===void 0||n.cancelBuild(),this.speckleRenderer.cancelRenderTree(e),t&&await this.unloadObject(e)}async unloadObject(e){var t;try{if(this.tree.findSubtree(e)){if(this.loaders[e])return void await this.cancelLoad(e,!0);delete this.loaders[e],this.speckleRenderer.removeRenderTree(e),(t=this.tree.getRenderTree(e))===null||t===void 0||t.purge(),this.tree.purge(e),this.requestRender(Qt.RENDER_RESET|Qt.SHADOWS)}}finally{De.warn(`Removed subtree ${e}`),this.emit(Cn.UnloadComplete,e)}}async unloadAll(){try{for(const e of Object.keys(this.loaders))this.loaders[e]&&await this.cancelLoad(e,!1),delete this.loaders[e];this.tree.root.children.forEach((e=>{var t;this.speckleRenderer.removeRenderTree(e.model.id),(t=this.tree.getRenderTree())===null||t===void 0||t.purge()})),this.tree.purge()}finally{De.warn("Removed all subtrees"),this.emit(Cn.UnloadAllComplete)}}dispose(){}}var Nt;qf.theAssets=new jn,(function(a){a[a.HIDDEN=0]="HIDDEN",a[a.DANGLING_START=1]="DANGLING_START",a[a.DANGLING_END=2]="DANGLING_END",a[a.COMPLETE=3]="COMPLETE"})(Nt||(Nt={}));class _u extends gt{constructor(){super(),this.startPoint=new A,this.endPoint=new A,this.startNormal=new A,this.endNormal=new A,this.value=0,this.units="m",this.precision=2,this._state=Nt.HIDDEN,this.renderingSize=new te,this.measurementId=It.generateUUID()}set state(e){this._state=e}get state(){return this._state}get bounds(){return new He().expandByPoint(this.startPoint).expandByPoint(this.endPoint)}frameUpdate(e,t,n){this.renderingCamera=e,this.renderingSize.copy(t)}toMeasurementData(){return{type:this.measurementType,startPoint:[this.startPoint.x,this.startPoint.y,this.startPoint.z],endPoint:[this.endPoint.x,this.endPoint.y,this.endPoint.z],startNormal:[this.startNormal.x,this.startNormal.y,this.startNormal.z],endNormal:[this.endNormal.x,this.endNormal.y,this.endNormal.z],value:this.value,uuid:this.measurementId}}fromMeasurementData(e){this.measurementId=e.uuid,this.startPoint.set(e.startPoint[0],e.startPoint[1],e.startPoint[2]),this.endPoint.set(e.endPoint[0],e.endPoint[1],e.endPoint[2]),this.startNormal.set(e.startNormal[0],e.startNormal[1],e.startNormal[2]),this.endNormal.set(e.endNormal[0],e.endNormal[1],e.endNormal[2]),this.value=e.value,this._state=Nt.COMPLETE}}const WN=new ae,XN=new ae,Yw=new He,Da=new A,us=new lt,Ai=[new A,new A,new A,new A],qw={text:"Test Text",fontSize:40,maxWidth:Number.POSITIVE_INFINITY,anchorX:"left",anchorY:"middle",billboard:"screen",backgroundColor:new Ie(16711680),backgroundCornerRadius:.5,backgroundMargins:new te(50,10),textColor:new Ie(65535),textOpacity:1,objectLayer:re.OVERLAY};class Rc extends Za{get textMesh(){return this}get backgroundMesh(){return this._background}get textBounds(){return this._textBounds}get backgroundMaterial(){return this._backgroundMaterial}constructor(e=qw){super(),this.DEBUG_BILLBOARDS=!1,this._params=Object.assign({},qw),this._textBounds=new He,this.depthOffset=-.1,this.material=new vr({}).getDerivedMaterial(),this.material.toneMapped=!1,this._backgroundMaterial=new Ar({}),this._backgroundMaterial.toneMapped=!1,this._background=new Ve(void 0,this._backgroundMaterial),this._background.frustumCulled=!1,this._background.raycast=()=>{};const t=new nt;t.setAttribute("position",new je(new Array(12).fill(0),3)),t.setIndex(new wf([0,1,2,0,2,3],1)),this._collisionMesh=new Ve(t,new ti({color:65280,wireframe:!0})),this._collisionMesh.name="TextLabel_Collision_Mesh",this._collisionMesh.renderOrder=1,this._collisionMesh.visible=this.DEBUG_BILLBOARDS,this.add(this._collisionMesh),this.updateParams(e).then().catch}async updateParams(e,t){return new Promise((n=>{if(this.material&&!(this.material instanceof vr)){const r=this.material;De.error(`TextLabel requires a SpeckleTextMaterial instance. Found ${r.constructor.name}`)}const i=Object.assign({},e);e.billboard==="screen"?(i.backgroundMargins&&i.backgroundMargins.multiplyScalar(window.devicePixelRatio),i.fontSize&&(i.fontSize*=window.devicePixelRatio),this.material.side=An,this._backgroundMaterial.side=An):(this.material.side=yt,this._backgroundMaterial.side=yt),i.text&&(this.text=i.text),i.fontSize&&(this.fontSize=i.fontSize),i.anchorX&&(this.anchorX=i.anchorX),i.anchorY&&(this.anchorY=i.anchorY),i.maxWidth&&(this.maxWidth=i.maxWidth),i.textColor!==void 0&&(this.material.color.copy(i.textColor),this.material.color.convertSRGBToLinear()),i.textOpacity!==void 0&&(this.material.opacity=i.textOpacity),i.objectLayer!==void 0&&(this.layers.set(i.objectLayer),this._collisionMesh.layers.set(i.objectLayer),this._background.layers.set(i.objectLayer)),this.material.needsUpdate=!0,Object.assign(this._params,i),this._needsSync?this.sync((()=>{this.textBoundsToBox(this._textBounds),this.updateBackground(),this.updateBillboarding(),t&&t(),n()})):(t&&t(),n())}))}raycast(e,t){if(!this._params.billboard)return void super.raycast(e,t);const n=this.matrixWorld,i=WN.copy(n).invert(),r=new A().set(n.elements[12],n.elements[13],n.elements[14]);if(this._params.billboard==="world"){const s=new He().copy(this._params.backgroundColor!==null?this._background.geometry.boundingBox:this._textBounds),o=new A().copy(s.min),l=new A().copy(s.max);Ai[0].set(o.x,o.y,0),Ai[1].set(l.x,o.y,0),Ai[2].set(l.x,l.y,0),Ai[3].set(o.x,l.y,0);const c=XN.extractRotation(e.camera.matrixWorld),u=new ae().makeTranslation(r.x,r.y,r.z);u.premultiply(i),u.multiply(c);for(let h=0;h<Ai.length;h++)Ai[h].applyMatrix4(u),this._collisionMesh.geometry.attributes.position.setXYZ(h,Ai[h].x,Ai[h].y,Ai[h].z)}if(this._params.billboard==="screen"){const s=new He().copy(this._textBounds);if(s.getSize(new A).length()===0||s.isInfiniteBox())return;const o=new A().copy(s.min),l=new A().copy(s.max);Ai[0].set(o.x,o.y,0),Ai[1].set(l.x,o.y,0),Ai[2].set(l.x,l.y,0),Ai[3].set(o.x,l.y,0);const c=(this._params.backgroundColor,this._backgroundMaterial.userData.billboardPixelOffsetSize.value),u=e.camera.projectionMatrixInverse,h=e.camera.matrixWorld,d=new lt(r.x,r.y,r.z,1).applyMatrix4(e.camera.matrixWorldInverse).applyMatrix4(e.camera.projectionMatrix),f=d.w;d.multiplyScalar(1/f);for(let p=0;p<Ai.length;p++)Da.copy(Ai[p]),Da.multiply(new A(2*c.z,2*c.w,0)),Da.add(new A(2*c.x,2*c.y,0)),us.set(d.x,d.y,d.z,1),us.add(new lt(Da.x,Da.y,0,0)),us.multiplyScalar(f),us.applyMatrix4(u),us.applyMatrix4(h),us.applyMatrix4(i),this._collisionMesh.geometry.attributes.position.setXYZ(p,us.x,us.y,us.z)}this._collisionMesh.geometry.attributes.position.needsUpdate=!0,this._collisionMesh.geometry.computeBoundingBox(),this._collisionMesh.geometry.computeBoundingSphere(),this._collisionMesh.raycast(e,t)}textBoundsToBox(e=new He){const{textRenderInfo:t}=this,n=t.visibleBounds,i=[];return i.push(n[0],n[3],0,n[2],n[3],0,n[0],n[1],0,n[2],n[1],0),e.setFromArray(i),e}updateBillboarding(){var e,t,n,i;if(this.material.setBillboarding(this._params.billboard),this._backgroundMaterial.setBillboarding(this._params.billboard),this._params.billboard==="screen"){const r=Yw.copy(this._textBounds);r.min.divideScalar(this.fontSize),r.max.divideScalar(this.fontSize);let s=r.getSize(Da);this.material.billboardPixelSize=new te(1/s.y,1/s.y),this._background.geometry.boundingBox||this._background.geometry.computeBoundingBox();const o=new He().copy(this._background.geometry.boundingBox);o.min.divideScalar(this.fontSize),o.max.divideScalar(this.fontSize),s=o.getSize(Da);const l=new te((t=(e=this._params.backgroundMargins)===null||e===void 0?void 0:e.x)!==null&&t!==void 0?t:0,(i=(n=this._params.backgroundMargins)===null||n===void 0?void 0:n.y)!==null&&i!==void 0?i:0);this._backgroundMaterial.billboardPixelSize=new te(1/s.y+l.x*(1/s.x)/this.fontSize,1/s.y+l.y*(1/s.y)/this.fontSize);const c=new te(0,0);switch(this.anchorX){case"left":c.x=.5*-l.x;break;case"right":c.x=.5*l.x}switch(this.anchorY){case"top":c.y=.5*-l.y;break;case"bottom":c.x=.5*l.y}this._backgroundMaterial.billboardPixelOffset=c}}updateBackground(){var e,t;if(!this._params.backgroundColor)return void(this._background&&(this._background.geometry.dispose(),this.remove(this._background)));this._background.parent||this.add(this._background);const n=Yw.copy(this._textBounds),i=n.getCenter(new A),r=n.getSize(new A),s=this.fontSize*((e=this._params.backgroundCornerRadius)!==null&&e!==void 0?e:0),o=this._params.billboard!=="screen"&&(t=this._params.backgroundMargins)!==null&&t!==void 0?t:new te;if(!n.isInfiniteBox()){const c=this.RectangleRounded(i,r.x+o.x,r.y+o.y,s,5);c.computeBoundingBox(),c.computeBoundingSphere(),this._background.geometry=c}const l=new Ie(this._params.backgroundColor).convertSRGBToLinear();this._background.material.color=l}RectangleRounded(e,t,n,i,r,s=!1){const o=[],l=[],c=[];if(s){let m=0;for(let g=0;g<=r;g++){const v=Math.PI/2*(g/(r+1)),y=i-i*Math.cos(v);y>m&&(m=y)}t+=2*m}const u=Math.min(i,t/2,n/2),h=r+1,d=4*(h+1);o.push(e.x,e.y,0),l.push(.5,.5);const f=[{cx:t/2-u,cy:n/2-u,angleStart:0},{cx:-t/2+u,cy:n/2-u,angleStart:Math.PI/2},{cx:-t/2+u,cy:-n/2+u,angleStart:Math.PI},{cx:t/2-u,cy:-n/2+u,angleStart:3*Math.PI/2}];for(let m=0;m<4;m++){const{cx:g,cy:v,angleStart:y}=f[m];for(let w=0;w<=h;w++){const x=y+Math.PI/2*(w/h),S=g+u*Math.cos(x),b=v+u*Math.sin(x);o.push(e.x+S,e.y+b,0),l.push(.5+S/t,.5+b/n)}}for(let m=1;m<=d;m++){const g=m<d?m+1:1;c.push(0,m,g)}const p=new nt;return p.setIndex(new _i(c,1)),p.setAttribute("position",new je(o,3)),p.setAttribute("uv",new je(l,2)),p.computeBoundingBox(),p}}const oi=new A,Tr={dashedLine:!1,normalIndicatorPixelSize:40,normalIndicatorColor:294651,normalIndicatorOpacity:1,lineColor:294651,lineOpacity:1,pointColor:294651,pointOpacity:1,textColor:16777215,textOpacity:1,textPixelHeight:11,pointPixelHeight:5};class co extends fi{set style(e){Object.assign(this._style,e),this.updateStyle()}set highlight(e){e?(this.normalIndicator.material.color=new Ie(16711680),this.line.material.color=new Ie(16711680),this.point.material.color=new Ie(16711680),this.text.material.color.copy(new Ie(16711680))):this.updateStyle()}getNormalIndicatorMaterial(){const e=new Or({color:294651,linewidth:1,worldUnits:!1,vertexColors:!1,alphaToCoverage:!1,resolution:new te(1,1)},["USE_RTE"]);return e.color=new Ie(this._style.normalIndicatorColor),e.color.convertSRGBToLinear(),e.toneMapped=!1,e.linewidth=2,e.worldUnits=!1,e.resolution=new te(256,256),e.opacity=this._style.normalIndicatorOpacity!==void 0?this._style.normalIndicatorOpacity:Tr.normalIndicatorOpacity,e.transparent=e.opacity<1,e.depthTest=!1,e}getLineMaterial(){const e=new Or({color:294651,linewidth:1,worldUnits:!1,vertexColors:!1,alphaToCoverage:!1,resolution:new te(1,1)},["USE_RTE","UNIFORM_OPACITY"].concat(this._style.dashedLine?["USE_DASH"]:[]));return e.color=new Ie(this._style.lineColor),e.color.convertSRGBToLinear(),e.toneMapped=!1,this._style.dashedLine&&(e.dashSize=1,e.gapSize=1,e.dashScale=10),e.linewidth=2,e.worldUnits=!1,e.resolution=new te(256,256),e.opacity=this._style.lineOpacity!==void 0?this._style.lineOpacity:Tr.lineOpacity,e.transparent=e.opacity<1,e.depthTest=!1,e}getPointMaterial(e){const t=new Ar({color:e||this._style.pointColor},["BILLBOARD_SCREEN"]);t.opacity=this._style.pointOpacity!==void 0?this._style.pointOpacity:Tr.pointOpacity,t.transparent=t.opacity<1,t.color.convertSRGBToLinear(),t.toneMapped=!1,t.depthTest=!1;const n=(this._style.pointPixelHeight!==void 0?this._style.pointPixelHeight:Tr.pointPixelHeight)*window.devicePixelRatio;return t.billboardPixelSize=new te(n,n),t}constructor(e){super(),this.normalIndicatorBuffer=new Float64Array(24),this.normalIndicatorNormal=new A,this.normalIndicatorTangent=new A,this.normalIndicatorBitangent=new A,this._style=Object.assign({},Tr),this.layers.set(re.MEASUREMENTS);const t=new la;t.setPositions(new Float32Array(this.normalIndicatorBuffer.length)),t.attributes.instanceStart.data.setUsage(Xn),ft.updateRTEGeometry(t,this.normalIndicatorBuffer),this.normalIndicator=new ao(t,void 0),this.normalIndicator.computeLineDistances(),this.normalIndicator.name="test-mesurements-normal-indicator",this.normalIndicator.frustumCulled=!1,this.normalIndicator.layers.set(re.MEASUREMENTS);const n=new Float64Array(18),i=new la;i.setPositions(new Float32Array(n)),i.attributes.instanceStart.data.setUsage(Xn),ft.updateRTEGeometry(i,n),this.line=new ao(i,void 0),this.line.computeLineDistances(),this.line.name="test-mesurements-line",this.line.frustumCulled=!1,this.line.renderOrder=0,this.line.layers.set(re.MEASUREMENTS);const r=new $a(1,16);this.point=new Ve(r),this.point.layers.set(re.MEASUREMENTS),this.point.visible=!1,this.point.renderOrder=1;const s=new Ve(r,this.getPointMaterial(16777215));s.renderOrder=2;const o=(this._style.pointPixelHeight!==void 0?this._style.pointPixelHeight:Tr.pointPixelHeight)*window.devicePixelRatio-2*window.devicePixelRatio;s.material.billboardPixelSize=new te(o,o),s.layers.set(re.MEASUREMENTS),this.point.add(s),this.text=new Rc({textColor:new Ie(this._style.textColor),fontSize:this._style.textPixelHeight!==void 0?this._style.textPixelHeight:Tr.textPixelHeight,textOpacity:this._style.textOpacity!==void 0?this._style.textOpacity:Tr.textOpacity,billboard:"screen",anchorX:"center",anchorY:"middle",backgroundColor:new Ie(294651),backgroundCornerRadius:.3,backgroundMargins:new te(30,10),objectLayer:re.MEASUREMENTS}),this.text.material.depthTest=!1,this.text.depthOffset=-.1,this.add(this.point),this.add(this.normalIndicator),this.add(this.line),this.add(this.text),this.style=e||Tr}enable(e,t,n,i){this.normalIndicator.visible=e,this.line.visible=t,this.point.visible=n,this.text.visible=i,this.text.textMesh.visible=i,this.line.material.visible=t}frameUpdate(e,t){let n=0;const i=this._style.normalIndicatorPixelSize!==void 0?this._style.normalIndicatorPixelSize:Tr.normalIndicatorPixelSize;if(e instanceof tn){const o=e.position.distanceTo(this.normalIndicator.position),l=It.degToRad(e.fov);n=i*(2*o*Math.tan(l/2)/t.y)/2}else e instanceof ki&&(n=i*((e.top-e.bottom)/t.y)/2);oi.copy(this.normalIndicator.position).addScaledVector(this.normalIndicatorTangent,n).addScaledVector(this.normalIndicatorBitangent,-n),oi.toArray(this.normalIndicatorBuffer,0),oi.copy(this.normalIndicator.position).addScaledVector(this.normalIndicatorTangent,-n).addScaledVector(this.normalIndicatorBitangent,-n),oi.toArray(this.normalIndicatorBuffer,3),oi.copy(this.normalIndicator.position).addScaledVector(this.normalIndicatorTangent,-n).addScaledVector(this.normalIndicatorBitangent,-n),oi.toArray(this.normalIndicatorBuffer,6),oi.copy(this.normalIndicator.position).addScaledVector(this.normalIndicatorTangent,-n).addScaledVector(this.normalIndicatorBitangent,n),oi.toArray(this.normalIndicatorBuffer,9),oi.copy(this.normalIndicator.position).addScaledVector(this.normalIndicatorTangent,-n).addScaledVector(this.normalIndicatorBitangent,n),oi.toArray(this.normalIndicatorBuffer,12),oi.copy(this.normalIndicator.position).addScaledVector(this.normalIndicatorTangent,n).addScaledVector(this.normalIndicatorBitangent,n),oi.toArray(this.normalIndicatorBuffer,15),oi.copy(this.normalIndicator.position).addScaledVector(this.normalIndicatorTangent,n).addScaledVector(this.normalIndicatorBitangent,n),oi.toArray(this.normalIndicatorBuffer,18),oi.copy(this.normalIndicator.position).addScaledVector(this.normalIndicatorTangent,n).addScaledVector(this.normalIndicatorBitangent,-n),oi.toArray(this.normalIndicatorBuffer,21);const r=this.normalIndicator.geometry.attributes.instanceStart.data,s=this.normalIndicator.geometry.attributes.instanceStartLow.data;ft.DoubleToHighLowBuffer(this.normalIndicatorBuffer,s.array,r.array),r.needsUpdate=!0,s.needsUpdate=!0,this.normalIndicator.geometry.computeBoundingBox(),this.normalIndicator.geometry.computeBoundingSphere(),this.normalIndicator.computeLineDistances()}updateNormalIndicator(e,t){this.normalIndicator.position.copy(e),this.normalIndicatorNormal.copy(t),Math.abs(t.x)>Math.abs(t.z)?this.normalIndicatorTangent.set(-t.y,t.x,0):this.normalIndicatorTangent.set(0,-t.z,t.y),this.normalIndicatorTangent.normalize(),this.normalIndicatorBitangent.crossVectors(this.normalIndicatorNormal,this.normalIndicatorTangent).normalize()}updatePoint(e){this.point.position.copy(e)}updateLine(e){const t=new Float64Array(3*e.length);e.forEach(((r,s)=>{r.toArray(t,3*s)}));const n=this.line.geometry.attributes.instanceStart.data,i=this.line.geometry.attributes.instanceStartLow.data;ft.DoubleToHighLowBuffer(t,i.array,n.array),n.needsUpdate=!0,n.updateRange={offset:0,count:3*e.length},i.needsUpdate=!0,i.updateRange={offset:0,count:3*e.length},this.line.visible=!0,this.line.geometry.instanceCount=e.length/2,this.line.geometry.attributes.instanceStart.needsUpdate=!0,this.line.geometry.attributes.instanceEnd.needsUpdate=!0,this.line.geometry.attributes.instanceStartLow.needsUpdate=!0,this.line.geometry.attributes.instanceEndLow.needsUpdate=!0,this.line.geometry.computeBoundingBox(),this.line.geometry.computeBoundingSphere(),this.line.computeLineDistances()}updateText(e,t,n,i){const r={text:e};return t&&this.text.position.copy(t),n&&this.text.quaternion.copy(n),i&&this.text.scale.copy(i),this.text.updateMatrixWorld(!0),this.text.updateParams(r)}updateStyle(){this.normalIndicator.material=this.getNormalIndicatorMaterial(),this.line.material=this.getLineMaterial(),this.point.material=this.getPointMaterial(),this.text.updateParams({textColor:new Ie(this._style.textColor)})}raycast(e,t){this.text.raycast(e,t)}updateClippingPlanes(e){var t;this.normalIndicator.material.clippingPlanes=e,this.point.material.clippingPlanes=e,this.point.children[0].material.clippingPlanes=e,this.line.material.clippingPlanes=e,this.text.backgroundMesh&&(this.text.backgroundMesh.material.clippingPlanes=e),this.text.textMesh&&(((t=this.text.textMesh)===null||t===void 0?void 0:t.material).clippingPlanes=e)}}const Gs=new A,jm=new A,_w=new A,$w=new A,JN=new A,rc=new A;class Ab extends _u{set isVisible(e){var t,n;(t=this.startGizmo)===null||t===void 0||t.enable(e,e,e,e),(n=this.endGizmo)===null||n===void 0||n.enable(e,e,e,e)}get bounds(){return new He().expandByPoint(this.startPoint).expandByPoint(this.midPoint)}get measurementType(){return Mi.PERPENDICULAR}constructor(){super(),this.startGizmo=null,this.endGizmo=null,this.flipStartNormal=!1,this.midPoint=new A,this.type="PerpendicularMeasurement",this.startPoint.set(NaN,NaN,NaN),this.startGizmo=new co,this.endGizmo=new co({dashedLine:!0,lineOpacity:.25}),this.startLineLength=.25,this.add(this.startGizmo),this.add(this.endGizmo),this.layers.set(re.MEASUREMENTS)}frameUpdate(e,t,n){var i,r;super.frameUpdate(e,t,n),(i=this.startGizmo)===null||i===void 0||i.frameUpdate(e,t),(r=this.endGizmo)===null||r===void 0||r.frameUpdate(e,t),this._state===Nt.DANGLING_START&&this.update()}locationUpdated(e,t){if(this.state===Nt.DANGLING_START)this.startPoint.copy(e),this.startNormal.copy(t);else if(this.state===Nt.DANGLING_END){const n=new A().subVectors(e,this.startPoint).normalize().dot(this.startNormal);this.flipStartNormal=n<0,this.endPoint.copy(e),this.endNormal.copy(t)}}locationSelected(){this.state===Nt.DANGLING_START?this.state=Nt.DANGLING_END:this.state===Nt.DANGLING_END&&(this.state=Nt.COMPLETE)}update(){var e,t,n,i,r,s,o,l,c,u,h,d,f;let p;if(isNaN(this.startPoint.length())||!this.renderingCamera)return Promise.resolve();(e=this.startGizmo)===null||e===void 0||e.updateNormalIndicator(this.startPoint,this.startNormal),(t=this.startGizmo)===null||t===void 0||t.updatePoint(this.startPoint),(n=this.endGizmo)===null||n===void 0||n.updateNormalIndicator(this.endPoint,this.endNormal),rc.copy(this.startNormal),this.flipStartNormal&&rc.negate();const m=this.startPoint.distanceTo(this.endPoint),g=Gs.copy(this.startPoint).sub(this.endPoint).normalize();let v=rc.dot(g);const y=Math.acos(Math.min(Math.max(v,-1),1));this.startLineLength=Math.abs(m*Math.cos(y)),this.midPoint.copy(Gs.copy(this.startPoint).add(jm.copy(rc).multiplyScalar(this.startLineLength)));const w=Gs.copy(this.startPoint).add(this.midPoint).multiplyScalar(.5);if(this._state===Nt.DANGLING_START&&((i=this.endGizmo)===null||i===void 0||i.enable(!1,!1,!1,!1)),this._state===Nt.DANGLING_END){const x=jm.copy(this.midPoint).sub(this.endPoint).normalize();this.endLineLength=this.midPoint.distanceTo(this.endPoint),v=this.endNormal.dot(x);const S=Math.acos(Math.min(Math.max(v,-1),1)),b=this.endLineLength*Math.cos(S),E=jm.copy(this.endPoint).add(_w.copy(this.endNormal).multiplyScalar(b)),M=_w.copy(this.startPoint),T=$w.copy(this.startPoint).add(JN.copy(rc).multiplyScalar(this.startLineLength));(r=this.startGizmo)===null||r===void 0||r.updateLine([M,T]);const I=$w.copy(this.endPoint);(s=this.endGizmo)===null||s===void 0||s.updateLine([I,E,E,this.midPoint,this.midPoint,I]),(o=this.endGizmo)===null||o===void 0||o.updatePoint(this.midPoint),this.value=this.midPoint.distanceTo(this.startPoint),this.startGizmo&&(p=this.startGizmo.updateText(`${(this.value*xn("m",this.units)).toFixed(this.precision)} ${this.units}`,w)),(l=this.endGizmo)===null||l===void 0||l.enable(!0,!0,!0,!0)}return this._state===Nt.COMPLETE&&((c=this.startGizmo)===null||c===void 0||c.updateLine([this.startPoint,this.midPoint]),(u=this.endGizmo)===null||u===void 0||u.updatePoint(this.midPoint),p=(h=this.startGizmo)===null||h===void 0?void 0:h.updateText(`${(this.value*xn("m",this.units)).toFixed(this.precision)} ${this.units}`,w),(d=this.startGizmo)===null||d===void 0||d.enable(!1,!0,!0,!0),(f=this.endGizmo)===null||f===void 0||f.enable(!1,!1,!0,!1)),p??Promise.resolve()}raycast(e,t){var n,i;const r=[];(n=this.startGizmo)===null||n===void 0||n.raycast(e,r),(i=this.endGizmo)===null||i===void 0||i.raycast(e,r),r.length&&t.push({distance:r[0].distance,face:r[0].face,faceIndex:r[0].faceIndex,object:this,point:r[0].point,uv:r[0].uv})}highlight(e){this.startGizmo&&(this.startGizmo.highlight=e),this.endGizmo&&(this.endGizmo.highlight=e)}updateClippingPlanes(e){this.startGizmo&&this.startGizmo.updateClippingPlanes(e),this.endGizmo&&this.endGizmo.updateClippingPlanes(e)}toMeasurementData(){const e=super.toMeasurementData();return e.innerPoints=[[this.midPoint.x,this.midPoint.y,this.midPoint.z]],this.flipStartNormal&&(Gs.copy(this.startNormal),Gs.negate(),e.startNormal=[Gs.x,Gs.y,Gs.z]),e}fromMeasurementData(e){super.fromMeasurementData(e),e.innerPoints&&this.midPoint.set(e.innerPoints[0][0],e.innerPoints[0][1],e.innerPoints[0][2])}}const ZN=new A;class Sb extends _u{set isVisible(e){var t,n;(t=this.startGizmo)===null||t===void 0||t.enable(e,e,e,e),(n=this.endGizmo)===null||n===void 0||n.enable(e,e,e,e)}get measurementType(){return Mi.POINTTOPOINT}constructor(){super(),this.startGizmo=null,this.endGizmo=null,this.type="PointToPointMeasurement",this.startGizmo=new co,this.endGizmo=new co({dashedLine:!0,lineOpacity:.25}),this.startLineLength=0,this.add(this.startGizmo),this.add(this.endGizmo),this.layers.set(re.MEASUREMENTS)}frameUpdate(e,t,n){var i,r;super.frameUpdate(e,t,n),(i=this.startGizmo)===null||i===void 0||i.frameUpdate(e,t),(r=this.endGizmo)===null||r===void 0||r.frameUpdate(e,t)}locationUpdated(e,t){this.state===Nt.DANGLING_START?(this.startPoint.copy(e),this.startNormal.copy(t)):this.state===Nt.DANGLING_END&&(this.endPoint.copy(e),this.endNormal.copy(t))}locationSelected(){this.state===Nt.DANGLING_START?this.state=Nt.DANGLING_END:this.state===Nt.DANGLING_END&&(this.state=Nt.COMPLETE)}update(){var e,t,n,i,r,s,o,l,c,u,h,d,f,p,m;let g;(e=this.startGizmo)===null||e===void 0||e.updateNormalIndicator(this.startPoint,this.startNormal),(t=this.startGizmo)===null||t===void 0||t.updatePoint(this.startPoint),(n=this.endGizmo)===null||n===void 0||n.updateNormalIndicator(this.endPoint,this.endNormal),this.startLineLength=this.startPoint.distanceTo(this.endPoint),this.value=this.startLineLength;const v=ZN.copy(this.startPoint).add(this.endPoint).multiplyScalar(.5);return this._state===Nt.DANGLING_START&&((i=this.startGizmo)===null||i===void 0||i.enable(!0,!1,!0,!1),(r=this.endGizmo)===null||r===void 0||r.enable(!1,!1,!1,!1)),this._state===Nt.DANGLING_END&&((s=this.startGizmo)===null||s===void 0||s.enable(!0,!0,!0,!0),(o=this.endGizmo)===null||o===void 0||o.enable(!0,!1,!0,!1),(l=this.startGizmo)===null||l===void 0||l.updateLine([this.startPoint,this.endPoint]),(c=this.endGizmo)===null||c===void 0||c.updatePoint(this.endPoint),g=(u=this.startGizmo)===null||u===void 0?void 0:u.updateText(`${(this.value*xn("m",this.units)).toFixed(this.precision)} ${this.units}`,v)),this._state===Nt.COMPLETE&&((h=this.startGizmo)===null||h===void 0||h.enable(!1,!0,!0,!0),(d=this.endGizmo)===null||d===void 0||d.enable(!1,!1,!0,!1),(f=this.startGizmo)===null||f===void 0||f.updateLine([this.startPoint,this.endPoint]),(p=this.endGizmo)===null||p===void 0||p.updatePoint(this.endPoint),g=(m=this.startGizmo)===null||m===void 0?void 0:m.updateText(`${(this.value*xn("m",this.units)).toFixed(this.precision)} ${this.units}`,v)),g??Promise.resolve()}raycast(e,t){var n,i;const r=[];(n=this.startGizmo)===null||n===void 0||n.raycast(e,r),(i=this.endGizmo)===null||i===void 0||i.raycast(e,r),r.length&&t.push({distance:r[0].distance,face:r[0].face,faceIndex:r[0].faceIndex,object:this,point:r[0].point,uv:r[0].uv})}highlight(e){this.startGizmo&&(this.startGizmo.highlight=e),this.endGizmo&&(this.endGizmo.highlight=e)}updateClippingPlanes(e){this.startGizmo&&this.startGizmo.updateClippingPlanes(e),this.endGizmo&&this.endGizmo.updateClippingPlanes(e)}}const KN=new A,YN=new A,qN=new A;class Pg extends _u{set isVisible(e){this.pointGizmos.forEach((t=>{t.enable(e,e,e,e)}))}get bounds(){const e=new He;return this.polygonPoints.forEach((t=>e.expandByPoint(t))),e}get measurementType(){return Mi.AREA}constructor(){super(),this.pointGizmos=[],this.surfacePoint=new A,this.surfaceNormal=new A,this.planeOrigin=new A,this.planeNormal=new A,this.labelPoint=new A,this.pointIndex=0,this.points=[],this.measuredPoints=[],this.polygonPoints=[],this.snapDistance=10,this.type="AreaMeasurement";const e=new co;e.text.backgroundMaterial.stencilWrite=!0,e.text.backgroundMaterial.depthWrite=!1,e.text.backgroundMaterial.depthTest=!1,e.text.backgroundMaterial.stencilFunc=Bu,e.text.backgroundMaterial.stencilRef=1,e.text.backgroundMaterial.stencilZPass=$s,e.enable(!1,!0,!0,!1),this.pointGizmos.push(e),this.add(this.pointGizmos[0]),this.layers.set(re.MEASUREMENTS),this.polygonPoints.push(new A)}frameUpdate(e,t,n){super.frameUpdate(e,t,n),this.pointGizmos.forEach((i=>{i.frameUpdate(e,t)}))}locationUpdated(e,t){this.surfacePoint.copy(e),this.surfaceNormal.copy(t),this.projectOnPlane(this.surfacePoint,this.planeOrigin,this.planeNormal,this.polygonPoints[0]),this.updateFillPolygon(this.polygonPoints)}locationSelected(){this.pointIndex===0&&(this.planeOrigin.copy(this.surfacePoint),this.planeNormal.copy(this.surfaceNormal),this.startPoint.copy(this.surfacePoint),this.startNormal.copy(this.startNormal)),this.addPoint(this.surfacePoint)}addPoint(e){const t=new A().copy(e);this.pointIndex>0&&(t.copy(this.projectOnPlane(e,this.planeOrigin,this.planeNormal)),e.distanceTo(this.points[0])<1e-10&&(this._state=Nt.COMPLETE,t.copy(this.measuredPoints[0]),e.copy(this.points[0])));const n=new co;return n.enable(!1,!0,!0,!1),this.pointGizmos.push(n),this.add(n),this.points.push(e.clone()),this.measuredPoints.push(t),this.polygonPoints.push(t),this.pointIndex++,this.update(),this.points.length>=2&&(this.projectOnPlane(e,this.planeOrigin,this.planeNormal,this.polygonPoints[0]),this.updateFillPolygon(this.polygonPoints),this.updateLabelLocation(this.measuredPoints)),this.points.length}removePoint(){return this.pointIndex<1?0:(this.remove(this.pointGizmos.pop()),this.points.pop(),this.measuredPoints.pop(),this.polygonPoints.pop(),this.pointIndex--,this.update(),this.updateFillPolygon(this.polygonPoints),this.updateLabelLocation(this.measuredPoints),this.points.length)}autoFinish(){this.surfacePoint.copy(this.planeOrigin),this.surfaceNormal.copy(this.planeNormal),this.locationSelected()}snap(e,t,n,i){if(this.pointIndex<2)return!1;const r=new A().copy(this.points[0]).project(this.renderingCamera);r.set((.5*r.x+.5)*this.renderingSize.x,(-.5*r.y+.5)*this.renderingSize.y,0);const s=new A((.5*e.x+.5)*this.renderingSize.x,(-.5*e.y+.5)*this.renderingSize.y,0);return r.distanceTo(s)<this.snapDistance*window.devicePixelRatio&&(n.copy(this.points[0]),i.copy(this.planeNormal),!0)}update(){let e=Promise.resolve();if(this.pointGizmos[this.pointIndex].updateNormalIndicator(this.surfacePoint,this.surfaceNormal),this.pointGizmos[this.pointIndex].updatePoint(this.surfacePoint),this.pointIndex===0)return this.pointGizmos[this.pointIndex].enable(!0,!0,!0,!1),e;const t=this.surfacePoint,n=this.points[this.pointIndex-1];if(this.pointGizmos[this.pointIndex].updateLine([n,t]),this.pointGizmos[this.pointIndex].enable(!0,!0,!0,!1),this.pointGizmos[this.pointIndex-1].enable(!1,!0,!0,!1),this.measuredPoints.length>1&&(this.value=this.shoelaceArea3D(this.polygonPoints,this.planeNormal),e=this.pointGizmos[0].updateText(`${(this.value*xn("m",this.units)).toFixed(this.precision)} ${this.units}`,this.labelPoint),this.pointGizmos[0].enable(!1,!0,!0,!0)),this._state===Nt.COMPLETE){for(let i=0;i<this.points.length-1;i++)this.pointGizmos[i].updatePoint(this.points[i]),this.pointGizmos[i].updateLine([this.points[i],this.points[i+1]]),this.pointGizmos[i].enable(!1,!0,!0,!1);this.pointGizmos[this.points.length-1].updateLine([this.points[this.points.length-1],this.points[0]]),this.pointGizmos[this.points.length].enable(!1,!1,!1,!1),this.pointGizmos[this.points.length-1].enable(!1,!1,!1,!1),this.pointGizmos[0].enable(!1,!0,!0,!0),this.pointGizmos[0].text._needsSync=!0,e=this.pointGizmos[0].updateText(`${(this.value*xn("m",this.units)).toFixed(this.precision)} ${this.units}`,this.labelPoint)}return e}updateLabelLocation(e){const t=new dt().setFromUnitVectors(this.planeNormal,new A(0,0,1)),n=new dt().copy(t).invert(),i=new A,r=e.map((o=>(i.copy(o),i.applyQuaternion(t),[i.x,i.y]))),s=vN([r],.1);this.labelPoint.set(s[0],s[1],this.planeOrigin.z),this.labelPoint.applyQuaternion(n),this.projectOnPlane(this.labelPoint,this.planeOrigin,this.planeNormal,this.labelPoint)}updateFillPolygon(e){if(!this.fillPolygon){const c=new Ar({color:294651,side:yt,opacity:.5,transparent:!0,toneMapped:!1});c.color.convertSRGBToLinear(),c.depthWrite=!1,c.depthTest=!1,c.stencilWrite=!0,c.stencilFunc=jA,c.stencilRef=1,c.stencilZPass=yc,this.fillPolygon=new Ve(new nt,c),this.fillPolygon.renderOrder=100,this.fillPolygon.frustumCulled=!1,this.fillPolygon.layers.set(re.MEASUREMENTS),this.add(this.fillPolygon)}const t=this.fillPolygon.geometry,n=t.getAttribute("position"),i=t.getIndex();if(e.length<3)return void(this.fillPolygon.visible=!1);this.fillPolygon.visible=!0;const[r,s]=this.chooseProjectionAxes(this.planeNormal),o=e.map((c=>new te(c[r],c[s]))),l=ft.triangulatePolygon(o);if(n&&n.count===e.length)e.forEach(((c,u)=>c.toArray(n.array,3*u))),n.needsUpdate=!0;else{const c=new Float32Array(3*e.length);e.forEach(((h,d)=>h.toArray(c,3*d)));const u=new wt(c,3);u.setUsage(Xn),t.setAttribute("position",u)}i&&i.count===l.length?(i.array.set(l,0),i.needsUpdate=!0):t.setIndex(new _i(l,1)),t.computeBoundingBox()}raycast(e,t){const n=[];this.pointGizmos.forEach((i=>{i.raycast(e,n)})),n.length&&t.push({distance:n[0].distance,face:n[0].face,faceIndex:n[0].faceIndex,object:this,point:n[0].point,uv:n[0].uv})}highlight(e){this.pointGizmos.forEach((t=>{t.highlight=e}))}updateClippingPlanes(e){this.pointGizmos.forEach((t=>{t.updateClippingPlanes(e)})),this.fillPolygon.material.clippingPlanes=e}projectOnPlane(e,t,n,i){const r=KN.copy(e),s=YN.copy(t),o=qN.copy(n).normalize(),l=r.sub(s).dot(o);return(i||new A).copy(e).sub(o.multiplyScalar(l))}chooseProjectionAxes(e){const t=e.clone().set(Math.abs(e.x),Math.abs(e.y),Math.abs(e.z));return t.z>=t.x&&t.z>=t.y?["x","y","z"]:t.y>=t.x&&t.y>=t.z?["x","z","y"]:["y","z","x"]}shoelaceArea(e){const t=e.length;if(t<3)return 0;let n=0;for(let i=0;i<t;i++){const r=(i+1)%t;n+=e[i].x*e[r].y-e[r].x*e[i].y}return Math.abs(n)/2}shoelaceArea3D(e,t){const[n,i]=this.chooseProjectionAxes(t),r=e.map((s=>new te(s[n],s[i])));return this.shoelaceArea(r)}toMeasurementData(){const e=super.toMeasurementData();return e.startPoint=[this.planeOrigin.x,this.planeOrigin.y,this.planeOrigin.z],e.startNormal=[this.planeNormal.x,this.planeNormal.y,this.planeNormal.z],e.innerPoints=this.points.map((t=>[t.x,t.y,t.z])),e}fromMeasurementData(e){var t;if(super.fromMeasurementData(e),this.planeOrigin.fromArray(e.startPoint),this.planeNormal.fromArray(e.startNormal),e.innerPoints)for(let n=0;n<((t=e.innerPoints)===null||t===void 0?void 0:t.length);n++)this.addPoint(new A().fromArray(e.innerPoints[n]))}}const _N=new lt,$N=new lt,ek=new lt,tk=new lt,nk=new ae,ik=new ae;class Dg extends _u{set isVisible(e){this.gizmo.visible=e,this.xLabel.visible=e,this.yLabel.visible=e,this.zLabel.visible=e}get measurementType(){return Mi.POINT}constructor(){super(),this.xLabelPosition=new A,this.yLabelPosition=new A,this.zLabelPosition=new A,this.pixelsOffX=50*window.devicePixelRatio,this.pixelsOffY=25*window.devicePixelRatio,this.type="PointMeasurement",this.gizmo=new co,this.add(this.gizmo),this.xLabel=new Rc({text:"sample",textColor:new Ie(16777215),fontSize:11,billboard:"screen",anchorX:"left",anchorY:"middle",backgroundColor:new Ie(16450564),backgroundMargins:new te(30,10),backgroundCornerRadius:.3,objectLayer:re.MEASUREMENTS}),this.xLabel.name="XLabel",this.xLabel.material.depthTest=!1,this.add(this.xLabel),this.yLabel=new Rc({text:"sample",textColor:new Ie(16777215),fontSize:11,anchorX:"left",anchorY:"middle",billboard:"screen",backgroundColor:new Ie(248067),backgroundMargins:new te(30,10),backgroundCornerRadius:.3,objectLayer:re.MEASUREMENTS}),this.yLabel.name="YLabel",this.yLabel.material.depthTest=!1,this.add(this.yLabel),this.zLabel=new Rc({text:"sample",textColor:new Ie(16777215),fontSize:11,billboard:"screen",anchorX:"left",anchorY:"middle",backgroundColor:new Ie(294651),backgroundMargins:new te(30,10),backgroundCornerRadius:.3,objectLayer:re.MEASUREMENTS}),this.zLabel.name="ZLabel",this.zLabel.material.depthTest=!1,this.add(this.zLabel),this.layers.set(re.MEASUREMENTS)}frameUpdate(e,t,n){super.frameUpdate(e,t,n),this.updateLabelPositions(),this.xLabel.position.copy(this.xLabelPosition),this.yLabel.position.copy(this.yLabelPosition),this.zLabel.position.copy(this.zLabelPosition),this.gizmo.frameUpdate(e,t)}locationUpdated(e,t){this.startPoint.copy(e),this.startNormal.copy(t)}locationSelected(){this.state===Nt.DANGLING_START&&(this.state=Nt.COMPLETE)}updateLabelPositions(){const e=this.renderingCamera;if(!e)return;const t=_N.set(this.startPoint.x,this.startPoint.y,this.startPoint.z,1);t.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);const n=t.w;t.multiplyScalar(1/n);const i=this.pixelsOffX/this.renderingSize.x*2,r=this.pixelsOffY/this.renderingSize.y*2,s=$N.set(t.x+i,t.y+r,t.z,1),o=ek.set(t.x+i,t.y,t.z,1),l=tk.set(t.x+i,t.y-r,t.z,1),c=nk.copy(e.projectionMatrix).invert(),u=ik.copy(e.matrixWorldInverse).invert();s.multiplyScalar(n),s.applyMatrix4(c),s.applyMatrix4(u),o.multiplyScalar(n),o.applyMatrix4(c),o.applyMatrix4(u),l.multiplyScalar(n),l.applyMatrix4(c),l.applyMatrix4(u),this.xLabelPosition.set(s.x,s.y,s.z),this.yLabelPosition.set(o.x,o.y,o.z),this.zLabelPosition.set(l.x,l.y,l.z)}async update(){this.xLabel.position.copy(this.xLabelPosition),this.yLabel.position.copy(this.yLabelPosition),this.zLabel.position.copy(this.zLabelPosition);const e=this.xLabel.updateParams({text:`X : ${(this.startPoint.x*xn("m",this.units)).toFixed(this.precision)} ${this.units}`}),t=this.yLabel.updateParams({text:`Y : ${(this.startPoint.y*xn("m",this.units)).toFixed(this.precision)} ${this.units}`}),n=this.zLabel.updateParams({text:`Z : ${(this.startPoint.z*xn("m",this.units)).toFixed(this.precision)} ${this.units}`});this.gizmo.updateNormalIndicator(this.startPoint,this.startNormal),this.gizmo.updatePoint(this.startPoint),this.gizmo.enable(!0,!1,!0,!1),this.value=this.startPoint.length(),await Promise.all([e,t,n])}raycast(e,t){const n=[];this.gizmo.raycast(e,n),this.xLabel.raycast(e,n),this.yLabel.raycast(e,n),this.zLabel.raycast(e,n),n.length&&t.push({distance:n[0].distance,face:n[0].face,faceIndex:n[0].faceIndex,object:this,point:n[0].point,uv:n[0].uv})}highlight(e){this.gizmo&&(this.gizmo.highlight=e),e?(this.xLabel.textMesh.material.color.copy(new Ie(16711680)),this.yLabel.textMesh.material.color.copy(new Ie(16711680)),this.zLabel.textMesh.material.color.copy(new Ie(16711680))):(this.xLabel.textMesh.material.color.copy(new Ie(16777215)),this.yLabel.textMesh.material.color.copy(new Ie(16777215)),this.zLabel.textMesh.material.color.copy(new Ie(16777215)))}updateClippingPlanes(e){var t,n,i;this.gizmo.updateClippingPlanes(e),this.xLabel.backgroundMesh&&(this.xLabel.backgroundMesh.material.clippingPlanes=e),this.xLabel.textMesh&&(((t=this.xLabel.textMesh)===null||t===void 0?void 0:t.material).clippingPlanes=e),this.yLabel.backgroundMesh&&(this.yLabel.backgroundMesh.material.clippingPlanes=e),this.yLabel.textMesh&&(((n=this.yLabel.textMesh)===null||n===void 0?void 0:n.material).clippingPlanes=e),this.zLabel.backgroundMesh&&(this.zLabel.backgroundMesh.material.clippingPlanes=e),this.zLabel.textMesh&&(((i=this.zLabel.textMesh)===null||i===void 0?void 0:i.material).clippingPlanes=e)}}var Cu;(function(a){a.CountChanged="measurement-count-changed",a.MeasurementsChanged="measurements-changed"})(Cu||(Cu={}));const sc={visible:!0,type:Mi.POINT,vertexSnap:!0,units:"m",precision:2,chain:!1};class Mb extends Zr{get inject(){return[lo]}get enabled(){return this._enabled}set enabled(e){this._enabled=e,this._activeMeasurement&&(this._activeMeasurement.isVisible=e,this._activeMeasurement.update(),e||this.cancelMeasurement()),this.viewer.requestRender()}get options(){return this._options}set options(e){const t=this._options.type!==e.type&&this._activeMeasurement&&this._activeMeasurement.state===Nt.DANGLING_START;Object.assign(this._options,e),t&&this.cancelMeasurement(),this.applyOptions()}get selectedMeasurement(){return this._selectedMeasurement}get activeMeasurement(){return this._activeMeasurement}get measurementCount(){return this._measurements.length}get mesurements(){return this._measurements}emitMeasurementCountChanged(){this.emit(Cu.CountChanged,this._measurements.length),this.emit(Cu.MeasurementsChanged,this._measurements)}constructor(e,t){super(e),this.cameraProvider=t,this._measurements=[],this._activeMeasurement=null,this._selectedMeasurement=null,this._options=Object.assign({},sc),this._frameLock=!1,this._paused=!1,this._sceneHit=!1,this.pointBuff=new A,this.normalBuff=new A,this.screenBuff0=new te,this.screenBuff1=new te,this.renderer=e.getRenderer(),this.raycaster=new Wu,this.raycaster.layers.enable(re.MEASUREMENTS),this.renderer.input.on(kn.PointerMove,this.onPointerMove.bind(this)),this.renderer.input.on(kn.Click,this.onPointerClick.bind(this)),this.renderer.input.on(kn.DoubleClick,this.onPointerDoubleClick.bind(this))}on(e,t){super.on(e,t)}onLateUpdate(){const e=this.renderer.renderingCamera;e&&(this._frameLock=!1,this.renderer.renderer.getDrawingBufferSize(this.screenBuff0),this._activeMeasurement&&this._enabled&&this._activeMeasurement.frameUpdate(e,this.screenBuff0,this.renderer.sceneBox),this._measurements.forEach((t=>{(this._enabled||t instanceof Dg)&&t.frameUpdate(e,this.screenBuff0,this.renderer.sceneBox)})),this._enabled&&this.updateClippingPlanes(this.renderer.clippingPlanes))}onResize(){this.renderer.renderer.getDrawingBufferSize(this.screenBuff0)}onPointerMove(e){var t;if(!this._enabled||this._paused)return;const n=this.renderer.renderingCamera;if(!n||this._frameLock)return;let i=this.renderer.intersections.intersect(this.renderer.scene,n,e,re.STREAM_CONTENT_MESH,!0,this.renderer.clippingVolume)||[];if(i=i.filter((s=>{const o=s.object.getBatchObjectMaterial(s.batchObject);return o&&!(o instanceof Ya)&&o.visible})),!i.length)return void(this._sceneHit=!1);this.pointBuff.copy(i[0].point),this.normalBuff.copy(i[0].face.normal);let r=this._options.vertexSnap;this._activeMeasurement&&this._activeMeasurement.snap&&(r=!this._activeMeasurement.snap(e,i[0],this.pointBuff,this.normalBuff)),r&&this.snap(i[0],this.pointBuff,this.normalBuff),this._activeMeasurement||(this._activeMeasurement=this.startMeasurement(),this._activeMeasurement.isVisible=!0),(t=this.activeMeasurement)===null||t===void 0||t.locationUpdated(this.pointBuff,this.normalBuff),this._activeMeasurement.update().then((()=>{this.viewer.requestRender()})),this._frameLock=!0,this._sceneHit=!0}onPointerClick(e){if(!this._enabled)return;const t=this.pickMeasurement(e);t?this.selectMeasurement(t,!0):e.event.button!==2?(e.event.pointerType==="touch"&&this.onPointerMove(e),this._activeMeasurement&&this._sceneHit&&(this._activeMeasurement.locationSelected(),this._activeMeasurement.state===Nt.COMPLETE&&this.finishMeasurement())):this._activeMeasurement&&this._activeMeasurement instanceof Pg?this._activeMeasurement.removePoint()===0&&this.cancelMeasurement():this.cancelMeasurement()}onPointerDoubleClick(e){const t=this.pickMeasurement(e);t?this.cameraProvider.setCameraView(t.bounds,!0):this._options.type!==Mi.PERPENDICULAR?this._options.type===Mi.AREA&&(this._activeMeasurement.autoFinish(),this.finishMeasurement()):this.autoLazerMeasure(e)}autoLazerMeasure(e){if(!this._activeMeasurement||!this.renderer.renderingCamera)return;this._activeMeasurement.state=Nt.DANGLING_START;let t=this.renderer.intersections.intersect(this.renderer.scene,this.renderer.renderingCamera,e,re.STREAM_CONTENT_MESH,!0,this.renderer.clippingVolume)||[];if(t=t.filter((o=>{const l=o.object.getBatchObjectMaterial(o.batchObject);return l&&!(l instanceof Ya)&&l.visible})),!t.length)return;const n=new A().copy(t[0].point),i=new A().copy(t[0].face.normal),r=new A().copy(n).add(new A().copy(i).multiplyScalar(1e-6));let s=this.renderer.intersections.intersectRay(this.renderer.scene,this.renderer.renderingCamera,new On(r,i),re.STREAM_CONTENT_MESH,!0,this.renderer.clippingVolume)||[];s=s.filter((o=>{const l=o.object.getBatchObjectMaterial(o.batchObject);return l&&!(l instanceof Ya)&&l.visible})),s.length?(this._activeMeasurement.startPoint.copy(n),this._activeMeasurement.startNormal.copy(i),this._activeMeasurement.endPoint.copy(s[0].point),this._activeMeasurement.endNormal.copy(s[0].face.normal),this._activeMeasurement.state=Nt.DANGLING_END,this._activeMeasurement.update().then((()=>{this.finishMeasurement()}))):this.flashMeasurement()}startMeasurement(){let e;if(this._options.type===Mi.PERPENDICULAR)e=new Ab;else if(this._options.type===Mi.POINTTOPOINT)e=new Sb;else if(this._options.type===Mi.AREA)e=new Pg;else{if(this._options.type!==Mi.POINT)throw new Error("Unsupported measurement type!");e=new Dg}return e.state=Nt.DANGLING_START,e.units=this._options.units!==void 0?this._options.units:sc.units,e.precision=this._options.precision!==void 0?this._options.precision:sc.precision,e.frameUpdate(this.renderer.renderingCamera,this.screenBuff0,this.renderer.sceneBox),this.renderer.scene.add(e),e}cancelMeasurement(){this._activeMeasurement&&this.renderer.scene.remove(this._activeMeasurement),this._activeMeasurement=null,this.viewer.requestRender()}finishMeasurement(){if(this._activeMeasurement){if(this._activeMeasurement.update(),this.pushMeasurement(this._activeMeasurement),this._options.chain){const e=new A,t=new A;let n;this._options.type===Mi.PERPENDICULAR?(n=this._activeMeasurement,e.copy(n.midPoint),t.copy(n.startNormal)):(n=this._activeMeasurement,e.copy(this.pointBuff),t.copy(this.normalBuff)),this._activeMeasurement=this.startMeasurement(),this._activeMeasurement.locationUpdated(e,t),this._activeMeasurement.locationSelected()}else this._activeMeasurement=null;this.viewer.requestRender()}}pushMeasurement(e){e.value>0?(this._measurements.push(e),this.emitMeasurementCountChanged()):(this.renderer.scene.remove(e),De.error("Ignoring zero value measurement!"))}findMeasurementFromData(e){return this._measurements.find((t=>t.measurementId===e.uuid))}removeMeasurement(e){const t=e?this.findMeasurementFromData(e):this._selectedMeasurement;t?(this._measurements.splice(this._measurements.indexOf(t),1),this.renderer.scene.remove(t),this._selectedMeasurement=null,this.emitMeasurementCountChanged(),this.viewer.requestRender()):this.cancelMeasurement()}setMeasurements(e){if(!e.length)return this._measurements.length&&this.clearMeasurements(),void(this._activeMeasurement&&this.cancelMeasurement());const t=this._measurements.map((i=>i.toMeasurementData())),n=tL(t,e,(i=>i.uuid));for(const i of n)this.removeMeasurement(i);for(const i of e)this.findMeasurementFromData(i)||this.addMeasurement(i)}clearMeasurements(){this.removeMeasurement(),this._measurements.forEach((e=>{this.renderer.scene.remove(e)})),this._measurements=[],this.emitMeasurementCountChanged(),this.viewer.requestRender()}flashMeasurement(){let e=0;const t=setInterval((()=>{this._activeMeasurement&&(this._activeMeasurement.highlight(!!(e++%2)),e>=5&&clearInterval(t),this.viewer.requestRender())}),100)}pickMeasurement(e){var t;return this.renderer.renderingCamera?(this._measurements.forEach((n=>{n.highlight(!1)})),this.raycaster.setFromCamera(e,this.renderer.renderingCamera),(t=this.raycaster.intersectObjects(this._measurements,!1)[0])===null||t===void 0?void 0:t.object):null}selectMeasurement(e,t){this.cancelMeasurement(),e.highlight(t),this._selectedMeasurement=e}snap(e,t,n){if(!this.renderer.renderingCamera)return;const i=e.batchObject.accelerationStructure.getVertexAtIndex(e.face.a).project(this.renderer.renderingCamera),r=e.batchObject.accelerationStructure.getVertexAtIndex(e.face.b).project(this.renderer.renderingCamera),s=e.batchObject.accelerationStructure.getVertexAtIndex(e.face.c).project(this.renderer.renderingCamera),o=e.point.project(this.renderer.renderingCamera),l=[i,r,s];l.sort(((d,f)=>o.distanceTo(d)-o.distanceTo(f)));const c=this.renderer.NDCToScreen(l[0].x,l[0].y),u=this.renderer.NDCToScreen(o.x,o.y);this.screenBuff0.set(c.x,c.y),this.screenBuff1.set(u.x,u.y);const h=l[0].unproject(this.renderer.renderingCamera);this.screenBuff0.distanceTo(this.screenBuff1)<10*window.devicePixelRatio&&(t.copy(h),n.copy(e.face.normal))}updateClippingPlanes(e){this._measurements.forEach((t=>{t.updateClippingPlanes(e)}))}applyOptions(){const e=[this._activeMeasurement,...this._measurements],t=[];e.forEach((n=>{n&&(n.units=this._options.units!==void 0?this._options.units:sc.units,n.precision=this._options.precision!==void 0?this._options.precision:sc.precision,t.push(n.update()))})),this.viewer.getRenderer().enableLayers([re.MEASUREMENTS],this._options.visible),this._options.visible?this.raycaster.layers.enable(re.MEASUREMENTS):this.raycaster.layers.disable(re.MEASUREMENTS),Promise.all(t).then((()=>{this.viewer.requestRender()}))}addMeasurement(e){const t=this._options;this._options.type=e.type,this._options.chain=!1,this._options.vertexSnap=!1;const n=this.startMeasurement();n.fromMeasurementData(e),n.isVisible=!0,n.update().then((()=>{this.viewer.requestRender()})),this.pushMeasurement(n),this._options.type=t.type,this._options.chain=t.chain,this._options.vertexSnap=t.vertexSnap}toMeasurementData(){return this._measurements.map((e=>e.toMeasurementData()))}}const rk={selectionMaterialData:{id:It.generateUUID(),color:294651,emissive:0,opacity:1,roughness:1,metalness:0,vertexColors:!1,lineWeight:1,stencilOutlines:zr.OVERLAY,pointSize:4}};class h0 extends Zr{get inject(){return[lo]}get enabled(){return this._enabled}set enabled(e){this._enabled=e}get options(){return this._options}set options(e){this._options=e,this.selectionMaterialData=Object.assign({},this.options.selectionMaterialData),this.transparentSelectionMaterialData=Object.assign({},this.options.selectionMaterialData),this.transparentSelectionMaterialData.opacity=.5,this.hiddenSelectionMaterialData=Object.assign({},this.options.selectionMaterialData),this.hiddenSelectionMaterialData.stencilOutlines=zr.OUTLINE_ONLY,this.hoverMaterialData=Object.assign({},this.options.hoverMaterialData),this.transparentHoverMaterialData=Object.assign({},this.options.hoverMaterialData),this.transparentHoverMaterialData.opacity=.5}constructor(e,t){super(e),this.cameraProvider=t,this.selectedNodes=[],this.selectionRvs={},this.selectionMaterials={},this._enabled=!0,this.viewer.on(Cn.ObjectClicked,this.onObjectClicked.bind(this)),this.viewer.on(Cn.ObjectDoubleClicked,this.onObjectDoubleClick.bind(this)),this.viewer.getRenderer().input.on(kn.PointerMove,this.onPointerMove.bind(this)),this.options=rk}getSelectedObjects(){return this.selectedNodes.map((e=>e.model.raw))}getSelectedNodes(){return this.selectedNodes}selectObjects(e,t=!1){if(this._enabled){t||(this.selectedNodes=[]);for(let n=0;n<e.length;n++){const i=this.viewer.getWorldTree().findId(e[n]);i&&this.selectedNodes.push(...i)}this.applySelection()}}unselectObjects(e){if(!this._enabled)return;const t=[];for(let n=0;n<e.length;n++){const i=this.viewer.getWorldTree().findId(e[n]);i&&t.push(...i)}this.clearSelection(t)}clearSelection(e){if(!e)return this.removeSelection(),void(this.selectedNodes=[]);const t=[];e.forEach((n=>{t.push(...this.viewer.getWorldTree().getRenderTree().getRenderViewsForNode(n))})),this.removeSelection(t),this.selectedNodes=this.selectedNodes.filter((n=>!e.includes(n)))}onObjectClicked(e){this._enabled&&(e?(e.multiple?this.selectedNodes.includes(e.hits[0].node)||this.selectedNodes.push(e.hits[0].node):this.selectedNodes=[e.hits[0].node],this.applySelection()):this.clearSelection())}onObjectDoubleClick(e){this._enabled&&(e?this.cameraProvider.setCameraView([e.hits[0].node.model.id],!0):this.cameraProvider.setCameraView([],!0))}onPointerMove(e){if(!this._enabled)return;const t=this.viewer.getRenderer().renderingCamera;if(!t||!this.options.hoverMaterialData)return;const n=this.viewer.getRenderer().intersections.intersect(this.viewer.getRenderer().scene,t,e,[re.STREAM_CONTENT_MESH,re.STREAM_CONTENT_POINT,re.STREAM_CONTENT_LINE,re.STREAM_CONTENT_TEXT],!0,this.viewer.getRenderer().clippingVolume)||[];let i=[null,null];for(let r=0;r<n.length&&(i=this.viewer.getRenderer().renderViewFromIntersection(n[r]),!i);r++);this.applyHover(i[0])}applySelection(){this.removeSelection();for(let r=0;r<this.selectedNodes.length;r++)this.viewer.getWorldTree().getRenderTree().getRenderViewsForNode(this.selectedNodes[r]).forEach((s=>{this.selectionRvs[s.guid]||(this.selectionRvs[s.guid]=s),this.selectionMaterials[s.guid]||(this.selectionMaterials[s.guid]=this.viewer.getRenderer().getMaterial(s))}));const e=Object.values(this.selectionRvs),t=e.filter((r=>this.selectionMaterials[r.guid]&&this.selectionMaterials[r.guid].visible&&this.selectionMaterials[r.guid]&&!(this.selectionMaterials[r.guid].transparent&&this.selectionMaterials[r.guid].opacity<1))),n=e.filter((r=>this.selectionMaterials[r.guid]&&this.selectionMaterials[r.guid].visible&&this.selectionMaterials[r.guid]&&this.selectionMaterials[r.guid].transparent&&this.selectionMaterials[r.guid].opacity<1)),i=e.filter((r=>this.selectionMaterials[r.guid]&&this.selectionMaterials[r.guid].visible===!1));this.viewer.getRenderer().setMaterial(t,this.selectionMaterialData),this.viewer.getRenderer().setMaterial(n,this.transparentSelectionMaterialData),this.viewer.getRenderer().setMaterial(i,this.hiddenSelectionMaterialData),this.viewer.requestRender(Qt.RENDER|Qt.CLIPPING_PLANES)}removeSelection(e){this.removeHover();const t={};(e=e||Object.values(this.selectionRvs)).forEach((n=>{const i=this.selectionMaterials[n.guid];i&&(t[i.uuid]||(t[i.uuid]={rvs:[],matName:i.constructor.name}),t[i.uuid].rvs.push(n))}));for(const n in t)this.viewer.getRenderer().setMaterial(t[n].rvs,this.selectionMaterials[t[n].rvs[0].guid]),t[n].rvs.forEach((i=>{delete this.selectionRvs[i.guid],delete this.selectionMaterials[i.guid]}))}applyHover(e){this.removeHover(),e&&(this.selectionRvs[e.guid]||(this.removeHover(),this.hoverRv=e,this.hoverMaterial=this.viewer.getRenderer().getMaterial(this.hoverRv),this.viewer.getRenderer().setMaterial([e],Tt.isTransparent(this.hoverMaterial)?this.transparentHoverMaterialData:this.hoverMaterialData),this.viewer.requestRender()))}removeHover(){this.hoverRv&&this.hoverMaterial&&this.viewer.getRenderer().setMaterial([this.hoverRv],this.hoverMaterial),this.hoverRv=null,this.hoverMaterial=null,this.viewer.requestRender()}}class sk extends Ss{constructor(e,t=null){super(),this.object=e,this.domElement=t,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(){}disconnect(){}dispose(){}update(){}}const Oa=new Wu,ui=new A,Vs=new A,ln=new dt,eA={X:new A(1,0,0),Y:new A(0,1,0),Z:new A(0,0,1)},Qm={type:"change"},tA={type:"mouseDown",mode:null},nA={type:"mouseUp",mode:null},iA={type:"objectChange"};class Wm extends sk{constructor(e,t=null){super(void 0,t);const n=new hk(this);this._root=n;const i=new dk;this._gizmo=i,n.add(i);const r=new fk;this._plane=r,n.add(r);const s=this;function o(y,w){let x=w;Object.defineProperty(s,y,{get:()=>x!==void 0?x:w,set(S){x!==S&&(x=S,r[y]=S,i[y]=S,s.dispatchEvent({type:y+"-changed",value:S}),s.dispatchEvent(Qm))}}),s[y]=w,r[y]=w,i[y]=w}this._doNotPick=!1,o("camera",e),o("object",void 0),o("enabled",!0),o("axis",null),o("mode","translate"),o("translationSnap",null),o("rotationSnap",null),o("scaleSnap",null),o("space","world"),o("size",1),o("dragging",!1),o("showX",!0),o("showY",!0),o("showZ",!0),o("minX",-1/0),o("maxX",1/0),o("minY",-1/0),o("maxY",1/0),o("minZ",-1/0),o("maxZ",1/0);const l=new A,c=new A,u=new dt,h=new dt,d=new A,f=new dt,p=new A,m=new A,g=new A,v=new A;o("worldPosition",l),o("worldPositionStart",c),o("worldQuaternion",u),o("worldQuaternionStart",h),o("cameraPosition",d),o("cameraQuaternion",f),o("pointStart",p),o("pointEnd",m),o("rotationAxis",g),o("rotationAngle",0),o("eye",v),this._offset=new A,this._startNorm=new A,this._endNorm=new A,this._cameraScale=new A,this._parentPosition=new A,this._parentQuaternion=new dt,this._parentQuaternionInv=new dt,this._parentScale=new A,this._worldScaleStart=new A,this._worldQuaternionInv=new dt,this._worldScale=new A,this._positionStart=new A,this._quaternionStart=new dt,this._scaleStart=new A,this._getPointer=ak.bind(this),this._onPointerDown=lk.bind(this),this._onPointerHover=ok.bind(this),this._onPointerMove=ck.bind(this),this._onPointerUp=uk.bind(this),t!==null&&this.connect()}connect(){this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointermove",this._onPointerHover),this.domElement.addEventListener("pointerup",this._onPointerUp),this.domElement.style.touchAction="none"}disconnect(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerHover),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.domElement.style.touchAction="auto"}getHelper(){return this._root}pointerHover(e){if(this._doNotPick)return void(this.axis=null);if(this.object===void 0||this.dragging===!0)return;e!==null&&Oa.setFromCamera(e,this.camera);const t=Pc(this._gizmo.picker[this.mode],Oa);this.axis=t?t.object.name:null}pointerDown(e){if(!this._doNotPick&&this.object!==void 0&&this.dragging!==!0&&(e===null||e.button===0)&&this.axis!==null){e!==null&&Oa.setFromCamera(e,this.camera);const t=Pc(this._plane,Oa,!0);t&&(this.object.updateMatrixWorld(),this.object.parent.updateMatrixWorld(),this._positionStart.copy(this.object.position),this._quaternionStart.copy(this.object.quaternion),this._scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this._worldScaleStart),this.pointStart.copy(t.point).sub(this.worldPositionStart)),this.dragging=!0,tA.mode=this.mode,this.dispatchEvent(tA)}}pointerMove(e){if(this._doNotPick)return;const t=this.axis,n=this.mode,i=this.object;let r=this.space;if(n==="scale"?r="local":t!=="E"&&t!=="XYZE"&&t!=="XYZ"||(r="world"),i===void 0||t===null||this.dragging===!1||e!==null&&e.button!==-1)return;e!==null&&Oa.setFromCamera(e,this.camera);const s=Pc(this._plane,Oa,!0);if(s){if(this.pointEnd.copy(s.point).sub(this.worldPositionStart),n==="translate")this._offset.copy(this.pointEnd).sub(this.pointStart),r==="local"&&t!=="XYZ"&&this._offset.applyQuaternion(this._worldQuaternionInv),t.indexOf("X")===-1&&(this._offset.x=0),t.indexOf("Y")===-1&&(this._offset.y=0),t.indexOf("Z")===-1&&(this._offset.z=0),r==="local"&&t!=="XYZ"?this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale):this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),i.position.copy(this._offset).add(this._positionStart),this.translationSnap&&(r==="local"&&(i.position.applyQuaternion(ln.copy(this._quaternionStart).invert()),t.search("X")!==-1&&(i.position.x=Math.round(i.position.x/this.translationSnap)*this.translationSnap),t.search("Y")!==-1&&(i.position.y=Math.round(i.position.y/this.translationSnap)*this.translationSnap),t.search("Z")!==-1&&(i.position.z=Math.round(i.position.z/this.translationSnap)*this.translationSnap),i.position.applyQuaternion(this._quaternionStart)),r==="world"&&(i.parent&&i.position.add(ui.setFromMatrixPosition(i.parent.matrixWorld)),t.search("X")!==-1&&(i.position.x=Math.round(i.position.x/this.translationSnap)*this.translationSnap),t.search("Y")!==-1&&(i.position.y=Math.round(i.position.y/this.translationSnap)*this.translationSnap),t.search("Z")!==-1&&(i.position.z=Math.round(i.position.z/this.translationSnap)*this.translationSnap),i.parent&&i.position.sub(ui.setFromMatrixPosition(i.parent.matrixWorld)))),i.position.x=Math.max(this.minX,Math.min(this.maxX,i.position.x)),i.position.y=Math.max(this.minY,Math.min(this.maxY,i.position.y)),i.position.z=Math.max(this.minZ,Math.min(this.maxZ,i.position.z));else if(n==="scale"){if(t.search("XYZ")!==-1){let o=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(o*=-1),Vs.set(o,o,o)}else ui.copy(this.pointStart),Vs.copy(this.pointEnd),ui.applyQuaternion(this._worldQuaternionInv),Vs.applyQuaternion(this._worldQuaternionInv),Vs.sub(ui),t.search("X")===-1&&(Vs.x=0),t.search("Y")===-1&&(Vs.y=0),t.search("Z")===-1&&(Vs.z=0);i.scale.copy(this._scaleStart).add(Vs.multiplyScalar(.5)),this.scaleSnap&&(t.search("X")!==-1&&(i.scale.x=Math.round(i.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),t.search("Y")!==-1&&(i.scale.y=Math.round(i.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),t.search("Z")!==-1&&(i.scale.z=Math.round(i.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if(n==="rotate"){this._offset.copy(this.pointEnd).sub(this.pointStart);const o=20/this.worldPosition.distanceTo(ui.setFromMatrixPosition(this.camera.matrixWorld));let l=!1;t==="XYZE"?(this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),this.rotationAngle=this._offset.dot(ui.copy(this.rotationAxis).cross(this.eye))*o):t!=="X"&&t!=="Y"&&t!=="Z"||(this.rotationAxis.copy(eA[t]),ui.copy(eA[t]),r==="local"&&ui.applyQuaternion(this.worldQuaternion),ui.cross(this.eye),ui.length()===0?l=!0:this.rotationAngle=this._offset.dot(ui.normalize())*o),(t==="E"||l)&&(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this._startNorm.copy(this.pointStart).normalize(),this._endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this._endNorm.cross(this._startNorm).dot(this.eye)<0?1:-1),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),r==="local"&&t!=="E"&&t!=="XYZE"?(i.quaternion.copy(this._quaternionStart),i.quaternion.multiply(ln.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this._parentQuaternionInv),i.quaternion.copy(ln.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),i.quaternion.multiply(this._quaternionStart).normalize())}this.dispatchEvent(Qm),this.dispatchEvent(iA)}}pointerUp(e){this._doNotPick||e!==null&&e.button!==0||(this.dragging&&this.axis!==null&&(nA.mode=this.mode,this.dispatchEvent(nA)),this.dragging=!1,this.axis=null)}dispose(){this.disconnect(),this._root.dispose()}attach(e){return this.object=e,this._root.visible=!0,this}detach(){return this.object=void 0,this.axis=null,this._root.visible=!1,this}reset(){this.enabled&&this.dragging&&(this.object.position.copy(this._positionStart),this.object.quaternion.copy(this._quaternionStart),this.object.scale.copy(this._scaleStart),this.dispatchEvent(Qm),this.dispatchEvent(iA),this.pointStart.copy(this.pointEnd))}getRaycaster(){return Oa}getMode(){return this.mode}setMode(e){this.mode=e}setTranslationSnap(e){this.translationSnap=e}setRotationSnap(e){this.rotationSnap=e}setScaleSnap(e){this.scaleSnap=e}setSize(e){this.size=e}setSpace(e){this.space=e}}function ak(a){if(this.domElement.ownerDocument.pointerLockElement)return{x:0,y:0,button:a.button};{const e=this.domElement.getBoundingClientRect();return{x:(a.clientX-e.left)/e.width*2-1,y:-(a.clientY-e.top)/e.height*2+1,button:a.button}}}function ok(a){if(this.enabled)switch(a.pointerType){case"mouse":case"pen":this.pointerHover(this._getPointer(a))}}function lk(a){this.enabled&&(document.pointerLockElement||this.domElement.setPointerCapture(a.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.pointerHover(this._getPointer(a)),this.pointerDown(this._getPointer(a)))}function ck(a){this.enabled&&this.pointerMove(this._getPointer(a))}function uk(a){this.enabled&&(this.domElement.releasePointerCapture(a.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.pointerUp(this._getPointer(a)))}function Pc(a,e,t){const n=e.intersectObject(a,!0);for(let i=0;i<n.length;i++)if(n[i].object.visible||t)return n[i];return!1}const Id=new mi,Jt=new A(0,1,0),rA=new A(0,0,0),sA=new ae,Rd=new dt,Vd=new dt,Cr=new A,aA=new ae,gc=new A(1,0,0),La=new A(0,1,0),vc=new A(0,0,1),Pd=new A,ac=new A,oc=new A;class hk extends gt{constructor(e){super(),this.isTransformControlsRoot=!0,this.controls=e,this.visible=!1}updateMatrixWorld(e){const t=this.controls;t.object!==void 0&&(t.object.updateMatrixWorld(),t.object.parent===null?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):t.object.parent.matrixWorld.decompose(t._parentPosition,t._parentQuaternion,t._parentScale),t.object.matrixWorld.decompose(t.worldPosition,t.worldQuaternion,t._worldScale),t._parentQuaternionInv.copy(t._parentQuaternion).invert(),t._worldQuaternionInv.copy(t.worldQuaternion).invert()),t.camera.updateMatrixWorld(),t.camera.matrixWorld.decompose(t.cameraPosition,t.cameraQuaternion,t._cameraScale),t.camera.isOrthographicCamera?t.camera.getWorldDirection(t.eye).negate():t.eye.copy(t.cameraPosition).sub(t.worldPosition).normalize(),super.updateMatrixWorld(e)}dispose(){this.traverse((function(e){e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}))}}class dk extends gt{constructor(){super(),this.isTransformControlsGizmo=!0,this.type="TransformControlsGizmo";const e=new ti({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),t=new mn({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),n=e.clone();n.opacity=.15;const i=t.clone();i.opacity=.5;const r=e.clone();r.color.setHex(16711680);const s=e.clone();s.color.setHex(65280);const o=e.clone();o.color.setHex(255);const l=e.clone();l.color.setHex(16711680),l.opacity=.5;const c=e.clone();c.color.setHex(65280),c.opacity=.5;const u=e.clone();u.color.setHex(255),u.opacity=.5;const h=e.clone();h.opacity=.25;const d=e.clone();d.color.setHex(16776960),d.opacity=.25,e.clone().color.setHex(16776960),e.clone().color.setHex(7895160);const f=new yn(0,.04,.1,12);f.translate(0,.05,0);const p=new Tn(.08,.08,.08);p.translate(0,.04,0);const m=new nt;m.setAttribute("position",new je([0,0,0,1,0,0],3));const g=new yn(.0075,.0075,.5,3);function v(R,k){const P=new Lr(R,.0075,3,64,k*Math.PI*2);return P.rotateY(Math.PI/2),P.rotateX(Math.PI/2),P}g.translate(0,.25,0);const y={X:[[new Ve(f,r),[.5,0,0],[0,0,-Math.PI/2]],[new Ve(f,r),[-.5,0,0],[0,0,Math.PI/2]],[new Ve(g,r),[0,0,0],[0,0,-Math.PI/2]]],Y:[[new Ve(f,s),[0,.5,0]],[new Ve(f,s),[0,-.5,0],[Math.PI,0,0]],[new Ve(g,s)]],Z:[[new Ve(f,o),[0,0,.5],[Math.PI/2,0,0]],[new Ve(f,o),[0,0,-.5],[-Math.PI/2,0,0]],[new Ve(g,o),null,[Math.PI/2,0,0]]],XYZ:[[new Ve(new mr(.1,0),h.clone()),[0,0,0]]]},w={X:[[new Ve(new yn(.2,0,.6,4),n),[.3,0,0],[0,0,-Math.PI/2]],[new Ve(new yn(.2,0,.6,4),n),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new Ve(new yn(.2,0,.6,4),n),[0,.3,0]],[new Ve(new yn(.2,0,.6,4),n),[0,-.3,0],[0,0,Math.PI]]],Z:[[new Ve(new yn(.2,0,.6,4),n),[0,0,.3],[Math.PI/2,0,0]],[new Ve(new yn(.2,0,.6,4),n),[0,0,-.3],[-Math.PI/2,0,0]]],XYZ:[[new Ve(new mr(.2,0),n)]],XY:[[new Ve(new Tn(.2,.2,.01),n),[.15,.15,0]]],YZ:[[new Ve(new Tn(.2,.2,.01),n),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new Ve(new Tn(.2,.2,.01),n),[.15,0,.15],[-Math.PI/2,0,0]]]},x={START:[[new Ve(new mr(.01,2),i),null,null,null,"helper"]],END:[[new Ve(new mr(.01,2),i),null,null,null,"helper"]],DELTA:[[new $n((function(){const R=new nt;return R.setAttribute("position",new je([0,0,0,1,1,1],3)),R})(),i),null,null,null,"helper"]],X:[[new $n(m,i.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new $n(m,i.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new $n(m,i.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},S={X:[[new Ve(v(.5,.5),r)]],Y:[[new Ve(v(.5,.5),s),null,[0,0,-Math.PI/2]]],Z:[[new Ve(v(.5,.5),o),null,[0,Math.PI/2,0]]]},b={AXIS:[[new $n(m,i.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},E={XYZE:[[new Ve(new xs(.25,10,8),n)]],X:[[new Ve(new Lr(.5,.1,4,24),n),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new Ve(new Lr(.5,.1,4,24),n),[0,0,0],[Math.PI/2,0,0]]],Z:[[new Ve(new Lr(.5,.1,4,24),n),[0,0,0],[0,0,-Math.PI/2]]]},M={X:[[new Ve(p,r),[.5,0,0],[0,0,-Math.PI/2]],[new Ve(g,r),[0,0,0],[0,0,-Math.PI/2]],[new Ve(p,r),[-.5,0,0],[0,0,Math.PI/2]]],Y:[[new Ve(p,s),[0,.5,0]],[new Ve(g,s)],[new Ve(p,s),[0,-.5,0],[0,0,Math.PI]]],Z:[[new Ve(p,o),[0,0,.5],[Math.PI/2,0,0]],[new Ve(g,o),[0,0,0],[Math.PI/2,0,0]],[new Ve(p,o),[0,0,-.5],[-Math.PI/2,0,0]]],XY:[[new Ve(new Tn(.15,.15,.01),u),[.15,.15,0]]],YZ:[[new Ve(new Tn(.15,.15,.01),l),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new Ve(new Tn(.15,.15,.01),c),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new Ve(new Tn(.1,.1,.1),h.clone())]]},T={X:[[new Ve(new yn(.2,0,.6,4),n),[.3,0,0],[0,0,-Math.PI/2]],[new Ve(new yn(.2,0,.6,4),n),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new Ve(new yn(.2,0,.6,4),n),[0,.3,0]],[new Ve(new yn(.2,0,.6,4),n),[0,-.3,0],[0,0,Math.PI]]],Z:[[new Ve(new yn(.2,0,.6,4),n),[0,0,.3],[Math.PI/2,0,0]],[new Ve(new yn(.2,0,.6,4),n),[0,0,-.3],[-Math.PI/2,0,0]]],XY:[[new Ve(new Tn(.2,.2,.01),n),[.15,.15,0]]],YZ:[[new Ve(new Tn(.2,.2,.01),n),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new Ve(new Tn(.2,.2,.01),n),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new Ve(new Tn(.2,.2,.2),n),[0,0,0]]]},I={X:[[new $n(m,i.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new $n(m,i.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new $n(m,i.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]};function O(R){const k=new gt;for(const P in R)for(let F=R[P].length;F--;){const N=R[P][F][0].clone(),Y=R[P][F][1],_=R[P][F][2],G=R[P][F][3],j=R[P][F][4];N.name=P,N.tag=j,Y&&N.position.set(Y[0],Y[1],Y[2]),_&&N.rotation.set(_[0],_[1],_[2]),G&&N.scale.set(G[0],G[1],G[2]),N.updateMatrix();const L=N.geometry.clone();L.applyMatrix4(N.matrix),N.geometry=L,N.renderOrder=1/0,N.position.set(0,0,0),N.rotation.set(0,0,0),N.scale.set(1,1,1),k.add(N)}return k}this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=O(y)),this.add(this.gizmo.rotate=O(S)),this.add(this.gizmo.scale=O(M)),this.add(this.picker.translate=O(w)),this.add(this.picker.rotate=O(E)),this.add(this.picker.scale=O(T)),this.add(this.helper.translate=O(x)),this.add(this.helper.rotate=O(b)),this.add(this.helper.scale=O(I)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}updateMatrixWorld(e){const t=(this.mode==="scale"?"local":this.space)==="local"?this.worldQuaternion:Vd;this.gizmo.translate.visible=this.mode==="translate",this.gizmo.rotate.visible=this.mode==="rotate",this.gizmo.scale.visible=this.mode==="scale",this.helper.translate.visible=this.mode==="translate",this.helper.rotate.visible=this.mode==="rotate",this.helper.scale.visible=this.mode==="scale";let n=[];n=n.concat(this.picker[this.mode].children),n=n.concat(this.gizmo[this.mode].children),n=n.concat(this.helper[this.mode].children);for(let i=0;i<n.length;i++){const r=n[i];let s;r.visible=!0,r.rotation.set(0,0,0),r.position.copy(this.worldPosition),s=this.camera.isOrthographicCamera?(this.camera.top-this.camera.bottom)/this.camera.zoom:this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),r.scale.set(1,1,1).multiplyScalar(s*this.size/4),r.tag!=="helper"?(r.quaternion.copy(t),this.mode==="translate"||this.mode==="scale"?(r.name==="X"&&Math.abs(Jt.copy(gc).applyQuaternion(t).dot(this.eye))>.99&&(r.scale.set(1e-10,1e-10,1e-10),r.visible=!1),r.name==="Y"&&Math.abs(Jt.copy(La).applyQuaternion(t).dot(this.eye))>.99&&(r.scale.set(1e-10,1e-10,1e-10),r.visible=!1),r.name==="Z"&&Math.abs(Jt.copy(vc).applyQuaternion(t).dot(this.eye))>.99&&(r.scale.set(1e-10,1e-10,1e-10),r.visible=!1),r.name==="XY"&&Math.abs(Jt.copy(vc).applyQuaternion(t).dot(this.eye))<.2&&(r.scale.set(1e-10,1e-10,1e-10),r.visible=!1),r.name==="YZ"&&Math.abs(Jt.copy(gc).applyQuaternion(t).dot(this.eye))<.2&&(r.scale.set(1e-10,1e-10,1e-10),r.visible=!1),r.name==="XZ"&&Math.abs(Jt.copy(La).applyQuaternion(t).dot(this.eye))<.2&&(r.scale.set(1e-10,1e-10,1e-10),r.visible=!1)):this.mode==="rotate"&&(Rd.copy(t),Jt.copy(this.eye).applyQuaternion(ln.copy(t).invert()),r.name.search("E")!==-1&&r.quaternion.setFromRotationMatrix(sA.lookAt(this.eye,rA,La)),r.name==="X"&&(ln.setFromAxisAngle(gc,Math.atan2(-Jt.y,Jt.z)),ln.multiplyQuaternions(Rd,ln),r.quaternion.copy(ln)),r.name==="Y"&&(ln.setFromAxisAngle(La,Math.atan2(Jt.x,Jt.z)),ln.multiplyQuaternions(Rd,ln),r.quaternion.copy(ln)),r.name==="Z"&&(ln.setFromAxisAngle(vc,Math.atan2(Jt.y,Jt.x)),ln.multiplyQuaternions(Rd,ln),r.quaternion.copy(ln))),r.visible=r.visible&&(r.name.indexOf("X")===-1||this.showX),r.visible=r.visible&&(r.name.indexOf("Y")===-1||this.showY),r.visible=r.visible&&(r.name.indexOf("Z")===-1||this.showZ),r.visible=r.visible&&(r.name.indexOf("E")===-1||this.showX&&this.showY&&this.showZ),r.material._color=r.material._color||r.material.color.clone(),r.material._opacity=r.material._opacity||r.material.opacity,r.material.color.copy(r.material._color),r.material.opacity=r.material._opacity,this.enabled&&this.axis&&(r.name===this.axis||this.axis.split("").some((function(o){return r.name===o})))&&(r.material.color.setHex(16776960),r.material.opacity=1)):(r.visible=!1,r.name==="AXIS"?(r.visible=!!this.axis,this.axis==="X"&&(ln.setFromEuler(Id.set(0,0,0)),r.quaternion.copy(t).multiply(ln),Math.abs(Jt.copy(gc).applyQuaternion(t).dot(this.eye))>.9&&(r.visible=!1)),this.axis==="Y"&&(ln.setFromEuler(Id.set(0,0,Math.PI/2)),r.quaternion.copy(t).multiply(ln),Math.abs(Jt.copy(La).applyQuaternion(t).dot(this.eye))>.9&&(r.visible=!1)),this.axis==="Z"&&(ln.setFromEuler(Id.set(0,Math.PI/2,0)),r.quaternion.copy(t).multiply(ln),Math.abs(Jt.copy(vc).applyQuaternion(t).dot(this.eye))>.9&&(r.visible=!1)),this.axis==="XYZE"&&(ln.setFromEuler(Id.set(0,Math.PI/2,0)),Jt.copy(this.rotationAxis),r.quaternion.setFromRotationMatrix(sA.lookAt(rA,Jt,La)),r.quaternion.multiply(ln),r.visible=this.dragging),this.axis==="E"&&(r.visible=!1)):r.name==="START"?(r.position.copy(this.worldPositionStart),r.visible=this.dragging):r.name==="END"?(r.position.copy(this.worldPosition),r.visible=this.dragging):r.name==="DELTA"?(r.position.copy(this.worldPositionStart),r.quaternion.copy(this.worldQuaternionStart),ui.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),ui.applyQuaternion(this.worldQuaternionStart.clone().invert()),r.scale.copy(ui),r.visible=this.dragging):(r.quaternion.copy(t),this.dragging?r.position.copy(this.worldPositionStart):r.position.copy(this.worldPosition),this.axis&&(r.visible=this.axis.search(r.name)!==-1)))}super.updateMatrixWorld(e)}}class fk extends Ve{constructor(){super(new Hi(1e5,1e5,2,2),new ti({visible:!1,wireframe:!0,side:yt,transparent:!0,opacity:.1,toneMapped:!1})),this.isTransformControlsPlane=!0,this.type="TransformControlsPlane"}updateMatrixWorld(e){let t=this.space;switch(this.position.copy(this.worldPosition),this.mode==="scale"&&(t="local"),Pd.copy(gc).applyQuaternion(t==="local"?this.worldQuaternion:Vd),ac.copy(La).applyQuaternion(t==="local"?this.worldQuaternion:Vd),oc.copy(vc).applyQuaternion(t==="local"?this.worldQuaternion:Vd),Jt.copy(ac),this.mode){case"translate":case"scale":switch(this.axis){case"X":Jt.copy(this.eye).cross(Pd),Cr.copy(Pd).cross(Jt);break;case"Y":Jt.copy(this.eye).cross(ac),Cr.copy(ac).cross(Jt);break;case"Z":Jt.copy(this.eye).cross(oc),Cr.copy(oc).cross(Jt);break;case"XY":Cr.copy(oc);break;case"YZ":Cr.copy(Pd);break;case"XZ":Jt.copy(oc),Cr.copy(ac);break;case"XYZ":case"E":Cr.set(0,0,0)}break;default:Cr.set(0,0,0)}Cr.length()===0?this.quaternion.copy(this.cameraQuaternion):(aA.lookAt(ui.set(0,0,0),Cr,Jt),this.quaternion.setFromRotationMatrix(aA)),super.updateMatrixWorld(e)}}var pr;(function(a){a.DragStart="section-box-drag-start",a.DragEnd="section-box-drag-end",a.Updated="section-box-changed"})(pr||(pr={}));const pk=new ae,mk=new dt,gk=new A,js=new mi,oA=new dt,vk=new Float32Array([-.5,-.5,-.5,.5,-.5,-.5,.5,.5,-.5,-.5,.5,-.5,-.5,-.5,.5,.5,-.5,.5,.5,.5,.5,-.5,.5,.5]),yk=new Uint16Array([0,1,3,3,1,2,1,5,2,2,5,6,5,4,6,6,4,7,4,0,7,7,0,3,3,2,7,7,2,6,4,5,0,0,5,1]),jd=[-.5,-.5,-.5,.5,-.5,-.5,.5,-.5,-.5,.5,.5,-.5,.5,.5,-.5,-.5,.5,-.5,-.5,.5,-.5,-.5,-.5,-.5,-.5,-.5,.5,.5,-.5,.5,.5,-.5,.5,.5,.5,.5,.5,.5,.5,-.5,.5,.5,-.5,.5,.5,-.5,-.5,.5,-.5,-.5,-.5,-.5,-.5,.5,.5,-.5,.5,.5,-.5,-.5,.5,.5,.5,.5,.5,-.5,-.5,.5,.5,-.5,.5,-.5],Dd=new Array(jd.length),lc=new Array(12);class uf extends Zr{get inject(){return[lo]}get enabled(){return this._enabled}set enabled(e){this._enabled=e,this.display.visible=e,e?(this.translateControls.attach(this.translationRotationAnchor),this.rotateControls.attach(this.translationRotationAnchor)):(this.translateControls.detach(),this.rotateControls.detach(),this.scaleControls.detach(),this.draggingFace=null,this.facePlane.visible=!1),this.viewer.getRenderer().renderer.localClippingEnabled=e,this.emit(pr.Updated,this.planes),this.viewer.requestRender()}get visible(){return this.display.visible}set visible(e){this._enabled&&(this.display.visible=e,e?(this.translateControls.attach(this.translationRotationAnchor),this.rotateControls.attach(this.translationRotationAnchor),this.draggingFace&&this.scaleControls.attach(this.scaleAnchor)):(this.translateControls.detach(),this.rotateControls.detach(),this.draggingFace&&this.scaleControls.detach()))}get sectionPlanes(){return this.planes}constructor(e,t){super(e,t),this.cameraProvider=t,this.rotationSnapAngle=Math.PI/12,this.obb=new Un,this.planes=[new kt(new A(1,0,0),.5),new kt(new A(-1,0,0),.5),new kt(new A(0,1,0),.5),new kt(new A(0,-1,0),.5),new kt(new A(0,0,1),.5),new kt(new A(0,0,-1),.5)],this.localPlanes=[new kt(new A(1,0,0),.5),new kt(new A(-1,0,0),.5),new kt(new A(0,1,0),.5),new kt(new A(0,-1,0),.5),new kt(new A(0,0,1),.5),new kt(new A(0,0,-1),.5)],this.cubeFaces={256:{verts:[1,2,5,6],axis:"x",normal:new A(1,0,0)},152:{verts:[1,2,5,6],axis:"x",normal:new A(1,0,0)},407:{verts:[0,3,4,7],axis:"x",normal:new A(1,0,0)},703:{verts:[0,3,4,7],axis:"x",normal:new A(1,0,0)},327:{verts:[2,3,6,7],axis:"y",normal:new A(0,1,0)},726:{verts:[2,3,6,7],axis:"y",normal:new A(0,1,0)},450:{verts:[0,1,4,5],axis:"y",normal:new A(0,1,0)},"051":{verts:[0,1,4,5],axis:"y",normal:new A(0,1,0)},312:{verts:[0,1,3,2],axis:"z",normal:new A(0,0,1)},"013":{verts:[0,1,3,2],axis:"z",normal:new A(0,0,1)},546:{verts:[4,5,7,6],axis:"z",normal:new A(0,0,1)},647:{verts:[4,5,7,6],axis:"z",normal:new A(0,0,1)}},this.lastObbTransform=new ae,this.dragging=!1,this.shiftKeyPressed=!1,this.sectionBoxHistory=[],this.currentHistoryIndex=0,this.maxHistorySize=100,this.viewer=e,this.dragging=!1,this.display=new fi,this.display.name="SectionBox",this.display.layers.set(re.PROPS),this.viewer.getRenderer().scene.add(this.display);const n=this.createCubeGeometry();this.boxHitMesh=new Ve(n,new ti({side:yt,visible:!1,depthWrite:!1})),this.boxHitMesh.layers.set(re.PROPS),this.display.add(this.boxHitMesh),this.boxOutline=this.createOutline(),this.display.add(this.boxOutline),this.facePlane=this.createFacePlane(),this.display.add(this.facePlane),this.translationRotationAnchor=new gt,this.translationRotationAnchor.name="TranslationAnchor",this.display.add(this.translationRotationAnchor),this.scaleAnchor=new gt,this.scaleAnchor.name="ScaleAnchor",this.display.add(this.scaleAnchor),this.raycaster=new Wu,this.raycaster.layers.set(re.PROPS),this.setupControls(),this.cameraProvider.on(Si.ProjectionChanged,(()=>{this.translateControls.camera=this.viewer.getRenderer().renderingCamera,this.rotateControls.camera=this.viewer.getRenderer().renderingCamera,this.scaleControls.camera=this.viewer.getRenderer().renderingCamera})),this.viewer.getRenderer().input.on(kn.Click,this.clickHandler.bind(this)),this.setupKeyboardListeners(),this.enabled=!1}onEarlyUpdate(){if(this.dragging)return;const e=Pc(this.translateControls._gizmo.picker.translate,this.translateControls.getRaycaster()),t=Pc(this.rotateControls._gizmo.picker.rotate,this.rotateControls.getRaycaster());(e?e.distance:Number.MAX_VALUE)<=(t?t.distance:Number.MAX_VALUE)?(this.translateControls._doNotPick=!1,this.rotateControls._doNotPick=!0):(this.translateControls._doNotPick=!0,this.rotateControls._doNotPick=!1)}on(e,t){super.on(e,t)}getBox(){return this.obb}setBox(e,t=0){if(t=t===0?1e-4:t,this.isOBB(e)){const n=ca.expandBoxRelative(e,t);this.obb.center.copy(n.center),this.obb.halfSize.copy(n.halfSize),this.obb.rotation.copy(n.rotation)}else if(this.isAABB(e)){let n=new He;n.min.copy(e.min),n.max.copy(e.max),n.isEmpty()&&(n=new He(new A(-1,-1,-1),new A(1,1,1))),n=ca.expandBoxRelative(e,t),this.obb.center.copy(n.getCenter(new A)),this.obb.halfSize.copy(n.getSize(new A).multiplyScalar(.5)),this.obb.rotation.identity()}else De.error(`Incorrect argument for setBox ${e}`);this.updatePlanes(),this.updateVisual(),this.emit(pr.Updated,this.planes)}toggle(){this.enabled=!this._enabled}getObbTransform(){return new ae().compose(this.obb.center,mk.setFromRotationMatrix(pk.setFromMatrix3(this.obb.rotation)),gk.copy(this.obb.halfSize).multiplyScalar(2))}setupControls(){const e=this.viewer.getRenderer().renderingCamera;if(!e)throw new Error("Cannot create SectionTool extension. No rendering camera found");this.translateControls=new Wm(e,this.viewer.getRenderer().renderer.domElement);for(let t=0;t<this.translateControls._root.children.length;t++)this.translateControls._root.children[t].traverse((n=>{n.layers.set(re.PROPS)}));this.translateControls.getRaycaster().layers.set(re.PROPS),this.translateControls.setSize(.75),this.translateControls.space="local",this.display.add(this.translateControls._root),this.rotateControls=new Wm(e,this.viewer.getRenderer().renderer.domElement);for(let t=0;t<this.rotateControls._root.children.length;t++)this.rotateControls._root.children[t].traverse((n=>{n.layers.set(re.PROPS)}));this.rotateControls.getRaycaster().layers.set(re.PROPS),this.rotateControls.setSize(.5),this.rotateControls.mode="rotate",this.rotateControls.space="local",this.display.add(this.rotateControls._root),this.scaleControls=new Wm(e,this.viewer.getRenderer().renderer.domElement);for(let t=0;t<this.scaleControls._root.children.length;t++)this.scaleControls._root.children[t].traverse((n=>{n.layers.set(re.PROPS)}));this.scaleControls.getRaycaster().layers.set(re.PROPS),this.scaleControls.setSize(.5),this.scaleControls.mode="scale",this.scaleControls._root.visible=!1,this.display.add(this.scaleControls._root),this.translateControls.addEventListener("change",this.changeHandler.bind(this)),this.translateControls.addEventListener("dragging-changed",this.draggingHandler.bind(this)),this.rotateControls.addEventListener("change",this.changeHandler.bind(this)),this.rotateControls.addEventListener("dragging-changed",this.draggingHandler.bind(this)),this.scaleControls.addEventListener("change",this.changeHandler.bind(this)),this.scaleControls.addEventListener("dragging-changed",this.draggingHandler.bind(this))}createObbState(){return new Un().copy(this.obb)}applyObbState(e){this.obb.copy(e)}saveToHistory(){const e=this.createObbState();this.currentHistoryIndex<this.sectionBoxHistory.length-1&&this.sectionBoxHistory.length>1&&(this.sectionBoxHistory=this.sectionBoxHistory.slice(0,this.currentHistoryIndex+1)),this.sectionBoxHistory.push(e),this.currentHistoryIndex=this.sectionBoxHistory.length-1,this.sectionBoxHistory.length>this.maxHistorySize&&(this.sectionBoxHistory.shift(),this.currentHistoryIndex=Math.max(0,this.currentHistoryIndex-1))}setupKeyboardListeners(){this.shiftKeyPressed=!1,this.keydownHandler=e=>{e.shiftKey&&!this.shiftKeyPressed&&(this.shiftKeyPressed=!0),!e.metaKey&&!e.ctrlKey||e.key!=="z"||e.shiftKey||this.enabled&&this.visible&&(e.preventDefault(),this.undoSectionBox()),(e.metaKey||e.ctrlKey)&&e.key==="z"&&e.shiftKey&&this.enabled&&this.visible&&(e.preventDefault(),this.redoSectionBox())},this.keyupHandler=e=>{!e.shiftKey&&this.shiftKeyPressed&&(this.shiftKeyPressed=!1)},document.addEventListener("keydown",this.keydownHandler),document.addEventListener("keyup",this.keyupHandler)}updateVisual(){this.translationRotationAnchor.position.copy(this.obb.center),this.translationRotationAnchor.quaternion.copy(new dt().setFromRotationMatrix(new ae().setFromMatrix3(this.obb.rotation))),this.scaleAnchor.scale.copy(this.obb.halfSize),this.boxHitMesh.position.copy(this.obb.center),this.boxHitMesh.scale.copy(this.obb.halfSize),this.boxHitMesh.scale.multiplyScalar(2),this.boxHitMesh.quaternion.copy(new dt().setFromRotationMatrix(new ae().setFromMatrix3(this.obb.rotation))),this.updateOutline()}draggingHandler(e){this.dragging=e.value,this.dragging?(this.sectionBoxHistory.length===0&&(this.sectionBoxHistory.push(this.createObbState()),this.currentHistoryIndex=0),this.cameraProvider.enabled=!1,e.target===this.translateControls?this.rotateControls.detach():e.target===this.rotateControls&&this.translateControls.detach(),this.emit(pr.DragStart)):(this.saveToHistory(),this.cameraProvider.enabled=!0,e.target===this.translateControls?this.rotateControls.attach(this.translationRotationAnchor):e.target===this.rotateControls&&this.translateControls.attach(this.translationRotationAnchor),this.emit(pr.DragEnd)),this.viewer.requestRender()}changeHandler(){this.obb.center.copy(this.translationRotationAnchor.position);let e=this.translationRotationAnchor.quaternion;if(this.shiftKeyPressed&&(e=this.snapQuaternionToGrid(e),this.translationRotationAnchor.quaternion.copy(e)),this.obb.rotation.copy(new Kt().setFromMatrix4(new ae().makeRotationFromQuaternion(e))),this.obb.halfSize.copy(this.scaleAnchor.scale),this.lastScale||(this.lastScale=new A().copy(this.scaleAnchor.scale)),this.lastScale.sub(this.scaleAnchor.scale),this.lastScale.negate(),this.draggingFace){const t=new A().copy(this.draggingFace.normal).applyQuaternion(new dt().setFromRotationMatrix(new ae().setFromMatrix3(this.obb.rotation))).normalize(),n=Math.abs(this.draggingFace.normal.x)*this.lastScale.x+Math.abs(this.draggingFace.normal.y)*this.lastScale.y+Math.abs(this.draggingFace.normal.z)*this.lastScale.z;t.multiplyScalar(n),this.obb.center.sub(t)}this.lastScale.copy(this.scaleAnchor.scale),this.updatePlanes(),this.updateVisual(),this.updateFaceControls(this.draggingFace),this.viewer.requestRender()}clickHandler(e){if(this.dragging||!this.enabled||!this.visible)return;this.raycaster.setFromCamera(e,this.cameraProvider.renderingCamera);let t=[];if(t=this.raycaster.intersectObject(this.boxHitMesh),!t.length)return this.translateControls.attach(this.translationRotationAnchor),this.rotateControls.attach(this.translationRotationAnchor),this.scaleControls.detach(),this.facePlane.visible=!1,void(this.draggingFace=null);this.draggingFace=t[0].face,this.translateControls.detach(),this.rotateControls.detach(),this.scaleControls.attach(this.scaleAnchor),this.updateFaceControls(this.draggingFace)}updatePlanes(){const e=this.getObbTransform();let t=!1;for(let n=0;n<16;n++)if(Math.abs(e.elements[n]-this.lastObbTransform.elements[n])>1e-6){t=!0;break}if(t){for(let n=0;n<this.localPlanes.length;n++)this.planes[n].copy(this.localPlanes[n]),this.planes[n].applyMatrix4(e);this.viewer.getRenderer().clippingPlanes=this.planes,this.viewer.getRenderer().clippingVolume=this.getBox(),this.emit(pr.Updated,this.planes),this.lastObbTransform.copy(e)}}createFacePlane(){const e=new Hi(1,1);ft.updateRTEGeometry(e,new Float32Array(12)),e.attributes.position.setUsage(Xn),e.attributes.position_low.setUsage(Xn);const t=new Ve(e,new hi({transparent:!0,side:yt,opacity:.1,wireframe:!1,color:681727,metalness:.1,roughness:.75},["USE_RTE"]));return t.layers.set(re.PROPS),t.renderOrder=5,t.frustumCulled=!1,t}updateFaceControls(e){if(!e)return;const t=this.boxHitMesh.geometry.attributes.position,n=this.cubeFaces[`${e.a}${e.b}${e.c}`],i=new A().fromBufferAttribute(t,n.verts[0]),r=new A().fromBufferAttribute(t,n.verts[3]),s=new A((i.x+r.x)/2,(i.y+r.y)/2,(i.z+r.z)/2),o=this.getObbTransform();s.applyMatrix4(o);const l=new dt().setFromUnitVectors(new A().copy(n.normal).negate(),e.normal);l.premultiply(new dt().setFromRotationMatrix(new ae().setFromMatrix3(this.obb.rotation))),this.scaleAnchor.position.copy(s),this.scaleAnchor.quaternion.copy(l),this.scaleControls.showX=n.axis==="x",this.scaleControls.showY=n.axis==="y",this.scaleControls.showZ=n.axis==="z",this.facePlane.visible=!0;const c=new A().fromBufferAttribute(t,n.verts[1]),u=new A().fromBufferAttribute(t,n.verts[2]);i.applyMatrix4(o),c.applyMatrix4(o),u.applyMatrix4(o),r.applyMatrix4(o),i.toArray(lc,0),c.toArray(lc,3),u.toArray(lc,6),r.toArray(lc,9);const h=this.facePlane.geometry.attributes.position,d=this.facePlane.geometry.attributes.position_low;ft.DoubleToHighLowBuffer(lc,d.array,h.array),h.needsUpdate=!0,d.needsUpdate=!0}createOutline(){const e=jd.slice(),t=new la;t.setPositions(e),t.attributes.instanceStart.data.setUsage(Xn),ft.updateRTEGeometry(t,e);const n=new Or({color:294651,linewidth:1,worldUnits:!1,vertexColors:!1,alphaToCoverage:!1,resolution:new te(32,32)},["USE_RTE"]);n.color=new Ie(294651),n.color.convertSRGBToLinear(),n.linewidth=1,n.worldUnits=!1,n.resolution=new te(32,32),n.toneMapped=!1;const i=new ao(t,n);return i.name="oriented-box-outline",i.frustumCulled=!1,i.renderOrder=1,i.layers.set(re.PROPS),i}updateOutline(){const e=this.getObbTransform(),t=new A;for(let r=0;r<jd.length;r+=3)t.fromArray(jd,r),t.applyMatrix4(e),Dd[r]=t.x,Dd[r+1]=t.y,Dd[r+2]=t.z;const n=this.boxOutline.geometry.attributes.instanceStart.data,i=this.boxOutline.geometry.attributes.instanceStartLow.data;ft.DoubleToHighLowBuffer(Dd,i.array,n.array),this.boxOutline.geometry.attributes.instanceStart.needsUpdate=!0,this.boxOutline.geometry.attributes.instanceEnd.needsUpdate=!0,this.boxOutline.geometry.attributes.instanceStartLow.needsUpdate=!0,this.boxOutline.geometry.attributes.instanceEndLow.needsUpdate=!0}createCubeGeometry(){const e=vk.slice(),t=yk.slice(),n=new nt;return n.setAttribute("position",new je(e,3)),n.setIndex(new _i(t,1)),n.computeBoundingBox(),n.computeVertexNormals(),n}reset(){this.translateControls.reset(),this.translateControls.reset(),this.scaleControls.reset()}isAABB(e){return e instanceof He||"min"in e&&"max"in e}isOBB(e){return e instanceof Un}snapQuaternionToGrid(e){return js.setFromQuaternion(e),this.rotationSnapAngle!==null&&(js.x=Math.round(js.x/this.rotationSnapAngle)*this.rotationSnapAngle,js.y=Math.round(js.y/this.rotationSnapAngle)*this.rotationSnapAngle,js.z=Math.round(js.z/this.rotationSnapAngle)*this.rotationSnapAngle),oA.setFromEuler(js),oA}undoSectionBox(){if(this.currentHistoryIndex>0){this.currentHistoryIndex--;const e=this.sectionBoxHistory[this.currentHistoryIndex];if(e){this.applyObbState(e),this.updatePlanes(),this.updateVisual(),this.updateFaceControls(this.draggingFace);const t=this.viewer.getExtension(Jr);t&&t.enabled&&t.requestUpdate(!0),this.viewer.requestRender()}}}redoSectionBox(){if(this.currentHistoryIndex<this.sectionBoxHistory.length-1){this.currentHistoryIndex++;const e=this.sectionBoxHistory[this.currentHistoryIndex];if(e){this.applyObbState(e),this.updatePlanes(),this.updateVisual(),this.updateFaceControls(this.draggingFace);const t=this.viewer.getExtension(Jr);t&&t.enabled&&t.requestUpdate(!0),this.viewer.requestRender()}}}dispose(){this.keydownHandler&&document.removeEventListener("keydown",this.keydownHandler),this.keyupHandler&&document.removeEventListener("keyup",this.keyupHandler)}}var Yt,Nn,hf,Xi;(function(a){a.POSITIVE_X="POSITIVE_X",a.POSITIVE_Y="POSITIVE_Y",a.POSITIVE_Z="POSITIVE_Z",a.NEGATIVE_X="NEGATIVE_X",a.NEGATIVE_Y="NEGATIVE_Y",a.NEGATIVE_Z="NEGATIVE_Z"})(Yt||(Yt={}));class Jr extends Zr{get inject(){return[uf]}constructor(e,t){super(e),this.sectionProvider=t,this.tmpVec=new A,this.up=new A(0,1,0),this.down=new A(0,-1,0),this.left=new A(-1,0,0),this.right=new A(1,0,0),this.forward=new A(0,0,1),this.back=new A(0,0,-1),this.planeOutlines={},this.lastSectionPlanes=[],this.sectionPlanesChanged=[],this.planeOutlines[Yt.POSITIVE_X]=this.createPlaneOutline(Yt.POSITIVE_X),this.planeOutlines[Yt.NEGATIVE_X]=this.createPlaneOutline(Yt.NEGATIVE_X),this.planeOutlines[Yt.POSITIVE_Y]=this.createPlaneOutline(Yt.POSITIVE_Y),this.planeOutlines[Yt.NEGATIVE_Y]=this.createPlaneOutline(Yt.NEGATIVE_Y),this.planeOutlines[Yt.NEGATIVE_Z]=this.createPlaneOutline(Yt.NEGATIVE_Z),this.planeOutlines[Yt.POSITIVE_Z]=this.createPlaneOutline(Yt.POSITIVE_Z);const n=new fi;n.name="SectionBoxOutlines",this.viewer.getRenderer().scene.add(n),n.add(this.getPlaneOutline(Yt.NEGATIVE_Z).renderable),n.add(this.getPlaneOutline(Yt.POSITIVE_Z).renderable),n.add(this.getPlaneOutline(Yt.POSITIVE_X).renderable),n.add(this.getPlaneOutline(Yt.NEGATIVE_X).renderable),n.add(this.getPlaneOutline(Yt.POSITIVE_Y).renderable),n.add(this.getPlaneOutline(Yt.NEGATIVE_Y).renderable),this.lastSectionPlanes.push(new kt,new kt,new kt,new kt,new kt,new kt),this.sectionProvider.on(pr.DragStart,this.onSectionBoxDragStart.bind(this)),this.sectionProvider.on(pr.DragEnd,this.onSectionBoxDragEnd.bind(this)),this.sectionProvider.on(pr.Updated,this.sectionUpdated.bind(this))}getPlaneOutline(e){return this.planeOutlines[e]}get enabled(){return this._enabled}set enabled(e){this._enabled=e;for(const t in this.planeOutlines)this.planeOutlines[t].renderable.visible=e}sectionUpdated(e){this.sectionProvider.enabled||(this.enabled=!1);for(const t in this.planeOutlines){const n=e.filter((i=>this.getPlaneId(i)!==t));this.planeOutlines[t].renderable.material.clippingPlanes=n}}requestUpdate(e=!1){this.setSectionPlaneChanged(this.viewer.getRenderer().clippingPlanes),this.updateOutlines(e?this.viewer.getRenderer().clippingPlanes:this.sectionPlanesChanged)}updatePlaneOutline(e,t,n){const i=new A,r=new A,s=new A,o=new A,l=new A,c=new Ui,u=this.getPlaneId(t);if(!u)return void De.error("Invalid plane! Aborting section outline update",t.normal);const h=this.planeOutlines[u].renderable;let d=0,f=h.geometry.attributes.instanceStart.data;const p=new Array;for(let g=0;g<e.length;g++){const v=new kt().copy(t);e[g].mesh.TAS.shapecast({intersectsTAS:y=>v.intersectsBox(y),intersectsBounds:y=>v.intersectsBox(y),intersectsTriangle(y,w,x,S,b){if(!b)throw new Error("Null batch object in AS intersection!");const E=e[g].mesh.getBatchObjectMaterial(b);if(E instanceof Ya||E.visible===!1||E===null)return;const M=v;let T=0;c.start.copy(y.a),c.end.copy(y.b),M.intersectLine(c,i)&&(i.add(l.copy(v.normal).multiplyScalar(-n)),p[3*d]=i.x,p[3*d+1]=i.y,p[3*d+2]=i.z,d++,T++),c.start.copy(y.b),c.end.copy(y.c),M.intersectLine(c,i)&&(i.add(l.copy(v.normal).multiplyScalar(-n)),p[3*d]=i.x,p[3*d+1]=i.y,p[3*d+2]=i.z,T++,d++),c.start.copy(y.c),c.end.copy(y.a),M.intersectLine(c,i)&&(i.add(l.copy(v.normal).multiplyScalar(-n)),p[3*d]=i.x,p[3*d+1]=i.y,p[3*d+2]=i.z,T++,d++),T===3&&(r.set(p[3*(d-3)],p[3*(d-3)+1],p[3*(d-3)+2]),s.set(p[3*(d-2)],p[3*(d-2)+1],p[3*(d-2)+2]),o.set(p[3*(d-1)],p[3*(d-1)+1],p[3*(d-1)+2]),o.equals(r)||o.equals(s)?(T--,d--):r.equals(s)&&(o.set(i.x,i.y,i.z),o.add(l.copy(v.normal).multiplyScalar(-n)),p[3*(d-2)]=o.x,p[3*(d-2)+1]=o.y,p[3*(d-2)+2]=o.z,T--,d--)),T!==2&&(d-=T)}})}p.length>f.array.length&&(this.resizeGeometryBuffer(this.planeOutlines[u],p.length),console.warn(`Resized outline buffer from ${f.array.length} to ${p.length}. ${p.length/6} instance count`)),f=h.geometry.attributes.instanceStart.data;const m=h.geometry.attributes.instanceStartLow.data;ft.DoubleToHighLowBuffer(p,m.array,f.array),f.needsUpdate=!0,f.updateRange={offset:0,count:3*d},m.needsUpdate=!0,m.updateRange={offset:0,count:3*d},h.visible=!0,h.geometry.instanceCount=d/2,h.geometry.attributes.instanceStart.needsUpdate=!0,h.geometry.attributes.instanceEnd.needsUpdate=!0,h.geometry.attributes.instanceStartLow.needsUpdate=!0,h.geometry.attributes.instanceEndLow.needsUpdate=!0,h.geometry.computeBoundingBox(),h.geometry.computeBoundingSphere()}createPlaneOutline(e){const t=new Float64Array(Jr.INITIAL_BUFFER_SIZE),n=new la;n.setPositions(new Float32Array(t)),n.attributes.instanceStart.data.setUsage(Xn),ft.updateRTEGeometry(n,t);const i=new Or({color:294651,linewidth:2,worldUnits:!1,vertexColors:!1,alphaToCoverage:!1,resolution:new te(919,848)},["USE_RTE"]);i.color=new Ie(294651),i.color.convertSRGBToLinear(),i.linewidth=2,i.worldUnits=!1,i.resolution=new te(1513,1306);const r=new ao(n,i);return r.name=`${e}-outline`,r.frustumCulled=!1,r.renderOrder=1,r.layers.set(re.PROPS),r.visible=!1,{renderable:r}}onSectionBoxDragStart(){this.enabled=!1}onSectionBoxDragEnd(){this.setSectionPlaneChanged(this.viewer.getRenderer().clippingPlanes),this.updateOutlines(this.sectionPlanesChanged)}setSectionPlaneChanged(e){this.sectionPlanesChanged.length=0;const t=this.viewer.World.getRelativeOffset(1e-4);for(let n=0;n<e.length;n++)(Math.abs(this.lastSectionPlanes[n].constant-e[n].constant)>t||Math.abs(this.lastSectionPlanes[n].normal.length()-e[n].normal.length())>t)&&this.sectionPlanesChanged.push(e[n]),this.lastSectionPlanes[n].copy(e[n])}updateOutlines(e){const t=performance.now(),n=this.viewer.World.getRelativeOffset(Jr.OUTLINE_Z_OFFSET);for(let i=0;i<e.length;i++)this.updatePlaneOutline(this.viewer.getRenderer().batcher.getBatches(void 0,ze.MESH),e[i],n);this.enabled=this.sectionProvider.enabled,De.warn("Outline time: ",performance.now()-t)}resizeGeometryBuffer(e,t){e.renderable.geometry.dispose();const n=new Float32Array(t);e.renderable.geometry=new la,e.renderable.geometry.setPositions(n),e.renderable.geometry.attributes.instanceStart.data.setUsage(Xn),ft.updateRTEGeometry(e.renderable.geometry,n)}getPlaneId(e){this.tmpVec.set(e.normal.x,e.normal.y,e.normal.z);let t=this.sectionProvider.getBox();t instanceof He&&(t=new Un().fromBox3(t));const n=new ae().setFromMatrix3(t.rotation).invert();return this.tmpVec.applyMatrix4(n).normalize(),this.tmpVec.set(Math.round(this.tmpVec.x),Math.round(this.tmpVec.y),Math.round(this.tmpVec.z)),this.tmpVec.equals(this.right)?Yt.POSITIVE_X:this.tmpVec.equals(this.left)?Yt.NEGATIVE_X:this.tmpVec.equals(this.up)?Yt.POSITIVE_Y:this.tmpVec.equals(this.down)?Yt.NEGATIVE_Y:this.tmpVec.equals(this.back)?Yt.NEGATIVE_Z:this.tmpVec.equals(this.forward)?Yt.POSITIVE_Z:void 0}}Jr.OUTLINE_Z_OFFSET=1e-4,Jr.INITIAL_BUFFER_SIZE=6e4;class d0 extends Zr{get filteringState(){return this.CurrentFilteringState}get enabled(){return this._enabled}set enabled(e){this._enabled=e}constructor(e){super(e),this.StateKey=void 0,this.VisibilityState=new lA,this.ColorStringFilterState=null,this.ColorNumericFilterState=null,this.UserspaceColorState=new cA,this.CurrentFilteringState={},this.idCache={},this.WTI=this.viewer.getWorldTree(),this.Renderer=this.viewer.getRenderer()}hideObjects(e,t=void 0,n=!1,i=!1){return this.setVisibilityState(e,t,Nn.HIDE,n,i)}showObjects(e,t=void 0,n=!1){return this.setVisibilityState(e,t,Nn.SHOW,n)}isolateObjects(e,t=void 0,n=!0,i=!0){return this.setVisibilityState(e,t,Nn.ISOLATE,n,i)}unIsolateObjects(e,t=void 0,n=!0,i=!0){return this.setVisibilityState(e,t,Nn.UNISOLATE,n,i)}setVisibilityState(e,t=void 0,n,i=!1,r=!1){if((t!==this.StateKey||Math.abs(n-this.VisibilityState.command)>1)&&this.VisibilityState.reset(),this.StateKey=t,this.VisibilityState.rvs=[],this.VisibilityState.ghost=r,i&&(e=[...e,...this.getDescendantIds(e)]),n===Nn.SHOW||n===Nn.UNISOLATE)for(let s=0;s<e.length;s++)this.VisibilityState.ids[e[s]]&&delete this.VisibilityState.ids[e[s]];if(n===Nn.HIDE||n===Nn.ISOLATE){const s=e.reduce(((o,l)=>(o[l]=1,o)),{});Object.assign(this.VisibilityState.ids,s)}if(Object.keys(this.VisibilityState.ids).length===0)return this.VisibilityState.command=Nn.NONE,this.setFilters();if(this.VisibilityState.command=n,n!==Nn.HIDE&&n!==Nn.SHOW||this.WTI.walk(this.visibilityWalk.bind(this)),n===Nn.ISOLATE||n===Nn.UNISOLATE){const s={};this.WTI.walk((o=>{if(!o.model.atomic||this.WTI.isRoot(o))return!0;const l=this.WTI.getRenderTree().getRenderViewNodesForNode(o);return this.VisibilityState.ids[o.model.id]?l.forEach((c=>{delete s[c.model.id]})):l.forEach((c=>{this.VisibilityState.ids[c.model.id]||(s[c.model.id]=c.model.renderView)})),!0})),this.VisibilityState.rvs=Object.values(s)}return this.setFilters()}visibilityWalk(e){return this.VisibilityState.ids[e.model.id]&&this.VisibilityState.rvs.push(...this.WTI.getRenderTree().getRenderViewsForNode(e)),!0}setColorFilter(e,t=!0){return e.type==="number"?(this.ColorStringFilterState=null,this.setNumericColorFilter(e,t)):e.type==="string"?(this.ColorNumericFilterState=null,this.setStringColorFilter(e,t)):this.filteringState}setNumericColorFilter(e,t){this.ColorNumericFilterState=new wk,this.ColorNumericFilterState.currentProp=e;const n=e.passMin||e.min,i=e.passMax||e.max,r={};for(let l=0;l<e.valueGroups.length;l++)r[e.valueGroups[l].id]||e.valueGroups[l].value>=n&&e.valueGroups[l].value<=i&&(r[e.valueGroups[l].id]=e.valueGroups[l].value);const s=[],o=[];return this.WTI.walk((l=>{if(!l.model.atomic||this.WTI.isRoot(l)||this.WTI.isSubtreeRoot(l))return!0;const c=this.WTI.getRenderTree().getRenderViewsForNode(l),u=r[l.model.raw.id];return u===void 0?s.push(...c):o.push({rvs:c,value:(u-n)/(i-n)}),!0})),this.ColorNumericFilterState.colorGroups=o,this.ColorNumericFilterState.nonMatchingRvs=s,this.ColorNumericFilterState.ghost=t,this.ColorNumericFilterState.matchingIds=r,this.setFilters()}setStringColorFilter(e,t){this.ColorStringFilterState=new xk,this.ColorStringFilterState.currentProp=e;const n=[];for(const o of e.valueGroups){const l=H2(o.value),c={...o,color:new Ie(l),rvs:[],idMap:{}};c.idMap={};for(let u=0;u<o.ids.length;u++)c.idMap[o.ids[u]]=1;n.push(c)}const i=jn.generateDiscreetRampTexture(n.map((o=>o.color.getHex()))),r={};this.WTI.walk((o=>{if(!o.model.atomic||this.WTI.isRoot(o)||this.WTI.isSubtreeRoot(o))return!0;const l=n.find((h=>h.idMap[o.model.raw.id])),c=this.WTI.getRenderTree().getRenderViewNodesForNode(o);if(!l)return c.forEach((h=>r[h.model.renderView.renderData.id]=h.model.renderView)),!0;const u=[];return c.forEach((h=>{this.WTI.getRenderTree().getAtomicParent(h)===o&&(u.push(h.model.renderView),delete r[h.model.renderView.renderData.id])})),l.rvs.push(...u),!0}));const s=Object.values(r);for(const o of n)delete o.idMap;return this.ColorStringFilterState.colorGroups=n,this.ColorStringFilterState.rampTexture=i,this.ColorStringFilterState.nonMatchingRvs=s,this.ColorStringFilterState.ghost=t,this.setFilters()}removeColorFilter(){return this.ColorNumericFilterState||this.ColorStringFilterState?(this.ColorStringFilterState=null,this.ColorNumericFilterState=null,this.setFilters()):this.filteringState}setUserObjectColors(e){this.UserspaceColorState=new cA,this.ColorNumericFilterState=null,this.ColorStringFilterState=null;const t=e.map((i=>({...i,nodes:[],rvs:[]})));for(const i of t)for(let r=0;r<i.objectIds.length;r++){const s=this.WTI.findId(i.objectIds[r]);s&&(i.nodes.push(...s),s.forEach((o=>{const l=this.WTI.getRenderTree().getRenderViewNodesForNode(o).map((c=>c.model.renderView));l&&i.rvs.push(...l)})))}this.UserspaceColorState.groups=t;const n=jn.generateDiscreetRampTexture(e.map((i=>new Ie(i.color).getHex())));return this.UserspaceColorState.rampTexture=n,this.setFilters()}removeUserObjectColors(){return this.UserspaceColorState=null,this.setFilters()}resetFilters(){return this.VisibilityState=new lA,this.ColorStringFilterState=null,this.ColorNumericFilterState=null,this.UserspaceColorState=null,this.StateKey=void 0,this.Renderer.resetMaterials(),this.CurrentFilteringState={},this.viewer.requestRender(Qt.RENDER_RESET|Qt.SHADOWS),this.emit(Cn.FilteringStateSet,this.CurrentFilteringState),null}setFilters(){var e,t;if(this.viewer.getRenderer().resetMaterials(),this.CurrentFilteringState={},this.ColorStringFilterState){this.CurrentFilteringState.colorGroups=[];let o=-1;for(const l of this.ColorStringFilterState.colorGroups)o++,this.Renderer.setMaterial(l.rvs,{filterType:ei.COLORED,rampIndex:o/this.ColorStringFilterState.colorGroups.length,rampIndexColor:l.color,rampTexture:this.ColorStringFilterState.rampTexture}),this.CurrentFilteringState.colorGroups.push({value:l.value,color:l.color.getHexString(),ids:l.ids}),this.ColorStringFilterState.currentProp&&(this.CurrentFilteringState.activePropFilterKey=this.ColorStringFilterState.currentProp.key)}if(this.ColorNumericFilterState){for(const o of this.ColorNumericFilterState.colorGroups)this.Renderer.setMaterial(o.rvs,{filterType:ei.GRADIENT,rampIndex:o.value});this.CurrentFilteringState.activePropFilterKey=this.ColorNumericFilterState.currentProp.key,this.CurrentFilteringState.passMin=this.ColorNumericFilterState.currentProp.passMin||this.ColorNumericFilterState.currentProp.min,this.CurrentFilteringState.passMax=this.ColorNumericFilterState.currentProp.passMax||this.ColorNumericFilterState.currentProp.max,this.CurrentFilteringState.isolatedObjects=Object.keys(this.ColorNumericFilterState.matchingIds)}const n=this.VisibilityState.command===Nn.HIDE||this.VisibilityState.command===Nn.SHOW,i=this.VisibilityState.command===Nn.ISOLATE||this.VisibilityState.command===Nn.UNISOLATE;(n||i)&&(this.Renderer.setMaterial(this.VisibilityState.rvs,{filterType:this.VisibilityState.ghost?ei.GHOST:ei.HIDDEN}),n&&(this.CurrentFilteringState.hiddenObjects=Object.keys(this.VisibilityState.ids)),i&&(this.CurrentFilteringState.isolatedObjects=Object.keys(this.VisibilityState.ids)));const r=((e=this.ColorStringFilterState)===null||e===void 0?void 0:e.nonMatchingRvs)||((t=this.ColorNumericFilterState)===null||t===void 0?void 0:t.nonMatchingRvs);let s=!1;if(this.ColorStringFilterState&&(s=this.ColorStringFilterState.ghost),this.ColorNumericFilterState&&(s=this.ColorNumericFilterState.ghost),r&&this.Renderer.setMaterial(r,{filterType:s?ei.GHOST:ei.HIDDEN}),this.UserspaceColorState){this.CurrentFilteringState.userColorGroups=[];let o=-1;for(const l of this.UserspaceColorState.groups)o++,this.Renderer.setMaterial(l.rvs,{filterType:ei.COLORED,rampIndex:o/this.UserspaceColorState.groups.length,rampIndexColor:new Ie(l.color),rampTexture:this.UserspaceColorState.rampTexture}),this.CurrentFilteringState.userColorGroups.push({ids:l.objectIds,color:l.color})}return this.Renderer.viewer.requestRender(Qt.RENDER_RESET|Qt.SHADOWS|Qt.CLIPPING_PLANES),this.emit(Cn.FilteringStateSet,this.CurrentFilteringState),this.CurrentFilteringState}getDescendantIds(e){const t=[],n=e.join(",");if(this.idCache[n]&&this.idCache[n].length)return this.idCache[n];for(let i=0;i<e.length;i++){const r=this.WTI.findId(e[i]);if(!r)continue;const s=r[0],o=s.all((l=>l.model.raw!==void 0)).map((l=>l.model.raw.id));t.push(...o),this.idCache[s.model.raw.id]=o}return this.idCache[n]=t,t}}(function(a){a[a.HIDE=10]="HIDE",a[a.SHOW=11]="SHOW",a[a.ISOLATE=20]="ISOLATE",a[a.UNISOLATE=21]="UNISOLATE",a[a.NONE=30]="NONE"})(Nn||(Nn={}));class lA{constructor(){this.command=Nn.NONE,this.ghost=!0,this.ids={},this.rvs=[]}reset(){this.ghost=!0,this.ids={},this.rvs=[]}}class xk{constructor(){this.ghost=!0}reset(){this.currentProp=null,this.colorGroups=[],this.nonMatchingRvs=[],this.rampTexture=void 0}}class wk{constructor(){this.ghost=!0}}class cA{constructor(){this.groups=[]}reset(){this.groups=[]}}(function(a){a.Finshed="explode-finished"})(hf||(hf={}));class bb extends Zr{constructor(){super(...arguments),this._enabled=!0,this.explodeTime=-1,this.explodeRange=0,this.explodeOrigin=new A}get enabled(){return this._enabled}set enabled(e){this._enabled=e}get visibleWorld(){const e=new He,t=this.viewer.getRenderer().batcher.getBatches();for(let n=0;n<t.length;n++){const i=t[n],r=i.renderViews.slice();r.sort(((h,d)=>h.batchStart-d.batchStart));const s=i.getVisibleRange();let o=0,l=r.length;for(;o<l;){const h=o+l>>>1;r[h].batchStart<s.offset?o=h+1:l=h}const c=s.offset,u=s.offset+s.count;for(;o<r.length;o++){const h=r[o];if(h.batchStart>=u)break;const d=h.batchStart+h.batchCount;h.batchStart>=c&&d<=u&&e.union(h.aabb)}}return e}onEarlyUpdate(){this._enabled&&this.explodeTime>-1&&(this.explode(this.explodeTime,this.explodeRange),this.explodeTime=-1)}setExplode(e){const t=this.visibleWorld,n=t.getSize(new A);this.explodeTime=e,this.explodeRange=Math.sqrt(n.x*n.x+n.y*n.y+n.z*n.z),t.getCenter(this.explodeOrigin)}explode(e,t){const n=this.viewer.getRenderer().getObjects(),i=new A;for(let r=0;r<n.length;r++){const s=n[r].aabb.getCenter(i).sub(this.explodeOrigin);s.normalize().multiplyScalar(e*t),n[r].transformTRS(s,void 0,void 0,void 0)}this.viewer.requestRender(Qt.RENDER_RESET|Qt.SHADOWS),this.emit(hf.Finshed)}}class Eb{constructor(e,t){this.spoofIDs=!1,this.typeLookupTable={},this.instanceDefinitionLookupTable={},this.instancedObjectsLookupTable={},this.instanceProxies={},this.renderMaterialMap={},this.colorMap={},this.instanceCounter=0,this.duplicateCounter=0,this.traverseCount=0,this.NodeConverterMapping={View3D:this.View3DToNode.bind(this),BlockInstance:this.BlockInstanceToNode.bind(this),Pointcloud:this.PointcloudToNode.bind(this),Brep:this.BrepToNode.bind(this),BrepX:this.BrepToNode.bind(this),ExtrusionX:this.BrepToNode.bind(this),SubDX:this.BrepToNode.bind(this),Mesh:this.MeshToNode.bind(this),Point:this.PointToNode.bind(this),Line:this.LineToNode.bind(this),Polyline:this.PolylineToNode.bind(this),Box:this.BoxToNode.bind(this),Polycurve:this.PolycurveToNode.bind(this),Curve:this.CurveToNode.bind(this),Circle:this.CircleToNode.bind(this),Arc:this.ArcToNode.bind(this),Ellipse:this.EllipseToNode.bind(this),RevitInstance:this.RevitInstanceToNode.bind(this),Text:this.TextToNode.bind(this),Dimension:this.DimensionToNode.bind(this),InstanceDefinitionProxy:this.InstanceDefinitionProxyToNode.bind(this),InstanceProxy:this.InstanceProxyToNode.bind(this),RenderMaterialProxy:this.RenderMaterialProxyToNode.bind(this),ColorProxy:this.ColorProxyToNode.bind(this),Region:this.RegionToNode.bind(this),Parameter:null},this.IgnoreNodes=["Parameter","RawEncoding"],e||De.warn("Converter initialized without a corresponding object loader. Any objects that include references will throw errors."),this.objectLoader=e,this.activePromises=0,this.maxChildrenPromises=200,this.tree=t}async traverse(e,t,n,i=null){try{if(t===null||typeof t!="object")return;t.referencedId&&(t=await this.resolveReference(t));const r=[];if(Array.isArray(t)){for(const c of t){if(typeof c!="object")break;if(this.activePromises>=this.maxChildrenPromises)await this.traverse(e,c,n,i);else{const u=this.traverse(e,c,n,i);r.push(u)}}return void(r.length>0&&(this.activePromises+=r.length,await Promise.all(r),this.activePromises-=r.length))}if(this.IgnoreNodes.includes(this.getSpeckleType(t))||!t.id)return;const s=this.tree.parse({id:this.getNodeId(t),raw:t,atomic:!0,children:[]});if(i===null?(this.subtree=this.tree.parse({id:e,raw:{id:e,children:[t]},atomic:!0,children:[]}),this.tree.addSubtree(this.subtree),this.addNode(s,this.subtree)):this.addNode(s,i),this.directNodeConverterExists(t))try{return void await this.convertToNode(t,s)}catch(c){De.warn(`(Traversing - direct) Failed to convert ${this.getSpeckleType(t)} with id: ${t.id}`,c)}const o=t;let l=this.getDisplayValue(o);if(s.model.atomic=!!l,l){if(Array.isArray(l))for(const c of l){const u=await this.resolveReference(c);u.units||(u.units=t.units);const h=this.tree.parse({id:this.getNodeId(u),raw:u,atomic:!1,children:[]});this.addNode(h,s),await this.convertToNode(u,h)}else{l=await this.resolveReference(l),l.units||(l.units=t.units);try{const c=this.tree.parse({id:this.getNodeId(l),raw:l,atomic:!1,children:[]});this.addNode(c,s),await this.convertToNode(l,c)}catch(c){De.warn(`(Traversing) Failed to convert obj with id: ${t.id}  ${c.message}`)}}if(t.speckle_type.toLowerCase().includes("builtelements")||t.speckle_type.toLowerCase().includes("objects.data")){const c=this.getElementsValue(t);return void(c&&(r.push(this.traverse(e,c,n,s)),this.activePromises+=r.length,await Promise.all(r),this.activePromises-=r.length))}}for(const c in o)if(c!=="__parents"&&c!=="bbox"&&c!=="__closure"&&!["displayMesh","@displayMesh","displayValue","@displayValue"].includes(c)&&typeof o[c]=="object"&&o[c]!==null)if(this.activePromises>=this.maxChildrenPromises)await this.traverse(e,o[c],n,s);else{const u=this.traverse(e,o[c],n,s);r.push(u)}r.length>0&&(this.activePromises+=r.length,await Promise.all(r),this.activePromises-=r.length)}finally{n(this.traverseCount++)}}getNodeId(e){return this.spoofIDs?It.generateUUID():e.id}addNode(e,t){this.tree.hasNodeId(e.model.id,t.model.subtreeId)&&(e.model.id=this.getDuplicateId(e.model.id,++this.duplicateCounter)),this.tree.addNode(e,t)}async dechunk(e){if(!e||e.length===0||Array.isArray(e[0])&&!e[0].referencedId)return e;if(!e[0].referencedId)return e[0]instanceof Object?e:[{data:e,id:It.generateUUID(),references:1}];const t=[];for(const n of e){const i=await this.objectLoader.getObject({id:n.referencedId});i.references===void 0?i.references=1:i.references++,i.data.length&&(typeof i.data[0]!="number"||isNaN(i.data[0]))&&De.error(`Chunk id ${i.id} might not have numeric geometry data. This is not supported!`),t.push(i)}return t}async resolveReference(e){return e.referencedId?await this.objectLoader.getObject({id:e.referencedId}):e}getSpeckleType(e){const t=e.speckle_type?e.speckle_type:"Base",n=this.typeLookupTable[t];if(n)return n;let i="Base";const r=this.getSpeckleTypeChain(e);for(const s of r)if(s in this.NodeConverterMapping){i=s;break}return this.typeLookupTable[t]=i,i}getSpeckleTypeChain(e){let t=["Base"];return t=e.speckle_type?e.speckle_type.split(":").reverse():t,t=t.map((n=>n.split(".").reverse()[0])),t}directNodeConverterExists(e){return this.getSpeckleType(e)in this.NodeConverterMapping}async convertToNode(e,t){e.referencedId&&(e=await this.resolveReference(e));try{if(this.directNodeConverterExists(e)){const n=this.NodeConverterMapping[this.getSpeckleType(e)];if(n)return await n(e,t)}return null}catch(n){throw De.warn(`(Direct convert) Failed to convert object with id: ${e.id}`),n}}getDisplayValue(e){const t=e.displayValue||e["@displayValue"]||e.displayMesh||e["@displayMesh"];if(t){if(Array.isArray(t)){const n=t.filter((i=>i));return t.length!==n.length&&De.warn(`Object ${e.id} has null display values which will be ignored`),n}return t}return null}getElementsValue(e){return e.elements||e["@elements"]}getBlockDefinition(e){return e["@blockDefinition"]||e.blockDefinition||e.definition||e["@definition"]}getBlockDefinitionGeometry(e){return e["@geometry"]||e.geometry}getCompoundId(e,t){const n=e.indexOf(wn.COMPOUND_ID_CHAR);return n===-1?e+wn.COMPOUND_ID_CHAR+t:e.substring(0,n)+wn.COMPOUND_ID_CHAR+t}getDuplicateId(e,t){const n=e.indexOf(wn.DUPLICATE_ID_CHAR);return n===-1?e+wn.DUPLICATE_ID_CHAR+t:e.substring(0,n)+wn.DUPLICATE_ID_CHAR+t}getEmptyTransformData(e){return{id:e,speckle_type:"Transform",units:"m",matrix:new Array(16)}}async View3DToNode(e,t){e.origin.units=e.units,e.target.units=e.units}async displayableLookup(e,t,n){if(this.directNodeConverterExists(e))await this.convertToNode(e,t);else{const i=this.getDisplayValue(e),r=this.getElementsValue(e),s=[...i||[],...r||[]];for(const o of s){const l=await this.resolveReference(o),c=this.tree.parse({id:this.getCompoundId(l.id,this.instanceCounter++),raw:l,atomic:!1,children:[],instanced:n});this.addNode(c,t),await this.displayableLookup(l,c,n)}}}async parseInstanceDefinitionGeometry(e,t,n){const i=It.generateUUID();let r=null;Array.isArray(e.transform)?(r=this.getEmptyTransformData(i),r.units=e.units,r.matrix=e.transform):r=e.transform?e.transform:this.getEmptyTransformData(i);const s=this.tree.parse({id:i,raw:r,atomic:!1,children:[]});this.addNode(s,n);const o=this.tree.parse({id:this.getCompoundId(t.id,this.instanceCounter++),raw:t,atomic:!1,children:[],instanced:!0});this.addNode(o,s),await this.displayableLookup(t,o,!0)}async parseInstanceElement(e,t,n){const i=this.tree.parse({id:this.getNodeId(t),raw:t,atomic:!1,children:[]});this.addNode(i,n),await this.displayableLookup(t,i,!1)}async BlockInstanceToNode(e,t){const n=await this.resolveReference(this.getBlockDefinition(e));t.model.raw.definition=n;for(const r of this.getBlockDefinitionGeometry(n)){const s=await this.resolveReference(r);await this.parseInstanceDefinitionGeometry(e,s,t)}const i=this.getElementsValue(e);if(i)for(const r of i){const s=await this.resolveReference(r);this.parseInstanceElement(e,s,t)}}async RevitInstanceToNode(e,t){const n=await this.resolveReference(e.definition);t.model.raw.definition=n,await this.parseInstanceDefinitionGeometry(e,n,t);const i=this.getElementsValue(e);if(i)for(const r of i){const s=await this.resolveReference(r);this.parseInstanceElement(e,s,t)}}async InstanceDefinitionProxyToNode(e,t){e.applicationId?this.instanceDefinitionLookupTable[e.applicationId]=t:De.warn(`Instance Definition Proxy ${e.id} has no applicationId`)}async InstanceProxyToNode(e,t){e.applicationId?this.instanceProxies[e.applicationId]=t:De.warn(`Instance proxy ${e.id} has no application id`)}async RenderMaterialProxyToNode(e,t){if(!e.value)return void De.error(`Render Material Proxy ${e.id} has no render material value!`);e.objects&&Array.isArray(e.objects)&&e.objects.length!==0||De.warn(`Render Material Proxy ${e.id} has no target objects!`);const n=e.value,i=e.objects;for(let r=0;r<i.length;r++)this.renderMaterialMap[i[r]]&&De.warn(`Overwritting renderMaterial ${i[r]}`),this.renderMaterialMap[i[r]]=n}async ColorProxyToNode(e,t){if(!e.value||typeof e.value!="number")return void De.error(`Color ${e.id} has no value, or value is not a number!`);if(!e.objects||!Array.isArray(e.objects)||e.objects.length===0)return void De.warn(`Color Proxy ${e.id} has no target objects!`);const n=e.objects;for(let i=0;i<n.length;i++)this.colorMap[n[i]]&&De.warn(`Overwritting color ${n[i]}`),this.colorMap[n[i]]=e}getInstanceProxyDefinitionId(e){return e.DefinitionId||e.definitionId}getInstanceProxyTransform(e){return e.transform||e.Transform?e.transform||e.Transform:new ae().toArray()}getInstanceProxyDefinitionObjects(e){return e.Objects||e.objects}createTransformNode(e){const t=It.generateUUID(),n=this.getEmptyTransformData(t);return n.units=e.units,n.matrix=this.getInstanceProxyTransform(e),this.tree.parse({id:t,raw:n,atomic:!1,children:[]})}async ConvertInstanceProxyToNode(e,t){const n=this.getInstanceProxyDefinitionId(e);if(!n)return void De.warn(`Instance Proxy ${e.id} has no definitionId`);const i=this.instanceDefinitionLookupTable[n],r=this.createTransformNode(e);this.addNode(r,t);const s=this.getInstanceProxyDefinitionObjects(i.model.raw);for(const o of s){const l=this.instancedObjectsLookupTable[o];if(!l){De.warn(`Object ${o} is is missing from definition ${n}. Someone probably sent an instance containing unsopprted elements - this is ok, do not panic.`);continue}const c=this.tree.parse({id:this.getCompoundId(l.id,this.instanceCounter++),raw:l,atomic:!1,children:[],instanced:!0});this.addNode(c,r),await this.displayableLookup(l,c,!0)}}async convertInstances(){this.NodeConverterMapping.InstanceProxy=this.ConvertInstanceProxyToNode.bind(this);const e={};let t=0;for(const n in this.instanceDefinitionLookupTable){const i=this.instanceDefinitionLookupTable[n],r=this.getInstanceProxyDefinitionObjects(i.model.raw);for(let s=0;s<r.length;s++)e[r[s].toString()]=null,t++}await this.tree.walkAsync((n=>{if(!n.model.raw.applicationId)return!0;const i=n.model.raw.applicationId.toString();return e[i]!==void 0&&(e[i]=n,t--),t!==0}),this.subtree);for(const n in e){const i=e[n];if(i){if(this.instancedObjectsLookupTable[n]=i.model.raw,this.instanceProxies[n]){const r=this.instanceProxies[n].model.raw.definitionId;Object.values(this.instanceProxies).forEach((s=>{s.model.raw.definitionId===r&&(s.model.raw.parentLayerApplicationId=s.parent.model.raw.applicationId)}))}else this.instancedObjectsLookupTable[n].parentLayerApplicationId=i.parent.model.raw.applicationId;delete this.instanceProxies[n],this.tree.removeNode(i,!0)}else De.error(`Consumable applicationId ${n} could not be found`)}for(const n in this.instanceProxies){const i=this.instanceProxies[n];await this.convertToNode(i.model.raw,i)}}async applyMaterials(){const e=Object.keys(this.renderMaterialMap).length,t=Object.keys(this.colorMap).length;if(e!==0||t!==0){await this.tree.walkAsync((n=>{if(!n.model.raw.applicationId)return!0;const i=n.model.raw.applicationId.toString(),r=n.model.raw.parentLayerApplicationId;return this.renderMaterialMap[i]?n.model.raw.renderMaterial=this.renderMaterialMap[i]:this.renderMaterialMap[r]&&(n.model.raw.renderMaterial=this.renderMaterialMap[r]),this.colorMap[i]===void 0||n.model.instanced||(n.model.color=this.colorMap[i].value),!0}),this.subtree);for(const n in this.instanceProxies){const i=this.tree.findAll((s=>this.getSpeckleType(s.model.raw)===et.InstanceProxy),this.instanceProxies[n]).reduce(((s,o)=>s&&s.model.raw.maxDepth>o.model.raw.maxDepth?s:o)).model.raw.maxDepth,r=this.tree.findAll((s=>s.model.raw.maxDepth===i),this.instanceProxies[n]);for(let s=0;s<r.length;s++){const o=this.colorMap[r[s].model.raw.applicationId]||this.colorMap[r[s].model.raw.parentLayerApplicationId],l=r[s].children[0].children;for(let c=0;c<l.length;c++){const u=this.colorMap[l[c].model.raw.applicationId],h=this.colorMap[l[c].model.raw.parentLayerApplicationId];if(u){if(u.source==="object"||u.source==="layer")l[c].model.color=u.value;else if(u.source==="block"&&o){if(o.source==="object")l[c].model.color=o.value;else if(o.source==="block"){const d=this.tree.getAncestors(r[s]).find((p=>this.getSpeckleType(p.model.raw)===et.InstanceProxy))||r[s],f=this.colorMap[d.model.raw.applicationId];l[c].model.color=f?.value}}}else l[c].model.color=h?.value}}}}}async PointcloudToNode(e,t){t.model.raw.points=await this.dechunk(e.points),t.model.raw.colors=await this.dechunk(e.colors)}async BrepToNode(e,t){try{if(!e)return;let n=this.getDisplayValue(e);if(Array.isArray(n)&&(n=n[0]),!n)return;const i=await this.resolveReference(n),r=this.tree.parse({id:t.model.instanced?this.getCompoundId(i.id,this.instanceCounter++):this.getNodeId(i),raw:i,atomic:!1,children:[],...t.model.instanced&&{instanced:t.model.instanced}});await this.convertToNode(i,r),this.addNode(r,t),delete e.Edges,delete e.Faces,delete e.Loops,delete e.Trims,delete e.Curve2D,delete e.Curve3D,delete e.Surfaces,delete e.Vertices}catch(n){throw De.warn(`Failed to convert brep id: ${e.id}`),n}}async MeshToNode(e,t){if(e){if(!e.vertices||e.vertices.length===0)return De.warn(`Object id ${e.id} of type ${e.speckle_type} has no vertex position data and will be ignored`),t.model.raw.vertices=[],t.model.raw.faces=[],t.model.raw.colors=[],void(t.model.raw.vertexNormals=[]);if(!e.faces||e.faces.length===0)return De.warn(`Object id ${e.id} of type ${e.speckle_type} has no face data and will be ignored`),t.model.raw.vertices=[],t.model.raw.faces=[],t.model.raw.colors=[],void(t.model.raw.vertexNormals=[]);t.model.raw.vertices=await this.dechunk(e.vertices),t.model.raw.faces=await this.dechunk(e.faces),t.model.raw.colors=await this.dechunk(e.colors),t.model.raw.vertexNormals=await this.dechunk(e.vertexNormals)}}async RegionToNode(e,t){try{if(!e)return;let n=this.getDisplayValue(e);if(Array.isArray(n)&&(n=n[0]),!n)return;const i=await this.resolveReference(n),r=this.tree.parse({id:t.model.instanced?this.getCompoundId(i.id,this.instanceCounter++):this.getNodeId(i),raw:i,atomic:!1,children:[],...t.model.instanced&&{instanced:t.model.instanced}});await this.convertToNode(i,r),this.addNode(r,t)}catch(n){throw De.warn(`Failed to convert Region id: ${e.id}`),n}}async TextToNode(e,t){}async DimensionToNode(e,t){const n=[...this.getDisplayValue(e)];for(const s of n){const o=this.tree.parse({id:this.getNodeId(s),raw:s,atomic:!1,children:[]});this.addNode(o,t),await this.convertToNode(s,o)}const i=JSON.parse(JSON.stringify(e));switch(i.plane=i.RhinoProps.plane,this.getSpeckleTypeChain(i)[0]){case"LengthDimension":i.plane.origin=i.position;break;case"DistanceDimension":case"AngleDimension":i.plane.origin=i.textPosition}i.speckle_type="Objects.Other.Text";const r=this.tree.parse({id:It.generateUUID(),raw:i,atomic:!1,children:[]});this.addNode(r,t),await this.convertToNode(i,r)}async PointToNode(e,t){}async LineToNode(e,t){}async PolylineToNode(e,t){t.model.raw.value=await this.dechunk(e.value)}async BoxToNode(e,t){}async PolycurveToNode(e,t){t.model.nestedNodes=[];for(let n=0;n<e.segments.length;n++){let i=e.segments[n];this.directNodeConverterExists(i)||(i=this.getDisplayValue(i),i.referencedId&&(i=await this.resolveReference(i)));const r=this.tree.parse({id:this.getNodeId(i),raw:i,atomic:!1,children:[]});await this.convertToNode(i,r),t.model.nestedNodes.push(r)}}async CurveToNode(e,t){let n=this.getDisplayValue(e);if(!n)return void De.warn(`Object ${e.id} of type ${e.speckle_type} has no display value and will be ignored`);t.model.nestedNodes=[],n=await this.resolveReference(e.displayValue),n.units=n.units||e.units;const i=this.tree.parse({id:this.getNodeId(n),raw:n,atomic:!1,children:[]});await this.convertToNode(n,i),t.model.nestedNodes.push(i)}async CircleToNode(e,t){}async ArcToNode(e,t){}async EllipseToNode(e,t){}handleDuplicates(){var e;const t=Mu.slice();t.splice(Mu.indexOf(et.Point),1);const n=(e=this.tree.getRenderTree(this.subtree.model.id))===null||e===void 0?void 0:e.getDuplicates();for(const i in n){const r=this.tree.findId(i);if(!r){De.warn(`Base duplicated object ${i} not found!`);continue}const s=this.getSpeckleType(r[0].model.raw);if(t.includes(s))for(const o in n[i])n[i][o].model.raw=structuredClone(n[i][o].model.raw)}return Promise.resolve()}}(function(a){a.LoadProgress="load-progress",a.LoadCancelled="load-cancelled",a.LoadWarning="load-warning",a.Converted="converted",a.Traversed="traversed"})(Xi||(Xi={}));class f0 extends Ku{constructor(e,t){super(),this._resource=e,this._resourceData=t}on(e,t){super.on(e,t)}dispose(){super.dispose()}}const uA=new A,hA=new A,Ak=new A,Sk=new A,Mk=new A,cc=new Ht;class bk{static triangulateFace(e,t,n,i,r){let s=t.get(e);function o(m){return e+m+1}function l(m,g){const v=3*t.get(o(m));return g.x=n.get(v),g.y=n.get(v+1),g.z=n.get(v+2),g}s<3&&(s+=3);const c=Mk;for(let m=s-1,g=0;g<s;m=g,g++){const v=l(m,uA),y=l(g,hA);c.x+=(y.y-v.y)*(v.z+y.z),c.y+=(y.z-v.z)*(v.x+y.x),c.z+=(y.x-v.x)*(v.y+y.y)}c.normalize();const u=[],h=[];for(let m=0;m<s;m++)u[m]=m-1,h[m]=m+1;u[0]=s-1,h[s-1]=0;let d=0,f=0,p=0;for(;s>=3;){let m=!0;if(s>3&&f<s){const g=l(u[d],uA),v=l(d,hA),y=l(h[d],Ak);if(cc.a.copy(g),cc.b.copy(v),cc.c.copy(y),cc.isFrontFacing(c)){let w=h[h[d]];do{if(cc.containsPoint(l(w,Sk))){m=!1;break}w=h[w]}while(w!==u[d])}else m=!1}if(m){const g=t.get(o(d)),v=t.get(o(h[d])),y=t.get(o(u[d]));i[r+p]=g,i[r+p+1]=v,i[r+p+2]=y,p+=3,h[u[d]]=h[d],u[h[d]]=u[d],s--,d=u[d],f=0}else d=h[d],f++}return p}}const Ek=new A,Tk=new A,Ck=new A,Ik=new A,Rk=new A,Pk=new A;class Tb extends l0{constructor(){super(...arguments),this.typeLookupTable={},this.meshTriangulationTime=0,this.actualTriangulateTime=0,this.pushTime=0}getSpeckleType(e){const t=e.raw.speckle_type?e.raw.speckle_type:"Base",n=this.typeLookupTable[t];if(n)return n;let i=et.Unknown,r=[];r=t.split(":").reverse(),r=r.map((s=>s.split(".").reverse()[0]));for(const s of r)if(s in et){i=s;break}return this.typeLookupTable[t]=i,i}convertNodeToGeometryData(e){switch(this.getSpeckleType(e)){case et.BlockInstance:return this.BlockInstanceToGeometryData(e);case et.Pointcloud:return this.PointcloudToGeometryData(e);case et.Brep:return this.BrepToGeometryData(e);case et.Mesh:return this.MeshToGeometryData(e);case et.Point:return this.PointToGeometryData(e);case et.Line:return this.LineToGeometryData(e);case et.Polyline:return this.PolylineToGeometryData(e);case et.Box:return this.BoxToGeometryData(e);case et.Polycurve:return this.PolycurveToGeometryData(e);case et.Curve:return this.CurveToGeometryData(e);case et.Circle:return this.CircleToGeometryData(e);case et.Arc:return this.ArcToGeometryData(e);case et.Ellipse:return this.EllipseToGeometryData(e);case et.View3D:return this.View3DToGeometryData(e);case et.RevitInstance:return this.RevitInstanceToGeometryData(e);case et.Text:return this.TextToGeometryData(e);case et.Transform:return this.TransformToGeometryData(e);case et.InstanceProxy:return this.InstanceProxyToGeometyData(e);case et.Region:return this.RegionGeometyData(e);case et.Unknown:default:return null}}disposeNodeGeometryData(e){switch(this.getSpeckleType(e)){case et.Pointcloud:e.raw.vertices=[],e.raw.colors=[];break;case et.Mesh:e.raw.vertices=[],e.raw.faces=[],e.raw.colors=[],e.raw.normals=[],e.raw.colors.forEach((t=>{t.references--,t.references||(De.warn(`Deleting chunk data ${t.id}`),delete t.data)}));break;case et.Point:e.raw.value?e.raw.value=[]:(delete e.raw.x,delete e.raw.y,delete e.raw.z);break;case et.Line:e.raw.start.value?e.raw.start.value=[]:(delete e.raw.start.x,delete e.raw.start.y,delete e.raw.start.z),e.raw.end.value?e.raw.end.value=[]:(delete e.raw.end.x,delete e.raw.end.y,delete e.raw.end.z);break;case et.Polyline:e.raw.value=[]}}View3DToGeometryData(e){const t=this.PointToVector3(e.raw.origin),n=this.PointToVector3(e.raw.target);return e.raw.origin=t,e.raw.target=n,{attributes:null,bakeTransform:null,transform:null}}TransformToGeometryData(e){const t=xn(e.raw.units),n=e.raw.value?e.raw.value:e.raw.matrix,i=new ae().fromArray(n).transpose();return{attributes:null,bakeTransform:null,transform:new ae().makeScale(t,t,t).multiply(i).multiply(new ae().makeScale(1/t,1/t,1/t))}}BlockInstanceToGeometryData(e){return null}RevitInstanceToGeometryData(e){return null}InstanceProxyToGeometyData(e){return null}PointcloudToGeometryData(e){const t=xn(e.raw.units),n=new Zt(e.instanced?e.raw.points.slice():e.raw.points),i=new Zt(e.raw.colors);let r=null;return i&&i.length!==0&&(i.length!==n.length/3&&De.warn(`Mesh (id ${e.raw.id}) colours are mismatched with vertice counts. The number of colours must equal the number of vertices.`),r=this.unpackColors(i,!0)),{attributes:{POSITION:n,COLOR:r?new Zt([{data:r,id:It.generateUUID(),references:1}]):void 0},bakeTransform:new ae().makeScale(t,t,t),transform:null}}BrepToGeometryData(e){return null}RegionGeometyData(e){return null}MeshToGeometryData(e){if(!e.raw)return null;const t=xn(e.raw.units);if(!e.raw.vertices||!e.raw.faces)return null;const n=performance.now(),i=new Zt(e.raw.vertices),r=new Zt(e.raw.faces),s=this.chunkArrayHasData(e.raw.colors)?new Zt(e.raw.colors):void 0;let o,l=e.raw.vertexNormals?new Zt(e.raw.vertexNormals):void 0,c=0,u=!0,h=0;for(;c<r.length;){const p=r.findChunkIndex(c);if(r.chunkArray[p].processed){c+=r.chunkArray[p].data.length;continue}let m=r.get(c);m<3&&(m+=3),c+=m+1,m!==3?(h+=3*(m-2),u=!1):h+=3}const d=h>=65535||i.length>=65535?new Uint32Array(h):new Uint16Array(h);let f=0;if(u)r.chunkArray.forEach((p=>{if(p.processed)return;let m=0;for(let g=0;g<p.data.length;g++)g%4!=0&&(p.data[m++]=p.data[g]);p.data.length=m,p.processed=!0})),r.updateOffsets();else for(c=0;c<r.length;){const p=r.findChunkIndex(c);if(r.chunkArray[p].processed){d.set(r.chunks[p],c),c+=r.chunkArray[p].data.length;continue}let m=r.get(c);if(m<3&&(m+=3),m===3)d[f]=r.get(c+1),d[f+1]=r.get(c+2),d[f+2]=r.get(c+3),f+=3;else{const g=performance.now();f+=bk.triangulateFace(c,r,i,d,f),this.actualTriangulateTime+=performance.now()-g}c+=m+1}return this.meshTriangulationTime+=performance.now()-n,s&&s.length!==0&&(s.length!==i.length/3?De.warn(`Mesh (id ${e.raw.id}) colours are mismatched with vertice counts. The number of colours must equal the number of vertices.`):o=new Zt([{id:It.generateUUID(),references:1,data:this.unpackColors(s,!0)}])),l&&l.length!==0?l.length!==i.length&&(De.warn(`Mesh (id ${e.raw.id}) normals are mismatched with vertice counts. The number of normals must equal the number of vertices.`),l=void 0):l=void 0,{attributes:{POSITION:i,INDEX:u?r:new Zt([{data:d,id:It.generateUUID(),references:1}]),...o&&{COLOR:o},...l&&{NORMAL:l}},bakeTransform:new ae().makeScale(t,t,t),transform:null,...e.instanced&&{instanced:!0}}}TextToGeometryData(e){const t=xn(e.raw.units),n=e.raw.plane||{origin:e.raw.origin,xdir:new A(1,0,0),ydir:new A(0,1,0),normal:new A(0,0,1)},i=e.raw.screenOriented||!1,r=new A(n.origin.x,n.origin.y,n.origin.z),s=new ae().makeScale(t,t,t),o=i?new ae:new ae().makeBasis(n.xdir,n.ydir,n.normal);return o.setPosition(r),o.premultiply(s),{attributes:null,bakeTransform:o,transform:null,metaData:e.raw}}PointToGeometryData(e){const t=xn(e.raw.units),n=this.PointToFloatArray(e.raw);return{attributes:{POSITION:new Zt([{data:n,id:It.generateUUID(),references:1}])},bakeTransform:new ae().makeScale(t,t,t),transform:null}}LineToGeometryData(e){const t=xn(e.raw.units);return{attributes:{POSITION:new Zt([{data:this.PointToFloatArray(e.raw.start).concat(this.PointToFloatArray(e.raw.end)),id:It.generateUUID(),references:1}])},bakeTransform:new ae().makeScale(t,t,t),transform:null}}PolylineToGeometryData(e){const t=xn(e.raw.units),n=new Zt(e.raw.value);let i=n;if(e.raw.closed){const r=new Float32Array(n.length+3);n.copyToBuffer(r,0),r[n.length]=r[0],r[n.length+1]=r[1],r[n.length+2]=r[2],i=new Zt([{data:r,id:It.generateUUID(),references:1}])}return{attributes:{POSITION:i},bakeTransform:new ae().makeScale(t,t,t),transform:null}}BoxToGeometryData(e){const t=xn(e.raw.units),n=new ae,i=new ae;if(e.raw.basePlane){n.setPosition(this.PointToVector3(e.raw.basePlane.origin));const u=1e-7,h=new A().copy(e.raw.basePlane.xdir),d=new A().copy(e.raw.basePlane.ydir),f=new A().copy(e.raw.basePlane.normal);Math.abs(h.dot(d))<u&&Math.abs(h.dot(f))<u&&Math.abs(d.dot(f))<u?i.makeBasis(e.raw.basePlane.xdir,e.raw.basePlane.ydir,e.raw.basePlane.normal):De.warn(`Box ${e.raw.id} does not have orthogonal base plane vectors`)}else De.warn(`Box ${e.raw.id} is missing it's base plane`);const r=(e.raw.xSize.end-e.raw.xSize.start)*t,s=(e.raw.ySize.end-e.raw.ySize.start)*t,o=(e.raw.zSize.end-e.raw.zSize.start)*t,l=new He(new A(.5*-r,.5*-s,.5*-o),new A(.5*r,.5*s,.5*o)),c=[l.min.x,l.min.y,l.min.z,l.min.x,l.max.y,l.min.z,l.min.x,l.min.y,l.max.z,l.min.x,l.max.y,l.max.z,l.min.x,l.min.y,l.min.z,l.min.x,l.min.y,l.max.z,l.min.x,l.max.y,l.min.z,l.min.x,l.max.y,l.max.z,l.max.x,l.min.y,l.min.z,l.max.x,l.max.y,l.min.z,l.max.x,l.min.y,l.max.z,l.max.x,l.max.y,l.max.z,l.max.x,l.min.y,l.min.z,l.max.x,l.min.y,l.max.z,l.max.x,l.max.y,l.min.z,l.max.x,l.max.y,l.max.z,l.max.x,l.min.y,l.max.z,l.min.x,l.min.y,l.max.z,l.max.x,l.min.y,l.min.z,l.min.x,l.min.y,l.min.z,l.max.x,l.max.y,l.max.z,l.min.x,l.max.y,l.max.z,l.max.x,l.max.y,l.min.z,l.min.x,l.max.y,l.min.z];return{attributes:{POSITION:new Zt([{data:c,id:It.generateUUID(),references:1}])},bakeTransform:new ae().copy(n).multiply(i),transform:null}}PolycurveToGeometryData(e){if(!e.nestedNodes||e.nestedNodes.length===0)return null;const t=[];for(let n=0;n<e.nestedNodes.length;n++){const i=e.nestedNodes[n].model,r=this.convertNodeToGeometryData(i);t.push(r)}return ft.mergeGeometryData(t)}CurveToGeometryData(e){if(!e.nestedNodes||e.nestedNodes.length===0)return null;const t=this.PolylineToGeometryData(e.nestedNodes[0].model);return t&&t.attributes?{attributes:{POSITION:t.attributes.POSITION},bakeTransform:t.bakeTransform,transform:null}:null}CircleToGeometryData(e){const t=xn(e.raw.units),n=this.getCircularCurvePoints(e.raw.plane,e.raw.radius*t);return{attributes:{POSITION:new Zt([{data:n,id:It.generateUUID(),references:1}])},bakeTransform:null,transform:null}}ArcToGeometryData(e){const t=new A(e.raw.plane.origin.x,e.raw.plane.origin.y,e.raw.plane.origin.z),n=new A(e.raw.startPoint.x,e.raw.startPoint.y,e.raw.startPoint.z),i=new A(e.raw.endPoint.x,e.raw.endPoint.y,e.raw.endPoint.z),r=new A(e.raw.midPoint.x,e.raw.midPoint.y,e.raw.midPoint.z),s=new A().subVectors(n,r).normalize(),o=new A().subVectors(i,r).normalize(),l=s.dot(o)>0,c=new A().subVectors(n,t);c.normalize();const u=new A().subVectors(i,t);u.normalize();const h=new A().crossVectors(c,u);if(h.normalize(),h.length()===0){const b=new A().subVectors(r,t);b.normalize(),h.copy(new A().crossVectors(c,b)),h.normalize()}const d=new A().crossVectors(h,c);d.normalize();const f=Math.min(Math.max(c.dot(u),-1),1),p=Math.acos(f),m=e.raw.radius,g=new Il(0,0,m,m,0,p,l,0).getPoints(50),v=new ae,y=xn(e.raw.plane.units),w=new ae().makeBasis(c,d,h),x=new ae().setPosition(t.multiplyScalar(y));v.multiply(x).multiply(w);const S=new ae().scale(new A(y,y,y));return v.multiply(S),{attributes:{POSITION:new Zt([{data:this.FlattenVector3Array(g),id:It.generateUUID(),references:1}])},bakeTransform:v,transform:null}}EllipseToGeometryData(e){const t=xn(e.raw.units),n=new A(e.raw.plane.origin.x,e.raw.plane.origin.y,e.raw.plane.origin.z).multiplyScalar(t),i=new A(e.raw.plane.xdir.x,e.raw.plane.xdir.y,e.raw.plane.xdir.z).normalize(),r=new A(e.raw.plane.ydir.x,e.raw.plane.ydir.y,e.raw.plane.ydir.z).normalize();let s=2*Math.PI*e.raw.firstRadius*t*10;s=parseInt(s.toString());const o=[];for(let l=0;l<=s;l++){const c=l*Math.PI*2/s,u=Math.cos(c)*e.raw.firstRadius*t,h=Math.sin(c)*e.raw.secondRadius*t,d=new A(i.x*u,i.y*u,i.z*u),f=new A(r.x*h,r.y*h,r.z*h),p=new A().addVectors(d,f).add(n);o.push(p)}return{attributes:{POSITION:new Zt([{data:this.FlattenVector3Array(o),id:It.generateUUID(),references:1}])},bakeTransform:null,transform:null}}getCircularCurvePoints(e,t,n=0,i=2*Math.PI,r=127){const s=this.PointToVector3(e.origin,Ek),o=this.PointToVector3(e.xdir,Tk),l=this.PointToVector3(e.ydir,Ck);o.normalize(),l.normalize();const c=new Float64Array(3*(r+1));for(let u=0;u<=r;u++){const h=n+u*(i-n)/r,d=Math.cos(h)*t,f=Math.sin(h)*t,p=Ik.set(o.x*d,o.y*d,o.z*d),m=Rk.set(l.x*f,l.y*f,l.z*f),g=Pk.addVectors(p,m).add(s);c[3*u]=g.x,c[3*u+1]=g.y,c[3*u+2]=g.z}return c}PointToVector3(e,t,n=!0){const i=n?xn(e.units):1,r=t||new A;return e.value?r.set(e.value[0]*i,e.value[1]*i,e.value[2]*i):r.set(e.x*i,e.y*i,e.z*i),r}PointToFloatArray(e){return e.value?[e.value[0],e.value[1],e.value[2]]:[e.x,e.y,e.z]}FlattenVector3Array(e){const t=new Array(3*e.length),n=[];for(let i=0,r=0;i<e.length;i++,r+=3)e[i].toArray(n),t[r]=n[0],t[r+1]=n[1],t[r+2]=n[2]?n[2]:0;return t}unpackColors(e,t=!1){const n=new Array(3*e.length);for(let i=0;i<e.length;i++){const r=e.get(i),s=r>>16&255,o=r>>8&255,l=255&r;n[3*i]=s/255,n[3*i+1]=o/255,n[3*i+2]=l/255,t&&(n[3*i]=this.srgbToLinear(n[3*i]),n[3*i+1]=this.srgbToLinear(n[3*i+1]),n[3*i+2]=this.srgbToLinear(n[3*i+2]))}return n}srgbToLinear(e){return e<=0?0:e>=1?1:e<.04045?e/12.92:Math.pow((e+.055)/1.055,2.4)}chunkArrayHasData(e){return e&&e.filter((t=>t.data&&t.data.length)).length>0}}class Iu extends f0{get resource(){return this._resource}get finished(){return this.isFinished}constructor(e,t,n,i,r,s,o,l){super(t,r),this.isCancelled=!1,this.isFinished=!1,this.tree=e,this.log=s||De.log;try{this.loader=this.initObjectLoader(t,n,i,r,o,l)}catch(c){return void De.error(c)}this.converter=new Eb(this.loader,this.tree)}initObjectLoader(e,t,n,i,r,s){let o;try{o=t||localStorage.getItem("AuthToken")}catch{}o||De.error("Viewer: no auth token present. Requests to non-public stream objects will fail.");const l=new URL(e),c=l.pathname.split("/");if(c.length<5||l.pathname.indexOf("streams")===-1||l.pathname.indexOf("objects")===-1)throw new Error("Unexpected object url format.");const u=l.origin,h=c[2],d=c[4];return yl.createFromUrl({serverUrl:u,streamId:h,objectId:d,token:o,attributeMask:r,objectTypeMask:s})}async load(){const e=performance.now();let t=!0,n=0;const i=await this.loader.getTotalObjectCount();let r=0,s=null;this.progressListen(),De.warn("Downloading object ",this.resource);for await(const h of this.loader.getObjectIterator()){if(this.isCancelled)return this.emit(Xi.LoadCancelled,this.resource),Promise.resolve(!1);t&&(s=this.converter.traverse(this.resource,h,(d=>{r++,this.emit(Xi.Traversed,{count:d})})),t=!1),n++,this.emit(Xi.LoadProgress,{progress:n/(i+1),id:this.resource})}if(s&&await s,De.warn(`Finished converting object ${this.resource} in ${(performance.now()-e)/Zu.second} seconds. Node count: ${this.tree.nodeCount}`),r===0&&(De.warn(`Viewer: no 3d objects found in object ${this.resource}`),this.emit(Xi.LoadWarning,{message:`No displayable objects found in object ${this.resource}.`})),this.isCancelled)return Promise.resolve(!1);await this.converter.convertInstances(),await this.converter.applyMaterials(),await this.converter.handleDuplicates(),await this.loader.disposeAsync();const o=performance.now(),l=new Tb,c=this.tree.getRenderTree(this.resource);if(!c)return Promise.resolve(!1);const u=c.buildRenderTree(l,(h=>{this.emit(Xi.Converted,{count:h})}));return De.warn(`Finished rendering object . Node count: ${this.tree.nodeCount} Total: ${i}`),u.then((()=>{De.log("ASYNC Tree build time -> ",performance.now()-o),De.log("Node build time -> ",c.buildNodeTime),De.log("Apply transform time -> ",c.applyTransformTime),De.log("Geometry build time -> ",c.convertTime),De.log("Get Node time -> ",c.getNodeTime),De.log("Other time -> ",c.otherTime),De.log("Triangulation time -> ",l.meshTriangulationTime),De.log("ACTUAL Triangulation time -> ",l.actualTriangulateTime),De.log("Push time -> ",l.pushTime),this.isFinished=!0})),u}progressListen(){if(Hd(ia.DEBUG,!1)!=="true")return;let e=0;this.on(Xi.LoadProgress,(t=>{const n=Math.floor(100*t.progress);n>e&&(De.log(`[debug] Loading ${n}%`),e=n)})),this.on(Xi.Traversed,(t=>{t.count%500==0&&De.log(`[debug] Traversed ${t.count}`)})),this.on(Xi.Converted,(t=>{t.count%500==0&&De.log(`[debug] Converted ${t.count}`)}))}cancel(){this.isCancelled=!0,this.isFinished=!1}dispose(){super.dispose(),this.loader.disposeAsync()}}var sl;(function(a){a[a.PLAIN=0]="PLAIN",a[a.COLORED=1]="COLORED"})(sl||(sl={}));class Cb extends Zr{get enabled(){return this._enabled}set enabled(e){this._enabled=e}constructor(e){super(e),this.addedMaterials=[],this.changedOldMaterials=[],this.changedNewMaterials=[],this.removedMaterials=[],this._diffTime=-1,this._diffMode=sl.COLORED,this.dynamicallyLoadedDiffResources=[],this.tree=e.getWorldTree(),this.addedMaterialMesh=new hi({color:new Ie("#00ff00"),emissive:0,roughness:1,metalness:0,opacity:1,side:An}),this.addedMaterialMesh.vertexColors=!1,this.addedMaterialMesh.depthWrite=!0,this.addedMaterialMesh.transparent=!0,this.addedMaterialMesh.clipShadows=!0,this.addedMaterialMesh.color.convertSRGBToLinear(),this.addedMaterialMesh.clippingPlanes=[],this.changedNewMaterialMesh=new hi({color:new Ie("#ffff00"),emissive:0,roughness:1,metalness:0,opacity:1,side:An}),this.changedNewMaterialMesh.vertexColors=!1,this.changedNewMaterialMesh.transparent=!0,this.changedNewMaterialMesh.depthWrite=!0,this.changedNewMaterialMesh.clipShadows=!0,this.changedNewMaterialMesh.color.convertSRGBToLinear(),this.changedNewMaterialMesh.clippingPlanes=[],this.changedOldMaterialMesh=new hi({color:new Ie("#ffff00"),emissive:0,roughness:1,metalness:0,opacity:1,side:An}),this.changedOldMaterialMesh.vertexColors=!1,this.changedOldMaterialMesh.transparent=!0,this.changedOldMaterialMesh.depthWrite=!0,this.changedOldMaterialMesh.clipShadows=!0,this.changedOldMaterialMesh.color.convertSRGBToLinear(),this.changedOldMaterialMesh.clippingPlanes=[],this.removedMaterialMesh=new hi({color:new Ie("#ff0000"),emissive:0,roughness:1,metalness:0,opacity:1,side:An}),this.removedMaterialMesh.vertexColors=!1,this.removedMaterialMesh.transparent=!0,this.removedMaterialMesh.depthWrite=!0,this.removedMaterialMesh.clipShadows=!0,this.removedMaterialMesh.color.convertSRGBToLinear(),this.removedMaterialMesh.clippingPlanes=[],this.addedMaterialPoint=new fr({color:65280,vertexColors:!1,size:2,sizeAttenuation:!1}),this.addedMaterialPoint.transparent=!0,this.addedMaterialPoint.color.convertSRGBToLinear(),this.addedMaterialPoint.toneMapped=!1,this.addedMaterialPoint.clippingPlanes=[],this.changedNewMaterialPoint=new fr({color:16776960,vertexColors:!1,size:2,sizeAttenuation:!1}),this.changedNewMaterialPoint.transparent=!0,this.changedNewMaterialPoint.color.convertSRGBToLinear(),this.changedNewMaterialPoint.toneMapped=!1,this.changedNewMaterialPoint.clippingPlanes=[],this.changedOldMaterialPoint=new fr({color:16776960,vertexColors:!1,size:2,sizeAttenuation:!1}),this.changedOldMaterialPoint.transparent=!0,this.changedOldMaterialPoint.color.convertSRGBToLinear(),this.changedOldMaterialPoint.toneMapped=!1,this.changedOldMaterialPoint.clippingPlanes=[],this.removedMaterialPoint=new fr({color:16711680,vertexColors:!1,size:2,sizeAttenuation:!1}),this.removedMaterialPoint.transparent=!0,this.removedMaterialPoint.color.convertSRGBToLinear(),this.removedMaterialPoint.toneMapped=!1,this.removedMaterialPoint.clippingPlanes=[]}async diff(e,t,n,i){const r=[];this.dynamicallyLoadedDiffResources=[],this.tree.findId(e)||(r.push(this.viewer.loadObject(new Iu(this.viewer.getWorldTree(),e,i),!1)),this.dynamicallyLoadedDiffResources.push(e)),this.tree.findId(t)||(r.push(this.viewer.loadObject(new Iu(this.viewer.getWorldTree(),t,i),!1)),this.dynamicallyLoadedDiffResources.push(t)),await Promise.all(r);const s=await this.getDiff(e,t);return this.viewer.getRenderer().pipeline.getPass("DEPTH").forEach((o=>{o.depthSide=An})),this.updateVisualDiff(0,n),Promise.resolve(s)}async undiff(){this.viewer.getRenderer().pipeline.getPass("DEPTH").forEach((t=>{t.depthSide=yt})),this.resetMaterialGroups(),this.viewer.getRenderer().resetMaterials();const e=[];if(this.dynamicallyLoadedDiffResources.length!==0)for(const t of this.dynamicallyLoadedDiffResources)e.push(this.viewer.unloadObject(t));this.dynamicallyLoadedDiffResources=[],await Promise.all(e)}buildIdMaps(e,t,n){var i;for(let r=0;r<e.length;r++){const s=e[r],o=s.model.raw.applicationId?s.model.raw.applicationId:(i=this.tree.getAncestors(s).find((l=>l.model.raw.applicationId)))===null||i===void 0?void 0:i.model.raw.applicationId;t[s.model.raw.id]={node:s,applicationId:o},o&&(n[o]=s)}}async getDiff(e,t){const n=await this.diffIterative(e,t);return this._visualDiff=this.getVisualDiffResult(n),Promise.resolve(n)}diffIterative(e,t){var n,i;const r={unchanged:[],added:[],removed:[],modified:[]},s=this.tree.getRenderTree(e),o=this.tree.getRenderTree(t);if(!s)return Promise.reject(new Error(`Could not make diff. Resource ${e} could not be fetched`));if(!o)return Promise.reject(new Error(`Could not make diff. Resource ${t} could not be fetched`));let l=s.getRenderableNodes(...Mu),c=o.getRenderableNodes(...Mu);l=l.map((p=>s.getAtomicParent(p))),c=c.map((p=>o.getAtomicParent(p))),l=[...Array.from(new Set(l))],c=[...Array.from(new Set(c))];const u={},h={};this.buildIdMaps(l,u,h);const d={},f={};this.buildIdMaps(c,d,f);for(let p=0;p<c.length;p++){const m=(n=u[c[p].model.raw.id])===null||n===void 0?void 0:n.node;if(m)r.unchanged.push(m);else{const g=d[c[p].model.raw.id].applicationId;if(!g){De.error(`No application ID found. Object id:${c[p].model.raw.id} is considered 'added'!`),r.added.push(c[p]);continue}const v=h[g];v?r.modified.push([v,c[p]]):r.added.push(c[p])}}for(let p=0;p<l.length;p++){const m=(i=d[l[p].model.raw.id])===null||i===void 0?void 0:i.node;if(m)r.unchanged.push(m);else{const g=u[l[p].model.raw.id].applicationId;if(!g){De.error(`No application ID found. Object id:${l[p].model.raw.id} is considered 'removed'!`),r.removed.push(l[p]);continue}f[g]||r.removed.push(l[p])}}return Promise.resolve(r)}updateVisualDiff(e,t){(t!==void 0&&t!==this._diffMode||!this._materialGroups)&&(this.resetMaterialGroups(),t!==void 0&&(this.buildMaterialGroups(t),this._diffMode=t));let n=!1;e!==void 0&&e!==this._diffTime&&(n=this._diffTime===0!=(e===0)||this._diffTime===1!=(e===1),this.setDiffTime(e),this._diffTime=e),this._materialGroups&&this._materialGroups.forEach((i=>{this.viewer.getRenderer().setMaterial(i.rvs,i.material)})),this.viewer.requestRender(n?Qt.RENDER_RESET|Qt.SHADOWS:Qt.RENDER)}setDiffTime(e){const t=Math.min(Math.max(1-e,0),1),n=Math.min(Math.max(e,0),1);this.addedMaterials.forEach((i=>{i.opacity=i.clampOpacity!==void 0?Math.min(t,i.clampOpacity):t,i.depthWrite=!(t<.5),i.transparent=i.opacity<1,i.visible=i.opacity!==0,i.needsCopy=!0})),this.changedOldMaterials.forEach((i=>{i.opacity=i.clampOpacity!==void 0?Math.min(n,i.clampOpacity):n,i.depthWrite=!(n<.5),i.transparent=i.opacity<1,i.visible=i.opacity!==0,i.needsCopy=!0})),this.changedNewMaterials.forEach((i=>{i.opacity=i.clampOpacity!==void 0?Math.min(t,i.clampOpacity):t,i.depthWrite=!(t<.5),i.transparent=i.opacity<1,i.visible=i.opacity!==0,i.needsCopy=!0})),this.removedMaterials.forEach((i=>{i.opacity=i.clampOpacity!==void 0?Math.min(n,i.clampOpacity):n,i.depthWrite=!(n<.5),i.transparent=i.opacity<1,i.visible=i.opacity!==0,i.needsCopy=!0}))}buildMaterialGroups(e){switch(e){case sl.COLORED:this._materialGroups=this.getColoredMaterialGroups(this._visualDiff);break;case sl.PLAIN:this._materialGroups=this.getPlainMaterialGroups(this._visualDiff);break;default:De.error(`Unsupported visual diff mode ${e}`)}}resetMaterialGroups(){this._materialGroups=null,this.addedMaterials=[],this.changedOldMaterials=[],this.changedNewMaterials=[],this.removedMaterials=[]}getVisualDiffResult(e){const t=this.tree.getRenderTree(),n=e.added.flatMap((l=>t.getRenderViewsForNode(l))),i=e.removed.flatMap((l=>t.getRenderViewsForNode(l))),r=e.unchanged.flatMap((l=>t.getRenderViewsForNode(l))),s=e.modified.flatMap((l=>t.getRenderViewsForNode(l[0]))).filter((l=>!r.includes(l)&&!i.includes(l))),o=e.modified.flatMap((l=>t.getRenderViewsForNode(l[1]))).filter((l=>!r.includes(l)&&!n.includes(l)));return{unchanged:r,added:n,removed:i,modifiedOld:s,modifiedNew:o}}getColoredMaterialGroups(e){const t=[{rvs:e.added.filter((n=>n.geometryType===ze.MESH||n.geometryType===ze.LINE)),material:this.addedMaterialMesh},{rvs:e.modifiedNew.filter((n=>n.geometryType===ze.MESH||n.geometryType===ze.LINE)),material:this.changedNewMaterialMesh},{rvs:e.modifiedOld.filter((n=>n.geometryType===ze.MESH||n.geometryType===ze.LINE)),material:this.changedOldMaterialMesh},{rvs:e.removed.filter((n=>n.geometryType===ze.MESH||n.geometryType===ze.LINE)),material:this.removedMaterialMesh},{rvs:e.added.filter((n=>n.geometryType===ze.POINT||n.geometryType===ze.POINT_CLOUD)),material:this.addedMaterialPoint},{rvs:e.modifiedNew.filter((n=>n.geometryType===ze.POINT||n.geometryType===ze.POINT_CLOUD)),material:this.changedNewMaterialPoint},{rvs:e.modifiedOld.filter((n=>n.geometryType===ze.POINT||n.geometryType===ze.POINT_CLOUD)),material:this.changedOldMaterialPoint},{rvs:e.removed.filter((n=>n.geometryType===ze.POINT||n.geometryType===ze.POINT_CLOUD)),material:this.removedMaterialPoint}];return this.addedMaterials.push(this.addedMaterialMesh,this.addedMaterialPoint),this.changedOldMaterials.push(this.changedOldMaterialMesh,this.changedOldMaterialPoint),this.changedNewMaterials.push(this.changedNewMaterialMesh,this.changedNewMaterialPoint),this.removedMaterials.push(this.removedMaterialMesh,this.removedMaterialPoint),t.filter((n=>n.rvs.length>0))}getPlainMaterialGroups(e){const t=this.getBatchesSubgroups(e.added),n=this.getBatchesSubgroups(e.modifiedOld),i=this.getBatchesSubgroups(e.modifiedNew),r=this.getBatchesSubgroups(e.removed);return this.addedMaterials=t.map((s=>s.material)),this.changedOldMaterials=n.map((s=>s.material)),this.changedNewMaterials=i.map((s=>s.material)),this.removedMaterials=r.map((s=>s.material)),[...t,...n,...i,...r]}getBatchesSubgroups(e){const t=oL(e,"batchId"),n=[];for(const i in t){const r=this.viewer.getRenderer().getBatchMaterial(t[i][0]).clone();r.clampOpacity=r.opacity,r.opacity=.5,r.transparent=!0,n.push({rvs:t[i],material:r})}return n}}class Dk{constructor(e){this.lastAsyncPause=0,this.NodeConverterMapping={Group:this.groupToNode.bind(this),Mesh:this.MeshToNode.bind(this)},this.tree=e}async asyncPause(){Date.now()-this.lastAsyncPause>=100&&(this.lastAsyncPause=Date.now(),await new Promise((e=>setTimeout(e,0))))}async traverse(e,t,n,i=null){await this.asyncPause();const r=this.tree.parse({id:i?t.uuid:e,raw:t,atomic:!0,children:[]});i?this.tree.addNode(r,i):this.tree.addSubtree(r);const s=t.type;if(this.directNodeConverterExists(t))try{await this.convertToNode(t,r)}catch(o){De.warn(`(Traversing - direct) Failed to convert ${s} with id: ${t.uuid}`,o)}for(let o=0;o<t.children.length;o++)this.traverse(e,t.children[o],n,r)}directNodeConverterExists(e){return e.type in this.NodeConverterMapping}async convertToNode(e,t){try{if(this.directNodeConverterExists(e)){const n=this.NodeConverterMapping[e.type];if(n)return await n(e,t)}return null}catch(n){throw De.warn(`(Direct convert) Failed to convert object with id: ${e.id}`),n}}async MeshToNode(e,t){var n,i;const r=e;if(r){if(r.geometry.attributes.position&&r.geometry.attributes.position.array.length!==0)return t.model.raw.vertices=r.geometry.attributes.position.array,t.model.raw.faces=(n=r.geometry.index)===null||n===void 0?void 0:n.array,t.model.raw.colors=(i=r.geometry.attributes.color)===null||i===void 0?void 0:i.array,Promise.resolve();De.warn(`Object id ${r.id} of type ${r.type} has no vertex position data and will be ignored`)}}groupToNode(e,t){return Promise.resolve()}}class Ok extends l0{getSpeckleType(e){switch(e.raw.type){case"Group":return et.BlockInstance;case"Mesh":return et.Mesh;default:return et.Unknown}}convertNodeToGeometryData(e){switch(this.getSpeckleType(e)){case et.BlockInstance:return this.BlockInstanceToGeometryData(e);case et.Mesh:return this.MeshToGeometryData(e);default:return null}}disposeNodeGeometryData(e){}BlockInstanceToGeometryData(e){const t=new ae().copy(e.raw.matrixWorld);return{attributes:null,bakeTransform:null,transform:new ae().makeScale(1,1,1).multiply(t).multiply(new ae().makeScale(1,1,1))}}MeshToGeometryData(e){return e.raw?(e.raw.geometry.index&&e.raw.geometry.index.array.length!==0||(e.raw.geometry=fN(e.raw.geometry)),{attributes:{POSITION:new Zt([{data:e.raw.geometry.attributes.position.array,id:It.generateUUID(),references:1}]),INDEX:new Zt([{data:e.raw.geometry.index.array,id:It.generateUUID(),references:1}]),...e.raw.geometry.attributes.color&&{COLOR:new Zt([{data:e.raw.geometry.attributes.color.array,id:It.generateUUID(),references:1}])}},bakeTransform:new ae().makeScale(1,1,1),transform:null}):null}}class Bk extends f0{get resource(){return this._resource}get finished(){return this.isFinished}constructor(e,t,n){super(t,n),this.isFinished=!1,this.tree=e,this.baseLoader=new dN,this.converter=new Dk(this.tree)}load(){return new Promise(((e,t)=>{new Promise(((n,i)=>{this._resourceData?this.converter.traverse(this._resource,this.baseLoader.parse(this._resourceData),(()=>{})).then((()=>n())).catch((r=>{De.error(`Loading obj ${this._resource} failed with ${r}`),i(new Error)})):this.baseLoader.load(this._resource,(r=>{this.converter.traverse(this._resource,r,(()=>{})).then((()=>{n()})).catch((()=>{i(new Error)}))}),(r=>{this.emit(Xi.LoadProgress,{progress:r.loaded/(r.total+1),id:this._resource})}),(r=>{De.error(`Loading obj ${this._resource} failed with ${r.error}`),i(new Error)}))})).then((async()=>{const n=performance.now(),i=this.tree.getRenderTree(this._resource);if(i){const r=await i.buildRenderTree(new Ok);De.log("Tree build time -> ",performance.now()-n),this.isFinished=!0,e(r)}else De.error(`Could not get render tree for ${this._resource}`),t(new Error)})).catch((()=>{De.error(`Could not load ${this._resource}`),t(new Error)}))}))}cancel(){this.isFinished=!1}dispose(){super.dispose()}}class Lk extends Ar{get vertexProgram(){return`
#define USE_ENVMAP
#include <common>
#ifdef USE_RTE
    // The high component is stored as the default 'position' attribute buffer
    attribute vec3 position_low;
    uniform vec3 uViewer_high;
    uniform vec3 uViewer_low;
#endif

#ifdef TRANSFORM_STORAGE
    attribute float objIndex;

    #if TRANSFORM_STORAGE == 0
        #if __VERSION__ == 300
            #define TRANSFORM_STRIDE 4
        #else
            #define TRANSFORM_STRIDE 4.
        #endif
        uniform sampler2D tTransforms;
        uniform float objCount;
    #elif TRANSFORM_STORAGE == 1
        uniform mat4 uTransforms[OBJ_COUNT];
    #endif
#endif
varying vec3 vNormal;
varying vec3 vViewPosition;

#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef USE_RTE
    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){
        /* 
        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl 
        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy 
        */
        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;
        highp vec3 e = t1 - position_low.xyz;
        /** This is redunant, but necessary as a workaround for Apple platforms */
        highp float x = position_high.x - relativeTo_high.x;
        highp float y = position_high.y - relativeTo_high.y;
        highp float z = position_high.z - relativeTo_high.z;
        highp vec3 v = vec3(x, y, z);
        /** End of redundant part */
        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;
        highp vec3 highDifference = t1 + t2;
        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);
        
        highp vec3 position = highDifference.xyz + lowDifference.xyz;
        return vec4(position, 1.);
    }
#endif

#ifdef TRANSFORM_STORAGE
    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){
        #if TRANSFORM_STORAGE == 0
            #if __VERSION__ == 300
                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); 
                vec4 v0 = texelFetch( tTransforms, uv, 0 );
                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);
                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);
                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #else
                float size = objCount * TRANSFORM_STRIDE;
                vec2 cUv = vec2(0.5/size, 0.5);
                vec2 dUv = vec2(1./size, 0.);
                
                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);
                vec4 v0 = texture2D( tTransforms, uv);
                vec4 v1 = texture2D( tTransforms, uv + dUv);
                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);
                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);
                quaternion = v0;
                pivotLow = vec4(v1.xyz, 1.);
                pivotHigh = vec4(v2.xyz, 1.);
                translation = vec4(v3.xyz, 1.);
                scale = vec4(v1.w, v2.w, v3.w, 1.);
            #endif
        #elif TRANSFORM_STORAGE == 1
            mat4 tMatrix = uTransforms[int(objIndex)];
            quaternion = tMatrix[0];
            pivotLow = vec4(tMatrix[1].xyz, 1.);
            pivotHigh = vec4(tMatrix[2].xyz, 1.);
            translation = vec4(tMatrix[3].xyz, 1.);
            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);
        #endif
    }

    vec3 rotate_vertex_position(vec3 position, vec4 quat)
    { 
        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);
    }

    /** Another workaround for Apple's stupid compiler */
    vec4 safeMul(vec4 a, vec4 b) {
        // Prevents constant folding and optimization
        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);
    }

    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)
    {
        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */
        /** The code below will not produce correct results in intel IrisXE integrated GPUs. 
         *  The geometry will turn mangled, albeit stable
         *  I can't know for sure what is going on, but rotating the difference seems to 
         *  force the result into a lower precision?
         */
        // highp vec4 position = v0 - v1;
        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);

        /** Subtracting the rotated vectors works. */
        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;

        /** An alternate workaround is
         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));
           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);

           However I'm not such a fan of the (1. + 1e-7) part
         */
    }

#endif

#if defined(BILLBOARD) || defined(BILLBOARD_FIXED)
    uniform vec3 billboardPos;
    uniform mat4 invProjection;
#endif
#ifdef BILLBOARD_FIXED
    uniform vec2 billboardSize;
#endif
varying float dotValue;

void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
        // #include <defaultnormal_vertex> // COMMENTED CHUNK
        vec3 transformedNormal = objectNormal;
        #ifdef USE_INSTANCING

            // this is in lieu of a per-instance normal-matrix
            // shear transforms in the instance matrix are not supported
            mat3 m = mat3( instanceMatrix );
            transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
            transformedNormal = m * transformedNormal;
            
            /* If we have negative scaling, we flip the normal */
            float signDet = sign(dot(m[0], cross(m[1], m[2])));
            // Optional fallback: treat 0 as +1
            signDet = signDet + (1.0 - abs(signDet));
            transformedNormal *= signDet;
        #endif
        transformedNormal = normalMatrix * transformedNormal;
        #ifdef FLIP_SIDED
            transformedNormal = - transformedNormal;
        #endif
        #ifdef USE_TANGENT
            vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
            #ifdef FLIP_SIDED
                transformedTangent = - transformedTangent;
            #endif
        #endif
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	// #include <project_vertex> COMMENTED CHUNK
    #ifdef TRANSFORM_STORAGE
        vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;
        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);
    #endif
    #ifdef USE_RTE
        vec4 position_lowT = vec4(position_low, 1.);
        vec4 position_highT = vec4(position, 1.);
        const vec3 ZERO3 = vec3(0., 0., 0.);

        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);
        #ifdef TRANSFORM_STORAGE
            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);
            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;
        #endif
    #endif

    #ifdef USE_RTE
        vec4 mvPosition = rteLocalPosition;
    #else
        vec4 mvPosition = vec4( transformed, 1.0 );
        #ifdef TRANSFORM_STORAGE
            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;
        #endif
        #ifdef USE_INSTANCING
            mvPosition = instanceMatrix * mvPosition;
        #endif
    #endif
    
    mvPosition = modelViewMatrix * mvPosition;

    vNormal = normalize( transformedNormal );
    vViewPosition = -mvPosition.xyz;

    #if defined(BILLBOARD)
        float div = 1.;
        gl_Position = projectionMatrix * (viewMatrix * vec4(billboardPos, 1.0) + vec4(position.x, position.y, 0., 0.0));
    #elif defined(BILLBOARD_FIXED)
        gl_Position = projectionMatrix * (viewMatrix * vec4(billboardPos, 1.0));
        float div = gl_Position.w;
        gl_Position /= gl_Position.w;
        gl_Position.xy += position.xy * billboardSize;
    #else
        gl_Position = projectionMatrix * mvPosition;
    #endif


	#include <logdepthbuf_vertex>
	// #include <clipping_planes_vertex> COMMENTED CHUNK
    #if NUM_CLIPPING_PLANES > 0
        #if defined(BILLBOARD) || defined(BILLBOARD_FIXED)
            vec4 movelViewProjection = gl_Position * div;
            vClipPosition = - (invProjection * movelViewProjection).xyz;
        #else
	        vClipPosition = - mvPosition.xyz;
        #endif
    #endif
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`}get fragmentProgram(){return`
uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

uniform float minIntensity;
varying vec3 vViewPosition;

#ifdef MATCAP_TEXTURE
	uniform sampler2D tMatcap;
#endif

void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	// modulation
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	// #include <output_fragment> COMMENTED CHUNK
	#ifdef OPAQUE
		diffuseColor.a = 1.0;
	#endif

	// https://github.com/mrdoob/three.js/pull/22425
	#ifdef USE_TRANSMISSION
		diffuseColor.a *= transmissionAlpha + 0.1;
	#endif

	vec3 normal = normalize( vNormal );
	vec3 viewDir = normalize( vViewPosition );
    vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
    vec3 y = cross( viewDir, x );
    vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;

	vec3 color = vec3(1.0);
	#ifdef MATCAP_TEXTURE
		color = texture2D(tMatcap, uv).rgb;
	#else
		color = vec3( mix( minIntensity, 1., uv.y ) );
	#endif

	gl_FragColor = vec4( color.rgb, diffuseColor.a);
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`}get uniformsDef(){return{...super.uniformsDef,minIntensity:.01,tMatcap:null}}constructor(e,t=[]){super(e,t)}set minIntensity(e){this.userData.minIntensity.value=e,this.needsUpdate=!0}set matcapTexture(e){this.defines&&(e?(this.defines.MATCAP_TEXTURE="",this.userData.tMatcap.value=e):(delete this.defines.MATCAP_TEXTURE,this.userData.tMatcap.value=null),this.needsUpdate=!0)}fastCopy(e,t){super.fastCopy(e,t),t.userData.tMatcap.value=e.userData.tMatcap.value}}const dA={minIntensity:.1,matcapTexture:null,opacity:1};class Ru extends Sn{get displayName(){return"GEOMETRY-VIEWPORT"}get overrideBatchMaterial(){return this.viewportMaterial}set options(e){super.options=e,this.viewportMaterial.blending=this._options.opacity<1?qs:Mn,this.viewportMaterial.side=this._options.opacity<1?An:yt,this.viewportMaterial.transparent=this._options.opacity<1,this.viewportMaterial.toneMapped=!1,this.viewportMaterial.minIntensity=this._options.minIntensity,this.viewportMaterial.opacity=this._options.opacity,this.setMatcapTexture(this._options.matcapTexture)}constructor(){super(),this._options=Object.assign({},dA),this.viewportMaterial=new Lk({}),this.options=dA}setMatcapTexture(e){e&&(this.pendingTexture=!0,jn.getTexture(e).then((t=>{this.viewportMaterial.matcapTexture=t,this.viewportMaterial.needsCopy=!0,this.pendingTexture=!1})).catch((t=>{De.error(`Matcap texture failed to load ${t}`),this.pendingTexture=!1})))}render(e,t,n){return super.render(e,t,n)||this.pendingTexture}}class Ib extends Xr{constructor(e,t=Cs){var n,i;super(e),this.accumulationFrameCount=16;const r=t.edges?new xo(e):null,s=t.edges?null:new Al;s&&(s.setLayers([re.STREAM_CONTENT_MESH]),s.setVisibility(ut.DEPTH),s.setJitter(!0),s.setClearColor(0,1),s.setClearFlags(Ct.COLOR|Ct.DEPTH));const o=t.edges?r?.depthPass.depthTexture:(n=s?.outputTarget)===null||n===void 0?void 0:n.texture,l=(t.edges?r?.dynamicPasses:[])||[],c=(t.edges?r?.progressivePasses:s?[s]:[])||[],u=new Ru;u.setLayers([re.STREAM_CONTENT,re.STREAM_CONTENT_MESH,re.STREAM_CONTENT_LINE,re.STREAM_CONTENT_POINT,re.STREAM_CONTENT_POINT_CLOUD,re.PROPS]),u.setVisibility(ut.OPAQUE),u.options={minIntensity:.75};const h=new Ru;h.setLayers([re.STREAM_CONTENT,re.STREAM_CONTENT_MESH,re.STREAM_CONTENT_LINE,re.STREAM_CONTENT_POINT,re.STREAM_CONTENT_POINT_CLOUD,re.STREAM_CONTENT_TEXT,re.SHADOWCATCHER]),h.setVisibility(ut.TRANSPARENT),h.options={minIntensity:.25,opacity:.5};const d=new Yf;d.setTexture("tDepth",o),d.accumulationFrames=this.accumulationFrameCount,d.options={kernelRadius:100,kernelSize:64},d.setClearColor(16777215,1);const f=new qi;f.options={blendAO:!0,blendEdges:t.edges},f.setTexture("tAo",(i=d.outputTarget)===null||i===void 0?void 0:i.texture),f.setTexture("tEdges",t.edges?r?.outputTexture:void 0),f.accumulationFrames=this.accumulationFrameCount;const p=new qi;p.options={blendAO:!1,blendEdges:t.edges},p.setTexture("tEdges",t.edges?r?.outputTextureDynamic:void 0),p.accumulationFrames=this.accumulationFrameCount;const m=new ua;m.setVisibility(ut.STENCIL),m.setLayers([re.STREAM_CONTENT_MESH]);const g=new ha;g.setVisibility(ut.STENCIL),g.setLayers([re.STREAM_CONTENT_MESH]),g.setClearFlags(Ct.DEPTH);const v=new Sn;v.setLayers([re.OVERLAY,re.MEASUREMENTS]),this.dynamicStage.push(...l,m,u,h,...t.edges?[p]:[],g,v),this.progressiveStage.push(...c,m,u,h,g,d,f,v),this.passthroughStage.push(m,u,h,g,f,v),this.passList=this.dynamicStage}}class Rb extends Ts{constructor(e,t){super(),this.materialMap={},this.tree=e,this.speckleRenderer=t,this.buildMaterials(),this.applyColorIndices()}get displayName(){return"SHADED"}setClippingPlanes(e){for(const t in this.materialMap)this.materialMap[t][2].clippingPlanes=e}buildMaterials(){const e=this.speckleRenderer.batcher.getBatches(void 0,ze.MESH);for(let t=0;t<e.length;t++){const n=e[t],i=new Map;i.set(8947848,[]);for(let o=0;o<n.renderViews.length;o++){const l=n.renderViews[o],c=l.renderData.colorMaterial;if(!c){const h=i.get(8947848);h&&h.push(l);continue}i.has(c.color)||i.set(c.color,[]);const u=i.get(c.color);u&&u.push(l)}const r=jn.generateDiscreetRampTexture(Array.from(i.keys())),s=new Ha({side:yt,transparent:!1,wireframe:!1});s.clipShadows=!0,s.setGradientTexture(r),this.materialMap[n.id]=[n,i,s]}}applyColorIndices(){for(const e in this.materialMap){const t=this.materialMap[e][0],n=this.materialMap[e][1],i=[];let r=0;for(const s of n.entries()){const o=s[0];i.push(...s[1].map((l=>({offset:l.batchStart,count:l.batchCount,materialOptions:{rampIndex:r/n.size,rampIndexColor:new Ie(o),rampWidth:4*s[1].length}})))),r++}t.setBatchBuffers(i)}}overrideMaterials(){for(const e in this.materialMap){const t=this.materialMap[e];t[0].renderObject.setOverrideBatchMaterial(t[2])}}restoreMaterials(){for(const e in this.materialMap)this.materialMap[e][0].renderObject.restoreBatchMaterial()}render(e,t,n){return!(!t||!n)&&(this.overrideMaterials(),this.onBeforeRender&&this.onBeforeRender(),this.applyLayers(t),e.setRenderTarget(this.outputTarget),this.clear(e),e.render(n,t),this.onAfterRender&&this.onAfterRender(),this.restoreMaterials(),!1)}}class Pb extends Xr{constructor(e,t=Cs,n){super(e);const i=t.edges?new xo(e):null,r=(t.edges?i?.dynamicPasses:[])||[],s=(t.edges?i?.progressivePasses:[])||[],o=new Rb(n,e);o.setLayers([re.STREAM_CONTENT_MESH,re.PROPS]),o.setClearColor(0,0),o.setClearFlags(Ct.COLOR),o.outputTarget=null;const l=new Sn;l.setLayers([re.STREAM_CONTENT_LINE,re.STREAM_CONTENT_POINT,re.STREAM_CONTENT_POINT_CLOUD,re.STREAM_CONTENT_TEXT]);const c=new qi;c.options={blendAO:!1,blendEdges:t.edges},c.setTexture("tEdges",t.edges?i?.outputTexture:void 0),c.accumulationFrames=this.accumulationFrameCount;const u=new qi;u.options={blendAO:!1,blendEdges:t.edges},u.setTexture("tEdges",t.edges?i?.outputTextureDynamic:void 0),u.accumulationFrames=this.accumulationFrameCount;const h=new ua;h.setVisibility(ut.STENCIL),h.setLayers([re.STREAM_CONTENT_MESH]);const d=new ha;d.setVisibility(ut.STENCIL),d.setLayers([re.STREAM_CONTENT_MESH]),d.setClearFlags(Ct.DEPTH);const f=new Sn;f.setLayers([re.OVERLAY,re.MEASUREMENTS]),this.dynamicStage.push(...r,h,o,l,...t.edges?[u]:[],d,f),this.progressiveStage.push(...s,h,o,l,d,c,f),this.passthroughStage.push(h,o,l,d,c,f),this.passList=this.dynamicStage}}var Pu;(function(a){a[a.Color=0]="Color",a[a.PackedDepth=1]="PackedDepth",a[a.Normals=2]="Normals",a[a.Passthrough=3]="Passthrough"})(Pu||(Pu={}));const zk={inputType:Pu.Passthrough};class p0 extends Ts{set options(e){super.options=e,this.setInputType(this._options.inputType)}constructor(){super(),this._options=Object.assign({},zk),this.materialCopy=new gn({defines:{INPUT_TYPE:this._options.inputType},uniforms:Hr.clone(Gd.uniforms),vertexShader:`
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }`,fragmentShader:`
    uniform float opacity;
    uniform sampler2D tDiffuse;
    varying vec2 vUv;

    const float UnpackDownscale = 255. / 256.;
    const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
    const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );

    float unpackRGBAToDepth( const in vec4 v ) {
        return dot( v, UnpackFactors );
    }

    vec3 unpackRGBToNormal( const in vec3 rgb ) {
        return 2.0 * rgb.xyz - 1.0;
    }

    void main() {
        vec4 inSample = texture2D( tDiffuse, vUv );
        vec3 outSample = inSample.rgb;
        #if INPUT_TYPE == 0
            /** 
                Un-premultiply alpha
            */
            inSample.rgb /= inSample.a;
            outSample = LinearTosRGB( inSample ).rgb;
        #elif INPUT_TYPE == 1
            outSample.rgb = vec3(unpackRGBAToDepth(inSample));
        #elif INPUT_TYPE == 2
            outSample.rgb = unpackRGBToNormal(inSample.rgb);
        #endif

        gl_FragColor.rgb = outSample;
        gl_FragColor.a = inSample.a;
    }`,transparent:!1}),this.materialCopy.depthWrite=!1,this.materialCopy.needsUpdate=!0,this.fsQuad=new zl(this.materialCopy)}setInputType(e){this.materialCopy.defines.INPUT_TYPE=e,this.materialCopy.needsUpdate=!0}setTexture(e,t){this.materialCopy.uniforms[e].value=t,this.materialCopy.needsUpdate=!0}get displayName(){return"OUTPUT"}render(e){return e.setRenderTarget(this._outputTarget),this.fsQuad.render(e),!1}}class Db extends Xr{constructor(e,t=Cs){super(e);const n=new xo(e);n.edgePassDynamic.outputTarget=null,n.depthPass.setVisibility(ut.DEPTH),n.depthPassDynamic.setVisibility(ut.DEPTH),n.edgePass.options={backgroundColor:0,...t},n.edgePassDynamic.options={backgroundColor:0,...t};const i=new ua;i.setVisibility(ut.STENCIL),i.setLayers([re.STREAM_CONTENT_MESH]);const r=new class extends Sn{get displayName(){return"GEOMETRY-HIDDEN"}get overrideBatchMaterial(){return this.hiddenMaterial}constructor(){super(),this.hiddenMaterial=new hi({side:yt,transparent:!1,opacity:1,wireframe:!1}),this.hiddenMaterial.colorWrite=!1}render(c,u,h){c.setOpaqueSort(this.sortOpaque);const d=super.render(c,u,h);return c.setOpaqueSort(null),d}sortOpaque(c,u){return+c.material.colorWrite-+u.material.colorWrite}};r.setLayers([re.STREAM_CONTENT_MESH,re.PROPS]);const s=new ha;s.setVisibility(ut.STENCIL),s.setLayers([re.STREAM_CONTENT_MESH]),s.setClearFlags(Ct.DEPTH);const o=new Sn;o.setLayers([re.OVERLAY,re.MEASUREMENTS]);const l=new p0;l.setTexture("tDiffuse",n.outputTexture),this.dynamicStage.push(...n.dynamicPasses,i,r,s,o),this.progressiveStage.push(...n.progressivePasses,l,i,r,s,o),this.passthroughStage.push(l,i,r,s,o),this.passList=this.dynamicStage}}var Xs,df,fA="data:image/png;base64,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";class Ob extends Xr{constructor(e,t=Cs){super(e);const n=new Ru;n.setLayers([re.STREAM_CONTENT,re.STREAM_CONTENT_MESH,re.STREAM_CONTENT_LINE,re.STREAM_CONTENT_POINT,re.STREAM_CONTENT_POINT_CLOUD,re.PROPS]),n.setVisibility(ut.OPAQUE),n.options={matcapTexture:{id:"defaultMatcap",src:fA,type:gr.TEXTURE_8BPP}};const i=new Ru;i.setLayers([re.STREAM_CONTENT,re.STREAM_CONTENT_MESH,re.STREAM_CONTENT_LINE,re.STREAM_CONTENT_POINT,re.STREAM_CONTENT_POINT_CLOUD,re.STREAM_CONTENT_TEXT]),i.setVisibility(ut.TRANSPARENT),i.options={opacity:.5,matcapTexture:{id:"defaultMatcap",src:fA,type:gr.TEXTURE_8BPP}};const r=new Sn;r.setLayers([re.SHADOWCATCHER]);const s=new Sn;s.setLayers([re.PROPS]);const o=new ua;o.setVisibility(ut.STENCIL),o.setLayers([re.STREAM_CONTENT_MESH]);const l=new ha;l.setVisibility(ut.STENCIL),l.setLayers([re.STREAM_CONTENT_MESH]),l.setClearFlags(Ct.DEPTH);const c=new Sn;c.setLayers([re.OVERLAY,re.MEASUREMENTS]);const u=t.edges?new xo(e):null;let h=null,d=null;u&&(h=new qi,h.options={blendAO:!1,blendEdges:!0},h.setTexture("tEdges",u.outputTexture),h.accumulationFrames=this.accumulationFrameCount,d=new qi,d.options={blendAO:!1,blendEdges:!0},d.setTexture("tEdges",u.outputTextureDynamic),d.accumulationFrames=this.accumulationFrameCount);const f=(t.edges?u?.dynamicPasses:[])||[],p=(t.edges?u?.progressivePasses:[])||[],m=t.edges&&d?[d]:[],g=t.edges&&h?[h]:[];this.dynamicStage.push(...f,o,r,n,i,...m,s,l,c),this.progressiveStage.push(...p,o,r,n,i,...g,s,l,c),this.passthroughStage.push(o,r,n,i,...g,l,s,c),this.passList=this.dynamicStage}}(function(a){a[a.DEFAULT=0]="DEFAULT",a[a.SOLID=1]="SOLID",a[a.PEN=2]="PEN",a[a.ARCTIC=3]="ARCTIC",a[a.SHADED=4]="SHADED"})(Xs||(Xs={})),(function(a){a.Changed="view-mode-changed"})(df||(df={}));class Bb extends Zr{get inject(){return[d0]}get viewModeOptions(){return this.viewModeOptions}get viewMode(){return this._viewMode}constructor(e,t){super(e),this.filteringExtension=t,this._viewModeOptions=Object.assign({},Cs,c0),t&&t.on(Cn.FilteringStateSet,(n=>{n.colorGroups&&n.colorGroups.length||n.userColorGroups&&n.userColorGroups.length||this.viewer.getRenderer().pipeline.getPass("SHADED").forEach((i=>{i.applyColorIndices()}))})),this.viewer.on(Cn.LoadComplete,(()=>{this.updateViewModeOptions(this._viewModeOptions)}))}on(e,t){super.on(e,t)}setViewMode(e,t){e!==this._viewMode||t&&t.edges!==this._viewModeOptions.edges?(this._viewMode=e,this.updateViewModes(e,t)):this.updateViewModeOptions(t),Object.assign(this._viewModeOptions,t)}updateViewModes(e,t){const n=this.viewer.getRenderer();switch(e){case Xs.DEFAULT:n.pipeline=new u0(n,t);break;case Xs.PEN:n.pipeline=new Db(n,t);break;case Xs.SOLID:n.pipeline=new Ob(n,t);break;case Xs.ARCTIC:n.pipeline=new Ib(n,t);break;case Xs.SHADED:n.pipeline=new Pb(n,t,this.viewer.getWorldTree())}this.updateViewModeOptions(t),this.viewer.requestRender(Qt.RENDER_RESET),this.emit(df.Changed,e)}updateViewModeOptions(e){if(!e)return;const t=this.viewer.World.getRelativeOffset(ur.depthBias);this.viewer.getRenderer().pipeline.getPass("EDGES").forEach((n=>{n.options={...e,depthBias:t}})),this.viewer.requestRender(Qt.RENDER_RESET)}}class Lb extends lo{constructor(e){super(e),this.keyMap={forward:!1,back:!1,left:!1,right:!1,up:!1,down:!1},this.contextMenuTriggered=!1,document.addEventListener("keydown",this.onKeyDown.bind(this)),document.addEventListener("keyup",this.onKeyUp.bind(this)),document.addEventListener("contextmenu",this.onContextMenu.bind(this))}onEarlyUpdate(e){super.onEarlyUpdate(e),this.contextMenuTriggered&&(this.cancelMove(),this.contextMenuTriggered=!1)}onKeyDown(e){switch(e.code){case"ArrowUp":case"KeyW":this.keyMap.forward=!0;break;case"ArrowLeft":case"KeyA":this.keyMap.left=!0;break;case"ArrowDown":case"KeyS":this.keyMap.back=!0;break;case"ArrowRight":case"KeyD":this.keyMap.right=!0;break;case"PageUp":case"KeyE":this.keyMap.up=!0;break;case"PageDown":case"KeyQ":this.keyMap.down=!0}!this._flyControls.enabled&&this._renderingCamera instanceof tn&&Object.values(this.keyMap).some((t=>t===!0))&&this.toggleControls()}onKeyUp(e){switch(e.code){case"ArrowUp":case"KeyW":this.keyMap.forward=!1;break;case"ArrowLeft":case"KeyA":this.keyMap.left=!1;break;case"ArrowDown":case"KeyS":this.keyMap.back=!1;break;case"ArrowRight":case"KeyD":this.keyMap.right=!1;break;case"PageUp":case"KeyE":this.keyMap.up=!1;break;case"PageDown":case"KeyQ":this.keyMap.down=!1}this._flyControls.enabled&&Object.values(this.keyMap).every((t=>t===!1))&&this.toggleControls()}onContextMenu(){this.contextMenuTriggered=!0}cancelMove(){this.keyMap.back=!1,this.keyMap.forward=!1,this.keyMap.down=!1,this.keyMap.up=!1,this.keyMap.left=!1,this.keyMap.right=!1,this._flyControls.enabled&&Object.values(this.keyMap).every((e=>e===!1))&&this.toggleControls()}}class Nk extends h0{onObjectClicked(e){}}class kk extends h0{constructor(e,t){super(e,t),this.cameraProvider=t;const n={selectionMaterialData:{id:It.generateUUID(),color:314363,emissive:0,opacity:1,roughness:1,metalness:0,vertexColors:!1,lineWeight:1,stencilOutlines:zr.OVERLAY,pointSize:4}};this.options=n}unselectObjects(e){if(!this._enabled||!this.selectedNodes.length)return;const t=[];for(let n=0;n<e.length;n++){const i=this.viewer.getWorldTree().findId(e[n]);i&&t.push(...i)}this.clearSelection(t.filter((n=>this.selectedNodes.includes(n))))}onObjectClicked(e){}onObjectDoubleClick(e){}onPointerMove(e){}}class Uk extends qf{constructor(e,t=a0){super(e,t),this.cameraController=this.createExtension(Lb),this.selection=this.createExtension(Nk),this.sections=this.createExtension(uf),this.createExtension(Jr),this.measurements=this.createExtension(Mb),this.filtering=this.createExtension(d0),this.explodeExtension=this.createExtension(bb),this.diffExtension=this.createExtension(Cb),this.highlightExtension=this.createExtension(kk),this.createExtension(Bb),this.on(Cn.LoadComplete,(()=>{const n=this.getExtension(uf),i=this.getExtension(Jr);n?.enabled&&i&&i.requestUpdate(!0)}))}async init(){await super.init()}getRenderer(){return this.speckleRenderer}setSectionBox(e,t){let n;e?(n=new Un,n.min=new A().fromArray(e.min),n.max=new A().fromArray(e.max),n.rotation=e.rotation&&e.rotation.length?new Kt().fromArray(e.rotation):new Kt().identity()):n=this.speckleRenderer.sceneBox,this.sections.setBox(n,t)}getCurrentSectionBox(){const e=this.sections.getBox();return{min:e.min.toArray(),max:e.max.toArray(),...e instanceof Un&&{rotation:e.rotation.toArray()}}}toggleSectionBox(){this.sections.toggle()}sectionBoxOff(){this.sections.enabled=!1}sectionBoxOn(){this.sections.enabled=!0}selectObjects(e){return e.length&&this.highlightExtension.unselectObjects(e),this.selection.selectObjects(e),this.filtering.filteringState.selectedObjects||(this.filtering.filteringState.selectedObjects=[]),this.filtering.filteringState.selectedObjects.push(...this.selection.getSelectedObjects().map((t=>t.id))),Promise.resolve(this.filtering.filteringState)}resetSelection(){return this.highlightExtension.clearSelection(),this.selection.clearSelection(),this.filtering.filteringState.selectedObjects&&(this.filtering.filteringState.selectedObjects.length=0),this.requestRender(Qt.RENDER|Qt.SHADOWS),Promise.resolve(this.filtering.filteringState)}hideObjects(e,t=void 0,n=!1,i=!1){return new Promise((r=>{r(this.preserveSelectionHighlightFilter((()=>this.filtering.hideObjects(e,t,n,i))))}))}showObjects(e,t=void 0,n=!1){return new Promise((i=>{i(this.preserveSelectionHighlightFilter((()=>this.filtering.showObjects(e,t,n))))}))}isolateObjects(e,t=void 0,n=!1,i=!0){return new Promise((r=>{r(this.preserveSelectionHighlightFilter((()=>this.filtering.isolateObjects(e,t,n,i))))}))}unIsolateObjects(e,t=void 0,n=!1){return new Promise((i=>{i(this.preserveSelectionHighlightFilter((()=>this.filtering.unIsolateObjects(e,t,n))))}))}highlightObjects(e){return e.length?this.highlightExtension.selectObjects(e):this.highlightExtension.clearSelection(),Promise.resolve(this.filtering.filteringState)}resetHighlight(){return this.highlightExtension.clearSelection(),Promise.resolve(this.filtering.filteringState)}setColorFilter(e,t=!0){return new Promise((n=>{n(this.preserveSelectionHighlightFilter((()=>this.filtering.setColorFilter(e,t))))}))}removeColorFilter(){return new Promise((e=>{e(this.preserveSelectionHighlightFilter((()=>this.filtering.removeColorFilter())))}))}setUserObjectColors(e){return new Promise((t=>{t(this.preserveSelectionHighlightFilter((()=>this.filtering.setUserObjectColors(e))))}))}resetFilters(){return new Promise((e=>{e(this.preserveSelectionHighlightFilter((()=>this.filtering.resetFilters())))}))}preserveSelectionHighlightFilter(e){const t=this.selection.getSelectedObjects().map((r=>r.id)),n=this.highlightExtension.getSelectedObjects().map((r=>r.id));t.length&&this.selection.clearSelection(),n.length&&this.highlightExtension.unselectObjects(n);const i=e();return i&&(i.selectedObjects||(i.selectedObjects=t),this.selection.selectObjects(i.selectedObjects)),n.length&&this.highlightExtension.selectObjects(n),i||this.filtering.filteringState}getDataTree(){De.error("DataTree is obsolete, please use WorldTree instead")}getWorldTree(){return this.tree}query(e){return Pi.isPointQuery(e)?(Pi.DefaultPointQuerySolver.setContext(this.speckleRenderer),Pi.DefaultPointQuerySolver.solve(e)):Pi.isIntersectionQuery(e)?(Pi.DefaultIntersectionQuerySolver.setContext(this.speckleRenderer),Pi.DefaultIntersectionQuerySolver.solve(e)):null}queryAsync(e){return null}zoom(e,t,n){this.cameraController.setCameraView(e,n,t)}setOrthoCameraOn(){this.cameraController.setOrthoCameraOn(),this.speckleRenderer.resetPipeline()}setPerspectiveCameraOn(){this.cameraController.setPerspectiveCameraOn(),this.speckleRenderer.resetPipeline()}toggleCameraProjection(){this.cameraController.toggleCameras(),this.speckleRenderer.resetPipeline()}setLightConfiguration(e){this.speckleRenderer.setSunLightConfiguration(e)}getViews(){return this.tree.findAll((e=>{var t;return((t=e.model.renderView)===null||t===void 0?void 0:t.speckleType)===et.View3D})).map((e=>e.model.raw))}setView(e,t=!0){this.cameraController.setCameraView(e,t)}screenshot(){return new Promise((e=>{e(this.speckleRenderer.renderer.domElement.toDataURL("image/png"))}))}explode(e){this.explodeExtension.setExplode(e)}getObjects(e){const t=this.tree.findId(e),n=[];return t&&t.forEach((i=>{i.model.renderView&&n.push(this.speckleRenderer.getObject(i.model.renderView))})),n}async loadObjectAsync(e,t=void 0,n=!0,i=!0){const r=new Iu(this.tree,e,t,n);return this.loadObject(r,i)}async diff(e,t,n,i){return this.diffExtension.diff(e,t,n,i)}async undiff(){return this.diffExtension.undiff()}setDiffTime(e,t){this.diffExtension.updateVisualDiff(t)}setVisualDiffMode(e,t){this.diffExtension.updateVisualDiff(void 0,t)}enableMeasurements(e){this.measurements.enabled=e,this.selection.enabled=!e}setMeasurementOptions(e){this.measurements.options=e}removeMeasurement(){this.measurements.removeMeasurement()}dispose(){}}class Fk extends Xr{constructor(e,t=Cs){var n,i,r,s;super(e);const o=t.edges?new xo(e):null,l=t.edges?null:new Al;l&&(l.setLayers([re.STREAM_CONTENT_MESH]),l.setVisibility(ut.DEPTH),l.setJitter(!0),l.setClearColor(0,1),l.setClearFlags(Ct.COLOR|Ct.DEPTH));const c=t.edges?o?.depthPass.depthTexture:(n=l?.outputTarget)===null||n===void 0?void 0:n.texture,u=new Sn;u.setLayers([re.STREAM_CONTENT,re.STREAM_CONTENT_MESH,re.STREAM_CONTENT_LINE,re.STREAM_CONTENT_POINT,re.STREAM_CONTENT_POINT_CLOUD,re.PROPS]),u.setVisibility(ut.OPAQUE);const h=new Sn;h.setLayers([re.STREAM_CONTENT,re.STREAM_CONTENT_MESH,re.STREAM_CONTENT_LINE,re.STREAM_CONTENT_POINT,re.STREAM_CONTENT_POINT_CLOUD,re.STREAM_CONTENT_TEXT,re.SHADOWCATCHER]),h.setVisibility(ut.TRANSPARENT);const d=new qi;d.options={blendAO:!1,blendEdges:t.edges},d.setTexture("tEdges",t.edges?o?.outputTextureDynamic:void 0),d.accumulationFrames=this.accumulationFrameCount;const f=(t.edges?o?.dynamicPasses:[])||[],p=new Yf;p.setTexture("tDepth",c),p.accumulationFrames=this.accumulationFrameCount,p.setClearColor(16777215,1);const m=new qi;m.options={blendAO:!0,blendEdges:!1},m.setTexture("tAo",(i=p.outputTarget)===null||i===void 0?void 0:i.texture),m.accumulationFrames=this.accumulationFrameCount;const g=pa.createRenderTarget({minFilter:St,magFilter:St}),v=new Sn;v.setLayers([re.STREAM_CONTENT,re.STREAM_CONTENT_MESH,re.STREAM_CONTENT_LINE,re.STREAM_CONTENT_POINT,re.STREAM_CONTENT_POINT_CLOUD,re.STREAM_CONTENT_TEXT]),v.setVisibility(ut.OPAQUE),v.setJitter(!0),v.outputTarget=g;const y=new Sn;y.setLayers([re.STREAM_CONTENT,re.STREAM_CONTENT_MESH,re.STREAM_CONTENT_LINE,re.STREAM_CONTENT_POINT,re.STREAM_CONTENT_POINT_CLOUD,re.STREAM_CONTENT_TEXT,re.SHADOWCATCHER]),y.setVisibility(ut.TRANSPARENT),y.setJitter(!0),y.outputTarget=g;const w=new qi;w.options={blendAO:!1,blendEdges:t.edges},w.setTexture("tEdges",t.edges?(r=o?.edgePass.outputTarget)===null||r===void 0?void 0:r.texture:void 0),w.accumulationFrames=this.accumulationFrameCount,w.outputTarget=g;const x=new lf;x.inputTexture=g.texture,x.accumulationFrames=this.accumulationFrameCount;const S=new p0;S.setTexture("tDiffuse",(s=x.outputTarget)===null||s===void 0?void 0:s.texture),S.options={inputType:Pu.Color};const b=new ua;b.setVisibility(ut.STENCIL),b.setLayers([re.STREAM_CONTENT_MESH]),b.setClearColor(0,0),b.setClearFlags(Ct.COLOR|Ct.DEPTH|Ct.STENCIL);const E=new ha;E.setVisibility(ut.STENCIL),E.setLayers([re.STREAM_CONTENT_MESH]),E.setClearFlags(Ct.DEPTH);const M=new ua;M.setVisibility(ut.STENCIL),M.setLayers([re.STREAM_CONTENT_MESH]),M.setClearColor(0,0),M.setClearFlags(Ct.COLOR|Ct.DEPTH|Ct.STENCIL),M.outputTarget=g;const T=new ha;T.setVisibility(ut.STENCIL),T.setLayers([re.STREAM_CONTENT_MESH]),T.setClearFlags(Ct.DEPTH),T.outputTarget=g;const I=new Sn;I.setLayers([re.OVERLAY,re.MEASUREMENTS]);const O=t.edges?[o?.depthPass,o?.edgePass]:l?[l]:[];this.dynamicStage.push(...f,b,u,h,...t.edges?[d]:[],E,I),this.progressiveStage.push(...O,M,v,y,T,...t.edges?[w]:[],x,S,p,m,I),this.passthroughStage.push(S,m,I),this.passList=this.dynamicStage}render(){const e=this.passList===this.passthroughStage,t=super.render();return e?(this.reset(),!0):t}}class Hk extends Iu{constructor(e,t,n){super(e,n||"",void 0,void 0,t)}initObjectLoader(e,t,n,i){return yl.createFromObjects([])}async load(){var e;const t=await this.loader.getRootObject();return!t&&this._resource?(De.error("No root id set!"),!1):(this._resource=this._resource||`/json/${(e=t?.baseId)!==null&&e!==void 0?e:"unnamed"}`,super.load())}}class Gk extends qf{async init(){await super.init(),this.getRenderer().renderer.autoClear=!0,this.getRenderer().renderer.autoClearColor=!0,this.getRenderer().renderer.autoClearDepth=!0,this.getRenderer().renderer.autoClearStencil=!0,this.getRenderer().renderer.xr.enabled=!0,this.getRenderer().renderer.setAnimationLoop(this.xrWrappedRender.bind(this)),this.on(Cn.LoadComplete,(()=>{for(const e in this.getRenderer().batcher.batches)this.getRenderer().batcher.batches[e].renderObject.layers.enableAll()}))}render(){Object.values(this.extensions).forEach((e=>{e.onRender()}))}xrWrappedRender(){const e=this.getRenderer().renderer,t=this.getRenderer().renderingCamera,n=t.layers.mask;t.layers.enableAll(),e.render(this.getRenderer().scene,t),t.layers.set(n)}}async function pA(a,e){const t={"Content-Type":"application/json",Authorization:""};e&&(t.Authorization=`Bearer ${e}`);const n=await fetch(`${a.origin}/graphql`,{method:"POST",headers:t,body:JSON.stringify({query:`
          query Stream($streamId: String!, $commitId: String!) {
            stream(id: $streamId) {
              commit(id: $commitId) {
                referencedObject
              }
            }
          }
        `,variables:{streamId:a.streamId,commitId:a.commitId}})}),{data:i}=await n.json();return`${a.origin}/streams/${a.streamId}/objects/${i.stream.commit.referencedObject}`}async function Vk(a,e){return Promise.resolve(`${a.origin}/streams/${a.projectId}/objects/${e.toString()}`)}async function jk(a,e,t){return t.versionId?(async function(n,i,r){const s=await fetch(`${i.origin}/graphql`,{method:"POST",headers:n,body:JSON.stringify({query:`
          query ViewerUrlHelperModelVersion($modelId: String!, $projectId: String!, $versionId: String!) {
            project(id: $projectId) {
              model(id: $modelId) {
                version(id: $versionId) {
                  referencedObject
                }
              }
            }
          }
        `,variables:{projectId:i.projectId,modelId:r.modelId,versionId:r.versionId}})});try{const o=await Og(s);return`${i.origin}/streams/${i.projectId}/objects/${o.project.model.version.referencedObject}`}catch(o){return Promise.reject(new Error(`Could not get object URLs for project ${i.projectId} and model ${r.modelId}. Error: ${o instanceof Error?o.message:o}`))}})(a,e,t):(async function(n,i,r){const s=await fetch(`${i.origin}/graphql`,{method:"POST",headers:n,body:JSON.stringify({query:`
          query ViewerUrlHelperModelLastVersion($modelId: String!, $projectId: String!) {
            project(id: $projectId) {
              model(id: $modelId) {
                versions(limit: 1) {
                  items {
                    referencedObject
                  }
                }
              }
            }
          }
        `,variables:{projectId:i.projectId,modelId:r.modelId}})});try{const o=await Og(s);return`${i.origin}/streams/${i.projectId}/objects/${o.project.model.versions.items[0].referencedObject}`}catch(o){return Promise.reject(new Error(`Could not get object URLs for project ${i.projectId} and model ${r.modelId}. Error: ${o instanceof Error?o.message:o}`))}})(a,e,t)}async function Qk(a,e){return(async function(t,n){const i=await fetch(`${n.origin}/graphql`,{method:"POST",headers:t,body:JSON.stringify({query:`
         query ViewerUrlHelperAllModel($projectId: String!) {
          project(id: $projectId) {
            models {
              items {
                versions(limit: 1) {
                  items {
                    referencedObject
                  }
                }
              }
            }
          }
        }
        `,variables:{projectId:n.projectId}})});try{const r=await Og(i),s=[];return r.project.models.items.forEach((o=>{o.versions.items.length&&s.push(`${n.origin}/streams/${n.projectId}/objects/${o.versions.items[0].referencedObject}`)})),s}catch(r){return Promise.reject(new Error(`Could not get object URLs for project ${n.projectId}. Error: ${r instanceof Error?r.message:r}`))}})(a,e)}async function Og(a){const{data:e}=await a.json();if(!e)throw new Error("Query failed");if(!e.project)throw new Error("Project not found");if(!e.project.model&&!e.project.models)throw new Error("Model(s) not found");return e}var Wk=Object.freeze({__proto__:null,getResourceUrls:async function(a,e){return a.includes("streams")?(async function(t,n){var i;const r=new URL(t),s=t.split("/streams/")[1].substring(0,10),o=[];if(t.includes("commits")){const l=t.split("/commits/")[1].substring(0,10),c=await pA({origin:r.origin,streamId:s,commitId:l},n);o.push(c)}if(t.includes("objects")&&o.push(t),t.includes("overlay=")){const l=(i=new URLSearchParams(r.search).get("overlay"))===null||i===void 0?void 0:i.split(",");if(l!==void 0)for(const c of l)c.length===10?o.push(await pA({origin:r.origin,streamId:s,commitId:c},n)):o.push(`${r.origin}/streams/${s}/objects/${c}`)}return o})(a,e):(async function(t,n){const i=new URL(decodeURI(t)),r=i.href.match(/[^/]+$/);if(!r)return Promise.reject(new Error("No model or object ids specified"));const s=i.href.split("/projects/")[1].substring(0,10),o={"Content-Type":"application/json",Authorization:""};n&&(o.Authorization=`Bearer ${n}`);const l={origin:i.origin,projectId:s},c=y2(decodeURIComponent(r[0])),u=[];for(let h=0;h<c.length;h++){const d=c[h];A2(d)?u.push(Vk(l,d)):w2(d)?u.push(jk(o,l,d)):x2(d)&&u.push(Qk(o,l))}try{return(await Promise.all(u)).flatMap((h=>Array.isArray(h)?h:[h]))}catch(h){return De.error(h),[]}})(a,e)}});const Zk=Object.defineProperty({__proto__:null,AccelerationStructure:zi,ArcticViewPipeline:Ib,AreaMeasurement:Pg,get AssetType(){return gr},Assets:jn,BaseGPass:Ts,BasitPass:Rb,BatchObject:Mt,BlendPass:qi,CONTAINED:ON,CameraController:lo,get CameraEvent(){return Si},ChunkArray:Zt,get ClearFlags(){return Ct},DefaultEdgesPassOptions:ur,DefaultEdgesPipelineOptions:c0,DefaultLightConfiguration:VM,DefaultObjectPickConfiguration:mb,DefaultPipeline:u0,DefaultPipelineOptions:Cs,DefaultProgressiveAOPassOptions:ub,DefaultViewerParams:a0,DepthNormalPass:pb,DepthPass:Al,DiffExtension:Cb,EdgesPass:mc,EdgesPipeline:xo,get ExplodeEvent(){return hf},ExplodeExtension:bb,Extension:Zr,get FilterMaterialType(){return ei},FilteringExtension:d0,Geometry:ft,GeometryConverter:l0,GeometryPass:Sn,get GeometryType(){return ze},HybridCameraController:Lb,INTERSECTED:DN,Input:oo,get InputEvent(){return kn},get InputType(){return Pu},InstancedBatchObject:rb,InstancedMeshBatch:Eg,LegacyViewer:Uk,LineBatch:Mg,Loader:f0,get LoaderEvent(){return Xi},Measurement:_u,get MeasurementEvent(){return Cu},get MeasurementState(){return Nt},MeasurementsExtension:Mb,MeshBatch:Tg,NOT_INTERSECTED:PN,get NearPlaneCalculation(){return Tu},NodeRenderView:eb,NormalsPass:Rg,ObjLoader:Bk,get ObjectLayers(){return re},get ObjectVisibility(){return ut},OutputPass:p0,PenViewPipeline:Db,PerpendicularMeasurement:Ab,Pipeline:pa,PointBatch:Cg,PointMeasurement:Dg,PointToPointMeasurement:Sb,ProgressiveAOPass:Yf,ProgressiveGPass:qu,ProgressivePipeline:Xr,RenderTree:tb,SectionOutlines:Jr,SectionTool:uf,get SectionToolEvent(){return pr},SelectionExtension:h0,ShadedViewPipeline:Pb,SolidViewPipeline:Ob,SpeckleBasicMaterial:Ar,SpeckleConverter:Eb,SpeckleGeometryConverter:Tb,SpeckleInstancedMesh:bu,SpeckleLineMaterial:Or,SpeckleLoader:Iu,SpeckleMesh:wl,SpeckleOfflineLoader:Hk,SpecklePointMaterial:fr,SpeckleRenderer:gb,SpeckleStandardMaterial:hi,SpeckleTextMaterial:vr,get SpeckleType(){return et},SpeckleWebGLRenderer:lb,StencilMaskPass:ha,get StencilOutlineType(){return zr},StencilPass:ua,TAAPass:lf,TAAPipeline:Fk,TextBatch:bg,TextLabel:Rc,TopLevelAccelerationStructure:_n,Units:tt,get UpdateFlags(){return Qt},UrlHelper:Wk,get ViewMode(){return Xs},get ViewModeEvent(){return df},ViewModes:Bb,Viewer:qf,get ViewerEvent(){return Cn},ViewportPass:Ru,VirtualArray:$M,get VisualDiffMode(){return sl},WebXrViewer:Gk,World:ca,WorldTree:xl},Symbol.toStringTag,{value:"Module"});export{a0 as I,Zk as i,Jk as t};
